#![doc = "This file has been autogenerated. Do not modify."]
#![doc = "To update, run: `cargo run --bin sourcegen ts`"]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
	PrimaryType,
	Declaration,
	Expression,
	Pattern,
	PrimaryExpression,
	Statement,
	AbstractClassDeclaration,
	AbstractMethodSignature,
	AccessibilityModifier,
	AmbientDeclaration,
	Arguments,
	Array,
	ArrayPattern,
	ArrayType,
	ArrowFunction,
	AsExpression,
	Asserts,
	AssignmentExpression,
	AssignmentPattern,
	AugmentedAssignmentExpression,
	AwaitExpression,
	BinaryExpression,
	BreakStatement,
	CallExpression,
	CallSignature,
	CatchClause,
	Class,
	ClassBody,
	ClassDeclaration,
	ClassHeritage,
	ComputedPropertyName,
	ConditionalType,
	Constraint,
	ConstructSignature,
	ConstructorType,
	ContinueStatement,
	DebuggerStatement,
	Decorator,
	DefaultType,
	DoStatement,
	ElseClause,
	EmptyStatement,
	EnumAssignment,
	EnumBody,
	EnumDeclaration,
	ExistentialType,
	ExportClause,
	ExportSpecifier,
	ExportStatement,
	ExpressionStatement,
	ExtendsClause,
	FinallyClause,
	FlowMaybeType,
	ForInStatement,
	ForStatement,
	FormalParameters,
	Function,
	FunctionDeclaration,
	FunctionSignature,
	FunctionType,
	GeneratorFunction,
	GeneratorFunctionDeclaration,
	GenericType,
	IfStatement,
	ImplementsClause,
	Import,
	ImportAlias,
	ImportClause,
	ImportRequireClause,
	ImportSpecifier,
	ImportStatement,
	IndexSignature,
	IndexTypeQuery,
	InferType,
	InterfaceDeclaration,
	InternalModule,
	IntersectionType,
	JsxAttribute,
	JsxClosingElement,
	JsxElement,
	JsxExpression,
	JsxFragment,
	JsxNamespaceName,
	JsxOpeningElement,
	JsxSelfClosingElement,
	LabeledStatement,
	LexicalDeclaration,
	LiteralType,
	LookupType,
	MappedTypeClause,
	MemberExpression,
	MetaProperty,
	MethodDefinition,
	MethodSignature,
	Module,
	NamedImports,
	NamespaceImport,
	NestedIdentifier,
	NestedTypeIdentifier,
	NewExpression,
	NonNullExpression,
	Object,
	ObjectAssignmentPattern,
	ObjectPattern,
	ObjectType,
	OmittingTypeAnnotation,
	OptingTypeAnnotation,
	OptionalParameter,
	OptionalType,
	Pair,
	PairPattern,
	ParenthesizedExpression,
	ParenthesizedType,
	PredefinedType,
	Program,
	PropertySignature,
	PublicFieldDefinition,
	ReadonlyType,
	Regex,
	RequiredParameter,
	RestPattern,
	RestType,
	ReturnStatement,
	SequenceExpression,
	SpreadElement,
	StatementBlock,
	StringLiteral,
	SubscriptExpression,
	SwitchBody,
	SwitchCase,
	SwitchDefault,
	SwitchStatement,
	TemplateString,
	TemplateSubstitution,
	TernaryExpression,
	ThrowStatement,
	TryStatement,
	TupleType,
	TypeAliasDeclaration,
	TypeAnnotation,
	TypeArguments,
	TypeAssertion,
	TypeParameter,
	TypeParameters,
	TypePredicate,
	TypePredicateAnnotation,
	TypeQuery,
	UnaryExpression,
	UnionType,
	UpdateExpression,
	VariableDeclaration,
	VariableDeclarator,
	WhileStatement,
	WithStatement,
	YieldExpression,
	BangToken,
	BangEqToken,
	BangEqEqToken,
	DquoteToken,
	DollarLbraceToken,
	PercentToken,
	PercentEqToken,
	AmpToken,
	AmpAmpToken,
	AmpAmpEqToken,
	AmpEqToken,
	SquoteToken,
	LparenToken,
	RparenToken,
	StarToken,
	StarStarToken,
	StarStarEqToken,
	StarEqToken,
	PlusToken,
	PlusPlusToken,
	PlusEqToken,
	CommaToken,
	DashToken,
	DashDashToken,
	DashEqToken,
	DashQmarkColonToken,
	DotToken,
	DotDotDotToken,
	SlashToken,
	SlashEqToken,
	ColonToken,
	SemiToken,
	LtToken,
	LtLtToken,
	LtLtEqToken,
	LtEqToken,
	EqToken,
	EqEqToken,
	EqEqEqToken,
	EqGtToken,
	GtToken,
	GtEqToken,
	GtGtToken,
	GtGtEqToken,
	GtGtGtToken,
	GtGtGtEqToken,
	QmarkToken,
	QmarkDotToken,
	QmarkColonToken,
	QmarkQmarkToken,
	QmarkQmarkEqToken,
	AtToken,
	LbrackToken,
	RbrackToken,
	CaretToken,
	CaretEqToken,
	BquoteToken,
	AbstractToken,
	AnyToken,
	AsToken,
	AssertsToken,
	AsyncToken,
	AwaitToken,
	BooleanToken,
	BreakToken,
	CaseToken,
	CatchToken,
	ClassToken,
	Comment,
	ConstToken,
	ContinueToken,
	DebuggerToken,
	DeclareToken,
	DefaultToken,
	DeleteToken,
	DoToken,
	ElseToken,
	EnumToken,
	EscapeSequence,
	ExportToken,
	ExtendsToken,
	False,
	FinallyToken,
	ForToken,
	FromToken,
	FunctionToken,
	GetToken,
	GlobalToken,
	HashBangLine,
	Identifier,
	IfToken,
	ImplementsToken,
	ImportToken,
	InToken,
	InferToken,
	InstanceofToken,
	InterfaceToken,
	IsToken,
	JsxText,
	KeyofToken,
	LetToken,
	ModuleToken,
	NamespaceToken,
	NewToken,
	Null,
	NumberToken,
	Number,
	OfToken,
	PrivateToken,
	PropertyIdentifier,
	ProtectedToken,
	PublicToken,
	ReadonlyToken,
	RegexFlags,
	RegexPattern,
	RequireToken,
	ReturnToken,
	SetToken,
	ShorthandPropertyIdentifier,
	ShorthandPropertyIdentifierPattern,
	StatementIdentifier,
	StaticToken,
	StringToken,
	Super,
	SwitchToken,
	SymbolToken,
	TargetToken,
	This,
	ThrowToken,
	True,
	TryToken,
	TypeToken,
	TypeIdentifier,
	TypeofToken,
	Undefined,
	VarToken,
	VoidToken,
	WhileToken,
	WithToken,
	YieldToken,
	LbraceToken,
	LbracePipeToken,
	PipeToken,
	PipeEqToken,
	PipePipeToken,
	PipePipeEqToken,
	PipeRbraceToken,
	RbraceToken,
	TildeToken,
	Whitespace,
	ERROR,
	__LAST,
}
use crate::ParserLanguage;
use SyntaxKind::*;
pub struct Language {
	pub name: &'static str,
}
pub const TS: Language = Language { name: "ts" };
impl Language {
	pub fn get_syntax_kind(&self, name: &str, named: bool) -> SyntaxKind {
		match (name, named) {
			("_primary_type", true) => PrimaryType,
			("declaration", true) => Declaration,
			("expression", true) => Expression,
			("pattern", true) => Pattern,
			("primary_expression", true) => PrimaryExpression,
			("statement", true) => Statement,
			("abstract_class_declaration", true) => AbstractClassDeclaration,
			("abstract_method_signature", true) => AbstractMethodSignature,
			("accessibility_modifier", true) => AccessibilityModifier,
			("ambient_declaration", true) => AmbientDeclaration,
			("arguments", true) => Arguments,
			("array", true) => Array,
			("array_pattern", true) => ArrayPattern,
			("array_type", true) => ArrayType,
			("arrow_function", true) => ArrowFunction,
			("as_expression", true) => AsExpression,
			("asserts", true) => Asserts,
			("assignment_expression", true) => AssignmentExpression,
			("assignment_pattern", true) => AssignmentPattern,
			("augmented_assignment_expression", true) => AugmentedAssignmentExpression,
			("await_expression", true) => AwaitExpression,
			("binary_expression", true) => BinaryExpression,
			("break_statement", true) => BreakStatement,
			("call_expression", true) => CallExpression,
			("call_signature", true) => CallSignature,
			("catch_clause", true) => CatchClause,
			("class", true) => Class,
			("class_body", true) => ClassBody,
			("class_declaration", true) => ClassDeclaration,
			("class_heritage", true) => ClassHeritage,
			("computed_property_name", true) => ComputedPropertyName,
			("conditional_type", true) => ConditionalType,
			("constraint", true) => Constraint,
			("construct_signature", true) => ConstructSignature,
			("constructor_type", true) => ConstructorType,
			("continue_statement", true) => ContinueStatement,
			("debugger_statement", true) => DebuggerStatement,
			("decorator", true) => Decorator,
			("default_type", true) => DefaultType,
			("do_statement", true) => DoStatement,
			("else_clause", true) => ElseClause,
			("empty_statement", true) => EmptyStatement,
			("enum_assignment", true) => EnumAssignment,
			("enum_body", true) => EnumBody,
			("enum_declaration", true) => EnumDeclaration,
			("existential_type", true) => ExistentialType,
			("export_clause", true) => ExportClause,
			("export_specifier", true) => ExportSpecifier,
			("export_statement", true) => ExportStatement,
			("expression_statement", true) => ExpressionStatement,
			("extends_clause", true) => ExtendsClause,
			("finally_clause", true) => FinallyClause,
			("flow_maybe_type", true) => FlowMaybeType,
			("for_in_statement", true) => ForInStatement,
			("for_statement", true) => ForStatement,
			("formal_parameters", true) => FormalParameters,
			("function", true) => Function,
			("function_declaration", true) => FunctionDeclaration,
			("function_signature", true) => FunctionSignature,
			("function_type", true) => FunctionType,
			("generator_function", true) => GeneratorFunction,
			("generator_function_declaration", true) => GeneratorFunctionDeclaration,
			("generic_type", true) => GenericType,
			("if_statement", true) => IfStatement,
			("implements_clause", true) => ImplementsClause,
			("import", true) => Import,
			("import_alias", true) => ImportAlias,
			("import_clause", true) => ImportClause,
			("import_require_clause", true) => ImportRequireClause,
			("import_specifier", true) => ImportSpecifier,
			("import_statement", true) => ImportStatement,
			("index_signature", true) => IndexSignature,
			("index_type_query", true) => IndexTypeQuery,
			("infer_type", true) => InferType,
			("interface_declaration", true) => InterfaceDeclaration,
			("internal_module", true) => InternalModule,
			("intersection_type", true) => IntersectionType,
			("jsx_attribute", true) => JsxAttribute,
			("jsx_closing_element", true) => JsxClosingElement,
			("jsx_element", true) => JsxElement,
			("jsx_expression", true) => JsxExpression,
			("jsx_fragment", true) => JsxFragment,
			("jsx_namespace_name", true) => JsxNamespaceName,
			("jsx_opening_element", true) => JsxOpeningElement,
			("jsx_self_closing_element", true) => JsxSelfClosingElement,
			("labeled_statement", true) => LabeledStatement,
			("lexical_declaration", true) => LexicalDeclaration,
			("literal_type", true) => LiteralType,
			("lookup_type", true) => LookupType,
			("mapped_type_clause", true) => MappedTypeClause,
			("member_expression", true) => MemberExpression,
			("meta_property", true) => MetaProperty,
			("method_definition", true) => MethodDefinition,
			("method_signature", true) => MethodSignature,
			("module", true) => Module,
			("named_imports", true) => NamedImports,
			("namespace_import", true) => NamespaceImport,
			("nested_identifier", true) => NestedIdentifier,
			("nested_type_identifier", true) => NestedTypeIdentifier,
			("new_expression", true) => NewExpression,
			("non_null_expression", true) => NonNullExpression,
			("object", true) => Object,
			("object_assignment_pattern", true) => ObjectAssignmentPattern,
			("object_pattern", true) => ObjectPattern,
			("object_type", true) => ObjectType,
			("omitting_type_annotation", true) => OmittingTypeAnnotation,
			("opting_type_annotation", true) => OptingTypeAnnotation,
			("optional_parameter", true) => OptionalParameter,
			("optional_type", true) => OptionalType,
			("pair", true) => Pair,
			("pair_pattern", true) => PairPattern,
			("parenthesized_expression", true) => ParenthesizedExpression,
			("parenthesized_type", true) => ParenthesizedType,
			("predefined_type", true) => PredefinedType,
			("program", true) => Program,
			("property_signature", true) => PropertySignature,
			("public_field_definition", true) => PublicFieldDefinition,
			("readonly_type", true) => ReadonlyType,
			("regex", true) => Regex,
			("required_parameter", true) => RequiredParameter,
			("rest_pattern", true) => RestPattern,
			("rest_type", true) => RestType,
			("return_statement", true) => ReturnStatement,
			("sequence_expression", true) => SequenceExpression,
			("spread_element", true) => SpreadElement,
			("statement_block", true) => StatementBlock,
			("string", true) => StringLiteral,
			("subscript_expression", true) => SubscriptExpression,
			("switch_body", true) => SwitchBody,
			("switch_case", true) => SwitchCase,
			("switch_default", true) => SwitchDefault,
			("switch_statement", true) => SwitchStatement,
			("template_string", true) => TemplateString,
			("template_substitution", true) => TemplateSubstitution,
			("ternary_expression", true) => TernaryExpression,
			("throw_statement", true) => ThrowStatement,
			("try_statement", true) => TryStatement,
			("tuple_type", true) => TupleType,
			("type_alias_declaration", true) => TypeAliasDeclaration,
			("type_annotation", true) => TypeAnnotation,
			("type_arguments", true) => TypeArguments,
			("type_assertion", true) => TypeAssertion,
			("type_parameter", true) => TypeParameter,
			("type_parameters", true) => TypeParameters,
			("type_predicate", true) => TypePredicate,
			("type_predicate_annotation", true) => TypePredicateAnnotation,
			("type_query", true) => TypeQuery,
			("unary_expression", true) => UnaryExpression,
			("union_type", true) => UnionType,
			("update_expression", true) => UpdateExpression,
			("variable_declaration", true) => VariableDeclaration,
			("variable_declarator", true) => VariableDeclarator,
			("while_statement", true) => WhileStatement,
			("with_statement", true) => WithStatement,
			("yield_expression", true) => YieldExpression,
			("!", false) => BangToken,
			("!=", false) => BangEqToken,
			("!==", false) => BangEqEqToken,
			("\"", false) => DquoteToken,
			("${", false) => DollarLbraceToken,
			("%", false) => PercentToken,
			("%=", false) => PercentEqToken,
			("&", false) => AmpToken,
			("&&", false) => AmpAmpToken,
			("&&=", false) => AmpAmpEqToken,
			("&=", false) => AmpEqToken,
			("'", false) => SquoteToken,
			("(", false) => LparenToken,
			(")", false) => RparenToken,
			("*", false) => StarToken,
			("**", false) => StarStarToken,
			("**=", false) => StarStarEqToken,
			("*=", false) => StarEqToken,
			("+", false) => PlusToken,
			("++", false) => PlusPlusToken,
			("+=", false) => PlusEqToken,
			(",", false) => CommaToken,
			("-", false) => DashToken,
			("--", false) => DashDashToken,
			("-=", false) => DashEqToken,
			("-?:", false) => DashQmarkColonToken,
			(".", false) => DotToken,
			("...", false) => DotDotDotToken,
			("/", false) => SlashToken,
			("/=", false) => SlashEqToken,
			(":", false) => ColonToken,
			(";", false) => SemiToken,
			("<", false) => LtToken,
			("<<", false) => LtLtToken,
			("<<=", false) => LtLtEqToken,
			("<=", false) => LtEqToken,
			("=", false) => EqToken,
			("==", false) => EqEqToken,
			("===", false) => EqEqEqToken,
			("=>", false) => EqGtToken,
			(">", false) => GtToken,
			(">=", false) => GtEqToken,
			(">>", false) => GtGtToken,
			(">>=", false) => GtGtEqToken,
			(">>>", false) => GtGtGtToken,
			(">>>=", false) => GtGtGtEqToken,
			("?", false) => QmarkToken,
			("?.", false) => QmarkDotToken,
			("?:", false) => QmarkColonToken,
			("??", false) => QmarkQmarkToken,
			("??=", false) => QmarkQmarkEqToken,
			("@", false) => AtToken,
			("[", false) => LbrackToken,
			("]", false) => RbrackToken,
			("^", false) => CaretToken,
			("^=", false) => CaretEqToken,
			("`", false) => BquoteToken,
			("abstract", false) => AbstractToken,
			("any", false) => AnyToken,
			("as", false) => AsToken,
			("asserts", false) => AssertsToken,
			("async", false) => AsyncToken,
			("await", false) => AwaitToken,
			("boolean", false) => BooleanToken,
			("break", false) => BreakToken,
			("case", false) => CaseToken,
			("catch", false) => CatchToken,
			("class", false) => ClassToken,
			("comment", true) => Comment,
			("const", false) => ConstToken,
			("continue", false) => ContinueToken,
			("debugger", false) => DebuggerToken,
			("declare", false) => DeclareToken,
			("default", false) => DefaultToken,
			("delete", false) => DeleteToken,
			("do", false) => DoToken,
			("else", false) => ElseToken,
			("enum", false) => EnumToken,
			("escape_sequence", true) => EscapeSequence,
			("export", false) => ExportToken,
			("extends", false) => ExtendsToken,
			("false", true) => False,
			("finally", false) => FinallyToken,
			("for", false) => ForToken,
			("from", false) => FromToken,
			("function", false) => FunctionToken,
			("get", false) => GetToken,
			("global", false) => GlobalToken,
			("hash_bang_line", true) => HashBangLine,
			("identifier", true) => Identifier,
			("if", false) => IfToken,
			("implements", false) => ImplementsToken,
			("import", false) => ImportToken,
			("in", false) => InToken,
			("infer", false) => InferToken,
			("instanceof", false) => InstanceofToken,
			("interface", false) => InterfaceToken,
			("is", false) => IsToken,
			("jsx_text", true) => JsxText,
			("keyof", false) => KeyofToken,
			("let", false) => LetToken,
			("module", false) => ModuleToken,
			("namespace", false) => NamespaceToken,
			("new", false) => NewToken,
			("null", true) => Null,
			("number", false) => NumberToken,
			("number", true) => Number,
			("of", false) => OfToken,
			("private", false) => PrivateToken,
			("property_identifier", true) => PropertyIdentifier,
			("protected", false) => ProtectedToken,
			("public", false) => PublicToken,
			("readonly", false) => ReadonlyToken,
			("regex_flags", true) => RegexFlags,
			("regex_pattern", true) => RegexPattern,
			("require", false) => RequireToken,
			("return", false) => ReturnToken,
			("set", false) => SetToken,
			("shorthand_property_identifier", true) => ShorthandPropertyIdentifier,
			("shorthand_property_identifier_pattern", true) => ShorthandPropertyIdentifierPattern,
			("statement_identifier", true) => StatementIdentifier,
			("static", false) => StaticToken,
			("string", false) => StringToken,
			("super", true) => Super,
			("switch", false) => SwitchToken,
			("symbol", false) => SymbolToken,
			("target", false) => TargetToken,
			("this", true) => This,
			("throw", false) => ThrowToken,
			("true", true) => True,
			("try", false) => TryToken,
			("type", false) => TypeToken,
			("type_identifier", true) => TypeIdentifier,
			("typeof", false) => TypeofToken,
			("undefined", true) => Undefined,
			("var", false) => VarToken,
			("void", false) => VoidToken,
			("while", false) => WhileToken,
			("with", false) => WithToken,
			("yield", false) => YieldToken,
			("{", false) => LbraceToken,
			("{|", false) => LbracePipeToken,
			("|", false) => PipeToken,
			("|=", false) => PipeEqToken,
			("||", false) => PipePipeToken,
			("||=", false) => PipePipeEqToken,
			("|}", false) => PipeRbraceToken,
			("}", false) => RbraceToken,
			("~", false) => TildeToken,
			("ERROR", true) => SyntaxKind::ERROR,
			_ => panic!("Syntax Kind not found: {} / {}", name, named),
		}
	}
}
impl ParserLanguage for Language {
	type SyntaxNode = SyntaxNode;
	fn name(&self) -> &'static str {
		self.name
	}
	fn get_kind(&self, kind: &str, named: bool) -> u16 {
		self.get_syntax_kind(kind, named).into()
	}
	fn whitespace_kind(&self) -> u16 {
		SyntaxKind::Whitespace.into()
	}
	fn new_root(&self, green: rowan::GreenNode) -> Self::SyntaxNode {
		SyntaxNode::new_root(green)
	}
}
impl From<u16> for SyntaxKind {
	#[inline]
	fn from(d: u16) -> SyntaxKind {
		assert!(d <= (SyntaxKind::__LAST as u16));
		unsafe { std::mem::transmute::<u16, SyntaxKind>(d) }
	}
}
impl From<SyntaxKind> for u16 {
	#[inline]
	fn from(k: SyntaxKind) -> u16 {
		k as u16
	}
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TS {}
impl rowan::Language for TS {
	type Kind = SyntaxKind;
	fn kind_from_raw(raw: rowan::SyntaxKind) -> SyntaxKind {
		SyntaxKind::from(raw.0)
	}
	fn kind_to_raw(kind: SyntaxKind) -> rowan::SyntaxKind {
		rowan::SyntaxKind(kind.into())
	}
}
pub type SyntaxNode = rowan::SyntaxNode<TS>;
pub type SyntaxToken = rowan::SyntaxToken<TS>;
pub type SyntaxElement = rowan::SyntaxElement<TS>;
pub type SyntaxNodeChildren = rowan::SyntaxNodeChildren<TS>;
pub type SyntaxElementChildren = rowan::SyntaxElementChildren<TS>;
