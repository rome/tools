# Analyzer

The analyzer is a generic crate aimed to implement a visitor-like infrastructure, where
it's possible to inspect a piece of AST and emit diagnostics or actions based on a
static check.

# Folder structure

First of all, you need to identify the crate where you want to implement the rule. If the rule
is going to be implemented for the JavaScript language (and its super languages), then the rule
will be implemented inside the `rome_js_analyze` crate.

Rules are divided by capabilities:
- `analyzers/` folder contains rules that don't require any particular capabilities, via the `Ast<>` query type;
- `semantic_analyzer/` folder contains rules that require the use of the semantic model, via `Semantic<>` query type;
- `aria_analyzers/` folder contains rules that require the use ARIA metadata, via `Aria<>` query type;
- `assists/` folder contains rules that contribute to refactor code, with not associated diagnostics;
these are rules that are usually meant for editors/IDEs;

Most of the rules will go under `semantic_analyzer/` or  `analyzers/` folders.

Inside the folders, we will have folders for each group that Rome supports.

When implementing **new rules**, they have to be implemented under the group `nursery`. New rules should
always be considered unstable/not exhaustive.

In addition to selecting a group, rules may be flagged as `recommended` if they
should be part of the set of rules that are run in the default configuration of the
Rome linter. As a general principle, rules should be recommended if they catch actual
programming errors (for instance detecting a coding pattern that will throw an
exception at runtime), while the more pedantic rules that check for certain unwanted
patterns but may have high false positive rates (for instance style-related rules)
are left off from the recommended set, and the final user should enable them
explicitly in their configuration. Rules intended to be recommended should be
flagged as such even if they are still part of the `nursery` group, as unstable rules
are only enabled by default on unstable builds.

## Lint rules

This gives to the project time to test the rule, find edge cases, etc.

When creating or updating lint rules, you need to be aware that there's a lot of generated code inside our toolchain, and
our CI makes sure that this code is not out of sync. If some autogenerated files are out of sync,
the CI will fail.

### Create your first rule

Let's say we want to create a new rule called `useAwesomeTricks`, which uses the semantic model.

1. create a new file under `semantic_analyzers/nursery` called `use_awesome_tricks`;
2. run the cargo alias `cargo codegen analyzer`, this command will update the file called `nursery.rs`
inside the `semantic_analyzers` folder
3. from there, use the [`declare_rule`](#declare_rule) macro to create a new type
   ```rust,ignore
   use rome_analyze::declare_rule;

   declare_rule! {
     /// Promotes the use of awesome tricks
     ///
     /// ## Examples
     ///
     /// ### Invalid
     ///
     pub(crate) UseAwesomeTricks {
         version: "0.10.0",
         name: "useAwesomeTricks",
         recommended: false,
        }
    }
   ```
4. Then you need to use the `Rule` trait to implement the rule on this new created struct
   ```rust,ignore
   use rome_analyze::{Rule, RuleCategory};
   use rome_js_syntax::JsAnyExpression;
   use rome_analyze::context::RuleContext;

   impl Rule for UseAwesomeTricks {
        type Query = Semantic<JsAnyExpression>;
        type State = String;
        type Signals = Option<Self::State>;
        type Options = ();

        fn run(ctx: &RuleContext<Self>) -> Self::Signals {}
   }
   ```
5. the `Query` needs to have the `Semantic` type, because we want to have access to the semantic model.
`Query` tells the engine on which AST node we want to trigger the rule.
6. The `State` type doesn't have to be used, so it can be considered optional, but it has
be defined as `type State = ()`
7. The `run` function must be implemented. This function is called every time the analyzer
finds a match for the query specified by the rule, and may return zero or more "signals".
8. Implement the optional `diagnostic` function, to tell the user where's the error and why:
    ```rust,ignore
    impl Rule for UseAwesomeTricks {
        // .. code
        fn diagnostic(_ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {}
    }
    ```
    While implementing the diagnostic, please keep [Rome's technical principals](https://rome.tools/#technical) in mind.
    This function is called of every signal emitted by the `run` function, and it may return
    zero or one diagnostic.

    You will have to manually update the file `rome_diagnostics_categories/src/categories.rs` and add a new category
    for the new rule you're about to create.
9. Implement the optional `action` function, if we are able to provide automatic code fix to the rule:
    ```rust,ignore
    impl Rule for UseAwesomeTricks {
        // .. code
        fn action(_ctx: &RuleContext<Self>, _state: &Self::State) -> Option<JsRuleAction> {}
    }
    ```
    This function is called of every signal emitted by the `run` function, and it may return
    zero or one code action.
    When returning a code action, you will need to pass `category` and `applicability` fields.
    `category` must be `ActionCategory::QuickFix`, while `applicability` must be `Applicability:MaybeIncorrect`

That's it! Now, let's test the rule

### Test a rule

Inside the `tests/spec` folder, rules are divided by group and rule name. The test infrastructure
is rigid around the association of the pair "group/rule name", which means that _**your test cases
are placed inside the wrong group, you won't see any diagnostics**_.

Since each new rule will start from `nursery`, that's where we start.

From there, you have two options:
- create a single file called like the rule name, e.g. `useAwesomeTricks.js`, `useAwesomeTricks.tsx`, etc. The
extension of the file matters based on which kind of file you need to test;
- create a folder called `useAwesomeTricks/`, and then create various files where you want to create
different cases. These options are useful if your rules target different super languages, or you want
to split your cases among different files;

Run the command `cargo test` and if you've done everything correctly, you should see some snapshots
emitted with diagnostics and code actions.

Check our main [contribution document](https://github.com/rome/tools/blob/main/CONTRIBUTING.md#snapshot-tests)
to know how to deal with the snapshot tests.

### Code generation

For simplicity, use [`just`](#using-just) to run all the commands with:

```shell
just codegen-linter
```

Explanation of the commands:

- `cargo codegen-configuration`, **this command must be run first** and, it will update the configuration;
- `cargo lintdoc`, it will update the website with the documentation of the rules, check [`declare_rule`](#declare_rule)
for more information about it;
- `cargo codegen-bindings`, it will update the TypeScript types released inside the JS APIs;
- `cargo codegen-schema`, it will update the JSON Schema file of the configuration, used by VSCode;


### Naming patterns for rules

1. Forbid a concept

   ```block
   no<Concept>
   ```

   When a rule's sole intention is to **forbid a single concept** - such as disallowing the use of `debugger` statements - the rule should be named using the `no` prefix. For example, the rule to disallow the use of `debugger` statements is named `noDebugger`.

1. Mandate a concept

   ```block
   use<Concept>
   ```

   When a rule's sole intention is to **mandate a single concept** - such as forcing the use of camel-casing - the rule should be named using the `use` prefix. For example, the rule to mandating the use of camel-cased variable names is named `useCamelCase`.


### `declare_rule`

 This macro is used to declare an analyzer rule type, and implement the
 [RuleMeta] trait for it

 # Example

 The macro itself expect the following syntax:
 ```rust,ignore
use rome_analyze::declare_rule;

 declare_rule! {
     /// Documentation
     pub(crate) ExampleRule {
         version: "0.7.0",
         name: "ruleName",
         recommended: false,
     }
 }
 ```

 #### Documentation

 The doc-comment for the rule is mandatory and is used to generate the
 documentation page for the rule on the website.

 Importantly, the tool used to generate those pages also runs tests on the
 code blocks included in the documentation written in languages supported by
 the Rome toolchain (JavaScript, JSX, TypeScript, ...) similar to how
 `rustdoc` generates tests from code blocks written in Rust. Because code
 blocks in Rust doc-comments are assumed to be written in Rust by default
 the language of the test must be explicitly specified, for instance:

 ```rust,ignore
use rome_analyze::declare_rule;
declare_rule! {
     /// Disallow the use of `var`
     ///
     /// ### Valid
     ///
     /// ```js
     /// let a, b;
     /// ```
     pub(crate) NoVar {
         version: "0.7.0",
         name: "noVar",
         recommended: false,
     }
}
 ```

 Additionally, it's possible to declare that a test should emit a diagnostic
 by adding `expect_diagnostic` to the language metadata:

 ```rust,ignore
use rome_analyze::declare_rule;
 declare_rule! {
     ///  Disallow the use of `var`
     ///
     ///  ### Invalid
     ///
     ///  ```js,expect_diagnostic
     ///  var a, b;
     ///  ```
     pub(crate) NoVar {
         version: "0.7.0",
         name: "noVar",
         recommended: false,
     }
 }
 ```

 This will cause the documentation generator to ensure the rule does emit
 exactly one diagnostic for this code, and to include a snapshot for the
 diagnostic in the resulting documentation page

#### Deprecation

 There are occasions when a rule must be deprecated, to avoid breaking changes. The reason
 of deprecations can be multiples.

 In order to do, the macro allows to add additional field to add the reason for deprecation

 ```rust,ignore
use rome_analyze::declare_rule;

 declare_rule! {
      /// Disallow the use of `var`
      ///
      /// ### Invalid
      ///
      /// ```js,expect_diagnostic
      /// var a, b;
      /// ```
     pub(crate) NoVar {
         version: "0.7.0",
         name: "noVar",
         deprecated: "Use the rule `noAnotherVar`",
         recommended: false,
     }
 }
 ```

#### Category Macro

 Declaring a rule using `declare_rule!` will cause a new `rule_category!`
 macro to be declared in the surrounding module. This macro can be used to
 refer to the corresponding diagnostic category for this lint rule, if it
 has one. Using this macro instead of getting the category for a diagnostic
 by dynamically parsing its string name has the advantage of statically
 injecting the category at compile time and checking that it is correctly
 registered to the `rome_diagnostics` library

 ```rust,ignore
 declare_rule! {
     /// Documentation
     pub(crate) ExampleRule {
         version: "0.7.0",
         name: "ruleName"
     }
 }

 impl Rule for ExampleRule {
     fn diagnostic(ctx: &RuleContext<Self>, _state: &Self::State) -> Option<RuleDiagnostic> {
         Some(RuleDiagnostic::new(
             rule_category!(),
             ctx.query().text_trimmed_range(),
             "message",
         ))
     }
 }
 ```

#### Rule configuration

Some rules may allow customization using configuration. The first step is to setup a struct to represent the rule configuartion.

```rust,ignore
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReactExtensiveDependenciesOptions {
    hooks_config: HashMap<String, ReactHookConfiguration>,
    stable_config: HashSet<StableReactHookConfiguration>,
}

impl Rule for UseExhaustiveDependencies {
    type Query = Semantic<JsCallExpression>;
    type State = Fix;
    type Signals = Vec<Self::State>;
    type Options = ReactExtensiveDependenciesOptions;

    ...
}
```

This allow the rule to be configured inside "rome.json" file like:

```json
{
    "linter": {
        "rules": {
            "recommended": true,
            "nursery": {
                "useExhaustiveDependencies": {
                    "level": "error",
                    "options": {
                        "hooks": [
                            ["useMyEffect", 0, 1]
                        ]
                    }
                }
            }
        },
    }
}
```

In this specific case, we don't want the configuration to replace all the standard React hooks configuration,
so to have more control on the options deserialization, we can implement the trait `DeserializableRuleOptions`.

In the example below we also deserialize to a struct with a more user friendly schema.

This code run only once when the analyzer is first called.

```rust,ignore

impl DeserializableRuleOptions for ReactExtensiveDependenciesOptions {
    fn try_from(value: serde_json::Value) -> Result<Self, serde_json::Error> {
        #[derive(Debug, Deserialize)]
        #[serde(deny_unknown_fields)]
        struct Options {
            #[serde(default)]
            hooks: Vec<(String, usize, usize)>,
            #[serde(default)]
            stables: HashSet<StableReactHookConfiguration>,
        }

        let options: Options = serde_json::from_value(value)?;

        let mut default = ReactExtensiveDependenciesOptions::default();
        for (k, closure_index, dependencies_index) in options.hooks.into_iter() {
            default.hooks_config.insert(
                k,
                ReactHookConfiguration {
                    closure_index,
                    dependencies_index,
                },
            );
        }
        default.stable_config.extend(options.stables.into_iter());

        Ok(default)
    }
}
```

If this the rule can retrieve its option with

```rust,ignore
let options = ctx.options();
```

#### Custom Visitors

Some lint rules may need to deeply inspect the child nodes of a query match
before deciding on whether they should emit a signal or not. These rules can be
inefficient to implement using the query system, as they will lead to redundant
traversal passes being executed over the same syntax tree. To make this more
efficient, you can implement a custom `Queryable` type and and associated
`Visitor` to emit it as part of the analyzer's main traversal pass. As an
example, here's how this could be done to implement the `useYield` rule:

```rust,ignore
// First, create a visitor struct that holds a stack of function syntax nodes and booleans
#[derive(Default)]
struct MissingYieldVisitor {
    stack: Vec<(AnyFunctionLike, bool)>,
}

// Implement the `Visitor` trait for this struct
impl Visitor for MissingYieldVisitor {
    fn visit(
        &mut self,
        event: &WalkEvent<SyntaxNode<Self::Language>>,
        ctx: VisitorContext<Self::Language>,
    ) {
        match event {
            WalkEvent::Enter(node) => {
                // When the visitor enters a function node, push a new entry on the stack
                if let Some(node) = AnyFunctionLike::cast_ref(node) {
                    self.stack.push((node, false));
                }

                if let Some((_, has_yield)) = self.stack.last_mut() {
                    // When the visitor enters a `yield` expression, set the
                    // `has_yield` flag for the top entry on the stack to `true`
                    if JsYieldExpression::can_cast(node.kind()) {
                        *has_yield = true;
                    }
                }
            }
            WalkEvent::Leave(node) => {
                // When the visitor exits a function, if it matches the node of the top-most
                // entry of the stack and the `has_yield` flag is `false`, emit a query match
                if let Some(exit_node) = AnyFunctionLike::cast_ref(node) {
                    if let Some((enter_node, has_yield)) = self.stack.pop() {
                        assert_eq!(enter_node, exit_node);
                        if !has_yield {
                            ctx.match_query(MissingYield(enter_node));
                        }
                    }
                }
            }
        }
    }
}

// Declare a query match struct type containing a JavaScript function node
struct MissingYield(AnyFunctionLike);

// Implement the `Queryable` trait for this type
impl Queryable for MissingYield {
    // `Input` is the type that `ctx.match_query()` is called with in the visitor
    type Input = Self;
    // `Output` if the type that `ctx.query()` will return in the rule
    type Output = AnyFunctionLike;

    fn build_visitor(
        analyzer: &mut impl AddVisitor<Self::Language>,
        _: &<Self::Language as Language>::Root,
    ) {
        // Register our custom visitor to run in the `Syntax` phase
        analyzer.add_visitor(Phases::Syntax, MissingYieldVisitor::default());
    }

    // Extract the output object from the input type
    fn unwrap_match(services: &ServiceBag, query: &Self::Input) -> Self::Output {
        query.0.clone()
    }
}

impl Rule for UseYield {
    // Declare the custom `MissingYield` queryable as the rule's query
    type Query = MissingYield;

    fn run(ctx: &RuleContext<Self>) -> Self::Signals {
        // Read the function's root node from the queryable output
        let query: &AnyFunctionLike = ctx.query();

        // ...
    }
}
```

# Using Just

It is also possible to do all the steps above using our `Just` automation. For example, we can create
a rule calling

```ignore
> just new-lintrule crates/rome_js_analyze/src/analyzers/nursery myRuleName
```

Once we are happy with our implementation we can call

```ignore
> just test-lintrule myRuleName
```

And at the end, to test our commits are ready to be push we can call

```ignore
> just check-ready
```

For more details on the available automations, look at our `justfile` at the root of the repository.
