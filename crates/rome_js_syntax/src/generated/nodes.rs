//! Generated file, do not edit by hand, see `xtask/codegen`

#![allow(clippy::enum_variant_names)]
#![allow(clippy::match_like_matches_macro)]
use crate::ast::DebugSyntaxElementChildren;
use crate::{
    JsLanguage, JsSyntaxElement, JsSyntaxElementChildren,
    JsSyntaxKind::{self, *},
    JsSyntaxList, JsSyntaxNode, JsSyntaxToken,
};
use rome_rowan::{
    support, AstNode, AstNodeList, AstNodeListIterator, AstSeparatedList,
    AstSeparatedListNodesIterator, NodeOrToken, SyntaxResult,
};
use std::fmt::{Debug, Formatter};

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ImportMeta {
    pub(crate) syntax: JsSyntaxNode,
}
impl ImportMeta {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> ImportMetaFields {
        ImportMetaFields {
            import_token: self.import_token(),
            dot_token: self.dot_token(),
            meta_token: self.meta_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn meta_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct ImportMetaFields {
    pub import_token: SyntaxResult<JsSyntaxToken>,
    pub dot_token: SyntaxResult<JsSyntaxToken>,
    pub meta_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayAssignmentPattern {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsArrayAssignmentPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsArrayAssignmentPatternFields {
        JsArrayAssignmentPatternFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayAssignmentPatternElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsArrayAssignmentPatternFields {
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub elements: JsArrayAssignmentPatternElementList,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayAssignmentPatternRestElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsArrayAssignmentPatternRestElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsArrayAssignmentPatternRestElementFields {
        JsArrayAssignmentPatternRestElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            pattern: self.pattern(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyAssignmentPattern> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsArrayAssignmentPatternRestElementFields {
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub pattern: SyntaxResult<JsAnyAssignmentPattern>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayBindingPattern {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsArrayBindingPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsArrayBindingPatternFields {
        JsArrayBindingPatternFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayBindingPatternElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsArrayBindingPatternFields {
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub elements: JsArrayBindingPatternElementList,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayBindingPatternRestElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsArrayBindingPatternRestElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsArrayBindingPatternRestElementFields {
        JsArrayBindingPatternRestElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            pattern: self.pattern(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsArrayBindingPatternRestElementFields {
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub pattern: SyntaxResult<JsAnyBindingPattern>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsArrayExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsArrayExpressionFields {
        JsArrayExpressionFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsArrayExpressionFields {
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub elements: JsArrayElementList,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayHole {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsArrayHole {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsArrayHoleFields {
        JsArrayHoleFields {}
    }
}
pub struct JsArrayHoleFields {}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrowFunctionExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsArrowFunctionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsArrowFunctionExpressionFields {
        JsArrowFunctionExpressionFields {
            async_token: self.async_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            fat_arrow_token: self.fat_arrow_token(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsAnyArrowFunctionParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
pub struct JsArrowFunctionExpressionFields {
    pub async_token: Option<JsSyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsAnyArrowFunctionParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub fat_arrow_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsAnyFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAssignmentExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsAssignmentExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsAssignmentExpressionFields {
        JsAssignmentExpressionFields {
            left: self.left(),
            operator_token: self.operator_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyAssignmentPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsAssignmentExpressionFields {
    pub left: SyntaxResult<JsAnyAssignmentPattern>,
    pub operator_token: SyntaxResult<JsSyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAssignmentWithDefault {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsAssignmentWithDefault {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsAssignmentWithDefaultFields {
        JsAssignmentWithDefaultFields {
            pattern: self.pattern(),
            eq_token: self.eq_token(),
            default: self.default(),
        }
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyAssignmentPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn default(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsAssignmentWithDefaultFields {
    pub pattern: SyntaxResult<JsAnyAssignmentPattern>,
    pub eq_token: SyntaxResult<JsSyntaxToken>,
    pub default: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAwaitExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsAwaitExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsAwaitExpressionFields {
        JsAwaitExpressionFields {
            await_token: self.await_token(),
            argument: self.argument(),
        }
    }
    pub fn await_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsAwaitExpressionFields {
    pub await_token: SyntaxResult<JsSyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBigIntLiteralExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsBigIntLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsBigIntLiteralExpressionFields {
        JsBigIntLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsBigIntLiteralExpressionFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBinaryExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsBinaryExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsBinaryExpressionFields {
        JsBinaryExpressionFields {
            left: self.left(),
            operator: self.operator(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsBinaryExpressionFields {
    pub left: SyntaxResult<JsAnyExpression>,
    pub operator: SyntaxResult<JsSyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBindingPatternWithDefault {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsBindingPatternWithDefault {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsBindingPatternWithDefaultFields {
        JsBindingPatternWithDefaultFields {
            pattern: self.pattern(),
            eq_token: self.eq_token(),
            default: self.default(),
        }
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn default(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsBindingPatternWithDefaultFields {
    pub pattern: SyntaxResult<JsAnyBindingPattern>,
    pub eq_token: SyntaxResult<JsSyntaxToken>,
    pub default: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBlockStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsBlockStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsBlockStatementFields {
        JsBlockStatementFields {
            l_curly_token: self.l_curly_token(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn statements(&self) -> JsStatementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsBlockStatementFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBooleanLiteralExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsBooleanLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsBooleanLiteralExpressionFields {
        JsBooleanLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsBooleanLiteralExpressionFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBreakStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsBreakStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsBreakStatementFields {
        JsBreakStatementFields {
            break_token: self.break_token(),
            label_token: self.label_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn break_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn label_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
}
pub struct JsBreakStatementFields {
    pub break_token: SyntaxResult<JsSyntaxToken>,
    pub label_token: Option<JsSyntaxToken>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCallArguments {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsCallArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsCallArgumentsFields {
        JsCallArgumentsFields {
            l_paren_token: self.l_paren_token(),
            args: self.args(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn args(&self) -> JsCallArgumentList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsCallArgumentsFields {
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub args: JsCallArgumentList,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCallExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsCallExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsCallExpressionFields {
        JsCallExpressionFields {
            callee: self.callee(),
            optional_chain_token: self.optional_chain_token(),
            type_arguments: self.type_arguments(),
            arguments: self.arguments(),
        }
    }
    pub fn callee(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_chain_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 2usize)
    }
    pub fn arguments(&self) -> SyntaxResult<JsCallArguments> {
        support::required_node(&self.syntax, 3usize)
    }
}
pub struct JsCallExpressionFields {
    pub callee: SyntaxResult<JsAnyExpression>,
    pub optional_chain_token: Option<JsSyntaxToken>,
    pub type_arguments: Option<TsTypeArguments>,
    pub arguments: SyntaxResult<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCaseClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsCaseClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsCaseClauseFields {
        JsCaseClauseFields {
            case_token: self.case_token(),
            test: self.test(),
            colon_token: self.colon_token(),
            consequent: self.consequent(),
        }
    }
    pub fn case_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn consequent(&self) -> JsStatementList {
        support::list(&self.syntax, 3usize)
    }
}
pub struct JsCaseClauseFields {
    pub case_token: SyntaxResult<JsSyntaxToken>,
    pub test: SyntaxResult<JsAnyExpression>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub consequent: JsStatementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCatchClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsCatchClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsCatchClauseFields {
        JsCatchClauseFields {
            catch_token: self.catch_token(),
            declaration: self.declaration(),
            body: self.body(),
        }
    }
    pub fn catch_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> Option<JsCatchDeclaration> {
        support::node(&self.syntax, 1usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsCatchClauseFields {
    pub catch_token: SyntaxResult<JsSyntaxToken>,
    pub declaration: Option<JsCatchDeclaration>,
    pub body: SyntaxResult<JsBlockStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCatchDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsCatchDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsCatchDeclarationFields {
        JsCatchDeclarationFields {
            l_paren_token: self.l_paren_token(),
            binding: self.binding(),
            type_annotation: self.type_annotation(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsCatchDeclarationFields {
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub binding: SyntaxResult<JsAnyBindingPattern>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsClassDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsClassDeclarationFields {
        JsClassDeclarationFields {
            abstract_token: self.abstract_token(),
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn abstract_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn class_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> {
        support::node(&self.syntax, 4usize)
    }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 5usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
    pub fn members(&self) -> JsClassMemberList {
        support::list(&self.syntax, 7usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 8usize)
    }
}
pub struct JsClassDeclarationFields {
    pub abstract_token: Option<JsSyntaxToken>,
    pub class_token: SyntaxResult<JsSyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassExportDefaultDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsClassExportDefaultDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsClassExportDefaultDeclarationFields {
        JsClassExportDefaultDeclarationFields {
            abstract_token: self.abstract_token(),
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn abstract_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn class_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> Option<JsAnyBinding> {
        support::node(&self.syntax, 2usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> {
        support::node(&self.syntax, 4usize)
    }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 5usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
    pub fn members(&self) -> JsClassMemberList {
        support::list(&self.syntax, 7usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 8usize)
    }
}
pub struct JsClassExportDefaultDeclarationFields {
    pub abstract_token: Option<JsSyntaxToken>,
    pub class_token: SyntaxResult<JsSyntaxToken>,
    pub id: Option<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsClassExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsClassExpressionFields {
        JsClassExpressionFields {
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn class_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn id(&self) -> Option<JsAnyBinding> {
        support::node(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> {
        support::node(&self.syntax, 3usize)
    }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 4usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn members(&self) -> JsClassMemberList {
        support::list(&self.syntax, 6usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
}
pub struct JsClassExpressionFields {
    pub class_token: SyntaxResult<JsSyntaxToken>,
    pub id: Option<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberAssignment {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsComputedMemberAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsComputedMemberAssignmentFields {
        JsComputedMemberAssignmentFields {
            object: self.object(),
            l_brack_token: self.l_brack_token(),
            member: self.member(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsComputedMemberAssignmentFields {
    pub object: SyntaxResult<JsAnyExpression>,
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub member: SyntaxResult<JsAnyExpression>,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsComputedMemberExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsComputedMemberExpressionFields {
        JsComputedMemberExpressionFields {
            object: self.object(),
            optional_chain_token: self.optional_chain_token(),
            l_brack_token: self.l_brack_token(),
            member: self.member(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_chain_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn member(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
pub struct JsComputedMemberExpressionFields {
    pub object: SyntaxResult<JsAnyExpression>,
    pub optional_chain_token: Option<JsSyntaxToken>,
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub member: SyntaxResult<JsAnyExpression>,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsComputedMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsComputedMemberNameFields {
        JsComputedMemberNameFields {
            l_brack_token: self.l_brack_token(),
            expression: self.expression(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsComputedMemberNameFields {
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConditionalExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsConditionalExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsConditionalExpressionFields {
        JsConditionalExpressionFields {
            test: self.test(),
            question_mark_token: self.question_mark_token(),
            consequent: self.consequent(),
            colon_token: self.colon_token(),
            alternate: self.alternate(),
        }
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn consequent(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn alternate(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 4usize)
    }
}
pub struct JsConditionalExpressionFields {
    pub test: SyntaxResult<JsAnyExpression>,
    pub question_mark_token: SyntaxResult<JsSyntaxToken>,
    pub consequent: SyntaxResult<JsAnyExpression>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub alternate: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConstructorClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsConstructorClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsConstructorClassMemberFields {
        JsConstructorClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            parameters: self.parameters(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsConstructorModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsLiteralMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsConstructorParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 3usize)
    }
}
pub struct JsConstructorClassMemberFields {
    pub modifiers: JsConstructorModifierList,
    pub name: SyntaxResult<JsLiteralMemberName>,
    pub parameters: SyntaxResult<JsConstructorParameters>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConstructorParameters {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsConstructorParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsConstructorParametersFields {
        JsConstructorParametersFields {
            l_paren_token: self.l_paren_token(),
            parameters: self.parameters(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> JsConstructorParameterList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsConstructorParametersFields {
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub parameters: JsConstructorParameterList,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsContinueStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsContinueStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsContinueStatementFields {
        JsContinueStatementFields {
            continue_token: self.continue_token(),
            label_token: self.label_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn continue_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn label_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
}
pub struct JsContinueStatementFields {
    pub continue_token: SyntaxResult<JsSyntaxToken>,
    pub label_token: Option<JsSyntaxToken>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDebuggerStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsDebuggerStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsDebuggerStatementFields {
        JsDebuggerStatementFields {
            debugger_token: self.debugger_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn debugger_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
}
pub struct JsDebuggerStatementFields {
    pub debugger_token: SyntaxResult<JsSyntaxToken>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDefaultClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsDefaultClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsDefaultClauseFields {
        JsDefaultClauseFields {
            default_token: self.default_token(),
            colon_token: self.colon_token(),
            consequent: self.consequent(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn consequent(&self) -> JsStatementList {
        support::list(&self.syntax, 2usize)
    }
}
pub struct JsDefaultClauseFields {
    pub default_token: SyntaxResult<JsSyntaxToken>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub consequent: JsStatementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDefaultImportSpecifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsDefaultImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsDefaultImportSpecifierFields {
        JsDefaultImportSpecifierFields {
            local_name: self.local_name(),
            trailing_comma_token: self.trailing_comma_token(),
        }
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn trailing_comma_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct JsDefaultImportSpecifierFields {
    pub local_name: SyntaxResult<JsAnyBinding>,
    pub trailing_comma_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDirective {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsDirective {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsDirectiveFields {
        JsDirectiveFields {
            value_token: self.value_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
}
pub struct JsDirectiveFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDoWhileStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsDoWhileStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsDoWhileStatementFields {
        JsDoWhileStatementFields {
            do_token: self.do_token(),
            body: self.body(),
            while_token: self.while_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn do_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn while_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 6usize)
    }
}
pub struct JsDoWhileStatementFields {
    pub do_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
    pub while_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub test: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsElseClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsElseClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsElseClauseFields {
        JsElseClauseFields {
            else_token: self.else_token(),
            alternate: self.alternate(),
        }
    }
    pub fn else_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn alternate(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsElseClauseFields {
    pub else_token: SyntaxResult<JsSyntaxToken>,
    pub alternate: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsEmptyClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsEmptyClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsEmptyClassMemberFields {
        JsEmptyClassMemberFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsEmptyClassMemberFields {
    pub semicolon_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsEmptyStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsEmptyStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsEmptyStatementFields {
        JsEmptyStatementFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsEmptyStatementFields {
    pub semicolon_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExport {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExport {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportFields {
        JsExportFields {
            export_token: self.export_token(),
            export_clause: self.export_clause(),
        }
    }
    pub fn export_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn export_clause(&self) -> SyntaxResult<JsAnyExportClause> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsExportFields {
    pub export_token: SyntaxResult<JsSyntaxToken>,
    pub export_clause: SyntaxResult<JsAnyExportClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportAsClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportAsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportAsClauseFields {
        JsExportAsClauseFields {
            as_token: self.as_token(),
            exported_name: self.exported_name(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn exported_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsExportAsClauseFields {
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub exported_name: SyntaxResult<JsLiteralExportName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportDefaultDeclarationClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportDefaultDeclarationClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportDefaultDeclarationClauseFields {
        JsExportDefaultDeclarationClauseFields {
            default_token: self.default_token(),
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<JsAnyExportDefaultDeclaration> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
}
pub struct JsExportDefaultDeclarationClauseFields {
    pub default_token: SyntaxResult<JsSyntaxToken>,
    pub declaration: SyntaxResult<JsAnyExportDefaultDeclaration>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportDefaultExpressionClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportDefaultExpressionClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportDefaultExpressionClauseFields {
        JsExportDefaultExpressionClauseFields {
            default_token: self.default_token(),
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
}
pub struct JsExportDefaultExpressionClauseFields {
    pub default_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportFromClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportFromClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportFromClauseFields {
        JsExportFromClauseFields {
            star_token: self.star_token(),
            export_as: self.export_as(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn star_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn export_as(&self) -> Option<JsExportAsClause> {
        support::node(&self.syntax, 1usize)
    }
    pub fn from_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> {
        support::node(&self.syntax, 4usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 5usize)
    }
}
pub struct JsExportFromClauseFields {
    pub star_token: SyntaxResult<JsSyntaxToken>,
    pub export_as: Option<JsExportAsClause>,
    pub from_token: SyntaxResult<JsSyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportNamedClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportNamedClauseFields {
        JsExportNamedClauseFields {
            type_token: self.type_token(),
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn specifiers(&self) -> JsExportNamedSpecifierList {
        support::list(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 4usize)
    }
}
pub struct JsExportNamedClauseFields {
    pub type_token: Option<JsSyntaxToken>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub specifiers: JsExportNamedSpecifierList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedFromClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportNamedFromClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportNamedFromClauseFields {
        JsExportNamedFromClauseFields {
            type_token: self.type_token(),
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn specifiers(&self) -> JsExportNamedFromSpecifierList {
        support::list(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn from_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> {
        support::node(&self.syntax, 6usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 7usize)
    }
}
pub struct JsExportNamedFromClauseFields {
    pub type_token: Option<JsSyntaxToken>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub specifiers: JsExportNamedFromSpecifierList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
    pub from_token: SyntaxResult<JsSyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedFromSpecifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportNamedFromSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportNamedFromSpecifierFields {
        JsExportNamedFromSpecifierFields {
            type_token: self.type_token(),
            source_name: self.source_name(),
            export_as: self.export_as(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn source_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn export_as(&self) -> Option<JsExportAsClause> {
        support::node(&self.syntax, 2usize)
    }
}
pub struct JsExportNamedFromSpecifierFields {
    pub type_token: Option<JsSyntaxToken>,
    pub source_name: SyntaxResult<JsLiteralExportName>,
    pub export_as: Option<JsExportAsClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedShorthandSpecifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportNamedShorthandSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportNamedShorthandSpecifierFields {
        JsExportNamedShorthandSpecifierFields {
            type_token: self.type_token(),
            name: self.name(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsExportNamedShorthandSpecifierFields {
    pub type_token: Option<JsSyntaxToken>,
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedSpecifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExportNamedSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExportNamedSpecifierFields {
        JsExportNamedSpecifierFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
            as_token: self.as_token(),
            exported_name: self.exported_name(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn exported_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 3usize)
    }
}
pub struct JsExportNamedSpecifierFields {
    pub type_token: Option<JsSyntaxToken>,
    pub local_name: SyntaxResult<JsReferenceIdentifier>,
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub exported_name: SyntaxResult<JsLiteralExportName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExpressionSnipped {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExpressionSnipped {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExpressionSnippedFields {
        JsExpressionSnippedFields {
            expression: self.expression(),
            eof_token: self.eof_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eof_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct JsExpressionSnippedFields {
    pub expression: SyntaxResult<JsAnyExpression>,
    pub eof_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExpressionStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExpressionStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExpressionStatementFields {
        JsExpressionStatementFields {
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
}
pub struct JsExpressionStatementFields {
    pub expression: SyntaxResult<JsAnyExpression>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExtendsClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsExtendsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsExtendsClauseFields {
        JsExtendsClauseFields {
            extends_token: self.extends_token(),
            super_class: self.super_class(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn super_class(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 2usize)
    }
}
pub struct JsExtendsClauseFields {
    pub extends_token: SyntaxResult<JsSyntaxToken>,
    pub super_class: SyntaxResult<JsAnyExpression>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFinallyClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsFinallyClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsFinallyClauseFields {
        JsFinallyClauseFields {
            finally_token: self.finally_token(),
            body: self.body(),
        }
    }
    pub fn finally_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsFinallyClauseFields {
    pub finally_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForInStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsForInStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsForInStatementFields {
        JsForInStatementFields {
            for_token: self.for_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            in_token: self.in_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> SyntaxResult<JsAnyForInOrOfInitializer> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn in_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 6usize)
    }
}
pub struct JsForInStatementFields {
    pub for_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub initializer: SyntaxResult<JsAnyForInOrOfInitializer>,
    pub in_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForOfStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsForOfStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsForOfStatementFields {
        JsForOfStatementFields {
            for_token: self.for_token(),
            await_token: self.await_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            of_token: self.of_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn await_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn initializer(&self) -> SyntaxResult<JsAnyForInOrOfInitializer> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn of_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 7usize)
    }
}
pub struct JsForOfStatementFields {
    pub for_token: SyntaxResult<JsSyntaxToken>,
    pub await_token: Option<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub initializer: SyntaxResult<JsAnyForInOrOfInitializer>,
    pub of_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsForStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsForStatementFields {
        JsForStatementFields {
            for_token: self.for_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            first_semi_token: self.first_semi_token(),
            test: self.test(),
            second_semi_token: self.second_semi_token(),
            update: self.update(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> Option<JsAnyForInitializer> {
        support::node(&self.syntax, 2usize)
    }
    pub fn first_semi_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn test(&self) -> Option<JsAnyExpression> {
        support::node(&self.syntax, 4usize)
    }
    pub fn second_semi_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn update(&self) -> Option<JsAnyExpression> {
        support::node(&self.syntax, 6usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 8usize)
    }
}
pub struct JsForStatementFields {
    pub for_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub initializer: Option<JsAnyForInitializer>,
    pub first_semi_token: SyntaxResult<JsSyntaxToken>,
    pub test: Option<JsAnyExpression>,
    pub second_semi_token: SyntaxResult<JsSyntaxToken>,
    pub update: Option<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForVariableDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsForVariableDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsForVariableDeclarationFields {
        JsForVariableDeclarationFields {
            kind_token: self.kind_token(),
            declarator: self.declarator(),
        }
    }
    pub fn kind_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declarator(&self) -> SyntaxResult<JsVariableDeclarator> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsForVariableDeclarationFields {
    pub kind_token: SyntaxResult<JsSyntaxToken>,
    pub declarator: SyntaxResult<JsVariableDeclarator>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFormalParameter {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsFormalParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsFormalParameterFields {
        JsFormalParameterFields {
            binding: self.binding(),
            question_mark_token: self.question_mark_token(),
            type_annotation: self.type_annotation(),
            initializer: self.initializer(),
        }
    }
    pub fn binding(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> {
        support::node(&self.syntax, 3usize)
    }
}
pub struct JsFormalParameterFields {
    pub binding: SyntaxResult<JsAnyBindingPattern>,
    pub question_mark_token: Option<JsSyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionBody {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsFunctionBody {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsFunctionBodyFields {
        JsFunctionBodyFields {
            l_curly_token: self.l_curly_token(),
            directives: self.directives(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn directives(&self) -> JsDirectiveList {
        support::list(&self.syntax, 1usize)
    }
    pub fn statements(&self) -> JsStatementList {
        support::list(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsFunctionBodyFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub directives: JsDirectiveList,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsFunctionDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsFunctionDeclarationFields {
        JsFunctionDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn function_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
pub struct JsFunctionDeclarationFields {
    pub async_token: Option<JsSyntaxToken>,
    pub function_token: SyntaxResult<JsSyntaxToken>,
    pub star_token: Option<JsSyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionExportDefaultDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsFunctionExportDefaultDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsFunctionExportDefaultDeclarationFields {
        JsFunctionExportDefaultDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn function_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn id(&self) -> Option<JsAnyBinding> {
        support::node(&self.syntax, 3usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
pub struct JsFunctionExportDefaultDeclarationFields {
    pub async_token: Option<JsSyntaxToken>,
    pub function_token: SyntaxResult<JsSyntaxToken>,
    pub star_token: Option<JsSyntaxToken>,
    pub id: Option<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsFunctionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsFunctionExpressionFields {
        JsFunctionExpressionFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn function_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn id(&self) -> Option<JsAnyBinding> {
        support::node(&self.syntax, 3usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
pub struct JsFunctionExpressionFields {
    pub async_token: Option<JsSyntaxToken>,
    pub function_token: SyntaxResult<JsSyntaxToken>,
    pub star_token: Option<JsSyntaxToken>,
    pub id: Option<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsGetterClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsGetterClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsGetterClassMemberFields {
        JsGetterClassMemberFields {
            modifiers: self.modifiers(),
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn get_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
pub struct JsGetterClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub get_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsGetterObjectMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsGetterObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsGetterObjectMemberFields {
        JsGetterObjectMemberFields {
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            body: self.body(),
        }
    }
    pub fn get_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 4usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
pub struct JsGetterObjectMemberFields {
    pub get_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierAssignment {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsIdentifierAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsIdentifierAssignmentFields {
        JsIdentifierAssignmentFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsIdentifierAssignmentFields {
    pub name_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierBinding {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsIdentifierBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsIdentifierBindingFields {
        JsIdentifierBindingFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsIdentifierBindingFields {
    pub name_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsIdentifierExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsIdentifierExpressionFields {
        JsIdentifierExpressionFields { name: self.name() }
    }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 0usize)
    }
}
pub struct JsIdentifierExpressionFields {
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIfStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsIfStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsIfStatementFields {
        JsIfStatementFields {
            if_token: self.if_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            consequent: self.consequent(),
            else_clause: self.else_clause(),
        }
    }
    pub fn if_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn consequent(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn else_clause(&self) -> Option<JsElseClause> {
        support::node(&self.syntax, 5usize)
    }
}
pub struct JsIfStatementFields {
    pub if_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub test: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub consequent: SyntaxResult<JsAnyStatement>,
    pub else_clause: Option<JsElseClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImport {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsImport {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsImportFields {
        JsImportFields {
            import_token: self.import_token(),
            import_clause: self.import_clause(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn import_clause(&self) -> SyntaxResult<JsAnyImportClause> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
}
pub struct JsImportFields {
    pub import_token: SyntaxResult<JsSyntaxToken>,
    pub import_clause: SyntaxResult<JsAnyImportClause>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportAssertion {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsImportAssertion {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsImportAssertionFields {
        JsImportAssertionFields {
            assert_token: self.assert_token(),
            l_curly_token: self.l_curly_token(),
            assertions: self.assertions(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn assert_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn assertions(&self) -> JsImportAssertionEntryList {
        support::list(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsImportAssertionFields {
    pub assert_token: SyntaxResult<JsSyntaxToken>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub assertions: JsImportAssertionEntryList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportAssertionEntry {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsImportAssertionEntry {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsImportAssertionEntryFields {
        JsImportAssertionEntryFields {
            key: self.key(),
            colon_token: self.colon_token(),
            value_token: self.value_token(),
        }
    }
    pub fn key(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsImportAssertionEntryFields {
    pub key: SyntaxResult<JsSyntaxToken>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportBareClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsImportBareClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsImportBareClauseFields {
        JsImportBareClauseFields {
            source: self.source(),
            assertion: self.assertion(),
        }
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct JsImportBareClauseFields {
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportCallExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsImportCallExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsImportCallExpressionFields {
        JsImportCallExpressionFields {
            import_token: self.import_token(),
            arguments: self.arguments(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn arguments(&self) -> SyntaxResult<JsCallArguments> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsImportCallExpressionFields {
    pub import_token: SyntaxResult<JsSyntaxToken>,
    pub arguments: SyntaxResult<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportDefaultClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsImportDefaultClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsImportDefaultClauseFields {
        JsImportDefaultClauseFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn from_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> {
        support::node(&self.syntax, 4usize)
    }
}
pub struct JsImportDefaultClauseFields {
    pub type_token: Option<JsSyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
    pub from_token: SyntaxResult<JsSyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportNamedClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsImportNamedClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsImportNamedClauseFields {
        JsImportNamedClauseFields {
            type_token: self.type_token(),
            default_specifier: self.default_specifier(),
            named_import: self.named_import(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn default_specifier(&self) -> Option<JsDefaultImportSpecifier> {
        support::node(&self.syntax, 1usize)
    }
    pub fn named_import(&self) -> SyntaxResult<JsAnyNamedImport> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn from_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> {
        support::node(&self.syntax, 5usize)
    }
}
pub struct JsImportNamedClauseFields {
    pub type_token: Option<JsSyntaxToken>,
    pub default_specifier: Option<JsDefaultImportSpecifier>,
    pub named_import: SyntaxResult<JsAnyNamedImport>,
    pub from_token: SyntaxResult<JsSyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportNamespaceClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsImportNamespaceClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsImportNamespaceClauseFields {
        JsImportNamespaceClauseFields {
            type_token: self.type_token(),
            star_token: self.star_token(),
            as_token: self.as_token(),
            local_name: self.local_name(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn star_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn from_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> {
        support::node(&self.syntax, 6usize)
    }
}
pub struct JsImportNamespaceClauseFields {
    pub type_token: Option<JsSyntaxToken>,
    pub star_token: SyntaxResult<JsSyntaxToken>,
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
    pub from_token: SyntaxResult<JsSyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsInExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsInExpressionFields {
        JsInExpressionFields {
            property: self.property(),
            in_token: self.in_token(),
            object: self.object(),
        }
    }
    pub fn property(&self) -> SyntaxResult<JsAnyInProperty> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn in_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsInExpressionFields {
    pub property: SyntaxResult<JsAnyInProperty>,
    pub in_token: SyntaxResult<JsSyntaxToken>,
    pub object: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInitializerClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsInitializerClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsInitializerClauseFields {
        JsInitializerClauseFields {
            eq_token: self.eq_token(),
            expression: self.expression(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsInitializerClauseFields {
    pub eq_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInstanceofExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsInstanceofExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsInstanceofExpressionFields {
        JsInstanceofExpressionFields {
            left: self.left(),
            instanceof_token: self.instanceof_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn instanceof_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsInstanceofExpressionFields {
    pub left: SyntaxResult<JsAnyExpression>,
    pub instanceof_token: SyntaxResult<JsSyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLabeledStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsLabeledStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsLabeledStatementFields {
        JsLabeledStatementFields {
            label_token: self.label_token(),
            colon_token: self.colon_token(),
            body: self.body(),
        }
    }
    pub fn label_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsLabeledStatementFields {
    pub label_token: SyntaxResult<JsSyntaxToken>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLiteralExportName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsLiteralExportName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsLiteralExportNameFields {
        JsLiteralExportNameFields {
            value: self.value(),
        }
    }
    pub fn value(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsLiteralExportNameFields {
    pub value: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLiteralMemberName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsLiteralMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsLiteralMemberNameFields {
        JsLiteralMemberNameFields {
            value: self.value(),
        }
    }
    pub fn value(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsLiteralMemberNameFields {
    pub value: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLogicalExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsLogicalExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsLogicalExpressionFields {
        JsLogicalExpressionFields {
            left: self.left(),
            operator: self.operator(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsLogicalExpressionFields {
    pub left: SyntaxResult<JsAnyExpression>,
    pub operator: SyntaxResult<JsSyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsMethodClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsMethodClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsMethodClassMemberFields {
        JsMethodClassMemberFields {
            modifiers: self.modifiers(),
            async_token: self.async_token(),
            star_token: self.star_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn async_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn question_mark_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 4usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 5usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 6usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 7usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 8usize)
    }
}
pub struct JsMethodClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub async_token: Option<JsSyntaxToken>,
    pub star_token: Option<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub question_mark_token: Option<JsSyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsMethodObjectMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsMethodObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsMethodObjectMemberFields {
        JsMethodObjectMemberFields {
            async_token: self.async_token(),
            star_token: self.star_token(),
            name: self.name(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn star_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
pub struct JsMethodObjectMemberFields {
    pub async_token: Option<JsSyntaxToken>,
    pub star_token: Option<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsModule {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsModule {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsModuleFields {
        JsModuleFields {
            interpreter_token: self.interpreter_token(),
            directives: self.directives(),
            items: self.items(),
            eof_token: self.eof_token(),
        }
    }
    pub fn interpreter_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn directives(&self) -> JsDirectiveList {
        support::list(&self.syntax, 1usize)
    }
    pub fn items(&self) -> JsModuleItemList {
        support::list(&self.syntax, 2usize)
    }
    pub fn eof_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsModuleFields {
    pub interpreter_token: Option<JsSyntaxToken>,
    pub directives: JsDirectiveList,
    pub items: JsModuleItemList,
    pub eof_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsModuleSource {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsModuleSource {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsModuleSourceFields {
        JsModuleSourceFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsModuleSourceFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsNameFields {
        JsNameFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsNameFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamedImportSpecifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsNamedImportSpecifierFields {
        JsNamedImportSpecifierFields {
            type_token: self.type_token(),
            name: self.name(),
            as_token: self.as_token(),
            local_name: self.local_name(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 3usize)
    }
}
pub struct JsNamedImportSpecifierFields {
    pub type_token: Option<JsSyntaxToken>,
    pub name: SyntaxResult<JsLiteralExportName>,
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamedImportSpecifiers {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsNamedImportSpecifiers {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsNamedImportSpecifiersFields {
        JsNamedImportSpecifiersFields {
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn specifiers(&self) -> JsNamedImportSpecifierList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsNamedImportSpecifiersFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub specifiers: JsNamedImportSpecifierList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamespaceImportSpecifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsNamespaceImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsNamespaceImportSpecifierFields {
        JsNamespaceImportSpecifierFields {
            star_token: self.star_token(),
            as_token: self.as_token(),
            local_name: self.local_name(),
        }
    }
    pub fn star_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsNamespaceImportSpecifierFields {
    pub star_token: SyntaxResult<JsSyntaxToken>,
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNewExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsNewExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsNewExpressionFields {
        JsNewExpressionFields {
            new_token: self.new_token(),
            callee: self.callee(),
            type_arguments: self.type_arguments(),
            arguments: self.arguments(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn callee(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 2usize)
    }
    pub fn arguments(&self) -> Option<JsCallArguments> {
        support::node(&self.syntax, 3usize)
    }
}
pub struct JsNewExpressionFields {
    pub new_token: SyntaxResult<JsSyntaxToken>,
    pub callee: SyntaxResult<JsAnyExpression>,
    pub type_arguments: Option<TsTypeArguments>,
    pub arguments: Option<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNullLiteralExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsNullLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsNullLiteralExpressionFields {
        JsNullLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsNullLiteralExpressionFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNumberLiteralExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsNumberLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsNumberLiteralExpressionFields {
        JsNumberLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsNumberLiteralExpressionFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPattern {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectAssignmentPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternFields {
        JsObjectAssignmentPatternFields {
            l_curly_token: self.l_curly_token(),
            properties: self.properties(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn properties(&self) -> JsObjectAssignmentPatternPropertyList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsObjectAssignmentPatternFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub properties: JsObjectAssignmentPatternPropertyList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternProperty {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectAssignmentPatternProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternPropertyFields {
        JsObjectAssignmentPatternPropertyFields {
            member: self.member(),
            colon_token: self.colon_token(),
            pattern: self.pattern(),
            init: self.init(),
        }
    }
    pub fn member(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyAssignmentPattern> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> {
        support::node(&self.syntax, 3usize)
    }
}
pub struct JsObjectAssignmentPatternPropertyFields {
    pub member: SyntaxResult<JsAnyObjectMemberName>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub pattern: SyntaxResult<JsAnyAssignmentPattern>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternRest {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectAssignmentPatternRest {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternRestFields {
        JsObjectAssignmentPatternRestFields {
            dotdotdot_token: self.dotdotdot_token(),
            target: self.target(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn target(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsObjectAssignmentPatternRestFields {
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub target: SyntaxResult<JsAnyAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternShorthandProperty {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectAssignmentPatternShorthandProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternShorthandPropertyFields {
        JsObjectAssignmentPatternShorthandPropertyFields {
            identifier: self.identifier(),
            init: self.init(),
        }
    }
    pub fn identifier(&self) -> SyntaxResult<JsIdentifierAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct JsObjectAssignmentPatternShorthandPropertyFields {
    pub identifier: SyntaxResult<JsIdentifierAssignment>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPattern {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectBindingPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectBindingPatternFields {
        JsObjectBindingPatternFields {
            l_curly_token: self.l_curly_token(),
            properties: self.properties(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn properties(&self) -> JsObjectBindingPatternPropertyList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsObjectBindingPatternFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub properties: JsObjectBindingPatternPropertyList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternProperty {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectBindingPatternProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectBindingPatternPropertyFields {
        JsObjectBindingPatternPropertyFields {
            member: self.member(),
            colon_token: self.colon_token(),
            pattern: self.pattern(),
            init: self.init(),
        }
    }
    pub fn member(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> {
        support::node(&self.syntax, 3usize)
    }
}
pub struct JsObjectBindingPatternPropertyFields {
    pub member: SyntaxResult<JsAnyObjectMemberName>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub pattern: SyntaxResult<JsAnyBindingPattern>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternRest {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectBindingPatternRest {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectBindingPatternRestFields {
        JsObjectBindingPatternRestFields {
            dotdotdot_token: self.dotdotdot_token(),
            binding: self.binding(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsObjectBindingPatternRestFields {
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub binding: SyntaxResult<JsAnyBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternShorthandProperty {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectBindingPatternShorthandProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectBindingPatternShorthandPropertyFields {
        JsObjectBindingPatternShorthandPropertyFields {
            identifier: self.identifier(),
            init: self.init(),
        }
    }
    pub fn identifier(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct JsObjectBindingPatternShorthandPropertyFields {
    pub identifier: SyntaxResult<JsAnyBinding>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsObjectExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsObjectExpressionFields {
        JsObjectExpressionFields {
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn members(&self) -> JsObjectMemberList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsObjectExpressionFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub members: JsObjectMemberList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParameters {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsParametersFields {
        JsParametersFields {
            l_paren_token: self.l_paren_token(),
            items: self.items(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> JsParameterList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsParametersFields {
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub items: JsParameterList,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParenthesizedAssignment {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsParenthesizedAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsParenthesizedAssignmentFields {
        JsParenthesizedAssignmentFields {
            l_paren_token: self.l_paren_token(),
            assignment: self.assignment(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn assignment(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsParenthesizedAssignmentFields {
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub assignment: SyntaxResult<JsAnyAssignment>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParenthesizedExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsParenthesizedExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsParenthesizedExpressionFields {
        JsParenthesizedExpressionFields {
            l_paren_token: self.l_paren_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsParenthesizedExpressionFields {
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPostUpdateExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsPostUpdateExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsPostUpdateExpressionFields {
        JsPostUpdateExpressionFields {
            operand: self.operand(),
            operator: self.operator(),
        }
    }
    pub fn operand(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct JsPostUpdateExpressionFields {
    pub operand: SyntaxResult<JsAnyAssignment>,
    pub operator: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPreUpdateExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsPreUpdateExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsPreUpdateExpressionFields {
        JsPreUpdateExpressionFields {
            operator: self.operator(),
            operand: self.operand(),
        }
    }
    pub fn operator(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn operand(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsPreUpdateExpressionFields {
    pub operator: SyntaxResult<JsSyntaxToken>,
    pub operand: SyntaxResult<JsAnyAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPrivateClassMemberName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsPrivateClassMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsPrivateClassMemberNameFields {
        JsPrivateClassMemberNameFields {
            hash_token: self.hash_token(),
            id_token: self.id_token(),
        }
    }
    pub fn hash_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn id_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct JsPrivateClassMemberNameFields {
    pub hash_token: SyntaxResult<JsSyntaxToken>,
    pub id_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPrivateName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsPrivateName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsPrivateNameFields {
        JsPrivateNameFields {
            hash_token: self.hash_token(),
            value_token: self.value_token(),
        }
    }
    pub fn hash_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct JsPrivateNameFields {
    pub hash_token: SyntaxResult<JsSyntaxToken>,
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPropertyClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsPropertyClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsPropertyClassMemberFields {
        JsPropertyClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            property_annotation: self.property_annotation(),
            value: self.value(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> JsPropertyModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn property_annotation(&self) -> Option<TsAnyPropertyAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn value(&self) -> Option<JsInitializerClause> {
        support::node(&self.syntax, 3usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 4usize)
    }
}
pub struct JsPropertyClassMemberFields {
    pub modifiers: JsPropertyModifierList,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub property_annotation: Option<TsAnyPropertyAnnotation>,
    pub value: Option<JsInitializerClause>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPropertyObjectMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsPropertyObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsPropertyObjectMemberFields {
        JsPropertyObjectMemberFields {
            name: self.name(),
            colon_token: self.colon_token(),
            value: self.value(),
        }
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn value(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsPropertyObjectMemberFields {
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub value: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsReferenceIdentifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsReferenceIdentifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsReferenceIdentifierFields {
        JsReferenceIdentifierFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsReferenceIdentifierFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsRegexLiteralExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsRegexLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsRegexLiteralExpressionFields {
        JsRegexLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsRegexLiteralExpressionFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsRestParameter {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsRestParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsRestParameterFields {
        JsRestParameterFields {
            dotdotdot_token: self.dotdotdot_token(),
            binding: self.binding(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
}
pub struct JsRestParameterFields {
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub binding: SyntaxResult<JsAnyBindingPattern>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsReturnStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsReturnStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsReturnStatementFields {
        JsReturnStatementFields {
            return_token: self.return_token(),
            argument: self.argument(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn return_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> Option<JsAnyExpression> {
        support::node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
}
pub struct JsReturnStatementFields {
    pub return_token: SyntaxResult<JsSyntaxToken>,
    pub argument: Option<JsAnyExpression>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsScript {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsScript {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsScriptFields {
        JsScriptFields {
            interpreter_token: self.interpreter_token(),
            directives: self.directives(),
            statements: self.statements(),
            eof_token: self.eof_token(),
        }
    }
    pub fn interpreter_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn directives(&self) -> JsDirectiveList {
        support::list(&self.syntax, 1usize)
    }
    pub fn statements(&self) -> JsStatementList {
        support::list(&self.syntax, 2usize)
    }
    pub fn eof_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsScriptFields {
    pub interpreter_token: Option<JsSyntaxToken>,
    pub directives: JsDirectiveList,
    pub statements: JsStatementList,
    pub eof_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSequenceExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsSequenceExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsSequenceExpressionFields {
        JsSequenceExpressionFields {
            left: self.left(),
            comma_token: self.comma_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn comma_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsSequenceExpressionFields {
    pub left: SyntaxResult<JsAnyExpression>,
    pub comma_token: SyntaxResult<JsSyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSetterClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsSetterClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsSetterClassMemberFields {
        JsSetterClassMemberFields {
            modifiers: self.modifiers(),
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn set_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
pub struct JsSetterClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub set_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub parameter: SyntaxResult<JsAnyFormalParameter>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSetterObjectMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsSetterObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsSetterObjectMemberFields {
        JsSetterObjectMemberFields {
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn set_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
pub struct JsSetterObjectMemberFields {
    pub set_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub parameter: SyntaxResult<JsAnyFormalParameter>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsShorthandNamedImportSpecifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsShorthandNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsShorthandNamedImportSpecifierFields {
        JsShorthandNamedImportSpecifierFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
        }
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsShorthandNamedImportSpecifierFields {
    pub type_token: Option<JsSyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsShorthandPropertyObjectMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsShorthandPropertyObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsShorthandPropertyObjectMemberFields {
        JsShorthandPropertyObjectMemberFields { name: self.name() }
    }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 0usize)
    }
}
pub struct JsShorthandPropertyObjectMemberFields {
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSpread {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsSpread {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsSpreadFields {
        JsSpreadFields {
            dotdotdot_token: self.dotdotdot_token(),
            argument: self.argument(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsSpreadFields {
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticInitializationBlockClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsStaticInitializationBlockClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsStaticInitializationBlockClassMemberFields {
        JsStaticInitializationBlockClassMemberFields {
            static_token: self.static_token(),
            l_curly_token: self.l_curly_token(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn static_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn statements(&self) -> JsStatementList {
        support::list(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsStaticInitializationBlockClassMemberFields {
    pub static_token: SyntaxResult<JsSyntaxToken>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticMemberAssignment {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsStaticMemberAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsStaticMemberAssignmentFields {
        JsStaticMemberAssignmentFields {
            object: self.object(),
            dot_token: self.dot_token(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsAnyName> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsStaticMemberAssignmentFields {
    pub object: SyntaxResult<JsAnyExpression>,
    pub dot_token: SyntaxResult<JsSyntaxToken>,
    pub member: SyntaxResult<JsAnyName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticMemberExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsStaticMemberExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsStaticMemberExpressionFields {
        JsStaticMemberExpressionFields {
            object: self.object(),
            operator: self.operator(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsAnyName> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsStaticMemberExpressionFields {
    pub object: SyntaxResult<JsAnyExpression>,
    pub operator: SyntaxResult<JsSyntaxToken>,
    pub member: SyntaxResult<JsAnyName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticModifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsStaticModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsStaticModifierFields {
        JsStaticModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsStaticModifierFields {
    pub modifier_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStringLiteralExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsStringLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsStringLiteralExpressionFields {
        JsStringLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsStringLiteralExpressionFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSuperExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsSuperExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsSuperExpressionFields {
        JsSuperExpressionFields {
            super_token: self.super_token(),
        }
    }
    pub fn super_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsSuperExpressionFields {
    pub super_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSwitchStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsSwitchStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsSwitchStatementFields {
        JsSwitchStatementFields {
            switch_token: self.switch_token(),
            l_paren_token: self.l_paren_token(),
            discriminant: self.discriminant(),
            r_paren_token: self.r_paren_token(),
            l_curly_token: self.l_curly_token(),
            cases: self.cases(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn switch_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn discriminant(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn cases(&self) -> JsSwitchCaseList {
        support::list(&self.syntax, 5usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
}
pub struct JsSwitchStatementFields {
    pub switch_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub discriminant: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub cases: JsSwitchCaseList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplate {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsTemplate {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsTemplateFields {
        JsTemplateFields {
            tag: self.tag(),
            type_arguments: self.type_arguments(),
            l_tick_token: self.l_tick_token(),
            elements: self.elements(),
            r_tick_token: self.r_tick_token(),
        }
    }
    pub fn tag(&self) -> Option<JsAnyExpression> {
        support::node(&self.syntax, 0usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 1usize)
    }
    pub fn l_tick_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn elements(&self) -> JsTemplateElementList {
        support::list(&self.syntax, 3usize)
    }
    pub fn r_tick_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
pub struct JsTemplateFields {
    pub tag: Option<JsAnyExpression>,
    pub type_arguments: Option<TsTypeArguments>,
    pub l_tick_token: SyntaxResult<JsSyntaxToken>,
    pub elements: JsTemplateElementList,
    pub r_tick_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplateChunkElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsTemplateChunkElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsTemplateChunkElementFields {
        JsTemplateChunkElementFields {
            template_chunk_token: self.template_chunk_token(),
        }
    }
    pub fn template_chunk_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsTemplateChunkElementFields {
    pub template_chunk_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplateElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsTemplateElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsTemplateElementFields {
        JsTemplateElementFields {
            dollar_curly_token: self.dollar_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn dollar_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsTemplateElementFields {
    pub dollar_curly_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsThisExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsThisExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsThisExpressionFields {
        JsThisExpressionFields {
            this_token: self.this_token(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsThisExpressionFields {
    pub this_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsThrowStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsThrowStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsThrowStatementFields {
        JsThrowStatementFields {
            throw_token: self.throw_token(),
            argument: self.argument(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn throw_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
}
pub struct JsThrowStatementFields {
    pub throw_token: SyntaxResult<JsSyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTryFinallyStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsTryFinallyStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsTryFinallyStatementFields {
        JsTryFinallyStatementFields {
            try_token: self.try_token(),
            body: self.body(),
            catch_clause: self.catch_clause(),
            finally_clause: self.finally_clause(),
        }
    }
    pub fn try_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn catch_clause(&self) -> Option<JsCatchClause> {
        support::node(&self.syntax, 2usize)
    }
    pub fn finally_clause(&self) -> SyntaxResult<JsFinallyClause> {
        support::required_node(&self.syntax, 3usize)
    }
}
pub struct JsTryFinallyStatementFields {
    pub try_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
    pub catch_clause: Option<JsCatchClause>,
    pub finally_clause: SyntaxResult<JsFinallyClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTryStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsTryStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsTryStatementFields {
        JsTryStatementFields {
            try_token: self.try_token(),
            body: self.body(),
            catch_clause: self.catch_clause(),
        }
    }
    pub fn try_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn catch_clause(&self) -> SyntaxResult<JsCatchClause> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsTryStatementFields {
    pub try_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
    pub catch_clause: SyntaxResult<JsCatchClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnaryExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsUnaryExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsUnaryExpressionFields {
        JsUnaryExpressionFields {
            operator: self.operator(),
            argument: self.argument(),
        }
    }
    pub fn operator(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsUnaryExpressionFields {
    pub operator: SyntaxResult<JsSyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsVariableDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsVariableDeclarationFields {
        JsVariableDeclarationFields {
            kind: self.kind(),
            declarators: self.declarators(),
        }
    }
    pub fn kind(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declarators(&self) -> JsVariableDeclaratorList {
        support::list(&self.syntax, 1usize)
    }
}
pub struct JsVariableDeclarationFields {
    pub kind: SyntaxResult<JsSyntaxToken>,
    pub declarators: JsVariableDeclaratorList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclarationClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsVariableDeclarationClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsVariableDeclarationClauseFields {
        JsVariableDeclarationClauseFields {
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn declaration(&self) -> SyntaxResult<JsVariableDeclaration> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
}
pub struct JsVariableDeclarationClauseFields {
    pub declaration: SyntaxResult<JsVariableDeclaration>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclarator {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsVariableDeclarator {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsVariableDeclaratorFields {
        JsVariableDeclaratorFields {
            id: self.id(),
            variable_annotation: self.variable_annotation(),
            initializer: self.initializer(),
        }
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn variable_annotation(&self) -> Option<TsAnyVariableAnnotation> {
        support::node(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> {
        support::node(&self.syntax, 2usize)
    }
}
pub struct JsVariableDeclaratorFields {
    pub id: SyntaxResult<JsAnyBindingPattern>,
    pub variable_annotation: Option<TsAnyVariableAnnotation>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsVariableStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsVariableStatementFields {
        JsVariableStatementFields {
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn declaration(&self) -> SyntaxResult<JsVariableDeclaration> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
}
pub struct JsVariableStatementFields {
    pub declaration: SyntaxResult<JsVariableDeclaration>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsWhileStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsWhileStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsWhileStatementFields {
        JsWhileStatementFields {
            while_token: self.while_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn while_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 4usize)
    }
}
pub struct JsWhileStatementFields {
    pub while_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub test: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsWithStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsWithStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsWithStatementFields {
        JsWithStatementFields {
            with_token: self.with_token(),
            l_paren_token: self.l_paren_token(),
            object: self.object(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn with_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 4usize)
    }
}
pub struct JsWithStatementFields {
    pub with_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub object: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsYieldArgument {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsYieldArgument {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsYieldArgumentFields {
        JsYieldArgumentFields {
            star_token: self.star_token(),
            expression: self.expression(),
        }
    }
    pub fn star_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsYieldArgumentFields {
    pub star_token: Option<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsYieldExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsYieldExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsYieldExpressionFields {
        JsYieldExpressionFields {
            yield_token: self.yield_token(),
            argument: self.argument(),
        }
    }
    pub fn yield_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> Option<JsYieldArgument> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct JsYieldExpressionFields {
    pub yield_token: SyntaxResult<JsSyntaxToken>,
    pub argument: Option<JsYieldArgument>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxAttribute {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxAttribute {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxAttributeFields {
        JsxAttributeFields {
            name: self.name(),
            initializer: self.initializer(),
        }
    }
    pub fn name(&self) -> SyntaxResult<JsxAnyAttributeName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn initializer(&self) -> Option<JsxAttributeInitializerClause> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct JsxAttributeFields {
    pub name: SyntaxResult<JsxAnyAttributeName>,
    pub initializer: Option<JsxAttributeInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxAttributeInitializerClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxAttributeInitializerClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxAttributeInitializerClauseFields {
        JsxAttributeInitializerClauseFields {
            eq_token: self.eq_token(),
            value: self.value(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn value(&self) -> SyntaxResult<JsxAnyAttributeValue> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct JsxAttributeInitializerClauseFields {
    pub eq_token: SyntaxResult<JsSyntaxToken>,
    pub value: SyntaxResult<JsxAnyAttributeValue>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxClosingElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxClosingElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxClosingElementFields {
        JsxClosingElementFields {
            l_angle_token: self.l_angle_token(),
            slash_token: self.slash_token(),
            name: self.name(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn slash_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxAnyElementName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsxClosingElementFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub slash_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsxAnyElementName>,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxClosingFragment {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxClosingFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxClosingFragmentFields {
        JsxClosingFragmentFields {
            l_angle_token: self.l_angle_token(),
            slash_token: self.slash_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn slash_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsxClosingFragmentFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub slash_token: SyntaxResult<JsSyntaxToken>,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxElementFields {
        JsxElementFields {
            opening_element: self.opening_element(),
            children: self.children(),
            closing_element: self.closing_element(),
        }
    }
    pub fn opening_element(&self) -> SyntaxResult<JsxOpeningElement> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn children(&self) -> JsxChildList {
        support::list(&self.syntax, 1usize)
    }
    pub fn closing_element(&self) -> SyntaxResult<JsxClosingElement> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsxElementFields {
    pub opening_element: SyntaxResult<JsxOpeningElement>,
    pub children: JsxChildList,
    pub closing_element: SyntaxResult<JsxClosingElement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxExpressionAttributeValue {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxExpressionAttributeValue {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxExpressionAttributeValueFields {
        JsxExpressionAttributeValueFields {
            l_curly_token: self.l_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsxExpressionAttributeValueFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxExpressionChild {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxExpressionChild {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxExpressionChildFields {
        JsxExpressionChildFields {
            l_curly_token: self.l_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> Option<JsAnyExpression> {
        support::node(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct JsxExpressionChildFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub expression: Option<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxFragment {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxFragmentFields {
        JsxFragmentFields {
            opening_fragment: self.opening_fragment(),
            children: self.children(),
            closing_fragment: self.closing_fragment(),
        }
    }
    pub fn opening_fragment(&self) -> SyntaxResult<JsxOpeningFragment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn children(&self) -> JsxChildList {
        support::list(&self.syntax, 1usize)
    }
    pub fn closing_fragment(&self) -> SyntaxResult<JsxClosingFragment> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsxFragmentFields {
    pub opening_fragment: SyntaxResult<JsxOpeningFragment>,
    pub children: JsxChildList,
    pub closing_fragment: SyntaxResult<JsxClosingFragment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxMemberName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxMemberNameFields {
        JsxMemberNameFields {
            object: self.object(),
            dot_token: self.dot_token(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsxAnyObjectName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsName> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsxMemberNameFields {
    pub object: SyntaxResult<JsxAnyObjectName>,
    pub dot_token: SyntaxResult<JsSyntaxToken>,
    pub member: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxNameFields {
        JsxNameFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsxNameFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxNamespaceName {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxNamespaceName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxNamespaceNameFields {
        JsxNamespaceNameFields {
            namespace: self.namespace(),
            colon_token: self.colon_token(),
            name: self.name(),
        }
    }
    pub fn namespace(&self) -> SyntaxResult<JsxName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxName> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct JsxNamespaceNameFields {
    pub namespace: SyntaxResult<JsxName>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsxName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxOpeningElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxOpeningElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxOpeningElementFields {
        JsxOpeningElementFields {
            l_angle_token: self.l_angle_token(),
            name: self.name(),
            type_arguments: self.type_arguments(),
            attributes: self.attributes(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxAnyElementName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 2usize)
    }
    pub fn attributes(&self) -> JsxAttributeList {
        support::list(&self.syntax, 3usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
pub struct JsxOpeningElementFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsxAnyElementName>,
    pub type_arguments: Option<TsTypeArguments>,
    pub attributes: JsxAttributeList,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxOpeningFragment {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxOpeningFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxOpeningFragmentFields {
        JsxOpeningFragmentFields {
            l_angle_token: self.l_angle_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct JsxOpeningFragmentFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxReferenceIdentifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxReferenceIdentifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxReferenceIdentifierFields {
        JsxReferenceIdentifierFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsxReferenceIdentifierFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSelfClosingElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxSelfClosingElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxSelfClosingElementFields {
        JsxSelfClosingElementFields {
            l_angle_token: self.l_angle_token(),
            name: self.name(),
            type_arguments: self.type_arguments(),
            attributes: self.attributes(),
            slash_token: self.slash_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxAnyElementName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 2usize)
    }
    pub fn attributes(&self) -> JsxAttributeList {
        support::list(&self.syntax, 3usize)
    }
    pub fn slash_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
}
pub struct JsxSelfClosingElementFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsxAnyElementName>,
    pub type_arguments: Option<TsTypeArguments>,
    pub attributes: JsxAttributeList,
    pub slash_token: SyntaxResult<JsSyntaxToken>,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSpreadAttribute {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxSpreadAttribute {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxSpreadAttributeFields {
        JsxSpreadAttributeFields {
            l_curly_token: self.l_curly_token(),
            dotdotdot_token: self.dotdotdot_token(),
            argument: self.argument(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsxSpreadAttributeFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSpreadChild {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxSpreadChild {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxSpreadChildFields {
        JsxSpreadChildFields {
            l_curly_token: self.l_curly_token(),
            dotdotdot_token: self.dotdotdot_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct JsxSpreadChildFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxString {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxString {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxStringFields {
        JsxStringFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsxStringFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxTagExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxTagExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxTagExpressionFields {
        JsxTagExpressionFields { tag: self.tag() }
    }
    pub fn tag(&self) -> SyntaxResult<JsxAnyTag> {
        support::required_node(&self.syntax, 0usize)
    }
}
pub struct JsxTagExpressionFields {
    pub tag: SyntaxResult<JsxAnyTag>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxText {
    pub(crate) syntax: JsSyntaxNode,
}
impl JsxText {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> JsxTextFields {
        JsxTextFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct JsxTextFields {
    pub value_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct NewTarget {
    pub(crate) syntax: JsSyntaxNode,
}
impl NewTarget {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> NewTargetFields {
        NewTargetFields {
            new_token: self.new_token(),
            dot_token: self.dot_token(),
            target_token: self.target_token(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn target_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct NewTargetFields {
    pub new_token: SyntaxResult<JsSyntaxToken>,
    pub dot_token: SyntaxResult<JsSyntaxToken>,
    pub target_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAbstractModifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsAbstractModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsAbstractModifierFields {
        TsAbstractModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsAbstractModifierFields {
    pub modifier_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAccessibilityModifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsAccessibilityModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsAccessibilityModifierFields {
        TsAccessibilityModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsAccessibilityModifierFields {
    pub modifier_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAnyType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsAnyType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsAnyTypeFields {
        TsAnyTypeFields {
            any_token: self.any_token(),
        }
    }
    pub fn any_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsAnyTypeFields {
    pub any_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsArrayType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsArrayType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsArrayTypeFields {
        TsArrayTypeFields {
            element_type: self.element_type(),
            l_brack_token: self.l_brack_token(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn element_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsArrayTypeFields {
    pub element_type: SyntaxResult<TsType>,
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAsAssignment {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsAsAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsAsAssignmentFields {
        TsAsAssignmentFields {
            assignment: self.assignment(),
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn assignment(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct TsAsAssignmentFields {
    pub assignment: SyntaxResult<JsAnyAssignment>,
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAsExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsAsExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsAsExpressionFields {
        TsAsExpressionFields {
            expression: self.expression(),
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct TsAsExpressionFields {
    pub expression: SyntaxResult<JsAnyExpression>,
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAssertsCondition {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsAssertsCondition {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsAssertsConditionFields {
        TsAssertsConditionFields {
            is_token: self.is_token(),
            ty: self.ty(),
        }
    }
    pub fn is_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsAssertsConditionFields {
    pub is_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAssertsReturnType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsAssertsReturnType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsAssertsReturnTypeFields {
        TsAssertsReturnTypeFields {
            asserts_token: self.asserts_token(),
            parameter_name: self.parameter_name(),
            predicate: self.predicate(),
        }
    }
    pub fn asserts_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn parameter_name(&self) -> SyntaxResult<TsAnyTypePredicateParameterName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn predicate(&self) -> Option<TsAssertsCondition> {
        support::node(&self.syntax, 2usize)
    }
}
pub struct TsAssertsReturnTypeFields {
    pub asserts_token: SyntaxResult<JsSyntaxToken>,
    pub parameter_name: SyntaxResult<TsAnyTypePredicateParameterName>,
    pub predicate: Option<TsAssertsCondition>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBigIntLiteralType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsBigIntLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsBigIntLiteralTypeFields {
        TsBigIntLiteralTypeFields {
            minus_token: self.minus_token(),
            literal_token: self.literal_token(),
        }
    }
    pub fn minus_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn literal_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct TsBigIntLiteralTypeFields {
    pub minus_token: Option<JsSyntaxToken>,
    pub literal_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBigintType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsBigintType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsBigintTypeFields {
        TsBigintTypeFields {
            bigint_token: self.bigint_token(),
        }
    }
    pub fn bigint_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsBigintTypeFields {
    pub bigint_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBooleanLiteralType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsBooleanLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsBooleanLiteralTypeFields {
        TsBooleanLiteralTypeFields {
            literal: self.literal(),
        }
    }
    pub fn literal(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsBooleanLiteralTypeFields {
    pub literal: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBooleanType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsBooleanType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsBooleanTypeFields {
        TsBooleanTypeFields {
            boolean_token: self.boolean_token(),
        }
    }
    pub fn boolean_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsBooleanTypeFields {
    pub boolean_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsCallSignatureTypeMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsCallSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsCallSignatureTypeMemberFields {
        TsCallSignatureTypeMemberFields {
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 3usize)
    }
}
pub struct TsCallSignatureTypeMemberFields {
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub separator_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConditionalType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsConditionalType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsConditionalTypeFields {
        TsConditionalTypeFields {
            check_type: self.check_type(),
            extends_token: self.extends_token(),
            extends_type: self.extends_type(),
            question_mark_token: self.question_mark_token(),
            true_type: self.true_type(),
            colon_token: self.colon_token(),
            false_type: self.false_type(),
        }
    }
    pub fn check_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn extends_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn extends_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn true_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn false_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 6usize)
    }
}
pub struct TsConditionalTypeFields {
    pub check_type: SyntaxResult<TsType>,
    pub extends_token: SyntaxResult<JsSyntaxToken>,
    pub extends_type: SyntaxResult<TsType>,
    pub question_mark_token: SyntaxResult<JsSyntaxToken>,
    pub true_type: SyntaxResult<TsType>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub false_type: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructSignatureTypeMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsConstructSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsConstructSignatureTypeMemberFields {
        TsConstructSignatureTypeMemberFields {
            new_token: self.new_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 4usize)
    }
}
pub struct TsConstructSignatureTypeMemberFields {
    pub new_token: SyntaxResult<JsSyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructorSignatureClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsConstructorSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsConstructorSignatureClassMemberFields {
        TsConstructorSignatureClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            parameters: self.parameters(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> JsConstructorModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsLiteralMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsConstructorParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 3usize)
    }
}
pub struct TsConstructorSignatureClassMemberFields {
    pub modifiers: JsConstructorModifierList,
    pub name: SyntaxResult<JsLiteralMemberName>,
    pub parameters: SyntaxResult<JsConstructorParameters>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructorType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsConstructorType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsConstructorTypeFields {
        TsConstructorTypeFields {
            abstract_token: self.abstract_token(),
            new_token: self.new_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            fat_arrow_token: self.fat_arrow_token(),
            return_type: self.return_type(),
        }
    }
    pub fn abstract_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn new_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 5usize)
    }
}
pub struct TsConstructorTypeFields {
    pub abstract_token: Option<JsSyntaxToken>,
    pub new_token: SyntaxResult<JsSyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub fat_arrow_token: SyntaxResult<JsSyntaxToken>,
    pub return_type: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareFunctionDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsDeclareFunctionDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsDeclareFunctionDeclarationFields {
        TsDeclareFunctionDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn async_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn function_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 6usize)
    }
}
pub struct TsDeclareFunctionDeclarationFields {
    pub async_token: Option<JsSyntaxToken>,
    pub function_token: SyntaxResult<JsSyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareModifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsDeclareModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsDeclareModifierFields {
        TsDeclareModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsDeclareModifierFields {
    pub modifier_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareStatement {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsDeclareStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsDeclareStatementFields {
        TsDeclareStatementFields {
            declare_token: self.declare_token(),
            declaration: self.declaration(),
        }
    }
    pub fn declare_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<JsAnyDeclarationClause> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsDeclareStatementFields {
    pub declare_token: SyntaxResult<JsSyntaxToken>,
    pub declaration: SyntaxResult<JsAnyDeclarationClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefaultTypeClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsDefaultTypeClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsDefaultTypeClauseFields {
        TsDefaultTypeClauseFields {
            eq_token: self.eq_token(),
            ty: self.ty(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsDefaultTypeClauseFields {
    pub eq_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefinitePropertyAnnotation {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsDefinitePropertyAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsDefinitePropertyAnnotationFields {
        TsDefinitePropertyAnnotationFields {
            excl_token: self.excl_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn excl_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsDefinitePropertyAnnotationFields {
    pub excl_token: SyntaxResult<JsSyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefiniteVariableAnnotation {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsDefiniteVariableAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsDefiniteVariableAnnotationFields {
        TsDefiniteVariableAnnotationFields {
            excl_token: self.excl_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn excl_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsDefiniteVariableAnnotationFields {
    pub excl_token: SyntaxResult<JsSyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEmptyExternalModuleDeclarationBody {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsEmptyExternalModuleDeclarationBody {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsEmptyExternalModuleDeclarationBodyFields {
        TsEmptyExternalModuleDeclarationBodyFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsEmptyExternalModuleDeclarationBodyFields {
    pub semicolon_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEnumDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsEnumDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsEnumDeclarationFields {
        TsEnumDeclarationFields {
            const_token: self.const_token(),
            enum_token: self.enum_token(),
            id: self.id(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn const_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn enum_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn members(&self) -> TsEnumMemberList {
        support::list(&self.syntax, 4usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
}
pub struct TsEnumDeclarationFields {
    pub const_token: Option<JsSyntaxToken>,
    pub enum_token: SyntaxResult<JsSyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub members: TsEnumMemberList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEnumMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsEnumMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsEnumMemberFields {
        TsEnumMemberFields {
            name: self.name(),
            initializer: self.initializer(),
        }
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct TsEnumMemberFields {
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportAsNamespaceClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsExportAsNamespaceClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsExportAsNamespaceClauseFields {
        TsExportAsNamespaceClauseFields {
            as_token: self.as_token(),
            namespace_token: self.namespace_token(),
            name: self.name(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn namespace_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 3usize)
    }
}
pub struct TsExportAsNamespaceClauseFields {
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub namespace_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsName>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportAssignmentClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsExportAssignmentClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsExportAssignmentClauseFields {
        TsExportAssignmentClauseFields {
            eq_token: self.eq_token(),
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
}
pub struct TsExportAssignmentClauseFields {
    pub eq_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportDeclareClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsExportDeclareClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsExportDeclareClauseFields {
        TsExportDeclareClauseFields {
            declare_token: self.declare_token(),
            declaration: self.declaration(),
        }
    }
    pub fn declare_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<JsAnyDeclarationClause> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsExportDeclareClauseFields {
    pub declare_token: SyntaxResult<JsSyntaxToken>,
    pub declaration: SyntaxResult<JsAnyDeclarationClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExtendsClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsExtendsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsExtendsClauseFields {
        TsExtendsClauseFields {
            extends_token: self.extends_token(),
            types: self.types(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsTypeList {
        support::list(&self.syntax, 1usize)
    }
}
pub struct TsExtendsClauseFields {
    pub extends_token: SyntaxResult<JsSyntaxToken>,
    pub types: TsTypeList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExternalModuleDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsExternalModuleDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsExternalModuleDeclarationFields {
        TsExternalModuleDeclarationFields {
            module_token: self.module_token(),
            source: self.source(),
            body: self.body(),
        }
    }
    pub fn module_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn body(&self) -> Option<TsAnyExternalModuleDeclarationBody> {
        support::node(&self.syntax, 2usize)
    }
}
pub struct TsExternalModuleDeclarationFields {
    pub module_token: SyntaxResult<JsSyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub body: Option<TsAnyExternalModuleDeclarationBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExternalModuleReference {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsExternalModuleReference {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsExternalModuleReferenceFields {
        TsExternalModuleReferenceFields {
            require_token: self.require_token(),
            l_paren_token: self.l_paren_token(),
            source: self.source(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn require_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct TsExternalModuleReferenceFields {
    pub require_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsFunctionType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsFunctionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsFunctionTypeFields {
        TsFunctionTypeFields {
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            fat_arrow_token: self.fat_arrow_token(),
            return_type: self.return_type(),
        }
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn return_type(&self) -> SyntaxResult<TsAnyReturnType> {
        support::required_node(&self.syntax, 3usize)
    }
}
pub struct TsFunctionTypeFields {
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub fat_arrow_token: SyntaxResult<JsSyntaxToken>,
    pub return_type: SyntaxResult<TsAnyReturnType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGetterSignatureClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsGetterSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsGetterSignatureClassMemberFields {
        TsGetterSignatureClassMemberFields {
            modifiers: self.modifiers(),
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn get_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 6usize)
    }
}
pub struct TsGetterSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub get_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGetterSignatureTypeMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsGetterSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsGetterSignatureTypeMemberFields {
        TsGetterSignatureTypeMemberFields {
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn get_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 5usize)
    }
}
pub struct TsGetterSignatureTypeMemberFields {
    pub get_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGlobalDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsGlobalDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsGlobalDeclarationFields {
        TsGlobalDeclarationFields {
            global_token: self.global_token(),
            body: self.body(),
        }
    }
    pub fn global_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<TsModuleBlock> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsGlobalDeclarationFields {
    pub global_token: SyntaxResult<JsSyntaxToken>,
    pub body: SyntaxResult<TsModuleBlock>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIdentifierBinding {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsIdentifierBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsIdentifierBindingFields {
        TsIdentifierBindingFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsIdentifierBindingFields {
    pub name_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImplementsClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsImplementsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsImplementsClauseFields {
        TsImplementsClauseFields {
            implements_token: self.implements_token(),
            types: self.types(),
        }
    }
    pub fn implements_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsTypeList {
        support::list(&self.syntax, 1usize)
    }
}
pub struct TsImplementsClauseFields {
    pub implements_token: SyntaxResult<JsSyntaxToken>,
    pub types: TsTypeList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportEqualsDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsImportEqualsDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsImportEqualsDeclarationFields {
        TsImportEqualsDeclarationFields {
            import_token: self.import_token(),
            type_token: self.type_token(),
            id: self.id(),
            eq_token: self.eq_token(),
            module_reference: self.module_reference(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn module_reference(&self) -> SyntaxResult<TsAnyModuleReference> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 5usize)
    }
}
pub struct TsImportEqualsDeclarationFields {
    pub import_token: SyntaxResult<JsSyntaxToken>,
    pub type_token: Option<JsSyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub eq_token: SyntaxResult<JsSyntaxToken>,
    pub module_reference: SyntaxResult<TsAnyModuleReference>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsImportType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsImportTypeFields {
        TsImportTypeFields {
            typeof_token: self.typeof_token(),
            import_token: self.import_token(),
            l_paren_token: self.l_paren_token(),
            argument_token: self.argument_token(),
            r_paren_token: self.r_paren_token(),
            qualifier_clause: self.qualifier_clause(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn typeof_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn import_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn argument_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn qualifier_clause(&self) -> Option<TsImportTypeQualifier> {
        support::node(&self.syntax, 5usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 6usize)
    }
}
pub struct TsImportTypeFields {
    pub typeof_token: Option<JsSyntaxToken>,
    pub import_token: SyntaxResult<JsSyntaxToken>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub argument_token: SyntaxResult<JsSyntaxToken>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub qualifier_clause: Option<TsImportTypeQualifier>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportTypeQualifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsImportTypeQualifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsImportTypeQualifierFields {
        TsImportTypeQualifierFields {
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn dot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn right(&self) -> SyntaxResult<TsAnyName> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsImportTypeQualifierFields {
    pub dot_token: SyntaxResult<JsSyntaxToken>,
    pub right: SyntaxResult<TsAnyName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsIndexSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsIndexSignatureClassMemberFields {
        TsIndexSignatureClassMemberFields {
            modifiers: self.modifiers(),
            l_brack_token: self.l_brack_token(),
            parameter: self.parameter(),
            r_brack_token: self.r_brack_token(),
            type_annotation: self.type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsIndexSignatureModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn parameter(&self) -> SyntaxResult<TsIndexSignatureParameter> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 5usize)
    }
}
pub struct TsIndexSignatureClassMemberFields {
    pub modifiers: TsIndexSignatureModifierList,
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub parameter: SyntaxResult<TsIndexSignatureParameter>,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureParameter {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsIndexSignatureParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsIndexSignatureParameterFields {
        TsIndexSignatureParameterFields {
            binding: self.binding(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn binding(&self) -> SyntaxResult<JsIdentifierBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsIndexSignatureParameterFields {
    pub binding: SyntaxResult<JsIdentifierBinding>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureTypeMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsIndexSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsIndexSignatureTypeMemberFields {
        TsIndexSignatureTypeMemberFields {
            readonly_token: self.readonly_token(),
            l_brack_token: self.l_brack_token(),
            parameter: self.parameter(),
            r_brack_token: self.r_brack_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn readonly_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn parameter(&self) -> SyntaxResult<TsIndexSignatureParameter> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 5usize)
    }
}
pub struct TsIndexSignatureTypeMemberFields {
    pub readonly_token: Option<JsSyntaxToken>,
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub parameter: SyntaxResult<TsIndexSignatureParameter>,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
    pub separator_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexedAccessType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsIndexedAccessType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsIndexedAccessTypeFields {
        TsIndexedAccessTypeFields {
            object_type: self.object_type(),
            l_brack_token: self.l_brack_token(),
            index_type: self.index_type(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn index_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
pub struct TsIndexedAccessTypeFields {
    pub object_type: SyntaxResult<TsType>,
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub index_type: SyntaxResult<TsType>,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInferType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsInferType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsInferTypeFields {
        TsInferTypeFields {
            infer_token: self.infer_token(),
            type_parameter: self.type_parameter(),
        }
    }
    pub fn infer_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_parameter(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsInferTypeFields {
    pub infer_token: SyntaxResult<JsSyntaxToken>,
    pub type_parameter: SyntaxResult<TsTypeParameterName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInterfaceDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsInterfaceDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsInterfaceDeclarationFields {
        TsInterfaceDeclarationFields {
            interface_token: self.interface_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn interface_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn id(&self) -> SyntaxResult<TsIdentifierBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn extends_clause(&self) -> Option<TsExtendsClause> {
        support::node(&self.syntax, 3usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn members(&self) -> TsTypeMemberList {
        support::list(&self.syntax, 5usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
}
pub struct TsInterfaceDeclarationFields {
    pub interface_token: SyntaxResult<JsSyntaxToken>,
    pub id: SyntaxResult<TsIdentifierBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<TsExtendsClause>,
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub members: TsTypeMemberList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIntersectionType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsIntersectionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsIntersectionTypeFields {
        TsIntersectionTypeFields {
            leading_separator_token: self.leading_separator_token(),
            types: self.types(),
        }
    }
    pub fn leading_separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsIntersectionTypeElementList {
        support::list(&self.syntax, 1usize)
    }
}
pub struct TsIntersectionTypeFields {
    pub leading_separator_token: Option<JsSyntaxToken>,
    pub types: TsIntersectionTypeElementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsMappedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsMappedTypeFields {
        TsMappedTypeFields {
            l_curly_token: self.l_curly_token(),
            readonly_modifier: self.readonly_modifier(),
            l_brack_token: self.l_brack_token(),
            property_name: self.property_name(),
            in_token: self.in_token(),
            keys_type: self.keys_type(),
            as_clause: self.as_clause(),
            r_brack_token: self.r_brack_token(),
            optional_modifier: self.optional_modifier(),
            mapped_type: self.mapped_type(),
            semicolon_token: self.semicolon_token(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn readonly_modifier(&self) -> Option<TsMappedTypeReadonlyModifierClause> {
        support::node(&self.syntax, 1usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn property_name(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn in_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn keys_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn as_clause(&self) -> Option<TsMappedTypeAsClause> {
        support::node(&self.syntax, 6usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
    pub fn optional_modifier(&self) -> Option<TsMappedTypeOptionalModifierClause> {
        support::node(&self.syntax, 8usize)
    }
    pub fn mapped_type(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 9usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 10usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 11usize)
    }
}
pub struct TsMappedTypeFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub readonly_modifier: Option<TsMappedTypeReadonlyModifierClause>,
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub property_name: SyntaxResult<TsTypeParameterName>,
    pub in_token: SyntaxResult<JsSyntaxToken>,
    pub keys_type: SyntaxResult<TsType>,
    pub as_clause: Option<TsMappedTypeAsClause>,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
    pub optional_modifier: Option<TsMappedTypeOptionalModifierClause>,
    pub mapped_type: Option<TsTypeAnnotation>,
    pub semicolon_token: Option<JsSyntaxToken>,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeAsClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsMappedTypeAsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsMappedTypeAsClauseFields {
        TsMappedTypeAsClauseFields {
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsMappedTypeAsClauseFields {
    pub as_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeOptionalModifierClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsMappedTypeOptionalModifierClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsMappedTypeOptionalModifierClauseFields {
        TsMappedTypeOptionalModifierClauseFields {
            operator_token: self.operator_token(),
            question_mark_token: self.question_mark_token(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct TsMappedTypeOptionalModifierClauseFields {
    pub operator_token: SyntaxResult<JsSyntaxToken>,
    pub question_mark_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeReadonlyModifierClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsMappedTypeReadonlyModifierClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsMappedTypeReadonlyModifierClauseFields {
        TsMappedTypeReadonlyModifierClauseFields {
            operator_token: self.operator_token(),
            readonly_token: self.readonly_token(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn readonly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct TsMappedTypeReadonlyModifierClauseFields {
    pub operator_token: SyntaxResult<JsSyntaxToken>,
    pub readonly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMethodSignatureClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsMethodSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsMethodSignatureClassMemberFields {
        TsMethodSignatureClassMemberFields {
            modifiers: self.modifiers(),
            async_token: self.async_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn async_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn question_mark_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 3usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 7usize)
    }
}
pub struct TsMethodSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub async_token: Option<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub question_mark_token: Option<JsSyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMethodSignatureTypeMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsMethodSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsMethodSignatureTypeMemberFields {
        TsMethodSignatureTypeMemberFields {
            name: self.name(),
            optional_token: self.optional_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 5usize)
    }
}
pub struct TsMethodSignatureTypeMemberFields {
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub optional_token: Option<JsSyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub separator_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsModuleBlock {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsModuleBlock {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsModuleBlockFields {
        TsModuleBlockFields {
            l_curly_token: self.l_curly_token(),
            items: self.items(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> JsModuleItemList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsModuleBlockFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub items: JsModuleItemList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsModuleDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsModuleDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsModuleDeclarationFields {
        TsModuleDeclarationFields {
            module_or_namespace: self.module_or_namespace(),
            name: self.name(),
            body: self.body(),
        }
    }
    pub fn module_or_namespace(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<TsAnyModuleName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn body(&self) -> SyntaxResult<TsModuleBlock> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct TsModuleDeclarationFields {
    pub module_or_namespace: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<TsAnyModuleName>,
    pub body: SyntaxResult<TsModuleBlock>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNameWithTypeArguments {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNameWithTypeArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNameWithTypeArgumentsFields {
        TsNameWithTypeArgumentsFields {
            name: self.name(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn name(&self) -> SyntaxResult<TsAnyName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct TsNameWithTypeArgumentsFields {
    pub name: SyntaxResult<TsAnyName>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNamedTupleTypeElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNamedTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNamedTupleTypeElementFields {
        TsNamedTupleTypeElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn dotdotdot_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn question_mark_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 4usize)
    }
}
pub struct TsNamedTupleTypeElementFields {
    pub dotdotdot_token: Option<JsSyntaxToken>,
    pub name: SyntaxResult<JsName>,
    pub question_mark_token: Option<JsSyntaxToken>,
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNeverType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNeverType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNeverTypeFields {
        TsNeverTypeFields {
            never_token: self.never_token(),
        }
    }
    pub fn never_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsNeverTypeFields {
    pub never_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonNullAssertionAssignment {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNonNullAssertionAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNonNullAssertionAssignmentFields {
        TsNonNullAssertionAssignmentFields {
            assignment: self.assignment(),
            excl_token: self.excl_token(),
        }
    }
    pub fn assignment(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn excl_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct TsNonNullAssertionAssignmentFields {
    pub assignment: SyntaxResult<JsAnyAssignment>,
    pub excl_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonNullAssertionExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNonNullAssertionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNonNullAssertionExpressionFields {
        TsNonNullAssertionExpressionFields {
            expression: self.expression(),
            excl_token: self.excl_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn excl_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct TsNonNullAssertionExpressionFields {
    pub expression: SyntaxResult<JsAnyExpression>,
    pub excl_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonPrimitiveType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNonPrimitiveType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNonPrimitiveTypeFields {
        TsNonPrimitiveTypeFields {
            object_token: self.object_token(),
        }
    }
    pub fn object_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsNonPrimitiveTypeFields {
    pub object_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNullLiteralType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNullLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNullLiteralTypeFields {
        TsNullLiteralTypeFields {
            literal_token: self.literal_token(),
        }
    }
    pub fn literal_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsNullLiteralTypeFields {
    pub literal_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNumberLiteralType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNumberLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNumberLiteralTypeFields {
        TsNumberLiteralTypeFields {
            minus_token: self.minus_token(),
            literal_token: self.literal_token(),
        }
    }
    pub fn minus_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn literal_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct TsNumberLiteralTypeFields {
    pub minus_token: Option<JsSyntaxToken>,
    pub literal_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNumberType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsNumberType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsNumberTypeFields {
        TsNumberTypeFields {
            number_token: self.number_token(),
        }
    }
    pub fn number_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsNumberTypeFields {
    pub number_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsObjectType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsObjectType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsObjectTypeFields {
        TsObjectTypeFields {
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn members(&self) -> TsTypeMemberList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsObjectTypeFields {
    pub l_curly_token: SyntaxResult<JsSyntaxToken>,
    pub members: TsTypeMemberList,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOptionalPropertyAnnotation {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsOptionalPropertyAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsOptionalPropertyAnnotationFields {
        TsOptionalPropertyAnnotationFields {
            question_mark_token: self.question_mark_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn question_mark_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct TsOptionalPropertyAnnotationFields {
    pub question_mark_token: SyntaxResult<JsSyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOptionalTupleTypeElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsOptionalTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsOptionalTupleTypeElementFields {
        TsOptionalTupleTypeElementFields {
            ty: self.ty(),
            question_mark_token: self.question_mark_token(),
        }
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
pub struct TsOptionalTupleTypeElementFields {
    pub ty: SyntaxResult<TsType>,
    pub question_mark_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOverrideModifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsOverrideModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsOverrideModifierFields {
        TsOverrideModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsOverrideModifierFields {
    pub modifier_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsParenthesizedType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsParenthesizedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsParenthesizedTypeFields {
        TsParenthesizedTypeFields {
            l_paren_token: self.l_paren_token(),
            ty: self.ty(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsParenthesizedTypeFields {
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPredicateReturnType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsPredicateReturnType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsPredicateReturnTypeFields {
        TsPredicateReturnTypeFields {
            parameter_name: self.parameter_name(),
            is_token: self.is_token(),
            ty: self.ty(),
        }
    }
    pub fn parameter_name(&self) -> SyntaxResult<TsAnyTypePredicateParameterName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn is_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct TsPredicateReturnTypeFields {
    pub parameter_name: SyntaxResult<TsAnyTypePredicateParameterName>,
    pub is_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertyParameter {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsPropertyParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsPropertyParameterFields {
        TsPropertyParameterFields {
            modifiers: self.modifiers(),
            formal_parameter: self.formal_parameter(),
        }
    }
    pub fn modifiers(&self) -> TsPropertyParameterModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn formal_parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsPropertyParameterFields {
    pub modifiers: TsPropertyParameterModifierList,
    pub formal_parameter: SyntaxResult<JsAnyFormalParameter>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertySignatureClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsPropertySignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsPropertySignatureClassMemberFields {
        TsPropertySignatureClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            property_annotation: self.property_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsPropertySignatureModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn property_annotation(&self) -> Option<TsAnyPropertySignatureAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 3usize)
    }
}
pub struct TsPropertySignatureClassMemberFields {
    pub modifiers: TsPropertySignatureModifierList,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub property_annotation: Option<TsAnyPropertySignatureAnnotation>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertySignatureTypeMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsPropertySignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsPropertySignatureTypeMemberFields {
        TsPropertySignatureTypeMemberFields {
            readonly_token: self.readonly_token(),
            name: self.name(),
            optional_token: self.optional_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn readonly_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn optional_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 4usize)
    }
}
pub struct TsPropertySignatureTypeMemberFields {
    pub readonly_token: Option<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub optional_token: Option<JsSyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsQualifiedModuleName {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsQualifiedModuleName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsQualifiedModuleNameFields {
        TsQualifiedModuleNameFields {
            left: self.left(),
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<TsAnyModuleName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsName> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct TsQualifiedModuleNameFields {
    pub left: SyntaxResult<TsAnyModuleName>,
    pub dot_token: SyntaxResult<JsSyntaxToken>,
    pub right: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsQualifiedName {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsQualifiedName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsQualifiedNameFields {
        TsQualifiedNameFields {
            left: self.left(),
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<TsAnyName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsName> {
        support::required_node(&self.syntax, 2usize)
    }
}
pub struct TsQualifiedNameFields {
    pub left: SyntaxResult<TsAnyName>,
    pub dot_token: SyntaxResult<JsSyntaxToken>,
    pub right: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReadonlyModifier {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsReadonlyModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsReadonlyModifierFields {
        TsReadonlyModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsReadonlyModifierFields {
    pub modifier_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReferenceType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsReferenceType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsReferenceTypeFields {
        TsReferenceTypeFields {
            name: self.name(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn name(&self) -> SyntaxResult<TsAnyName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct TsReferenceTypeFields {
    pub name: SyntaxResult<TsAnyName>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsRestTupleTypeElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsRestTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsRestTupleTypeElementFields {
        TsRestTupleTypeElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            ty: self.ty(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsRestTupleTypeElementFields {
    pub dotdotdot_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReturnTypeAnnotation {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsReturnTypeAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsReturnTypeAnnotationFields {
        TsReturnTypeAnnotationFields {
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsAnyReturnType> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsReturnTypeAnnotationFields {
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsAnyReturnType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSetterSignatureClassMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsSetterSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsSetterSignatureClassMemberFields {
        TsSetterSignatureClassMemberFields {
            modifiers: self.modifiers(),
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn set_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 6usize)
    }
}
pub struct TsSetterSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub set_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub parameter: SyntaxResult<JsAnyFormalParameter>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSetterSignatureTypeMember {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsSetterSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsSetterSignatureTypeMemberFields {
        TsSetterSignatureTypeMemberFields {
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            separator_token: self.separator_token(),
        }
    }
    pub fn set_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 5usize)
    }
}
pub struct TsSetterSignatureTypeMemberFields {
    pub set_token: SyntaxResult<JsSyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub l_paren_token: SyntaxResult<JsSyntaxToken>,
    pub parameter: SyntaxResult<JsAnyFormalParameter>,
    pub r_paren_token: SyntaxResult<JsSyntaxToken>,
    pub separator_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsStringLiteralType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsStringLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsStringLiteralTypeFields {
        TsStringLiteralTypeFields {
            literal_token: self.literal_token(),
        }
    }
    pub fn literal_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsStringLiteralTypeFields {
    pub literal_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsStringType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsStringType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsStringTypeFields {
        TsStringTypeFields {
            string_token: self.string_token(),
        }
    }
    pub fn string_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsStringTypeFields {
    pub string_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSymbolType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsSymbolType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsSymbolTypeFields {
        TsSymbolTypeFields {
            symbol_token: self.symbol_token(),
        }
    }
    pub fn symbol_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsSymbolTypeFields {
    pub symbol_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateChunkElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTemplateChunkElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTemplateChunkElementFields {
        TsTemplateChunkElementFields {
            template_chunk_token: self.template_chunk_token(),
        }
    }
    pub fn template_chunk_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsTemplateChunkElementFields {
    pub template_chunk_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateElement {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTemplateElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTemplateElementFields {
        TsTemplateElementFields {
            dollar_curly_token: self.dollar_curly_token(),
            ty: self.ty(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn dollar_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsTemplateElementFields {
    pub dollar_curly_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub r_curly_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateLiteralType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTemplateLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTemplateLiteralTypeFields {
        TsTemplateLiteralTypeFields {
            l_tick_token: self.l_tick_token(),
            elements: self.elements(),
            r_tick_token: self.r_tick_token(),
        }
    }
    pub fn l_tick_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> TsTemplateElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_tick_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsTemplateLiteralTypeFields {
    pub l_tick_token: SyntaxResult<JsSyntaxToken>,
    pub elements: TsTemplateElementList,
    pub r_tick_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsThisParameter {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsThisParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsThisParameterFields {
        TsThisParameterFields {
            this_token: self.this_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 1usize)
    }
}
pub struct TsThisParameterFields {
    pub this_token: SyntaxResult<JsSyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsThisType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsThisType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsThisTypeFields {
        TsThisTypeFields {
            this_token: self.this_token(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsThisTypeFields {
    pub this_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTupleType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTupleType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTupleTypeFields {
        TsTupleTypeFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> TsTupleTypeElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsTupleTypeFields {
    pub l_brack_token: SyntaxResult<JsSyntaxToken>,
    pub elements: TsTupleTypeElementList,
    pub r_brack_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAliasDeclaration {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeAliasDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeAliasDeclarationFields {
        TsTypeAliasDeclarationFields {
            type_token: self.type_token(),
            binding_identifier: self.binding_identifier(),
            type_parameters: self.type_parameters(),
            eq_token: self.eq_token(),
            ty: self.ty(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding_identifier(&self) -> SyntaxResult<TsIdentifierBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn semicolon_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 5usize)
    }
}
pub struct TsTypeAliasDeclarationFields {
    pub type_token: SyntaxResult<JsSyntaxToken>,
    pub binding_identifier: SyntaxResult<TsIdentifierBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub eq_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub semicolon_token: Option<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAnnotation {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeAnnotationFields {
        TsTypeAnnotationFields {
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn colon_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsTypeAnnotationFields {
    pub colon_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeArguments {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeArgumentsFields {
        TsTypeArgumentsFields {
            l_angle_token: self.l_angle_token(),
            ts_type_argument_list: self.ts_type_argument_list(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ts_type_argument_list(&self) -> TsTypeArgumentList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsTypeArgumentsFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub ts_type_argument_list: TsTypeArgumentList,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAssertionAssignment {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeAssertionAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeAssertionAssignmentFields {
        TsTypeAssertionAssignmentFields {
            l_angle_token: self.l_angle_token(),
            ty: self.ty(),
            r_angle_token: self.r_angle_token(),
            assignment: self.assignment(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn assignment(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 3usize)
    }
}
pub struct TsTypeAssertionAssignmentFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
    pub assignment: SyntaxResult<JsAnyAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAssertionExpression {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeAssertionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeAssertionExpressionFields {
        TsTypeAssertionExpressionFields {
            l_angle_token: self.l_angle_token(),
            ty: self.ty(),
            r_angle_token: self.r_angle_token(),
            expression: self.expression(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 3usize)
    }
}
pub struct TsTypeAssertionExpressionFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeConstraintClause {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeConstraintClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeConstraintClauseFields {
        TsTypeConstraintClauseFields {
            extends_token: self.extends_token(),
            ty: self.ty(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsTypeConstraintClauseFields {
    pub extends_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeOperatorType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeOperatorType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeOperatorTypeFields {
        TsTypeOperatorTypeFields {
            operator_token: self.operator_token(),
            ty: self.ty(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsTypeOperatorTypeFields {
    pub operator_token: SyntaxResult<JsSyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameter {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeParameterFields {
        TsTypeParameterFields {
            name: self.name(),
            constraint: self.constraint(),
            default: self.default(),
        }
    }
    pub fn name(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn constraint(&self) -> Option<TsTypeConstraintClause> {
        support::node(&self.syntax, 1usize)
    }
    pub fn default(&self) -> Option<TsDefaultTypeClause> {
        support::node(&self.syntax, 2usize)
    }
}
pub struct TsTypeParameterFields {
    pub name: SyntaxResult<TsTypeParameterName>,
    pub constraint: Option<TsTypeConstraintClause>,
    pub default: Option<TsDefaultTypeClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameterName {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeParameterName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeParameterNameFields {
        TsTypeParameterNameFields {
            ident_token: self.ident_token(),
        }
    }
    pub fn ident_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsTypeParameterNameFields {
    pub ident_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameters {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeParametersFields {
        TsTypeParametersFields {
            l_angle_token: self.l_angle_token(),
            items: self.items(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> TsTypeParameterList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
pub struct TsTypeParametersFields {
    pub l_angle_token: SyntaxResult<JsSyntaxToken>,
    pub items: TsTypeParameterList,
    pub r_angle_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeofType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsTypeofType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsTypeofTypeFields {
        TsTypeofTypeFields {
            typeof_token: self.typeof_token(),
            expression_name: self.expression_name(),
        }
    }
    pub fn typeof_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression_name(&self) -> SyntaxResult<TsAnyName> {
        support::required_node(&self.syntax, 1usize)
    }
}
pub struct TsTypeofTypeFields {
    pub typeof_token: SyntaxResult<JsSyntaxToken>,
    pub expression_name: SyntaxResult<TsAnyName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUndefinedType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsUndefinedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsUndefinedTypeFields {
        TsUndefinedTypeFields {
            undefined_token: self.undefined_token(),
        }
    }
    pub fn undefined_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsUndefinedTypeFields {
    pub undefined_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUnionType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsUnionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsUnionTypeFields {
        TsUnionTypeFields {
            leading_separator_token: self.leading_separator_token(),
            types: self.types(),
        }
    }
    pub fn leading_separator_token(&self) -> Option<JsSyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsUnionTypeVariantList {
        support::list(&self.syntax, 1usize)
    }
}
pub struct TsUnionTypeFields {
    pub leading_separator_token: Option<JsSyntaxToken>,
    pub types: TsUnionTypeVariantList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUnknownType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsUnknownType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsUnknownTypeFields {
        TsUnknownTypeFields {
            unknown_token: self.unknown_token(),
        }
    }
    pub fn unknown_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsUnknownTypeFields {
    pub unknown_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsVoidType {
    pub(crate) syntax: JsSyntaxNode,
}
impl TsVoidType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn as_fields(&self) -> TsVoidTypeFields {
        TsVoidTypeFields {
            void_token: self.void_token(),
        }
    }
    pub fn void_token(&self) -> SyntaxResult<JsSyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
pub struct TsVoidTypeFields {
    pub void_token: SyntaxResult<JsSyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyArrayAssignmentPatternElement {
    JsAnyAssignmentPattern(JsAnyAssignmentPattern),
    JsArrayAssignmentPatternRestElement(JsArrayAssignmentPatternRestElement),
    JsArrayHole(JsArrayHole),
    JsAssignmentWithDefault(JsAssignmentWithDefault),
    JsUnknownAssignment(JsUnknownAssignment),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyArrayBindingPatternElement {
    JsAnyBindingPattern(JsAnyBindingPattern),
    JsArrayBindingPatternRestElement(JsArrayBindingPatternRestElement),
    JsArrayHole(JsArrayHole),
    JsBindingPatternWithDefault(JsBindingPatternWithDefault),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyArrayElement {
    JsAnyExpression(JsAnyExpression),
    JsArrayHole(JsArrayHole),
    JsSpread(JsSpread),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyArrowFunctionParameters {
    JsAnyBinding(JsAnyBinding),
    JsParameters(JsParameters),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyAssignment {
    JsComputedMemberAssignment(JsComputedMemberAssignment),
    JsIdentifierAssignment(JsIdentifierAssignment),
    JsParenthesizedAssignment(JsParenthesizedAssignment),
    JsStaticMemberAssignment(JsStaticMemberAssignment),
    JsUnknownAssignment(JsUnknownAssignment),
    TsAsAssignment(TsAsAssignment),
    TsNonNullAssertionAssignment(TsNonNullAssertionAssignment),
    TsTypeAssertionAssignment(TsTypeAssertionAssignment),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyAssignmentPattern {
    JsAnyAssignment(JsAnyAssignment),
    JsArrayAssignmentPattern(JsArrayAssignmentPattern),
    JsObjectAssignmentPattern(JsObjectAssignmentPattern),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyBinding {
    JsIdentifierBinding(JsIdentifierBinding),
    JsUnknownBinding(JsUnknownBinding),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyBindingPattern {
    JsAnyBinding(JsAnyBinding),
    JsArrayBindingPattern(JsArrayBindingPattern),
    JsObjectBindingPattern(JsObjectBindingPattern),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyCallArgument {
    JsAnyExpression(JsAnyExpression),
    JsSpread(JsSpread),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyClass {
    JsClassDeclaration(JsClassDeclaration),
    JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration),
    JsClassExpression(JsClassExpression),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyClassMember {
    JsConstructorClassMember(JsConstructorClassMember),
    JsEmptyClassMember(JsEmptyClassMember),
    JsGetterClassMember(JsGetterClassMember),
    JsMethodClassMember(JsMethodClassMember),
    JsPropertyClassMember(JsPropertyClassMember),
    JsSetterClassMember(JsSetterClassMember),
    JsStaticInitializationBlockClassMember(JsStaticInitializationBlockClassMember),
    JsUnknownMember(JsUnknownMember),
    TsConstructorSignatureClassMember(TsConstructorSignatureClassMember),
    TsGetterSignatureClassMember(TsGetterSignatureClassMember),
    TsIndexSignatureClassMember(TsIndexSignatureClassMember),
    TsMethodSignatureClassMember(TsMethodSignatureClassMember),
    TsPropertySignatureClassMember(TsPropertySignatureClassMember),
    TsSetterSignatureClassMember(TsSetterSignatureClassMember),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyClassMemberName {
    JsComputedMemberName(JsComputedMemberName),
    JsLiteralMemberName(JsLiteralMemberName),
    JsPrivateClassMemberName(JsPrivateClassMemberName),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyConstructorParameter {
    JsAnyFormalParameter(JsAnyFormalParameter),
    JsRestParameter(JsRestParameter),
    TsPropertyParameter(TsPropertyParameter),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyDeclaration {
    JsClassDeclaration(JsClassDeclaration),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsVariableDeclaration(JsVariableDeclaration),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyDeclarationClause {
    JsClassDeclaration(JsClassDeclaration),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsVariableDeclarationClause(JsVariableDeclarationClause),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyExportClause {
    JsAnyDeclarationClause(JsAnyDeclarationClause),
    JsExportDefaultDeclarationClause(JsExportDefaultDeclarationClause),
    JsExportDefaultExpressionClause(JsExportDefaultExpressionClause),
    JsExportFromClause(JsExportFromClause),
    JsExportNamedClause(JsExportNamedClause),
    JsExportNamedFromClause(JsExportNamedFromClause),
    TsExportAsNamespaceClause(TsExportAsNamespaceClause),
    TsExportAssignmentClause(TsExportAssignmentClause),
    TsExportDeclareClause(TsExportDeclareClause),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyExportDefaultDeclaration {
    JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration),
    JsFunctionExportDefaultDeclaration(JsFunctionExportDefaultDeclaration),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyExportNamedSpecifier {
    JsExportNamedShorthandSpecifier(JsExportNamedShorthandSpecifier),
    JsExportNamedSpecifier(JsExportNamedSpecifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyExpression {
    ImportMeta(ImportMeta),
    JsAnyLiteralExpression(JsAnyLiteralExpression),
    JsArrayExpression(JsArrayExpression),
    JsArrowFunctionExpression(JsArrowFunctionExpression),
    JsAssignmentExpression(JsAssignmentExpression),
    JsAwaitExpression(JsAwaitExpression),
    JsBinaryExpression(JsBinaryExpression),
    JsCallExpression(JsCallExpression),
    JsClassExpression(JsClassExpression),
    JsComputedMemberExpression(JsComputedMemberExpression),
    JsConditionalExpression(JsConditionalExpression),
    JsFunctionExpression(JsFunctionExpression),
    JsIdentifierExpression(JsIdentifierExpression),
    JsImportCallExpression(JsImportCallExpression),
    JsInExpression(JsInExpression),
    JsInstanceofExpression(JsInstanceofExpression),
    JsLogicalExpression(JsLogicalExpression),
    JsNewExpression(JsNewExpression),
    JsObjectExpression(JsObjectExpression),
    JsParenthesizedExpression(JsParenthesizedExpression),
    JsPostUpdateExpression(JsPostUpdateExpression),
    JsPreUpdateExpression(JsPreUpdateExpression),
    JsSequenceExpression(JsSequenceExpression),
    JsStaticMemberExpression(JsStaticMemberExpression),
    JsSuperExpression(JsSuperExpression),
    JsTemplate(JsTemplate),
    JsThisExpression(JsThisExpression),
    JsUnaryExpression(JsUnaryExpression),
    JsUnknownExpression(JsUnknownExpression),
    JsYieldExpression(JsYieldExpression),
    JsxTagExpression(JsxTagExpression),
    NewTarget(NewTarget),
    TsAsExpression(TsAsExpression),
    TsNonNullAssertionExpression(TsNonNullAssertionExpression),
    TsTypeAssertionExpression(TsTypeAssertionExpression),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyForInOrOfInitializer {
    JsAnyAssignmentPattern(JsAnyAssignmentPattern),
    JsForVariableDeclaration(JsForVariableDeclaration),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyForInitializer {
    JsAnyExpression(JsAnyExpression),
    JsVariableDeclaration(JsVariableDeclaration),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyFormalParameter {
    JsFormalParameter(JsFormalParameter),
    JsUnknownParameter(JsUnknownParameter),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyFunction {
    JsArrowFunctionExpression(JsArrowFunctionExpression),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsFunctionExportDefaultDeclaration(JsFunctionExportDefaultDeclaration),
    JsFunctionExpression(JsFunctionExpression),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyFunctionBody {
    JsAnyExpression(JsAnyExpression),
    JsFunctionBody(JsFunctionBody),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyImportAssertionEntry {
    JsImportAssertionEntry(JsImportAssertionEntry),
    JsUnknownImportAssertionEntry(JsUnknownImportAssertionEntry),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyImportClause {
    JsImportBareClause(JsImportBareClause),
    JsImportDefaultClause(JsImportDefaultClause),
    JsImportNamedClause(JsImportNamedClause),
    JsImportNamespaceClause(JsImportNamespaceClause),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyInProperty {
    JsAnyExpression(JsAnyExpression),
    JsPrivateName(JsPrivateName),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyLiteralExpression {
    JsBigIntLiteralExpression(JsBigIntLiteralExpression),
    JsBooleanLiteralExpression(JsBooleanLiteralExpression),
    JsNullLiteralExpression(JsNullLiteralExpression),
    JsNumberLiteralExpression(JsNumberLiteralExpression),
    JsRegexLiteralExpression(JsRegexLiteralExpression),
    JsStringLiteralExpression(JsStringLiteralExpression),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyMethodModifier {
    JsStaticModifier(JsStaticModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyModuleItem {
    JsAnyStatement(JsAnyStatement),
    JsExport(JsExport),
    JsImport(JsImport),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyName {
    JsName(JsName),
    JsPrivateName(JsPrivateName),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyNamedImport {
    JsNamedImportSpecifiers(JsNamedImportSpecifiers),
    JsNamespaceImportSpecifier(JsNamespaceImportSpecifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyNamedImportSpecifier {
    JsNamedImportSpecifier(JsNamedImportSpecifier),
    JsShorthandNamedImportSpecifier(JsShorthandNamedImportSpecifier),
    JsUnknownNamedImportSpecifier(JsUnknownNamedImportSpecifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyObjectAssignmentPatternMember {
    JsObjectAssignmentPatternProperty(JsObjectAssignmentPatternProperty),
    JsObjectAssignmentPatternRest(JsObjectAssignmentPatternRest),
    JsObjectAssignmentPatternShorthandProperty(JsObjectAssignmentPatternShorthandProperty),
    JsUnknownAssignment(JsUnknownAssignment),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyObjectBindingPatternMember {
    JsIdentifierBinding(JsIdentifierBinding),
    JsObjectBindingPatternProperty(JsObjectBindingPatternProperty),
    JsObjectBindingPatternRest(JsObjectBindingPatternRest),
    JsObjectBindingPatternShorthandProperty(JsObjectBindingPatternShorthandProperty),
    JsUnknownBinding(JsUnknownBinding),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyObjectMember {
    JsGetterObjectMember(JsGetterObjectMember),
    JsMethodObjectMember(JsMethodObjectMember),
    JsPropertyObjectMember(JsPropertyObjectMember),
    JsSetterObjectMember(JsSetterObjectMember),
    JsShorthandPropertyObjectMember(JsShorthandPropertyObjectMember),
    JsSpread(JsSpread),
    JsUnknownMember(JsUnknownMember),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyObjectMemberName {
    JsComputedMemberName(JsComputedMemberName),
    JsLiteralMemberName(JsLiteralMemberName),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyParameter {
    JsAnyFormalParameter(JsAnyFormalParameter),
    JsRestParameter(JsRestParameter),
    TsThisParameter(TsThisParameter),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyPropertyModifier {
    JsStaticModifier(JsStaticModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyRoot {
    JsExpressionSnipped(JsExpressionSnipped),
    JsModule(JsModule),
    JsScript(JsScript),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyStatement {
    JsBlockStatement(JsBlockStatement),
    JsBreakStatement(JsBreakStatement),
    JsClassDeclaration(JsClassDeclaration),
    JsContinueStatement(JsContinueStatement),
    JsDebuggerStatement(JsDebuggerStatement),
    JsDoWhileStatement(JsDoWhileStatement),
    JsEmptyStatement(JsEmptyStatement),
    JsExpressionStatement(JsExpressionStatement),
    JsForInStatement(JsForInStatement),
    JsForOfStatement(JsForOfStatement),
    JsForStatement(JsForStatement),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsIfStatement(JsIfStatement),
    JsLabeledStatement(JsLabeledStatement),
    JsReturnStatement(JsReturnStatement),
    JsSwitchStatement(JsSwitchStatement),
    JsThrowStatement(JsThrowStatement),
    JsTryFinallyStatement(JsTryFinallyStatement),
    JsTryStatement(JsTryStatement),
    JsUnknownStatement(JsUnknownStatement),
    JsVariableStatement(JsVariableStatement),
    JsWhileStatement(JsWhileStatement),
    JsWithStatement(JsWithStatement),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsDeclareStatement(TsDeclareStatement),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnySwitchClause {
    JsCaseClause(JsCaseClause),
    JsDefaultClause(JsDefaultClause),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsAnyTemplateElement {
    JsTemplateChunkElement(JsTemplateChunkElement),
    JsTemplateElement(JsTemplateElement),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsxAnyAttribute {
    JsxAttribute(JsxAttribute),
    JsxSpreadAttribute(JsxSpreadAttribute),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsxAnyAttributeName {
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsxAnyAttributeValue {
    JsxAnyTag(JsxAnyTag),
    JsxExpressionAttributeValue(JsxExpressionAttributeValue),
    JsxString(JsxString),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsxAnyChild {
    JsxElement(JsxElement),
    JsxExpressionChild(JsxExpressionChild),
    JsxFragment(JsxFragment),
    JsxSelfClosingElement(JsxSelfClosingElement),
    JsxSpreadChild(JsxSpreadChild),
    JsxText(JsxText),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsxAnyElementName {
    JsxMemberName(JsxMemberName),
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
    JsxReferenceIdentifier(JsxReferenceIdentifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsxAnyName {
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsxAnyObjectName {
    JsxMemberName(JsxMemberName),
    JsxNamespaceName(JsxNamespaceName),
    JsxReferenceIdentifier(JsxReferenceIdentifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum JsxAnyTag {
    JsxElement(JsxElement),
    JsxFragment(JsxFragment),
    JsxSelfClosingElement(JsxSelfClosingElement),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyExternalModuleDeclarationBody {
    TsEmptyExternalModuleDeclarationBody(TsEmptyExternalModuleDeclarationBody),
    TsModuleBlock(TsModuleBlock),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyIndexSignatureModifier {
    JsStaticModifier(JsStaticModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyMethodSignatureModifier {
    JsStaticModifier(JsStaticModifier),
    TsAbstractModifier(TsAbstractModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyModuleName {
    TsIdentifierBinding(TsIdentifierBinding),
    TsQualifiedModuleName(TsQualifiedModuleName),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyModuleReference {
    TsAnyName(TsAnyName),
    TsExternalModuleReference(TsExternalModuleReference),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyName {
    JsReferenceIdentifier(JsReferenceIdentifier),
    TsQualifiedName(TsQualifiedName),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyPropertyAnnotation {
    TsDefinitePropertyAnnotation(TsDefinitePropertyAnnotation),
    TsOptionalPropertyAnnotation(TsOptionalPropertyAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyPropertyParameterModifier {
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyPropertySignatureAnnotation {
    TsOptionalPropertyAnnotation(TsOptionalPropertyAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyPropertySignatureModifier {
    JsStaticModifier(JsStaticModifier),
    TsAbstractModifier(TsAbstractModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsDeclareModifier(TsDeclareModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyReturnType {
    TsAssertsReturnType(TsAssertsReturnType),
    TsPredicateReturnType(TsPredicateReturnType),
    TsType(TsType),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyTemplateElement {
    TsTemplateChunkElement(TsTemplateChunkElement),
    TsTemplateElement(TsTemplateElement),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyTupleTypeElement {
    TsNamedTupleTypeElement(TsNamedTupleTypeElement),
    TsOptionalTupleTypeElement(TsOptionalTupleTypeElement),
    TsRestTupleTypeElement(TsRestTupleTypeElement),
    TsType(TsType),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyTypeMember {
    JsUnknownMember(JsUnknownMember),
    TsCallSignatureTypeMember(TsCallSignatureTypeMember),
    TsConstructSignatureTypeMember(TsConstructSignatureTypeMember),
    TsGetterSignatureTypeMember(TsGetterSignatureTypeMember),
    TsIndexSignatureTypeMember(TsIndexSignatureTypeMember),
    TsMethodSignatureTypeMember(TsMethodSignatureTypeMember),
    TsPropertySignatureTypeMember(TsPropertySignatureTypeMember),
    TsSetterSignatureTypeMember(TsSetterSignatureTypeMember),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyTypePredicateParameterName {
    JsReferenceIdentifier(JsReferenceIdentifier),
    TsThisType(TsThisType),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsAnyVariableAnnotation {
    TsDefiniteVariableAnnotation(TsDefiniteVariableAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum TsType {
    TsAnyType(TsAnyType),
    TsArrayType(TsArrayType),
    TsBigIntLiteralType(TsBigIntLiteralType),
    TsBigintType(TsBigintType),
    TsBooleanLiteralType(TsBooleanLiteralType),
    TsBooleanType(TsBooleanType),
    TsConditionalType(TsConditionalType),
    TsConstructorType(TsConstructorType),
    TsFunctionType(TsFunctionType),
    TsImportType(TsImportType),
    TsIndexedAccessType(TsIndexedAccessType),
    TsInferType(TsInferType),
    TsIntersectionType(TsIntersectionType),
    TsMappedType(TsMappedType),
    TsNeverType(TsNeverType),
    TsNonPrimitiveType(TsNonPrimitiveType),
    TsNullLiteralType(TsNullLiteralType),
    TsNumberLiteralType(TsNumberLiteralType),
    TsNumberType(TsNumberType),
    TsObjectType(TsObjectType),
    TsParenthesizedType(TsParenthesizedType),
    TsReferenceType(TsReferenceType),
    TsStringLiteralType(TsStringLiteralType),
    TsStringType(TsStringType),
    TsSymbolType(TsSymbolType),
    TsTemplateLiteralType(TsTemplateLiteralType),
    TsThisType(TsThisType),
    TsTupleType(TsTupleType),
    TsTypeOperatorType(TsTypeOperatorType),
    TsTypeofType(TsTypeofType),
    TsUndefinedType(TsUndefinedType),
    TsUnionType(TsUnionType),
    TsUnknownType(TsUnknownType),
    TsVoidType(TsVoidType),
}
impl AstNode<JsLanguage> for ImportMeta {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == IMPORT_META
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for ImportMeta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ImportMeta")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("meta_token", &support::DebugSyntaxResult(self.meta_token()))
            .finish()
    }
}
impl From<ImportMeta> for JsSyntaxNode {
    fn from(n: ImportMeta) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<ImportMeta> for JsSyntaxElement {
    fn from(n: ImportMeta) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsArrayAssignmentPattern {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_ASSIGNMENT_PATTERN
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsArrayAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayAssignmentPattern")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayAssignmentPattern> for JsSyntaxNode {
    fn from(n: JsArrayAssignmentPattern) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsArrayAssignmentPattern> for JsSyntaxElement {
    fn from(n: JsArrayAssignmentPattern) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsArrayAssignmentPatternRestElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsArrayAssignmentPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayAssignmentPatternRestElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .finish()
    }
}
impl From<JsArrayAssignmentPatternRestElement> for JsSyntaxNode {
    fn from(n: JsArrayAssignmentPatternRestElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsArrayAssignmentPatternRestElement> for JsSyntaxElement {
    fn from(n: JsArrayAssignmentPatternRestElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsArrayBindingPattern {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_BINDING_PATTERN
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsArrayBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayBindingPattern")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayBindingPattern> for JsSyntaxNode {
    fn from(n: JsArrayBindingPattern) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsArrayBindingPattern> for JsSyntaxElement {
    fn from(n: JsArrayBindingPattern) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsArrayBindingPatternRestElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_BINDING_PATTERN_REST_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsArrayBindingPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayBindingPatternRestElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .finish()
    }
}
impl From<JsArrayBindingPatternRestElement> for JsSyntaxNode {
    fn from(n: JsArrayBindingPatternRestElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsArrayBindingPatternRestElement> for JsSyntaxElement {
    fn from(n: JsArrayBindingPatternRestElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsArrayExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsArrayExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayExpression")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayExpression> for JsSyntaxNode {
    fn from(n: JsArrayExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsArrayExpression> for JsSyntaxElement {
    fn from(n: JsArrayExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsArrayHole {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_HOLE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsArrayHole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayHole").finish()
    }
}
impl From<JsArrayHole> for JsSyntaxNode {
    fn from(n: JsArrayHole) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsArrayHole> for JsSyntaxElement {
    fn from(n: JsArrayHole) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsArrowFunctionExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARROW_FUNCTION_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsArrowFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrowFunctionExpression")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsArrowFunctionExpression> for JsSyntaxNode {
    fn from(n: JsArrowFunctionExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsArrowFunctionExpression> for JsSyntaxElement {
    fn from(n: JsArrowFunctionExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsAssignmentExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ASSIGNMENT_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsAssignmentExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAssignmentExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsAssignmentExpression> for JsSyntaxNode {
    fn from(n: JsAssignmentExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsAssignmentExpression> for JsSyntaxElement {
    fn from(n: JsAssignmentExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsAssignmentWithDefault {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ASSIGNMENT_WITH_DEFAULT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsAssignmentWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAssignmentWithDefault")
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("default", &support::DebugSyntaxResult(self.default()))
            .finish()
    }
}
impl From<JsAssignmentWithDefault> for JsSyntaxNode {
    fn from(n: JsAssignmentWithDefault) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsAssignmentWithDefault> for JsSyntaxElement {
    fn from(n: JsAssignmentWithDefault) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsAwaitExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_AWAIT_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsAwaitExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAwaitExpression")
            .field(
                "await_token",
                &support::DebugSyntaxResult(self.await_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsAwaitExpression> for JsSyntaxNode {
    fn from(n: JsAwaitExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsAwaitExpression> for JsSyntaxElement {
    fn from(n: JsAwaitExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsBigIntLiteralExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_BIG_INT_LITERAL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsBigIntLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBigIntLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsBigIntLiteralExpression> for JsSyntaxNode {
    fn from(n: JsBigIntLiteralExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsBigIntLiteralExpression> for JsSyntaxElement {
    fn from(n: JsBigIntLiteralExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsBinaryExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_BINARY_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsBinaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBinaryExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field("operator", &support::DebugSyntaxResult(self.operator()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsBinaryExpression> for JsSyntaxNode {
    fn from(n: JsBinaryExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsBinaryExpression> for JsSyntaxElement {
    fn from(n: JsBinaryExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsBindingPatternWithDefault {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_BINDING_PATTERN_WITH_DEFAULT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsBindingPatternWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBindingPatternWithDefault")
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("default", &support::DebugSyntaxResult(self.default()))
            .finish()
    }
}
impl From<JsBindingPatternWithDefault> for JsSyntaxNode {
    fn from(n: JsBindingPatternWithDefault) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsBindingPatternWithDefault> for JsSyntaxElement {
    fn from(n: JsBindingPatternWithDefault) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsBlockStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_BLOCK_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsBlockStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBlockStatement")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsBlockStatement> for JsSyntaxNode {
    fn from(n: JsBlockStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsBlockStatement> for JsSyntaxElement {
    fn from(n: JsBlockStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsBooleanLiteralExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_BOOLEAN_LITERAL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsBooleanLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBooleanLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsBooleanLiteralExpression> for JsSyntaxNode {
    fn from(n: JsBooleanLiteralExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsBooleanLiteralExpression> for JsSyntaxElement {
    fn from(n: JsBooleanLiteralExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsBreakStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_BREAK_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsBreakStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBreakStatement")
            .field(
                "break_token",
                &support::DebugSyntaxResult(self.break_token()),
            )
            .field(
                "label_token",
                &support::DebugOptionalElement(self.label_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsBreakStatement> for JsSyntaxNode {
    fn from(n: JsBreakStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsBreakStatement> for JsSyntaxElement {
    fn from(n: JsBreakStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsCallArguments {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CALL_ARGUMENTS
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsCallArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCallArguments")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("args", &self.args())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsCallArguments> for JsSyntaxNode {
    fn from(n: JsCallArguments) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsCallArguments> for JsSyntaxElement {
    fn from(n: JsCallArguments) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsCallExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CALL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCallExpression")
            .field("callee", &support::DebugSyntaxResult(self.callee()))
            .field(
                "optional_chain_token",
                &support::DebugOptionalElement(self.optional_chain_token()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("arguments", &support::DebugSyntaxResult(self.arguments()))
            .finish()
    }
}
impl From<JsCallExpression> for JsSyntaxNode {
    fn from(n: JsCallExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsCallExpression> for JsSyntaxElement {
    fn from(n: JsCallExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsCaseClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CASE_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsCaseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCaseClause")
            .field("case_token", &support::DebugSyntaxResult(self.case_token()))
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("consequent", &self.consequent())
            .finish()
    }
}
impl From<JsCaseClause> for JsSyntaxNode {
    fn from(n: JsCaseClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsCaseClause> for JsSyntaxElement {
    fn from(n: JsCaseClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsCatchClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CATCH_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsCatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCatchClause")
            .field(
                "catch_token",
                &support::DebugSyntaxResult(self.catch_token()),
            )
            .field(
                "declaration",
                &support::DebugOptionalElement(self.declaration()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsCatchClause> for JsSyntaxNode {
    fn from(n: JsCatchClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsCatchClause> for JsSyntaxElement {
    fn from(n: JsCatchClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsCatchDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CATCH_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsCatchDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCatchDeclaration")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsCatchDeclaration> for JsSyntaxNode {
    fn from(n: JsCatchDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsCatchDeclaration> for JsSyntaxElement {
    fn from(n: JsCatchDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsClassDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CLASS_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsClassDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassDeclaration")
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassDeclaration> for JsSyntaxNode {
    fn from(n: JsClassDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsClassDeclaration> for JsSyntaxElement {
    fn from(n: JsClassDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsClassExportDefaultDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CLASS_EXPORT_DEFAULT_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsClassExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassExportDefaultDeclaration")
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassExportDefaultDeclaration> for JsSyntaxNode {
    fn from(n: JsClassExportDefaultDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsClassExportDefaultDeclaration> for JsSyntaxElement {
    fn from(n: JsClassExportDefaultDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsClassExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CLASS_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsClassExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassExpression")
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassExpression> for JsSyntaxNode {
    fn from(n: JsClassExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsClassExpression> for JsSyntaxElement {
    fn from(n: JsClassExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsComputedMemberAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_COMPUTED_MEMBER_ASSIGNMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsComputedMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberAssignment")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberAssignment> for JsSyntaxNode {
    fn from(n: JsComputedMemberAssignment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsComputedMemberAssignment> for JsSyntaxElement {
    fn from(n: JsComputedMemberAssignment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsComputedMemberExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_COMPUTED_MEMBER_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsComputedMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberExpression")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "optional_chain_token",
                &support::DebugOptionalElement(self.optional_chain_token()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberExpression> for JsSyntaxNode {
    fn from(n: JsComputedMemberExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsComputedMemberExpression> for JsSyntaxElement {
    fn from(n: JsComputedMemberExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsComputedMemberName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_COMPUTED_MEMBER_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsComputedMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberName")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberName> for JsSyntaxNode {
    fn from(n: JsComputedMemberName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsComputedMemberName> for JsSyntaxElement {
    fn from(n: JsComputedMemberName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsConditionalExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CONDITIONAL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsConditionalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConditionalExpression")
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field("consequent", &support::DebugSyntaxResult(self.consequent()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("alternate", &support::DebugSyntaxResult(self.alternate()))
            .finish()
    }
}
impl From<JsConditionalExpression> for JsSyntaxNode {
    fn from(n: JsConditionalExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsConditionalExpression> for JsSyntaxElement {
    fn from(n: JsConditionalExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsConstructorClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CONSTRUCTOR_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsConstructorClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConstructorClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsConstructorClassMember> for JsSyntaxNode {
    fn from(n: JsConstructorClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsConstructorClassMember> for JsSyntaxElement {
    fn from(n: JsConstructorClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsConstructorParameters {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CONSTRUCTOR_PARAMETERS
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsConstructorParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConstructorParameters")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameters", &self.parameters())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsConstructorParameters> for JsSyntaxNode {
    fn from(n: JsConstructorParameters) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsConstructorParameters> for JsSyntaxElement {
    fn from(n: JsConstructorParameters) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsContinueStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CONTINUE_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsContinueStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsContinueStatement")
            .field(
                "continue_token",
                &support::DebugSyntaxResult(self.continue_token()),
            )
            .field(
                "label_token",
                &support::DebugOptionalElement(self.label_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsContinueStatement> for JsSyntaxNode {
    fn from(n: JsContinueStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsContinueStatement> for JsSyntaxElement {
    fn from(n: JsContinueStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsDebuggerStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_DEBUGGER_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsDebuggerStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDebuggerStatement")
            .field(
                "debugger_token",
                &support::DebugSyntaxResult(self.debugger_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDebuggerStatement> for JsSyntaxNode {
    fn from(n: JsDebuggerStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsDebuggerStatement> for JsSyntaxElement {
    fn from(n: JsDebuggerStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsDefaultClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_DEFAULT_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDefaultClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("consequent", &self.consequent())
            .finish()
    }
}
impl From<JsDefaultClause> for JsSyntaxNode {
    fn from(n: JsDefaultClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsDefaultClause> for JsSyntaxElement {
    fn from(n: JsDefaultClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsDefaultImportSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_DEFAULT_IMPORT_SPECIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsDefaultImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDefaultImportSpecifier")
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field(
                "trailing_comma_token",
                &support::DebugSyntaxResult(self.trailing_comma_token()),
            )
            .finish()
    }
}
impl From<JsDefaultImportSpecifier> for JsSyntaxNode {
    fn from(n: JsDefaultImportSpecifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsDefaultImportSpecifier> for JsSyntaxElement {
    fn from(n: JsDefaultImportSpecifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsDirective {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_DIRECTIVE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDirective")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDirective> for JsSyntaxNode {
    fn from(n: JsDirective) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsDirective> for JsSyntaxElement {
    fn from(n: JsDirective) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsDoWhileStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_DO_WHILE_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsDoWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDoWhileStatement")
            .field("do_token", &support::DebugSyntaxResult(self.do_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "while_token",
                &support::DebugSyntaxResult(self.while_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDoWhileStatement> for JsSyntaxNode {
    fn from(n: JsDoWhileStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsDoWhileStatement> for JsSyntaxElement {
    fn from(n: JsDoWhileStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsElseClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ELSE_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsElseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsElseClause")
            .field("else_token", &support::DebugSyntaxResult(self.else_token()))
            .field("alternate", &support::DebugSyntaxResult(self.alternate()))
            .finish()
    }
}
impl From<JsElseClause> for JsSyntaxNode {
    fn from(n: JsElseClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsElseClause> for JsSyntaxElement {
    fn from(n: JsElseClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsEmptyClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EMPTY_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsEmptyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsEmptyClassMember")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsEmptyClassMember> for JsSyntaxNode {
    fn from(n: JsEmptyClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsEmptyClassMember> for JsSyntaxElement {
    fn from(n: JsEmptyClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsEmptyStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EMPTY_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsEmptyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsEmptyStatement")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsEmptyStatement> for JsSyntaxNode {
    fn from(n: JsEmptyStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsEmptyStatement> for JsSyntaxElement {
    fn from(n: JsEmptyStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExport {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExport")
            .field(
                "export_token",
                &support::DebugSyntaxResult(self.export_token()),
            )
            .field(
                "export_clause",
                &support::DebugSyntaxResult(self.export_clause()),
            )
            .finish()
    }
}
impl From<JsExport> for JsSyntaxNode {
    fn from(n: JsExport) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExport> for JsSyntaxElement {
    fn from(n: JsExport) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportAsClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_AS_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportAsClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "exported_name",
                &support::DebugSyntaxResult(self.exported_name()),
            )
            .finish()
    }
}
impl From<JsExportAsClause> for JsSyntaxNode {
    fn from(n: JsExportAsClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportAsClause> for JsSyntaxElement {
    fn from(n: JsExportAsClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportDefaultDeclarationClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_DEFAULT_DECLARATION_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportDefaultDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportDefaultDeclarationClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportDefaultDeclarationClause> for JsSyntaxNode {
    fn from(n: JsExportDefaultDeclarationClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportDefaultDeclarationClause> for JsSyntaxElement {
    fn from(n: JsExportDefaultDeclarationClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportDefaultExpressionClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportDefaultExpressionClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportDefaultExpressionClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportDefaultExpressionClause> for JsSyntaxNode {
    fn from(n: JsExportDefaultExpressionClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportDefaultExpressionClause> for JsSyntaxElement {
    fn from(n: JsExportDefaultExpressionClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportFromClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_FROM_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportFromClause")
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field(
                "export_as",
                &support::DebugOptionalElement(self.export_as()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportFromClause> for JsSyntaxNode {
    fn from(n: JsExportFromClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportFromClause> for JsSyntaxElement {
    fn from(n: JsExportFromClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportNamedClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_NAMED_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportNamedClause> for JsSyntaxNode {
    fn from(n: JsExportNamedClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportNamedClause> for JsSyntaxElement {
    fn from(n: JsExportNamedClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportNamedFromClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_NAMED_FROM_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportNamedFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedFromClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportNamedFromClause> for JsSyntaxNode {
    fn from(n: JsExportNamedFromClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportNamedFromClause> for JsSyntaxElement {
    fn from(n: JsExportNamedFromClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportNamedFromSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_NAMED_FROM_SPECIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportNamedFromSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedFromSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "source_name",
                &support::DebugSyntaxResult(self.source_name()),
            )
            .field(
                "export_as",
                &support::DebugOptionalElement(self.export_as()),
            )
            .finish()
    }
}
impl From<JsExportNamedFromSpecifier> for JsSyntaxNode {
    fn from(n: JsExportNamedFromSpecifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportNamedFromSpecifier> for JsSyntaxElement {
    fn from(n: JsExportNamedFromSpecifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportNamedShorthandSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_NAMED_SHORTHAND_SPECIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportNamedShorthandSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedShorthandSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsExportNamedShorthandSpecifier> for JsSyntaxNode {
    fn from(n: JsExportNamedShorthandSpecifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportNamedShorthandSpecifier> for JsSyntaxElement {
    fn from(n: JsExportNamedShorthandSpecifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExportNamedSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_NAMED_SPECIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "exported_name",
                &support::DebugSyntaxResult(self.exported_name()),
            )
            .finish()
    }
}
impl From<JsExportNamedSpecifier> for JsSyntaxNode {
    fn from(n: JsExportNamedSpecifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExportNamedSpecifier> for JsSyntaxElement {
    fn from(n: JsExportNamedSpecifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExpressionSnipped {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPRESSION_SNIPPED
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExpressionSnipped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExpressionSnipped")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsExpressionSnipped> for JsSyntaxNode {
    fn from(n: JsExpressionSnipped) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExpressionSnipped> for JsSyntaxElement {
    fn from(n: JsExpressionSnipped) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExpressionStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPRESSION_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExpressionStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExpressionStatement")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExpressionStatement> for JsSyntaxNode {
    fn from(n: JsExpressionStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExpressionStatement> for JsSyntaxElement {
    fn from(n: JsExpressionStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsExtendsClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXTENDS_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExtendsClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field(
                "super_class",
                &support::DebugSyntaxResult(self.super_class()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<JsExtendsClause> for JsSyntaxNode {
    fn from(n: JsExtendsClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsExtendsClause> for JsSyntaxElement {
    fn from(n: JsExtendsClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsFinallyClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FINALLY_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsFinallyClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFinallyClause")
            .field(
                "finally_token",
                &support::DebugSyntaxResult(self.finally_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFinallyClause> for JsSyntaxNode {
    fn from(n: JsFinallyClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsFinallyClause> for JsSyntaxElement {
    fn from(n: JsFinallyClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsForInStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FOR_IN_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsForInStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForInStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugSyntaxResult(self.initializer()),
            )
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForInStatement> for JsSyntaxNode {
    fn from(n: JsForInStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsForInStatement> for JsSyntaxElement {
    fn from(n: JsForInStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsForOfStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FOR_OF_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsForOfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForOfStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "await_token",
                &support::DebugOptionalElement(self.await_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugSyntaxResult(self.initializer()),
            )
            .field("of_token", &support::DebugSyntaxResult(self.of_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForOfStatement> for JsSyntaxNode {
    fn from(n: JsForOfStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsForOfStatement> for JsSyntaxElement {
    fn from(n: JsForOfStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsForStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FOR_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsForStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .field(
                "first_semi_token",
                &support::DebugSyntaxResult(self.first_semi_token()),
            )
            .field("test", &support::DebugOptionalElement(self.test()))
            .field(
                "second_semi_token",
                &support::DebugSyntaxResult(self.second_semi_token()),
            )
            .field("update", &support::DebugOptionalElement(self.update()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForStatement> for JsSyntaxNode {
    fn from(n: JsForStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsForStatement> for JsSyntaxElement {
    fn from(n: JsForStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsForVariableDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FOR_VARIABLE_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsForVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForVariableDeclaration")
            .field("kind_token", &support::DebugSyntaxResult(self.kind_token()))
            .field("declarator", &support::DebugSyntaxResult(self.declarator()))
            .finish()
    }
}
impl From<JsForVariableDeclaration> for JsSyntaxNode {
    fn from(n: JsForVariableDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsForVariableDeclaration> for JsSyntaxElement {
    fn from(n: JsForVariableDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsFormalParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FORMAL_PARAMETER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFormalParameter")
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsFormalParameter> for JsSyntaxNode {
    fn from(n: JsFormalParameter) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsFormalParameter> for JsSyntaxElement {
    fn from(n: JsFormalParameter) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsFunctionBody {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FUNCTION_BODY
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionBody")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("directives", &self.directives())
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsFunctionBody> for JsSyntaxNode {
    fn from(n: JsFunctionBody) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsFunctionBody> for JsSyntaxElement {
    fn from(n: JsFunctionBody) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsFunctionDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FUNCTION_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionDeclaration> for JsSyntaxNode {
    fn from(n: JsFunctionDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsFunctionDeclaration> for JsSyntaxElement {
    fn from(n: JsFunctionDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsFunctionExportDefaultDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FUNCTION_EXPORT_DEFAULT_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsFunctionExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionExportDefaultDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionExportDefaultDeclaration> for JsSyntaxNode {
    fn from(n: JsFunctionExportDefaultDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsFunctionExportDefaultDeclaration> for JsSyntaxElement {
    fn from(n: JsFunctionExportDefaultDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsFunctionExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_FUNCTION_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionExpression")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionExpression> for JsSyntaxNode {
    fn from(n: JsFunctionExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsFunctionExpression> for JsSyntaxElement {
    fn from(n: JsFunctionExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsGetterClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_GETTER_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsGetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsGetterClassMember")
            .field("modifiers", &self.modifiers())
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsGetterClassMember> for JsSyntaxNode {
    fn from(n: JsGetterClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsGetterClassMember> for JsSyntaxElement {
    fn from(n: JsGetterClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsGetterObjectMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_GETTER_OBJECT_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsGetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsGetterObjectMember")
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsGetterObjectMember> for JsSyntaxNode {
    fn from(n: JsGetterObjectMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsGetterObjectMember> for JsSyntaxElement {
    fn from(n: JsGetterObjectMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsIdentifierAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IDENTIFIER_ASSIGNMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsIdentifierAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierAssignment")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<JsIdentifierAssignment> for JsSyntaxNode {
    fn from(n: JsIdentifierAssignment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsIdentifierAssignment> for JsSyntaxElement {
    fn from(n: JsIdentifierAssignment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsIdentifierBinding {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IDENTIFIER_BINDING
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierBinding")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<JsIdentifierBinding> for JsSyntaxNode {
    fn from(n: JsIdentifierBinding) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsIdentifierBinding> for JsSyntaxElement {
    fn from(n: JsIdentifierBinding) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsIdentifierExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IDENTIFIER_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsIdentifierExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierExpression")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsIdentifierExpression> for JsSyntaxNode {
    fn from(n: JsIdentifierExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsIdentifierExpression> for JsSyntaxElement {
    fn from(n: JsIdentifierExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsIfStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IF_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsIfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIfStatement")
            .field("if_token", &support::DebugSyntaxResult(self.if_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("consequent", &support::DebugSyntaxResult(self.consequent()))
            .field(
                "else_clause",
                &support::DebugOptionalElement(self.else_clause()),
            )
            .finish()
    }
}
impl From<JsIfStatement> for JsSyntaxNode {
    fn from(n: JsIfStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsIfStatement> for JsSyntaxElement {
    fn from(n: JsIfStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsImport {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImport")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "import_clause",
                &support::DebugSyntaxResult(self.import_clause()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsImport> for JsSyntaxNode {
    fn from(n: JsImport) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsImport> for JsSyntaxElement {
    fn from(n: JsImport) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsImportAssertion {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT_ASSERTION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsImportAssertion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportAssertion")
            .field(
                "assert_token",
                &support::DebugSyntaxResult(self.assert_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("assertions", &self.assertions())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsImportAssertion> for JsSyntaxNode {
    fn from(n: JsImportAssertion) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsImportAssertion> for JsSyntaxElement {
    fn from(n: JsImportAssertion) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsImportAssertionEntry {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT_ASSERTION_ENTRY
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportAssertionEntry")
            .field("key", &support::DebugSyntaxResult(self.key()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsImportAssertionEntry> for JsSyntaxNode {
    fn from(n: JsImportAssertionEntry) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsImportAssertionEntry> for JsSyntaxElement {
    fn from(n: JsImportAssertionEntry) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsImportBareClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT_BARE_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsImportBareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportBareClause")
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .finish()
    }
}
impl From<JsImportBareClause> for JsSyntaxNode {
    fn from(n: JsImportBareClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsImportBareClause> for JsSyntaxElement {
    fn from(n: JsImportBareClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsImportCallExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT_CALL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsImportCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportCallExpression")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field("arguments", &support::DebugSyntaxResult(self.arguments()))
            .finish()
    }
}
impl From<JsImportCallExpression> for JsSyntaxNode {
    fn from(n: JsImportCallExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsImportCallExpression> for JsSyntaxElement {
    fn from(n: JsImportCallExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsImportDefaultClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT_DEFAULT_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsImportDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportDefaultClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .finish()
    }
}
impl From<JsImportDefaultClause> for JsSyntaxNode {
    fn from(n: JsImportDefaultClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsImportDefaultClause> for JsSyntaxElement {
    fn from(n: JsImportDefaultClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsImportNamedClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT_NAMED_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsImportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportNamedClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "default_specifier",
                &support::DebugOptionalElement(self.default_specifier()),
            )
            .field(
                "named_import",
                &support::DebugSyntaxResult(self.named_import()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .finish()
    }
}
impl From<JsImportNamedClause> for JsSyntaxNode {
    fn from(n: JsImportNamedClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsImportNamedClause> for JsSyntaxElement {
    fn from(n: JsImportNamedClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsImportNamespaceClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT_NAMESPACE_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsImportNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportNamespaceClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .finish()
    }
}
impl From<JsImportNamespaceClause> for JsSyntaxNode {
    fn from(n: JsImportNamespaceClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsImportNamespaceClause> for JsSyntaxElement {
    fn from(n: JsImportNamespaceClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsInExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IN_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsInExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInExpression")
            .field("property", &support::DebugSyntaxResult(self.property()))
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("object", &support::DebugSyntaxResult(self.object()))
            .finish()
    }
}
impl From<JsInExpression> for JsSyntaxNode {
    fn from(n: JsInExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsInExpression> for JsSyntaxElement {
    fn from(n: JsInExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsInitializerClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_INITIALIZER_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInitializerClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<JsInitializerClause> for JsSyntaxNode {
    fn from(n: JsInitializerClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsInitializerClause> for JsSyntaxElement {
    fn from(n: JsInitializerClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsInstanceofExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_INSTANCEOF_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsInstanceofExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInstanceofExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "instanceof_token",
                &support::DebugSyntaxResult(self.instanceof_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsInstanceofExpression> for JsSyntaxNode {
    fn from(n: JsInstanceofExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsInstanceofExpression> for JsSyntaxElement {
    fn from(n: JsInstanceofExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsLabeledStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_LABELED_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsLabeledStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLabeledStatement")
            .field(
                "label_token",
                &support::DebugSyntaxResult(self.label_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsLabeledStatement> for JsSyntaxNode {
    fn from(n: JsLabeledStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsLabeledStatement> for JsSyntaxElement {
    fn from(n: JsLabeledStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsLiteralExportName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_LITERAL_EXPORT_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsLiteralExportName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLiteralExportName")
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsLiteralExportName> for JsSyntaxNode {
    fn from(n: JsLiteralExportName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsLiteralExportName> for JsSyntaxElement {
    fn from(n: JsLiteralExportName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsLiteralMemberName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_LITERAL_MEMBER_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsLiteralMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLiteralMemberName")
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsLiteralMemberName> for JsSyntaxNode {
    fn from(n: JsLiteralMemberName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsLiteralMemberName> for JsSyntaxElement {
    fn from(n: JsLiteralMemberName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsLogicalExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_LOGICAL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsLogicalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLogicalExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field("operator", &support::DebugSyntaxResult(self.operator()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsLogicalExpression> for JsSyntaxNode {
    fn from(n: JsLogicalExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsLogicalExpression> for JsSyntaxElement {
    fn from(n: JsLogicalExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsMethodClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_METHOD_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsMethodClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsMethodClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsMethodClassMember> for JsSyntaxNode {
    fn from(n: JsMethodClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsMethodClassMember> for JsSyntaxElement {
    fn from(n: JsMethodClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsMethodObjectMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_METHOD_OBJECT_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsMethodObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsMethodObjectMember")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsMethodObjectMember> for JsSyntaxNode {
    fn from(n: JsMethodObjectMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsMethodObjectMember> for JsSyntaxElement {
    fn from(n: JsMethodObjectMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsModule {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_MODULE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsModule")
            .field(
                "interpreter_token",
                &support::DebugOptionalElement(self.interpreter_token()),
            )
            .field("directives", &self.directives())
            .field("items", &self.items())
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsModule> for JsSyntaxNode {
    fn from(n: JsModule) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsModule> for JsSyntaxElement {
    fn from(n: JsModule) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsModuleSource {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_MODULE_SOURCE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsModuleSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsModuleSource")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsModuleSource> for JsSyntaxNode {
    fn from(n: JsModuleSource) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsModuleSource> for JsSyntaxElement {
    fn from(n: JsModuleSource) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsName")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsName> for JsSyntaxNode {
    fn from(n: JsName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsName> for JsSyntaxElement {
    fn from(n: JsName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsNamedImportSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_NAMED_IMPORT_SPECIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamedImportSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsNamedImportSpecifier> for JsSyntaxNode {
    fn from(n: JsNamedImportSpecifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsNamedImportSpecifier> for JsSyntaxElement {
    fn from(n: JsNamedImportSpecifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsNamedImportSpecifiers {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_NAMED_IMPORT_SPECIFIERS
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsNamedImportSpecifiers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamedImportSpecifiers")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsNamedImportSpecifiers> for JsSyntaxNode {
    fn from(n: JsNamedImportSpecifiers) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsNamedImportSpecifiers> for JsSyntaxElement {
    fn from(n: JsNamedImportSpecifiers) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsNamespaceImportSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_NAMESPACE_IMPORT_SPECIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsNamespaceImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamespaceImportSpecifier")
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsNamespaceImportSpecifier> for JsSyntaxNode {
    fn from(n: JsNamespaceImportSpecifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsNamespaceImportSpecifier> for JsSyntaxElement {
    fn from(n: JsNamespaceImportSpecifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsNewExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_NEW_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsNewExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNewExpression")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field("callee", &support::DebugSyntaxResult(self.callee()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field(
                "arguments",
                &support::DebugOptionalElement(self.arguments()),
            )
            .finish()
    }
}
impl From<JsNewExpression> for JsSyntaxNode {
    fn from(n: JsNewExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsNewExpression> for JsSyntaxElement {
    fn from(n: JsNewExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsNullLiteralExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_NULL_LITERAL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsNullLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNullLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsNullLiteralExpression> for JsSyntaxNode {
    fn from(n: JsNullLiteralExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsNullLiteralExpression> for JsSyntaxElement {
    fn from(n: JsNullLiteralExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsNumberLiteralExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_NUMBER_LITERAL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsNumberLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNumberLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsNumberLiteralExpression> for JsSyntaxNode {
    fn from(n: JsNumberLiteralExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsNumberLiteralExpression> for JsSyntaxElement {
    fn from(n: JsNumberLiteralExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectAssignmentPattern {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_ASSIGNMENT_PATTERN
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPattern")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("properties", &self.properties())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectAssignmentPattern> for JsSyntaxNode {
    fn from(n: JsObjectAssignmentPattern) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectAssignmentPattern> for JsSyntaxElement {
    fn from(n: JsObjectAssignmentPattern) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectAssignmentPatternProperty {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectAssignmentPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternProperty")
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternProperty> for JsSyntaxNode {
    fn from(n: JsObjectAssignmentPatternProperty) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectAssignmentPatternProperty> for JsSyntaxElement {
    fn from(n: JsObjectAssignmentPatternProperty) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectAssignmentPatternRest {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_ASSIGNMENT_PATTERN_REST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectAssignmentPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternRest")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("target", &support::DebugSyntaxResult(self.target()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternRest> for JsSyntaxNode {
    fn from(n: JsObjectAssignmentPatternRest) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectAssignmentPatternRest> for JsSyntaxElement {
    fn from(n: JsObjectAssignmentPatternRest) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectAssignmentPatternShorthandProperty {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectAssignmentPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternShorthandProperty")
            .field("identifier", &support::DebugSyntaxResult(self.identifier()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for JsSyntaxNode {
    fn from(n: JsObjectAssignmentPatternShorthandProperty) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for JsSyntaxElement {
    fn from(n: JsObjectAssignmentPatternShorthandProperty) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectBindingPattern {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_BINDING_PATTERN
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPattern")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("properties", &self.properties())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectBindingPattern> for JsSyntaxNode {
    fn from(n: JsObjectBindingPattern) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectBindingPattern> for JsSyntaxElement {
    fn from(n: JsObjectBindingPattern) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectBindingPatternProperty {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_BINDING_PATTERN_PROPERTY
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectBindingPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternProperty")
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectBindingPatternProperty> for JsSyntaxNode {
    fn from(n: JsObjectBindingPatternProperty) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectBindingPatternProperty> for JsSyntaxElement {
    fn from(n: JsObjectBindingPatternProperty) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectBindingPatternRest {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_BINDING_PATTERN_REST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectBindingPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternRest")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .finish()
    }
}
impl From<JsObjectBindingPatternRest> for JsSyntaxNode {
    fn from(n: JsObjectBindingPatternRest) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectBindingPatternRest> for JsSyntaxElement {
    fn from(n: JsObjectBindingPatternRest) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectBindingPatternShorthandProperty {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectBindingPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternShorthandProperty")
            .field("identifier", &support::DebugSyntaxResult(self.identifier()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectBindingPatternShorthandProperty> for JsSyntaxNode {
    fn from(n: JsObjectBindingPatternShorthandProperty) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectBindingPatternShorthandProperty> for JsSyntaxElement {
    fn from(n: JsObjectBindingPatternShorthandProperty) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsObjectExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsObjectExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectExpression")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectExpression> for JsSyntaxNode {
    fn from(n: JsObjectExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsObjectExpression> for JsSyntaxElement {
    fn from(n: JsObjectExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsParameters {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PARAMETERS
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParameters")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("items", &self.items())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParameters> for JsSyntaxNode {
    fn from(n: JsParameters) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsParameters> for JsSyntaxElement {
    fn from(n: JsParameters) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsParenthesizedAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PARENTHESIZED_ASSIGNMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsParenthesizedAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParenthesizedAssignment")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParenthesizedAssignment> for JsSyntaxNode {
    fn from(n: JsParenthesizedAssignment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsParenthesizedAssignment> for JsSyntaxElement {
    fn from(n: JsParenthesizedAssignment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsParenthesizedExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PARENTHESIZED_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsParenthesizedExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParenthesizedExpression")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParenthesizedExpression> for JsSyntaxNode {
    fn from(n: JsParenthesizedExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsParenthesizedExpression> for JsSyntaxElement {
    fn from(n: JsParenthesizedExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsPostUpdateExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_POST_UPDATE_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsPostUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPostUpdateExpression")
            .field("operand", &support::DebugSyntaxResult(self.operand()))
            .field("operator", &support::DebugSyntaxResult(self.operator()))
            .finish()
    }
}
impl From<JsPostUpdateExpression> for JsSyntaxNode {
    fn from(n: JsPostUpdateExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsPostUpdateExpression> for JsSyntaxElement {
    fn from(n: JsPostUpdateExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsPreUpdateExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PRE_UPDATE_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsPreUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPreUpdateExpression")
            .field("operator", &support::DebugSyntaxResult(self.operator()))
            .field("operand", &support::DebugSyntaxResult(self.operand()))
            .finish()
    }
}
impl From<JsPreUpdateExpression> for JsSyntaxNode {
    fn from(n: JsPreUpdateExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsPreUpdateExpression> for JsSyntaxElement {
    fn from(n: JsPreUpdateExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsPrivateClassMemberName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PRIVATE_CLASS_MEMBER_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsPrivateClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPrivateClassMemberName")
            .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
            .field("id_token", &support::DebugSyntaxResult(self.id_token()))
            .finish()
    }
}
impl From<JsPrivateClassMemberName> for JsSyntaxNode {
    fn from(n: JsPrivateClassMemberName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsPrivateClassMemberName> for JsSyntaxElement {
    fn from(n: JsPrivateClassMemberName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsPrivateName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PRIVATE_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsPrivateName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPrivateName")
            .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsPrivateName> for JsSyntaxNode {
    fn from(n: JsPrivateName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsPrivateName> for JsSyntaxElement {
    fn from(n: JsPrivateName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsPropertyClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PROPERTY_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsPropertyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPropertyClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "property_annotation",
                &support::DebugOptionalElement(self.property_annotation()),
            )
            .field("value", &support::DebugOptionalElement(self.value()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsPropertyClassMember> for JsSyntaxNode {
    fn from(n: JsPropertyClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsPropertyClassMember> for JsSyntaxElement {
    fn from(n: JsPropertyClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsPropertyObjectMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PROPERTY_OBJECT_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPropertyObjectMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsPropertyObjectMember> for JsSyntaxNode {
    fn from(n: JsPropertyObjectMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsPropertyObjectMember> for JsSyntaxElement {
    fn from(n: JsPropertyObjectMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsReferenceIdentifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_REFERENCE_IDENTIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsReferenceIdentifier")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsReferenceIdentifier> for JsSyntaxNode {
    fn from(n: JsReferenceIdentifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsReferenceIdentifier> for JsSyntaxElement {
    fn from(n: JsReferenceIdentifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsRegexLiteralExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_REGEX_LITERAL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsRegexLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsRegexLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsRegexLiteralExpression> for JsSyntaxNode {
    fn from(n: JsRegexLiteralExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsRegexLiteralExpression> for JsSyntaxElement {
    fn from(n: JsRegexLiteralExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsRestParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_REST_PARAMETER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsRestParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsRestParameter")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<JsRestParameter> for JsSyntaxNode {
    fn from(n: JsRestParameter) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsRestParameter> for JsSyntaxElement {
    fn from(n: JsRestParameter) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsReturnStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_RETURN_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsReturnStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsReturnStatement")
            .field(
                "return_token",
                &support::DebugSyntaxResult(self.return_token()),
            )
            .field("argument", &support::DebugOptionalElement(self.argument()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsReturnStatement> for JsSyntaxNode {
    fn from(n: JsReturnStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsReturnStatement> for JsSyntaxElement {
    fn from(n: JsReturnStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsScript {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SCRIPT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsScript")
            .field(
                "interpreter_token",
                &support::DebugOptionalElement(self.interpreter_token()),
            )
            .field("directives", &self.directives())
            .field("statements", &self.statements())
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsScript> for JsSyntaxNode {
    fn from(n: JsScript) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsScript> for JsSyntaxElement {
    fn from(n: JsScript) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsSequenceExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SEQUENCE_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsSequenceExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSequenceExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "comma_token",
                &support::DebugSyntaxResult(self.comma_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsSequenceExpression> for JsSyntaxNode {
    fn from(n: JsSequenceExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsSequenceExpression> for JsSyntaxElement {
    fn from(n: JsSequenceExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsSetterClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SETTER_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsSetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSetterClassMember")
            .field("modifiers", &self.modifiers())
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsSetterClassMember> for JsSyntaxNode {
    fn from(n: JsSetterClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsSetterClassMember> for JsSyntaxElement {
    fn from(n: JsSetterClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsSetterObjectMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SETTER_OBJECT_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsSetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSetterObjectMember")
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsSetterObjectMember> for JsSyntaxNode {
    fn from(n: JsSetterObjectMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsSetterObjectMember> for JsSyntaxElement {
    fn from(n: JsSetterObjectMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsShorthandNamedImportSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SHORTHAND_NAMED_IMPORT_SPECIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsShorthandNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsShorthandNamedImportSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsShorthandNamedImportSpecifier> for JsSyntaxNode {
    fn from(n: JsShorthandNamedImportSpecifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsShorthandNamedImportSpecifier> for JsSyntaxElement {
    fn from(n: JsShorthandNamedImportSpecifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsShorthandPropertyObjectMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SHORTHAND_PROPERTY_OBJECT_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsShorthandPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsShorthandPropertyObjectMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsShorthandPropertyObjectMember> for JsSyntaxNode {
    fn from(n: JsShorthandPropertyObjectMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsShorthandPropertyObjectMember> for JsSyntaxElement {
    fn from(n: JsShorthandPropertyObjectMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsSpread {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SPREAD
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsSpread {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSpread")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsSpread> for JsSyntaxNode {
    fn from(n: JsSpread) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsSpread> for JsSyntaxElement {
    fn from(n: JsSpread) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsStaticInitializationBlockClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsStaticInitializationBlockClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticInitializationBlockClassMember")
            .field(
                "static_token",
                &support::DebugSyntaxResult(self.static_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsStaticInitializationBlockClassMember> for JsSyntaxNode {
    fn from(n: JsStaticInitializationBlockClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsStaticInitializationBlockClassMember> for JsSyntaxElement {
    fn from(n: JsStaticInitializationBlockClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsStaticMemberAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_STATIC_MEMBER_ASSIGNMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsStaticMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticMemberAssignment")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsStaticMemberAssignment> for JsSyntaxNode {
    fn from(n: JsStaticMemberAssignment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsStaticMemberAssignment> for JsSyntaxElement {
    fn from(n: JsStaticMemberAssignment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsStaticMemberExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_STATIC_MEMBER_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsStaticMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticMemberExpression")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field("operator", &support::DebugSyntaxResult(self.operator()))
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsStaticMemberExpression> for JsSyntaxNode {
    fn from(n: JsStaticMemberExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsStaticMemberExpression> for JsSyntaxElement {
    fn from(n: JsStaticMemberExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsStaticModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_STATIC_MODIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsStaticModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<JsStaticModifier> for JsSyntaxNode {
    fn from(n: JsStaticModifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsStaticModifier> for JsSyntaxElement {
    fn from(n: JsStaticModifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsStringLiteralExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_STRING_LITERAL_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsStringLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStringLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsStringLiteralExpression> for JsSyntaxNode {
    fn from(n: JsStringLiteralExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsStringLiteralExpression> for JsSyntaxElement {
    fn from(n: JsStringLiteralExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsSuperExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SUPER_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsSuperExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSuperExpression")
            .field(
                "super_token",
                &support::DebugSyntaxResult(self.super_token()),
            )
            .finish()
    }
}
impl From<JsSuperExpression> for JsSyntaxNode {
    fn from(n: JsSuperExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsSuperExpression> for JsSyntaxElement {
    fn from(n: JsSuperExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsSwitchStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SWITCH_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsSwitchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSwitchStatement")
            .field(
                "switch_token",
                &support::DebugSyntaxResult(self.switch_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "discriminant",
                &support::DebugSyntaxResult(self.discriminant()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("cases", &self.cases())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsSwitchStatement> for JsSyntaxNode {
    fn from(n: JsSwitchStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsSwitchStatement> for JsSyntaxElement {
    fn from(n: JsSwitchStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsTemplate {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_TEMPLATE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplate")
            .field("tag", &support::DebugOptionalElement(self.tag()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field(
                "l_tick_token",
                &support::DebugSyntaxResult(self.l_tick_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_tick_token",
                &support::DebugSyntaxResult(self.r_tick_token()),
            )
            .finish()
    }
}
impl From<JsTemplate> for JsSyntaxNode {
    fn from(n: JsTemplate) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsTemplate> for JsSyntaxElement {
    fn from(n: JsTemplate) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsTemplateChunkElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_TEMPLATE_CHUNK_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplateChunkElement")
            .field(
                "template_chunk_token",
                &support::DebugSyntaxResult(self.template_chunk_token()),
            )
            .finish()
    }
}
impl From<JsTemplateChunkElement> for JsSyntaxNode {
    fn from(n: JsTemplateChunkElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsTemplateChunkElement> for JsSyntaxElement {
    fn from(n: JsTemplateChunkElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsTemplateElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_TEMPLATE_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplateElement")
            .field(
                "dollar_curly_token",
                &support::DebugSyntaxResult(self.dollar_curly_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsTemplateElement> for JsSyntaxNode {
    fn from(n: JsTemplateElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsTemplateElement> for JsSyntaxElement {
    fn from(n: JsTemplateElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsThisExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_THIS_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsThisExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsThisExpression")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .finish()
    }
}
impl From<JsThisExpression> for JsSyntaxNode {
    fn from(n: JsThisExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsThisExpression> for JsSyntaxElement {
    fn from(n: JsThisExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsThrowStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_THROW_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsThrowStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsThrowStatement")
            .field(
                "throw_token",
                &support::DebugSyntaxResult(self.throw_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsThrowStatement> for JsSyntaxNode {
    fn from(n: JsThrowStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsThrowStatement> for JsSyntaxElement {
    fn from(n: JsThrowStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsTryFinallyStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_TRY_FINALLY_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsTryFinallyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTryFinallyStatement")
            .field("try_token", &support::DebugSyntaxResult(self.try_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "catch_clause",
                &support::DebugOptionalElement(self.catch_clause()),
            )
            .field(
                "finally_clause",
                &support::DebugSyntaxResult(self.finally_clause()),
            )
            .finish()
    }
}
impl From<JsTryFinallyStatement> for JsSyntaxNode {
    fn from(n: JsTryFinallyStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsTryFinallyStatement> for JsSyntaxElement {
    fn from(n: JsTryFinallyStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsTryStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_TRY_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsTryStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTryStatement")
            .field("try_token", &support::DebugSyntaxResult(self.try_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "catch_clause",
                &support::DebugSyntaxResult(self.catch_clause()),
            )
            .finish()
    }
}
impl From<JsTryStatement> for JsSyntaxNode {
    fn from(n: JsTryStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsTryStatement> for JsSyntaxElement {
    fn from(n: JsTryStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsUnaryExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNARY_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnaryExpression")
            .field("operator", &support::DebugSyntaxResult(self.operator()))
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsUnaryExpression> for JsSyntaxNode {
    fn from(n: JsUnaryExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnaryExpression> for JsSyntaxElement {
    fn from(n: JsUnaryExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsVariableDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_VARIABLE_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclaration")
            .field("kind", &support::DebugSyntaxResult(self.kind()))
            .field("declarators", &self.declarators())
            .finish()
    }
}
impl From<JsVariableDeclaration> for JsSyntaxNode {
    fn from(n: JsVariableDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsVariableDeclaration> for JsSyntaxElement {
    fn from(n: JsVariableDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsVariableDeclarationClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_VARIABLE_DECLARATION_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsVariableDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclarationClause")
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsVariableDeclarationClause> for JsSyntaxNode {
    fn from(n: JsVariableDeclarationClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsVariableDeclarationClause> for JsSyntaxElement {
    fn from(n: JsVariableDeclarationClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsVariableDeclarator {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_VARIABLE_DECLARATOR
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsVariableDeclarator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclarator")
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "variable_annotation",
                &support::DebugOptionalElement(self.variable_annotation()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsVariableDeclarator> for JsSyntaxNode {
    fn from(n: JsVariableDeclarator) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsVariableDeclarator> for JsSyntaxElement {
    fn from(n: JsVariableDeclarator) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsVariableStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_VARIABLE_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsVariableStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableStatement")
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsVariableStatement> for JsSyntaxNode {
    fn from(n: JsVariableStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsVariableStatement> for JsSyntaxElement {
    fn from(n: JsVariableStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsWhileStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_WHILE_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsWhileStatement")
            .field(
                "while_token",
                &support::DebugSyntaxResult(self.while_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsWhileStatement> for JsSyntaxNode {
    fn from(n: JsWhileStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsWhileStatement> for JsSyntaxElement {
    fn from(n: JsWhileStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsWithStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_WITH_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsWithStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsWithStatement")
            .field("with_token", &support::DebugSyntaxResult(self.with_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsWithStatement> for JsSyntaxNode {
    fn from(n: JsWithStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsWithStatement> for JsSyntaxElement {
    fn from(n: JsWithStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsYieldArgument {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_YIELD_ARGUMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsYieldArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsYieldArgument")
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<JsYieldArgument> for JsSyntaxNode {
    fn from(n: JsYieldArgument) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsYieldArgument> for JsSyntaxElement {
    fn from(n: JsYieldArgument) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsYieldExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_YIELD_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsYieldExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsYieldExpression")
            .field(
                "yield_token",
                &support::DebugSyntaxResult(self.yield_token()),
            )
            .field("argument", &support::DebugOptionalElement(self.argument()))
            .finish()
    }
}
impl From<JsYieldExpression> for JsSyntaxNode {
    fn from(n: JsYieldExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsYieldExpression> for JsSyntaxElement {
    fn from(n: JsYieldExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxAttribute {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_ATTRIBUTE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxAttribute")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsxAttribute> for JsSyntaxNode {
    fn from(n: JsxAttribute) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxAttribute> for JsSyntaxElement {
    fn from(n: JsxAttribute) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxAttributeInitializerClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_ATTRIBUTE_INITIALIZER_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxAttributeInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxAttributeInitializerClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsxAttributeInitializerClause> for JsSyntaxNode {
    fn from(n: JsxAttributeInitializerClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxAttributeInitializerClause> for JsSyntaxElement {
    fn from(n: JsxAttributeInitializerClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxClosingElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_CLOSING_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxClosingElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxClosingElement> for JsSyntaxNode {
    fn from(n: JsxClosingElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxClosingElement> for JsSyntaxElement {
    fn from(n: JsxClosingElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxClosingFragment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_CLOSING_FRAGMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxClosingFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxClosingFragment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxClosingFragment> for JsSyntaxNode {
    fn from(n: JsxClosingFragment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxClosingFragment> for JsSyntaxElement {
    fn from(n: JsxClosingFragment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxElement")
            .field(
                "opening_element",
                &support::DebugSyntaxResult(self.opening_element()),
            )
            .field("children", &self.children())
            .field(
                "closing_element",
                &support::DebugSyntaxResult(self.closing_element()),
            )
            .finish()
    }
}
impl From<JsxElement> for JsSyntaxNode {
    fn from(n: JsxElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxElement> for JsSyntaxElement {
    fn from(n: JsxElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxExpressionAttributeValue {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_EXPRESSION_ATTRIBUTE_VALUE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxExpressionAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxExpressionAttributeValue")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxExpressionAttributeValue> for JsSyntaxNode {
    fn from(n: JsxExpressionAttributeValue) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxExpressionAttributeValue> for JsSyntaxElement {
    fn from(n: JsxExpressionAttributeValue) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxExpressionChild {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_EXPRESSION_CHILD
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxExpressionChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxExpressionChild")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "expression",
                &support::DebugOptionalElement(self.expression()),
            )
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxExpressionChild> for JsSyntaxNode {
    fn from(n: JsxExpressionChild) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxExpressionChild> for JsSyntaxElement {
    fn from(n: JsxExpressionChild) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxFragment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_FRAGMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxFragment")
            .field(
                "opening_fragment",
                &support::DebugSyntaxResult(self.opening_fragment()),
            )
            .field("children", &self.children())
            .field(
                "closing_fragment",
                &support::DebugSyntaxResult(self.closing_fragment()),
            )
            .finish()
    }
}
impl From<JsxFragment> for JsSyntaxNode {
    fn from(n: JsxFragment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxFragment> for JsSyntaxElement {
    fn from(n: JsxFragment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxMemberName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_MEMBER_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxMemberName")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsxMemberName> for JsSyntaxNode {
    fn from(n: JsxMemberName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxMemberName> for JsSyntaxElement {
    fn from(n: JsxMemberName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxName")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxName> for JsSyntaxNode {
    fn from(n: JsxName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxName> for JsSyntaxElement {
    fn from(n: JsxName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxNamespaceName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_NAMESPACE_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxNamespaceName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxNamespaceName")
            .field("namespace", &support::DebugSyntaxResult(self.namespace()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsxNamespaceName> for JsSyntaxNode {
    fn from(n: JsxNamespaceName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxNamespaceName> for JsSyntaxElement {
    fn from(n: JsxNamespaceName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxOpeningElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_OPENING_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxOpeningElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxOpeningElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("attributes", &self.attributes())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxOpeningElement> for JsSyntaxNode {
    fn from(n: JsxOpeningElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxOpeningElement> for JsSyntaxElement {
    fn from(n: JsxOpeningElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxOpeningFragment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_OPENING_FRAGMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxOpeningFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxOpeningFragment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxOpeningFragment> for JsSyntaxNode {
    fn from(n: JsxOpeningFragment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxOpeningFragment> for JsSyntaxElement {
    fn from(n: JsxOpeningFragment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxReferenceIdentifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_REFERENCE_IDENTIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxReferenceIdentifier")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxReferenceIdentifier> for JsSyntaxNode {
    fn from(n: JsxReferenceIdentifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxReferenceIdentifier> for JsSyntaxElement {
    fn from(n: JsxReferenceIdentifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxSelfClosingElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_SELF_CLOSING_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxSelfClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSelfClosingElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("attributes", &self.attributes())
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxSelfClosingElement> for JsSyntaxNode {
    fn from(n: JsxSelfClosingElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxSelfClosingElement> for JsSyntaxElement {
    fn from(n: JsxSelfClosingElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxSpreadAttribute {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_SPREAD_ATTRIBUTE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxSpreadAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSpreadAttribute")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxSpreadAttribute> for JsSyntaxNode {
    fn from(n: JsxSpreadAttribute) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxSpreadAttribute> for JsSyntaxElement {
    fn from(n: JsxSpreadAttribute) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxSpreadChild {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_SPREAD_CHILD
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxSpreadChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSpreadChild")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxSpreadChild> for JsSyntaxNode {
    fn from(n: JsxSpreadChild) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxSpreadChild> for JsSyntaxElement {
    fn from(n: JsxSpreadChild) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxString {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_STRING
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxString")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxString> for JsSyntaxNode {
    fn from(n: JsxString) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxString> for JsSyntaxElement {
    fn from(n: JsxString) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxTagExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_TAG_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxTagExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxTagExpression")
            .field("tag", &support::DebugSyntaxResult(self.tag()))
            .finish()
    }
}
impl From<JsxTagExpression> for JsSyntaxNode {
    fn from(n: JsxTagExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxTagExpression> for JsSyntaxElement {
    fn from(n: JsxTagExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for JsxText {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_TEXT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsxText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxText")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxText> for JsSyntaxNode {
    fn from(n: JsxText) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsxText> for JsSyntaxElement {
    fn from(n: JsxText) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for NewTarget {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == NEW_TARGET
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for NewTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NewTarget")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field(
                "target_token",
                &support::DebugSyntaxResult(self.target_token()),
            )
            .finish()
    }
}
impl From<NewTarget> for JsSyntaxNode {
    fn from(n: NewTarget) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<NewTarget> for JsSyntaxElement {
    fn from(n: NewTarget) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsAbstractModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ABSTRACT_MODIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsAbstractModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAbstractModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsAbstractModifier> for JsSyntaxNode {
    fn from(n: TsAbstractModifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsAbstractModifier> for JsSyntaxElement {
    fn from(n: TsAbstractModifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsAccessibilityModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ACCESSIBILITY_MODIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsAccessibilityModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAccessibilityModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsAccessibilityModifier> for JsSyntaxNode {
    fn from(n: TsAccessibilityModifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsAccessibilityModifier> for JsSyntaxElement {
    fn from(n: TsAccessibilityModifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsAnyType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ANY_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsAnyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAnyType")
            .field("any_token", &support::DebugSyntaxResult(self.any_token()))
            .finish()
    }
}
impl From<TsAnyType> for JsSyntaxNode {
    fn from(n: TsAnyType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsAnyType> for JsSyntaxElement {
    fn from(n: TsAnyType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsArrayType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ARRAY_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsArrayType")
            .field(
                "element_type",
                &support::DebugSyntaxResult(self.element_type()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsArrayType> for JsSyntaxNode {
    fn from(n: TsArrayType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsArrayType> for JsSyntaxElement {
    fn from(n: TsArrayType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsAsAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_AS_ASSIGNMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsAsAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAsAssignment")
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAsAssignment> for JsSyntaxNode {
    fn from(n: TsAsAssignment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsAsAssignment> for JsSyntaxElement {
    fn from(n: TsAsAssignment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsAsExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_AS_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsAsExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAsExpression")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAsExpression> for JsSyntaxNode {
    fn from(n: TsAsExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsAsExpression> for JsSyntaxElement {
    fn from(n: TsAsExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsAssertsCondition {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ASSERTS_CONDITION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsAssertsCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAssertsCondition")
            .field("is_token", &support::DebugSyntaxResult(self.is_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAssertsCondition> for JsSyntaxNode {
    fn from(n: TsAssertsCondition) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsAssertsCondition> for JsSyntaxElement {
    fn from(n: TsAssertsCondition) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsAssertsReturnType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ASSERTS_RETURN_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsAssertsReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAssertsReturnType")
            .field(
                "asserts_token",
                &support::DebugSyntaxResult(self.asserts_token()),
            )
            .field(
                "parameter_name",
                &support::DebugSyntaxResult(self.parameter_name()),
            )
            .field(
                "predicate",
                &support::DebugOptionalElement(self.predicate()),
            )
            .finish()
    }
}
impl From<TsAssertsReturnType> for JsSyntaxNode {
    fn from(n: TsAssertsReturnType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsAssertsReturnType> for JsSyntaxElement {
    fn from(n: TsAssertsReturnType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsBigIntLiteralType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_BIG_INT_LITERAL_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsBigIntLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBigIntLiteralType")
            .field(
                "minus_token",
                &support::DebugOptionalElement(self.minus_token()),
            )
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsBigIntLiteralType> for JsSyntaxNode {
    fn from(n: TsBigIntLiteralType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsBigIntLiteralType> for JsSyntaxElement {
    fn from(n: TsBigIntLiteralType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsBigintType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_BIGINT_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsBigintType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBigintType")
            .field(
                "bigint_token",
                &support::DebugSyntaxResult(self.bigint_token()),
            )
            .finish()
    }
}
impl From<TsBigintType> for JsSyntaxNode {
    fn from(n: TsBigintType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsBigintType> for JsSyntaxElement {
    fn from(n: TsBigintType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsBooleanLiteralType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_BOOLEAN_LITERAL_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsBooleanLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBooleanLiteralType")
            .field("literal", &support::DebugSyntaxResult(self.literal()))
            .finish()
    }
}
impl From<TsBooleanLiteralType> for JsSyntaxNode {
    fn from(n: TsBooleanLiteralType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsBooleanLiteralType> for JsSyntaxElement {
    fn from(n: TsBooleanLiteralType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsBooleanType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_BOOLEAN_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsBooleanType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBooleanType")
            .field(
                "boolean_token",
                &support::DebugSyntaxResult(self.boolean_token()),
            )
            .finish()
    }
}
impl From<TsBooleanType> for JsSyntaxNode {
    fn from(n: TsBooleanType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsBooleanType> for JsSyntaxElement {
    fn from(n: TsBooleanType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsCallSignatureTypeMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_CALL_SIGNATURE_TYPE_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsCallSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsCallSignatureTypeMember")
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsCallSignatureTypeMember> for JsSyntaxNode {
    fn from(n: TsCallSignatureTypeMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsCallSignatureTypeMember> for JsSyntaxElement {
    fn from(n: TsCallSignatureTypeMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsConditionalType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_CONDITIONAL_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsConditionalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConditionalType")
            .field("check_type", &support::DebugSyntaxResult(self.check_type()))
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field(
                "extends_type",
                &support::DebugSyntaxResult(self.extends_type()),
            )
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field("true_type", &support::DebugSyntaxResult(self.true_type()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("false_type", &support::DebugSyntaxResult(self.false_type()))
            .finish()
    }
}
impl From<TsConditionalType> for JsSyntaxNode {
    fn from(n: TsConditionalType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsConditionalType> for JsSyntaxElement {
    fn from(n: TsConditionalType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsConstructSignatureTypeMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsConstructSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructSignatureTypeMember")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsConstructSignatureTypeMember> for JsSyntaxNode {
    fn from(n: TsConstructSignatureTypeMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsConstructSignatureTypeMember> for JsSyntaxElement {
    fn from(n: TsConstructSignatureTypeMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsConstructorSignatureClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsConstructorSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructorSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsConstructorSignatureClassMember> for JsSyntaxNode {
    fn from(n: TsConstructorSignatureClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsConstructorSignatureClassMember> for JsSyntaxElement {
    fn from(n: TsConstructorSignatureClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsConstructorType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_CONSTRUCTOR_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsConstructorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructorType")
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field(
                "return_type",
                &support::DebugSyntaxResult(self.return_type()),
            )
            .finish()
    }
}
impl From<TsConstructorType> for JsSyntaxNode {
    fn from(n: TsConstructorType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsConstructorType> for JsSyntaxElement {
    fn from(n: TsConstructorType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsDeclareFunctionDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_DECLARE_FUNCTION_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsDeclareFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareFunctionDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsDeclareFunctionDeclaration> for JsSyntaxNode {
    fn from(n: TsDeclareFunctionDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsDeclareFunctionDeclaration> for JsSyntaxElement {
    fn from(n: TsDeclareFunctionDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsDeclareModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_DECLARE_MODIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsDeclareModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsDeclareModifier> for JsSyntaxNode {
    fn from(n: TsDeclareModifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsDeclareModifier> for JsSyntaxElement {
    fn from(n: TsDeclareModifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsDeclareStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_DECLARE_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsDeclareStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareStatement")
            .field(
                "declare_token",
                &support::DebugSyntaxResult(self.declare_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .finish()
    }
}
impl From<TsDeclareStatement> for JsSyntaxNode {
    fn from(n: TsDeclareStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsDeclareStatement> for JsSyntaxElement {
    fn from(n: TsDeclareStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsDefaultTypeClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_DEFAULT_TYPE_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsDefaultTypeClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefaultTypeClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsDefaultTypeClause> for JsSyntaxNode {
    fn from(n: TsDefaultTypeClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsDefaultTypeClause> for JsSyntaxElement {
    fn from(n: TsDefaultTypeClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsDefinitePropertyAnnotation {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_DEFINITE_PROPERTY_ANNOTATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsDefinitePropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefinitePropertyAnnotation")
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsDefinitePropertyAnnotation> for JsSyntaxNode {
    fn from(n: TsDefinitePropertyAnnotation) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsDefinitePropertyAnnotation> for JsSyntaxElement {
    fn from(n: TsDefinitePropertyAnnotation) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsDefiniteVariableAnnotation {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_DEFINITE_VARIABLE_ANNOTATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsDefiniteVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefiniteVariableAnnotation")
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsDefiniteVariableAnnotation> for JsSyntaxNode {
    fn from(n: TsDefiniteVariableAnnotation) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsDefiniteVariableAnnotation> for JsSyntaxElement {
    fn from(n: TsDefiniteVariableAnnotation) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsEmptyExternalModuleDeclarationBody {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsEmptyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEmptyExternalModuleDeclarationBody")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsEmptyExternalModuleDeclarationBody> for JsSyntaxNode {
    fn from(n: TsEmptyExternalModuleDeclarationBody) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsEmptyExternalModuleDeclarationBody> for JsSyntaxElement {
    fn from(n: TsEmptyExternalModuleDeclarationBody) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsEnumDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ENUM_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsEnumDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEnumDeclaration")
            .field(
                "const_token",
                &support::DebugOptionalElement(self.const_token()),
            )
            .field("enum_token", &support::DebugSyntaxResult(self.enum_token()))
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsEnumDeclaration> for JsSyntaxNode {
    fn from(n: TsEnumDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsEnumDeclaration> for JsSyntaxElement {
    fn from(n: TsEnumDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsEnumMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ENUM_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsEnumMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEnumMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<TsEnumMember> for JsSyntaxNode {
    fn from(n: TsEnumMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsEnumMember> for JsSyntaxElement {
    fn from(n: TsEnumMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsExportAsNamespaceClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_EXPORT_AS_NAMESPACE_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsExportAsNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportAsNamespaceClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "namespace_token",
                &support::DebugSyntaxResult(self.namespace_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsExportAsNamespaceClause> for JsSyntaxNode {
    fn from(n: TsExportAsNamespaceClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsExportAsNamespaceClause> for JsSyntaxElement {
    fn from(n: TsExportAsNamespaceClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsExportAssignmentClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_EXPORT_ASSIGNMENT_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsExportAssignmentClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportAssignmentClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsExportAssignmentClause> for JsSyntaxNode {
    fn from(n: TsExportAssignmentClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsExportAssignmentClause> for JsSyntaxElement {
    fn from(n: TsExportAssignmentClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsExportDeclareClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_EXPORT_DECLARE_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsExportDeclareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportDeclareClause")
            .field(
                "declare_token",
                &support::DebugSyntaxResult(self.declare_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .finish()
    }
}
impl From<TsExportDeclareClause> for JsSyntaxNode {
    fn from(n: TsExportDeclareClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsExportDeclareClause> for JsSyntaxElement {
    fn from(n: TsExportDeclareClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsExtendsClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_EXTENDS_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExtendsClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsExtendsClause> for JsSyntaxNode {
    fn from(n: TsExtendsClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsExtendsClause> for JsSyntaxElement {
    fn from(n: TsExtendsClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsExternalModuleDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_EXTERNAL_MODULE_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsExternalModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExternalModuleDeclaration")
            .field(
                "module_token",
                &support::DebugSyntaxResult(self.module_token()),
            )
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field("body", &support::DebugOptionalElement(self.body()))
            .finish()
    }
}
impl From<TsExternalModuleDeclaration> for JsSyntaxNode {
    fn from(n: TsExternalModuleDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsExternalModuleDeclaration> for JsSyntaxElement {
    fn from(n: TsExternalModuleDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsExternalModuleReference {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_EXTERNAL_MODULE_REFERENCE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsExternalModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExternalModuleReference")
            .field(
                "require_token",
                &support::DebugSyntaxResult(self.require_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<TsExternalModuleReference> for JsSyntaxNode {
    fn from(n: TsExternalModuleReference) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsExternalModuleReference> for JsSyntaxElement {
    fn from(n: TsExternalModuleReference) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsFunctionType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_FUNCTION_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsFunctionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsFunctionType")
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field(
                "return_type",
                &support::DebugSyntaxResult(self.return_type()),
            )
            .finish()
    }
}
impl From<TsFunctionType> for JsSyntaxNode {
    fn from(n: TsFunctionType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsFunctionType> for JsSyntaxElement {
    fn from(n: TsFunctionType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsGetterSignatureClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_GETTER_SIGNATURE_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsGetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGetterSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsGetterSignatureClassMember> for JsSyntaxNode {
    fn from(n: TsGetterSignatureClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsGetterSignatureClassMember> for JsSyntaxElement {
    fn from(n: TsGetterSignatureClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsGetterSignatureTypeMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_GETTER_SIGNATURE_TYPE_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsGetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGetterSignatureTypeMember")
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsGetterSignatureTypeMember> for JsSyntaxNode {
    fn from(n: TsGetterSignatureTypeMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsGetterSignatureTypeMember> for JsSyntaxElement {
    fn from(n: TsGetterSignatureTypeMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsGlobalDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_GLOBAL_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsGlobalDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGlobalDeclaration")
            .field(
                "global_token",
                &support::DebugSyntaxResult(self.global_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<TsGlobalDeclaration> for JsSyntaxNode {
    fn from(n: TsGlobalDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsGlobalDeclaration> for JsSyntaxElement {
    fn from(n: TsGlobalDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsIdentifierBinding {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_IDENTIFIER_BINDING
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIdentifierBinding")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<TsIdentifierBinding> for JsSyntaxNode {
    fn from(n: TsIdentifierBinding) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsIdentifierBinding> for JsSyntaxElement {
    fn from(n: TsIdentifierBinding) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsImplementsClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_IMPLEMENTS_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsImplementsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImplementsClause")
            .field(
                "implements_token",
                &support::DebugSyntaxResult(self.implements_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsImplementsClause> for JsSyntaxNode {
    fn from(n: TsImplementsClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsImplementsClause> for JsSyntaxElement {
    fn from(n: TsImplementsClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsImportEqualsDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_IMPORT_EQUALS_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsImportEqualsDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportEqualsDeclaration")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field(
                "module_reference",
                &support::DebugSyntaxResult(self.module_reference()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsImportEqualsDeclaration> for JsSyntaxNode {
    fn from(n: TsImportEqualsDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsImportEqualsDeclaration> for JsSyntaxElement {
    fn from(n: TsImportEqualsDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsImportType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_IMPORT_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsImportType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportType")
            .field(
                "typeof_token",
                &support::DebugOptionalElement(self.typeof_token()),
            )
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "argument_token",
                &support::DebugSyntaxResult(self.argument_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "qualifier_clause",
                &support::DebugOptionalElement(self.qualifier_clause()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsImportType> for JsSyntaxNode {
    fn from(n: TsImportType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsImportType> for JsSyntaxElement {
    fn from(n: TsImportType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsImportTypeQualifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_IMPORT_TYPE_QUALIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsImportTypeQualifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportTypeQualifier")
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsImportTypeQualifier> for JsSyntaxNode {
    fn from(n: TsImportTypeQualifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsImportTypeQualifier> for JsSyntaxElement {
    fn from(n: TsImportTypeQualifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsIndexSignatureClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INDEX_SIGNATURE_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsIndexSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureClassMember> for JsSyntaxNode {
    fn from(n: TsIndexSignatureClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsIndexSignatureClassMember> for JsSyntaxElement {
    fn from(n: TsIndexSignatureClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsIndexSignatureParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INDEX_SIGNATURE_PARAMETER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsIndexSignatureParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureParameter")
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureParameter> for JsSyntaxNode {
    fn from(n: TsIndexSignatureParameter) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsIndexSignatureParameter> for JsSyntaxElement {
    fn from(n: TsIndexSignatureParameter) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsIndexSignatureTypeMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INDEX_SIGNATURE_TYPE_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsIndexSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureTypeMember")
            .field(
                "readonly_token",
                &support::DebugOptionalElement(self.readonly_token()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureTypeMember> for JsSyntaxNode {
    fn from(n: TsIndexSignatureTypeMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsIndexSignatureTypeMember> for JsSyntaxElement {
    fn from(n: TsIndexSignatureTypeMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsIndexedAccessType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INDEXED_ACCESS_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsIndexedAccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexedAccessType")
            .field(
                "object_type",
                &support::DebugSyntaxResult(self.object_type()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("index_type", &support::DebugSyntaxResult(self.index_type()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsIndexedAccessType> for JsSyntaxNode {
    fn from(n: TsIndexedAccessType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsIndexedAccessType> for JsSyntaxElement {
    fn from(n: TsIndexedAccessType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsInferType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INFER_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsInferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInferType")
            .field(
                "infer_token",
                &support::DebugSyntaxResult(self.infer_token()),
            )
            .field(
                "type_parameter",
                &support::DebugSyntaxResult(self.type_parameter()),
            )
            .finish()
    }
}
impl From<TsInferType> for JsSyntaxNode {
    fn from(n: TsInferType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsInferType> for JsSyntaxElement {
    fn from(n: TsInferType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsInterfaceDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INTERFACE_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsInterfaceDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInterfaceDeclaration")
            .field(
                "interface_token",
                &support::DebugSyntaxResult(self.interface_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsInterfaceDeclaration> for JsSyntaxNode {
    fn from(n: TsInterfaceDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsInterfaceDeclaration> for JsSyntaxElement {
    fn from(n: TsInterfaceDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsIntersectionType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INTERSECTION_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsIntersectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIntersectionType")
            .field(
                "leading_separator_token",
                &support::DebugOptionalElement(self.leading_separator_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsIntersectionType> for JsSyntaxNode {
    fn from(n: TsIntersectionType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsIntersectionType> for JsSyntaxElement {
    fn from(n: TsIntersectionType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsMappedType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_MAPPED_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsMappedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedType")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "readonly_modifier",
                &support::DebugOptionalElement(self.readonly_modifier()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field(
                "property_name",
                &support::DebugSyntaxResult(self.property_name()),
            )
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("keys_type", &support::DebugSyntaxResult(self.keys_type()))
            .field(
                "as_clause",
                &support::DebugOptionalElement(self.as_clause()),
            )
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "optional_modifier",
                &support::DebugOptionalElement(self.optional_modifier()),
            )
            .field(
                "mapped_type",
                &support::DebugOptionalElement(self.mapped_type()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsMappedType> for JsSyntaxNode {
    fn from(n: TsMappedType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsMappedType> for JsSyntaxElement {
    fn from(n: TsMappedType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsMappedTypeAsClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_MAPPED_TYPE_AS_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsMappedTypeAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeAsClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsMappedTypeAsClause> for JsSyntaxNode {
    fn from(n: TsMappedTypeAsClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsMappedTypeAsClause> for JsSyntaxElement {
    fn from(n: TsMappedTypeAsClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsMappedTypeOptionalModifierClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_MAPPED_TYPE_OPTIONAL_MODIFIER_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsMappedTypeOptionalModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeOptionalModifierClause")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .finish()
    }
}
impl From<TsMappedTypeOptionalModifierClause> for JsSyntaxNode {
    fn from(n: TsMappedTypeOptionalModifierClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsMappedTypeOptionalModifierClause> for JsSyntaxElement {
    fn from(n: TsMappedTypeOptionalModifierClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsMappedTypeReadonlyModifierClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_MAPPED_TYPE_READONLY_MODIFIER_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsMappedTypeReadonlyModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeReadonlyModifierClause")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field(
                "readonly_token",
                &support::DebugSyntaxResult(self.readonly_token()),
            )
            .finish()
    }
}
impl From<TsMappedTypeReadonlyModifierClause> for JsSyntaxNode {
    fn from(n: TsMappedTypeReadonlyModifierClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsMappedTypeReadonlyModifierClause> for JsSyntaxElement {
    fn from(n: TsMappedTypeReadonlyModifierClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsMethodSignatureClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_METHOD_SIGNATURE_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsMethodSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMethodSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsMethodSignatureClassMember> for JsSyntaxNode {
    fn from(n: TsMethodSignatureClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsMethodSignatureClassMember> for JsSyntaxElement {
    fn from(n: TsMethodSignatureClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsMethodSignatureTypeMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_METHOD_SIGNATURE_TYPE_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsMethodSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMethodSignatureTypeMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "optional_token",
                &support::DebugOptionalElement(self.optional_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsMethodSignatureTypeMember> for JsSyntaxNode {
    fn from(n: TsMethodSignatureTypeMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsMethodSignatureTypeMember> for JsSyntaxElement {
    fn from(n: TsMethodSignatureTypeMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsModuleBlock {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_MODULE_BLOCK
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsModuleBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsModuleBlock")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("items", &self.items())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsModuleBlock> for JsSyntaxNode {
    fn from(n: TsModuleBlock) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsModuleBlock> for JsSyntaxElement {
    fn from(n: TsModuleBlock) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsModuleDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_MODULE_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsModuleDeclaration")
            .field(
                "module_or_namespace",
                &support::DebugSyntaxResult(self.module_or_namespace()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<TsModuleDeclaration> for JsSyntaxNode {
    fn from(n: TsModuleDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsModuleDeclaration> for JsSyntaxElement {
    fn from(n: TsModuleDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNameWithTypeArguments {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NAME_WITH_TYPE_ARGUMENTS
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNameWithTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNameWithTypeArguments")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsNameWithTypeArguments> for JsSyntaxNode {
    fn from(n: TsNameWithTypeArguments) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNameWithTypeArguments> for JsSyntaxElement {
    fn from(n: TsNameWithTypeArguments) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNamedTupleTypeElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NAMED_TUPLE_TYPE_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNamedTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNamedTupleTypeElement")
            .field(
                "dotdotdot_token",
                &support::DebugOptionalElement(self.dotdotdot_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsNamedTupleTypeElement> for JsSyntaxNode {
    fn from(n: TsNamedTupleTypeElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNamedTupleTypeElement> for JsSyntaxElement {
    fn from(n: TsNamedTupleTypeElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNeverType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NEVER_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNeverType")
            .field(
                "never_token",
                &support::DebugSyntaxResult(self.never_token()),
            )
            .finish()
    }
}
impl From<TsNeverType> for JsSyntaxNode {
    fn from(n: TsNeverType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNeverType> for JsSyntaxElement {
    fn from(n: TsNeverType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNonNullAssertionAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NON_NULL_ASSERTION_ASSIGNMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNonNullAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonNullAssertionAssignment")
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .finish()
    }
}
impl From<TsNonNullAssertionAssignment> for JsSyntaxNode {
    fn from(n: TsNonNullAssertionAssignment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNonNullAssertionAssignment> for JsSyntaxElement {
    fn from(n: TsNonNullAssertionAssignment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNonNullAssertionExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NON_NULL_ASSERTION_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNonNullAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonNullAssertionExpression")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .finish()
    }
}
impl From<TsNonNullAssertionExpression> for JsSyntaxNode {
    fn from(n: TsNonNullAssertionExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNonNullAssertionExpression> for JsSyntaxElement {
    fn from(n: TsNonNullAssertionExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNonPrimitiveType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NON_PRIMITIVE_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNonPrimitiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonPrimitiveType")
            .field(
                "object_token",
                &support::DebugSyntaxResult(self.object_token()),
            )
            .finish()
    }
}
impl From<TsNonPrimitiveType> for JsSyntaxNode {
    fn from(n: TsNonPrimitiveType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNonPrimitiveType> for JsSyntaxElement {
    fn from(n: TsNonPrimitiveType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNullLiteralType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NULL_LITERAL_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNullLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNullLiteralType")
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsNullLiteralType> for JsSyntaxNode {
    fn from(n: TsNullLiteralType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNullLiteralType> for JsSyntaxElement {
    fn from(n: TsNullLiteralType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNumberLiteralType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NUMBER_LITERAL_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNumberLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNumberLiteralType")
            .field(
                "minus_token",
                &support::DebugOptionalElement(self.minus_token()),
            )
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsNumberLiteralType> for JsSyntaxNode {
    fn from(n: TsNumberLiteralType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNumberLiteralType> for JsSyntaxElement {
    fn from(n: TsNumberLiteralType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsNumberType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_NUMBER_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsNumberType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNumberType")
            .field(
                "number_token",
                &support::DebugSyntaxResult(self.number_token()),
            )
            .finish()
    }
}
impl From<TsNumberType> for JsSyntaxNode {
    fn from(n: TsNumberType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsNumberType> for JsSyntaxElement {
    fn from(n: TsNumberType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsObjectType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_OBJECT_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsObjectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsObjectType")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsObjectType> for JsSyntaxNode {
    fn from(n: TsObjectType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsObjectType> for JsSyntaxElement {
    fn from(n: TsObjectType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsOptionalPropertyAnnotation {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_OPTIONAL_PROPERTY_ANNOTATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsOptionalPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOptionalPropertyAnnotation")
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsOptionalPropertyAnnotation> for JsSyntaxNode {
    fn from(n: TsOptionalPropertyAnnotation) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsOptionalPropertyAnnotation> for JsSyntaxElement {
    fn from(n: TsOptionalPropertyAnnotation) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsOptionalTupleTypeElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_OPTIONAL_TUPLE_TYPE_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsOptionalTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOptionalTupleTypeElement")
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .finish()
    }
}
impl From<TsOptionalTupleTypeElement> for JsSyntaxNode {
    fn from(n: TsOptionalTupleTypeElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsOptionalTupleTypeElement> for JsSyntaxElement {
    fn from(n: TsOptionalTupleTypeElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsOverrideModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_OVERRIDE_MODIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsOverrideModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOverrideModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsOverrideModifier> for JsSyntaxNode {
    fn from(n: TsOverrideModifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsOverrideModifier> for JsSyntaxElement {
    fn from(n: TsOverrideModifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsParenthesizedType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_PARENTHESIZED_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsParenthesizedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsParenthesizedType")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<TsParenthesizedType> for JsSyntaxNode {
    fn from(n: TsParenthesizedType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsParenthesizedType> for JsSyntaxElement {
    fn from(n: TsParenthesizedType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsPredicateReturnType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_PREDICATE_RETURN_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsPredicateReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPredicateReturnType")
            .field(
                "parameter_name",
                &support::DebugSyntaxResult(self.parameter_name()),
            )
            .field("is_token", &support::DebugSyntaxResult(self.is_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsPredicateReturnType> for JsSyntaxNode {
    fn from(n: TsPredicateReturnType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsPredicateReturnType> for JsSyntaxElement {
    fn from(n: TsPredicateReturnType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsPropertyParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_PROPERTY_PARAMETER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsPropertyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertyParameter")
            .field("modifiers", &self.modifiers())
            .field(
                "formal_parameter",
                &support::DebugSyntaxResult(self.formal_parameter()),
            )
            .finish()
    }
}
impl From<TsPropertyParameter> for JsSyntaxNode {
    fn from(n: TsPropertyParameter) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsPropertyParameter> for JsSyntaxElement {
    fn from(n: TsPropertyParameter) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsPropertySignatureClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_PROPERTY_SIGNATURE_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsPropertySignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertySignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "property_annotation",
                &support::DebugOptionalElement(self.property_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsPropertySignatureClassMember> for JsSyntaxNode {
    fn from(n: TsPropertySignatureClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsPropertySignatureClassMember> for JsSyntaxElement {
    fn from(n: TsPropertySignatureClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsPropertySignatureTypeMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_PROPERTY_SIGNATURE_TYPE_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsPropertySignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertySignatureTypeMember")
            .field(
                "readonly_token",
                &support::DebugOptionalElement(self.readonly_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "optional_token",
                &support::DebugOptionalElement(self.optional_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsPropertySignatureTypeMember> for JsSyntaxNode {
    fn from(n: TsPropertySignatureTypeMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsPropertySignatureTypeMember> for JsSyntaxElement {
    fn from(n: TsPropertySignatureTypeMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsQualifiedModuleName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_QUALIFIED_MODULE_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsQualifiedModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsQualifiedModuleName")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsQualifiedModuleName> for JsSyntaxNode {
    fn from(n: TsQualifiedModuleName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsQualifiedModuleName> for JsSyntaxElement {
    fn from(n: TsQualifiedModuleName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsQualifiedName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_QUALIFIED_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsQualifiedName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsQualifiedName")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsQualifiedName> for JsSyntaxNode {
    fn from(n: TsQualifiedName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsQualifiedName> for JsSyntaxElement {
    fn from(n: TsQualifiedName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsReadonlyModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_READONLY_MODIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsReadonlyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReadonlyModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsReadonlyModifier> for JsSyntaxNode {
    fn from(n: TsReadonlyModifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsReadonlyModifier> for JsSyntaxElement {
    fn from(n: TsReadonlyModifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsReferenceType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_REFERENCE_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsReferenceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReferenceType")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsReferenceType> for JsSyntaxNode {
    fn from(n: TsReferenceType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsReferenceType> for JsSyntaxElement {
    fn from(n: TsReferenceType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsRestTupleTypeElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_REST_TUPLE_TYPE_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsRestTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsRestTupleTypeElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsRestTupleTypeElement> for JsSyntaxNode {
    fn from(n: TsRestTupleTypeElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsRestTupleTypeElement> for JsSyntaxElement {
    fn from(n: TsRestTupleTypeElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsReturnTypeAnnotation {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_RETURN_TYPE_ANNOTATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsReturnTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReturnTypeAnnotation")
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsReturnTypeAnnotation> for JsSyntaxNode {
    fn from(n: TsReturnTypeAnnotation) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsReturnTypeAnnotation> for JsSyntaxElement {
    fn from(n: TsReturnTypeAnnotation) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsSetterSignatureClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_SETTER_SIGNATURE_CLASS_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsSetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSetterSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsSetterSignatureClassMember> for JsSyntaxNode {
    fn from(n: TsSetterSignatureClassMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsSetterSignatureClassMember> for JsSyntaxElement {
    fn from(n: TsSetterSignatureClassMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsSetterSignatureTypeMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_SETTER_SIGNATURE_TYPE_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsSetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSetterSignatureTypeMember")
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsSetterSignatureTypeMember> for JsSyntaxNode {
    fn from(n: TsSetterSignatureTypeMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsSetterSignatureTypeMember> for JsSyntaxElement {
    fn from(n: TsSetterSignatureTypeMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsStringLiteralType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_STRING_LITERAL_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsStringLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsStringLiteralType")
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsStringLiteralType> for JsSyntaxNode {
    fn from(n: TsStringLiteralType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsStringLiteralType> for JsSyntaxElement {
    fn from(n: TsStringLiteralType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsStringType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_STRING_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsStringType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsStringType")
            .field(
                "string_token",
                &support::DebugSyntaxResult(self.string_token()),
            )
            .finish()
    }
}
impl From<TsStringType> for JsSyntaxNode {
    fn from(n: TsStringType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsStringType> for JsSyntaxElement {
    fn from(n: TsStringType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsSymbolType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_SYMBOL_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsSymbolType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSymbolType")
            .field(
                "symbol_token",
                &support::DebugSyntaxResult(self.symbol_token()),
            )
            .finish()
    }
}
impl From<TsSymbolType> for JsSyntaxNode {
    fn from(n: TsSymbolType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsSymbolType> for JsSyntaxElement {
    fn from(n: TsSymbolType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTemplateChunkElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TEMPLATE_CHUNK_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateChunkElement")
            .field(
                "template_chunk_token",
                &support::DebugSyntaxResult(self.template_chunk_token()),
            )
            .finish()
    }
}
impl From<TsTemplateChunkElement> for JsSyntaxNode {
    fn from(n: TsTemplateChunkElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTemplateChunkElement> for JsSyntaxElement {
    fn from(n: TsTemplateChunkElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTemplateElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TEMPLATE_ELEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateElement")
            .field(
                "dollar_curly_token",
                &support::DebugSyntaxResult(self.dollar_curly_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsTemplateElement> for JsSyntaxNode {
    fn from(n: TsTemplateElement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTemplateElement> for JsSyntaxElement {
    fn from(n: TsTemplateElement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTemplateLiteralType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TEMPLATE_LITERAL_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTemplateLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateLiteralType")
            .field(
                "l_tick_token",
                &support::DebugSyntaxResult(self.l_tick_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_tick_token",
                &support::DebugSyntaxResult(self.r_tick_token()),
            )
            .finish()
    }
}
impl From<TsTemplateLiteralType> for JsSyntaxNode {
    fn from(n: TsTemplateLiteralType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTemplateLiteralType> for JsSyntaxElement {
    fn from(n: TsTemplateLiteralType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsThisParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_THIS_PARAMETER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsThisParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsThisParameter")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsThisParameter> for JsSyntaxNode {
    fn from(n: TsThisParameter) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsThisParameter> for JsSyntaxElement {
    fn from(n: TsThisParameter) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsThisType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_THIS_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsThisType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsThisType")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .finish()
    }
}
impl From<TsThisType> for JsSyntaxNode {
    fn from(n: TsThisType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsThisType> for JsSyntaxElement {
    fn from(n: TsThisType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTupleType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TUPLE_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTupleType")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsTupleType> for JsSyntaxNode {
    fn from(n: TsTupleType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTupleType> for JsSyntaxElement {
    fn from(n: TsTupleType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeAliasDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_ALIAS_DECLARATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeAliasDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAliasDeclaration")
            .field("type_token", &support::DebugSyntaxResult(self.type_token()))
            .field(
                "binding_identifier",
                &support::DebugSyntaxResult(self.binding_identifier()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsTypeAliasDeclaration> for JsSyntaxNode {
    fn from(n: TsTypeAliasDeclaration) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeAliasDeclaration> for JsSyntaxElement {
    fn from(n: TsTypeAliasDeclaration) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeAnnotation {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_ANNOTATION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAnnotation")
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeAnnotation> for JsSyntaxNode {
    fn from(n: TsTypeAnnotation) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeAnnotation> for JsSyntaxElement {
    fn from(n: TsTypeAnnotation) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeArguments {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_ARGUMENTS
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeArguments")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ts_type_argument_list", &self.ts_type_argument_list())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<TsTypeArguments> for JsSyntaxNode {
    fn from(n: TsTypeArguments) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeArguments> for JsSyntaxElement {
    fn from(n: TsTypeArguments) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeAssertionAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_ASSERTION_ASSIGNMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAssertionAssignment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .finish()
    }
}
impl From<TsTypeAssertionAssignment> for JsSyntaxNode {
    fn from(n: TsTypeAssertionAssignment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeAssertionAssignment> for JsSyntaxElement {
    fn from(n: TsTypeAssertionAssignment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeAssertionExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_ASSERTION_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAssertionExpression")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<TsTypeAssertionExpression> for JsSyntaxNode {
    fn from(n: TsTypeAssertionExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeAssertionExpression> for JsSyntaxElement {
    fn from(n: TsTypeAssertionExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeConstraintClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_CONSTRAINT_CLAUSE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeConstraintClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeConstraintClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeConstraintClause> for JsSyntaxNode {
    fn from(n: TsTypeConstraintClause) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeConstraintClause> for JsSyntaxElement {
    fn from(n: TsTypeConstraintClause) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeOperatorType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_OPERATOR_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeOperatorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeOperatorType")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeOperatorType> for JsSyntaxNode {
    fn from(n: TsTypeOperatorType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeOperatorType> for JsSyntaxElement {
    fn from(n: TsTypeOperatorType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_PARAMETER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameter")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "constraint",
                &support::DebugOptionalElement(self.constraint()),
            )
            .field("default", &support::DebugOptionalElement(self.default()))
            .finish()
    }
}
impl From<TsTypeParameter> for JsSyntaxNode {
    fn from(n: TsTypeParameter) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeParameter> for JsSyntaxElement {
    fn from(n: TsTypeParameter) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeParameterName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_PARAMETER_NAME
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameterName")
            .field(
                "ident_token",
                &support::DebugSyntaxResult(self.ident_token()),
            )
            .finish()
    }
}
impl From<TsTypeParameterName> for JsSyntaxNode {
    fn from(n: TsTypeParameterName) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeParameterName> for JsSyntaxElement {
    fn from(n: TsTypeParameterName) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeParameters {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_PARAMETERS
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameters")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("items", &self.items())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<TsTypeParameters> for JsSyntaxNode {
    fn from(n: TsTypeParameters) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeParameters> for JsSyntaxElement {
    fn from(n: TsTypeParameters) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsTypeofType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPEOF_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsTypeofType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeofType")
            .field(
                "typeof_token",
                &support::DebugSyntaxResult(self.typeof_token()),
            )
            .field(
                "expression_name",
                &support::DebugSyntaxResult(self.expression_name()),
            )
            .finish()
    }
}
impl From<TsTypeofType> for JsSyntaxNode {
    fn from(n: TsTypeofType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsTypeofType> for JsSyntaxElement {
    fn from(n: TsTypeofType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsUndefinedType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_UNDEFINED_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsUndefinedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUndefinedType")
            .field(
                "undefined_token",
                &support::DebugSyntaxResult(self.undefined_token()),
            )
            .finish()
    }
}
impl From<TsUndefinedType> for JsSyntaxNode {
    fn from(n: TsUndefinedType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsUndefinedType> for JsSyntaxElement {
    fn from(n: TsUndefinedType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsUnionType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_UNION_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsUnionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUnionType")
            .field(
                "leading_separator_token",
                &support::DebugOptionalElement(self.leading_separator_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsUnionType> for JsSyntaxNode {
    fn from(n: TsUnionType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsUnionType> for JsSyntaxElement {
    fn from(n: TsUnionType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsUnknownType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_UNKNOWN_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsUnknownType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUnknownType")
            .field(
                "unknown_token",
                &support::DebugSyntaxResult(self.unknown_token()),
            )
            .finish()
    }
}
impl From<TsUnknownType> for JsSyntaxNode {
    fn from(n: TsUnknownType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsUnknownType> for JsSyntaxElement {
    fn from(n: TsUnknownType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl AstNode<JsLanguage> for TsVoidType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_VOID_TYPE
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for TsVoidType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsVoidType")
            .field("void_token", &support::DebugSyntaxResult(self.void_token()))
            .finish()
    }
}
impl From<TsVoidType> for JsSyntaxNode {
    fn from(n: TsVoidType) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<TsVoidType> for JsSyntaxElement {
    fn from(n: TsVoidType) -> JsSyntaxElement {
        n.syntax.into()
    }
}
impl From<JsArrayAssignmentPatternRestElement> for JsAnyArrayAssignmentPatternElement {
    fn from(node: JsArrayAssignmentPatternRestElement) -> JsAnyArrayAssignmentPatternElement {
        JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(node)
    }
}
impl From<JsArrayHole> for JsAnyArrayAssignmentPatternElement {
    fn from(node: JsArrayHole) -> JsAnyArrayAssignmentPatternElement {
        JsAnyArrayAssignmentPatternElement::JsArrayHole(node)
    }
}
impl From<JsAssignmentWithDefault> for JsAnyArrayAssignmentPatternElement {
    fn from(node: JsAssignmentWithDefault) -> JsAnyArrayAssignmentPatternElement {
        JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(node)
    }
}
impl From<JsUnknownAssignment> for JsAnyArrayAssignmentPatternElement {
    fn from(node: JsUnknownAssignment) -> JsAnyArrayAssignmentPatternElement {
        JsAnyArrayAssignmentPatternElement::JsUnknownAssignment(node)
    }
}
impl AstNode<JsLanguage> for JsAnyArrayAssignmentPatternElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT
            | JS_ARRAY_HOLE
            | JS_ASSIGNMENT_WITH_DEFAULT
            | JS_UNKNOWN_ASSIGNMENT => true,
            k if JsAnyAssignmentPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT => {
                JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(
                    JsArrayAssignmentPatternRestElement { syntax },
                )
            }
            JS_ARRAY_HOLE => {
                JsAnyArrayAssignmentPatternElement::JsArrayHole(JsArrayHole { syntax })
            }
            JS_ASSIGNMENT_WITH_DEFAULT => {
                JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(
                    JsAssignmentWithDefault { syntax },
                )
            }
            JS_UNKNOWN_ASSIGNMENT => {
                JsAnyArrayAssignmentPatternElement::JsUnknownAssignment(JsUnknownAssignment {
                    syntax,
                })
            }
            _ => {
                if let Some(js_any_assignment_pattern) = JsAnyAssignmentPattern::cast(syntax) {
                    return Some(JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(
                        js_any_assignment_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                &it.syntax
            }
            JsAnyArrayAssignmentPatternElement::JsArrayHole(it) => &it.syntax,
            JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => &it.syntax,
            JsAnyArrayAssignmentPatternElement::JsUnknownAssignment(it) => &it.syntax,
            JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyArrayAssignmentPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyArrayAssignmentPatternElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyArrayAssignmentPatternElement::JsUnknownAssignment(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyArrayAssignmentPatternElement> for JsSyntaxNode {
    fn from(n: JsAnyArrayAssignmentPatternElement) -> JsSyntaxNode {
        match n {
            JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(it) => it.into(),
            JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                it.into()
            }
            JsAnyArrayAssignmentPatternElement::JsArrayHole(it) => it.into(),
            JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => it.into(),
            JsAnyArrayAssignmentPatternElement::JsUnknownAssignment(it) => it.into(),
        }
    }
}
impl From<JsAnyArrayAssignmentPatternElement> for JsSyntaxElement {
    fn from(n: JsAnyArrayAssignmentPatternElement) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayBindingPatternRestElement> for JsAnyArrayBindingPatternElement {
    fn from(node: JsArrayBindingPatternRestElement) -> JsAnyArrayBindingPatternElement {
        JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(node)
    }
}
impl From<JsArrayHole> for JsAnyArrayBindingPatternElement {
    fn from(node: JsArrayHole) -> JsAnyArrayBindingPatternElement {
        JsAnyArrayBindingPatternElement::JsArrayHole(node)
    }
}
impl From<JsBindingPatternWithDefault> for JsAnyArrayBindingPatternElement {
    fn from(node: JsBindingPatternWithDefault) -> JsAnyArrayBindingPatternElement {
        JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(node)
    }
}
impl AstNode<JsLanguage> for JsAnyArrayBindingPatternElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_ARRAY_BINDING_PATTERN_REST_ELEMENT
            | JS_ARRAY_HOLE
            | JS_BINDING_PATTERN_WITH_DEFAULT => true,
            k if JsAnyBindingPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_BINDING_PATTERN_REST_ELEMENT => {
                JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(
                    JsArrayBindingPatternRestElement { syntax },
                )
            }
            JS_ARRAY_HOLE => JsAnyArrayBindingPatternElement::JsArrayHole(JsArrayHole { syntax }),
            JS_BINDING_PATTERN_WITH_DEFAULT => {
                JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(
                    JsBindingPatternWithDefault { syntax },
                )
            }
            _ => {
                if let Some(js_any_binding_pattern) = JsAnyBindingPattern::cast(syntax) {
                    return Some(JsAnyArrayBindingPatternElement::JsAnyBindingPattern(
                        js_any_binding_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => &it.syntax,
            JsAnyArrayBindingPatternElement::JsArrayHole(it) => &it.syntax,
            JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(it) => &it.syntax,
            JsAnyArrayBindingPatternElement::JsAnyBindingPattern(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyArrayBindingPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyArrayBindingPatternElement::JsAnyBindingPattern(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyArrayBindingPatternElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyArrayBindingPatternElement> for JsSyntaxNode {
    fn from(n: JsAnyArrayBindingPatternElement) -> JsSyntaxNode {
        match n {
            JsAnyArrayBindingPatternElement::JsAnyBindingPattern(it) => it.into(),
            JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => it.into(),
            JsAnyArrayBindingPatternElement::JsArrayHole(it) => it.into(),
            JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(it) => it.into(),
        }
    }
}
impl From<JsAnyArrayBindingPatternElement> for JsSyntaxElement {
    fn from(n: JsAnyArrayBindingPatternElement) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayHole> for JsAnyArrayElement {
    fn from(node: JsArrayHole) -> JsAnyArrayElement {
        JsAnyArrayElement::JsArrayHole(node)
    }
}
impl From<JsSpread> for JsAnyArrayElement {
    fn from(node: JsSpread) -> JsAnyArrayElement {
        JsAnyArrayElement::JsSpread(node)
    }
}
impl AstNode<JsLanguage> for JsAnyArrayElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_ARRAY_HOLE | JS_SPREAD => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_HOLE => JsAnyArrayElement::JsArrayHole(JsArrayHole { syntax }),
            JS_SPREAD => JsAnyArrayElement::JsSpread(JsSpread { syntax }),
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyArrayElement::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyArrayElement::JsArrayHole(it) => &it.syntax,
            JsAnyArrayElement::JsSpread(it) => &it.syntax,
            JsAnyArrayElement::JsAnyExpression(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyArrayElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyArrayElement::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayElement::JsSpread(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyArrayElement> for JsSyntaxNode {
    fn from(n: JsAnyArrayElement) -> JsSyntaxNode {
        match n {
            JsAnyArrayElement::JsAnyExpression(it) => it.into(),
            JsAnyArrayElement::JsArrayHole(it) => it.into(),
            JsAnyArrayElement::JsSpread(it) => it.into(),
        }
    }
}
impl From<JsAnyArrayElement> for JsSyntaxElement {
    fn from(n: JsAnyArrayElement) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsParameters> for JsAnyArrowFunctionParameters {
    fn from(node: JsParameters) -> JsAnyArrowFunctionParameters {
        JsAnyArrowFunctionParameters::JsParameters(node)
    }
}
impl AstNode<JsLanguage> for JsAnyArrowFunctionParameters {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_PARAMETERS => true,
            k if JsAnyBinding::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_PARAMETERS => JsAnyArrowFunctionParameters::JsParameters(JsParameters { syntax }),
            _ => {
                if let Some(js_any_binding) = JsAnyBinding::cast(syntax) {
                    return Some(JsAnyArrowFunctionParameters::JsAnyBinding(js_any_binding));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyArrowFunctionParameters::JsParameters(it) => &it.syntax,
            JsAnyArrowFunctionParameters::JsAnyBinding(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyArrowFunctionParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyArrowFunctionParameters::JsAnyBinding(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrowFunctionParameters::JsParameters(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyArrowFunctionParameters> for JsSyntaxNode {
    fn from(n: JsAnyArrowFunctionParameters) -> JsSyntaxNode {
        match n {
            JsAnyArrowFunctionParameters::JsAnyBinding(it) => it.into(),
            JsAnyArrowFunctionParameters::JsParameters(it) => it.into(),
        }
    }
}
impl From<JsAnyArrowFunctionParameters> for JsSyntaxElement {
    fn from(n: JsAnyArrowFunctionParameters) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsComputedMemberAssignment> for JsAnyAssignment {
    fn from(node: JsComputedMemberAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsComputedMemberAssignment(node)
    }
}
impl From<JsIdentifierAssignment> for JsAnyAssignment {
    fn from(node: JsIdentifierAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsIdentifierAssignment(node)
    }
}
impl From<JsParenthesizedAssignment> for JsAnyAssignment {
    fn from(node: JsParenthesizedAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsParenthesizedAssignment(node)
    }
}
impl From<JsStaticMemberAssignment> for JsAnyAssignment {
    fn from(node: JsStaticMemberAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsStaticMemberAssignment(node)
    }
}
impl From<JsUnknownAssignment> for JsAnyAssignment {
    fn from(node: JsUnknownAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsUnknownAssignment(node)
    }
}
impl From<TsAsAssignment> for JsAnyAssignment {
    fn from(node: TsAsAssignment) -> JsAnyAssignment {
        JsAnyAssignment::TsAsAssignment(node)
    }
}
impl From<TsNonNullAssertionAssignment> for JsAnyAssignment {
    fn from(node: TsNonNullAssertionAssignment) -> JsAnyAssignment {
        JsAnyAssignment::TsNonNullAssertionAssignment(node)
    }
}
impl From<TsTypeAssertionAssignment> for JsAnyAssignment {
    fn from(node: TsTypeAssertionAssignment) -> JsAnyAssignment {
        JsAnyAssignment::TsTypeAssertionAssignment(node)
    }
}
impl AstNode<JsLanguage> for JsAnyAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_COMPUTED_MEMBER_ASSIGNMENT
                | JS_IDENTIFIER_ASSIGNMENT
                | JS_PARENTHESIZED_ASSIGNMENT
                | JS_STATIC_MEMBER_ASSIGNMENT
                | JS_UNKNOWN_ASSIGNMENT
                | TS_AS_ASSIGNMENT
                | TS_NON_NULL_ASSERTION_ASSIGNMENT
                | TS_TYPE_ASSERTION_ASSIGNMENT
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_COMPUTED_MEMBER_ASSIGNMENT => {
                JsAnyAssignment::JsComputedMemberAssignment(JsComputedMemberAssignment { syntax })
            }
            JS_IDENTIFIER_ASSIGNMENT => {
                JsAnyAssignment::JsIdentifierAssignment(JsIdentifierAssignment { syntax })
            }
            JS_PARENTHESIZED_ASSIGNMENT => {
                JsAnyAssignment::JsParenthesizedAssignment(JsParenthesizedAssignment { syntax })
            }
            JS_STATIC_MEMBER_ASSIGNMENT => {
                JsAnyAssignment::JsStaticMemberAssignment(JsStaticMemberAssignment { syntax })
            }
            JS_UNKNOWN_ASSIGNMENT => {
                JsAnyAssignment::JsUnknownAssignment(JsUnknownAssignment { syntax })
            }
            TS_AS_ASSIGNMENT => JsAnyAssignment::TsAsAssignment(TsAsAssignment { syntax }),
            TS_NON_NULL_ASSERTION_ASSIGNMENT => {
                JsAnyAssignment::TsNonNullAssertionAssignment(TsNonNullAssertionAssignment {
                    syntax,
                })
            }
            TS_TYPE_ASSERTION_ASSIGNMENT => {
                JsAnyAssignment::TsTypeAssertionAssignment(TsTypeAssertionAssignment { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyAssignment::JsComputedMemberAssignment(it) => &it.syntax,
            JsAnyAssignment::JsIdentifierAssignment(it) => &it.syntax,
            JsAnyAssignment::JsParenthesizedAssignment(it) => &it.syntax,
            JsAnyAssignment::JsStaticMemberAssignment(it) => &it.syntax,
            JsAnyAssignment::JsUnknownAssignment(it) => &it.syntax,
            JsAnyAssignment::TsAsAssignment(it) => &it.syntax,
            JsAnyAssignment::TsNonNullAssertionAssignment(it) => &it.syntax,
            JsAnyAssignment::TsTypeAssertionAssignment(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyAssignment::JsComputedMemberAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::JsIdentifierAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::JsParenthesizedAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::JsStaticMemberAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::JsUnknownAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::TsAsAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::TsNonNullAssertionAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::TsTypeAssertionAssignment(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyAssignment> for JsSyntaxNode {
    fn from(n: JsAnyAssignment) -> JsSyntaxNode {
        match n {
            JsAnyAssignment::JsComputedMemberAssignment(it) => it.into(),
            JsAnyAssignment::JsIdentifierAssignment(it) => it.into(),
            JsAnyAssignment::JsParenthesizedAssignment(it) => it.into(),
            JsAnyAssignment::JsStaticMemberAssignment(it) => it.into(),
            JsAnyAssignment::JsUnknownAssignment(it) => it.into(),
            JsAnyAssignment::TsAsAssignment(it) => it.into(),
            JsAnyAssignment::TsNonNullAssertionAssignment(it) => it.into(),
            JsAnyAssignment::TsTypeAssertionAssignment(it) => it.into(),
        }
    }
}
impl From<JsAnyAssignment> for JsSyntaxElement {
    fn from(n: JsAnyAssignment) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayAssignmentPattern> for JsAnyAssignmentPattern {
    fn from(node: JsArrayAssignmentPattern) -> JsAnyAssignmentPattern {
        JsAnyAssignmentPattern::JsArrayAssignmentPattern(node)
    }
}
impl From<JsObjectAssignmentPattern> for JsAnyAssignmentPattern {
    fn from(node: JsObjectAssignmentPattern) -> JsAnyAssignmentPattern {
        JsAnyAssignmentPattern::JsObjectAssignmentPattern(node)
    }
}
impl AstNode<JsLanguage> for JsAnyAssignmentPattern {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_ARRAY_ASSIGNMENT_PATTERN | JS_OBJECT_ASSIGNMENT_PATTERN => true,
            k if JsAnyAssignment::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_ASSIGNMENT_PATTERN => {
                JsAnyAssignmentPattern::JsArrayAssignmentPattern(JsArrayAssignmentPattern {
                    syntax,
                })
            }
            JS_OBJECT_ASSIGNMENT_PATTERN => {
                JsAnyAssignmentPattern::JsObjectAssignmentPattern(JsObjectAssignmentPattern {
                    syntax,
                })
            }
            _ => {
                if let Some(js_any_assignment) = JsAnyAssignment::cast(syntax) {
                    return Some(JsAnyAssignmentPattern::JsAnyAssignment(js_any_assignment));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyAssignmentPattern::JsArrayAssignmentPattern(it) => &it.syntax,
            JsAnyAssignmentPattern::JsObjectAssignmentPattern(it) => &it.syntax,
            JsAnyAssignmentPattern::JsAnyAssignment(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyAssignmentPattern::JsAnyAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignmentPattern::JsArrayAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignmentPattern::JsObjectAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyAssignmentPattern> for JsSyntaxNode {
    fn from(n: JsAnyAssignmentPattern) -> JsSyntaxNode {
        match n {
            JsAnyAssignmentPattern::JsAnyAssignment(it) => it.into(),
            JsAnyAssignmentPattern::JsArrayAssignmentPattern(it) => it.into(),
            JsAnyAssignmentPattern::JsObjectAssignmentPattern(it) => it.into(),
        }
    }
}
impl From<JsAnyAssignmentPattern> for JsSyntaxElement {
    fn from(n: JsAnyAssignmentPattern) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsIdentifierBinding> for JsAnyBinding {
    fn from(node: JsIdentifierBinding) -> JsAnyBinding {
        JsAnyBinding::JsIdentifierBinding(node)
    }
}
impl From<JsUnknownBinding> for JsAnyBinding {
    fn from(node: JsUnknownBinding) -> JsAnyBinding {
        JsAnyBinding::JsUnknownBinding(node)
    }
}
impl AstNode<JsLanguage> for JsAnyBinding {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_IDENTIFIER_BINDING | JS_UNKNOWN_BINDING)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IDENTIFIER_BINDING => {
                JsAnyBinding::JsIdentifierBinding(JsIdentifierBinding { syntax })
            }
            JS_UNKNOWN_BINDING => JsAnyBinding::JsUnknownBinding(JsUnknownBinding { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyBinding::JsIdentifierBinding(it) => &it.syntax,
            JsAnyBinding::JsUnknownBinding(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyBinding::JsIdentifierBinding(it) => std::fmt::Debug::fmt(it, f),
            JsAnyBinding::JsUnknownBinding(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyBinding> for JsSyntaxNode {
    fn from(n: JsAnyBinding) -> JsSyntaxNode {
        match n {
            JsAnyBinding::JsIdentifierBinding(it) => it.into(),
            JsAnyBinding::JsUnknownBinding(it) => it.into(),
        }
    }
}
impl From<JsAnyBinding> for JsSyntaxElement {
    fn from(n: JsAnyBinding) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayBindingPattern> for JsAnyBindingPattern {
    fn from(node: JsArrayBindingPattern) -> JsAnyBindingPattern {
        JsAnyBindingPattern::JsArrayBindingPattern(node)
    }
}
impl From<JsObjectBindingPattern> for JsAnyBindingPattern {
    fn from(node: JsObjectBindingPattern) -> JsAnyBindingPattern {
        JsAnyBindingPattern::JsObjectBindingPattern(node)
    }
}
impl AstNode<JsLanguage> for JsAnyBindingPattern {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_ARRAY_BINDING_PATTERN | JS_OBJECT_BINDING_PATTERN => true,
            k if JsAnyBinding::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_BINDING_PATTERN => {
                JsAnyBindingPattern::JsArrayBindingPattern(JsArrayBindingPattern { syntax })
            }
            JS_OBJECT_BINDING_PATTERN => {
                JsAnyBindingPattern::JsObjectBindingPattern(JsObjectBindingPattern { syntax })
            }
            _ => {
                if let Some(js_any_binding) = JsAnyBinding::cast(syntax) {
                    return Some(JsAnyBindingPattern::JsAnyBinding(js_any_binding));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyBindingPattern::JsArrayBindingPattern(it) => &it.syntax,
            JsAnyBindingPattern::JsObjectBindingPattern(it) => &it.syntax,
            JsAnyBindingPattern::JsAnyBinding(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyBindingPattern::JsAnyBinding(it) => std::fmt::Debug::fmt(it, f),
            JsAnyBindingPattern::JsArrayBindingPattern(it) => std::fmt::Debug::fmt(it, f),
            JsAnyBindingPattern::JsObjectBindingPattern(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyBindingPattern> for JsSyntaxNode {
    fn from(n: JsAnyBindingPattern) -> JsSyntaxNode {
        match n {
            JsAnyBindingPattern::JsAnyBinding(it) => it.into(),
            JsAnyBindingPattern::JsArrayBindingPattern(it) => it.into(),
            JsAnyBindingPattern::JsObjectBindingPattern(it) => it.into(),
        }
    }
}
impl From<JsAnyBindingPattern> for JsSyntaxElement {
    fn from(n: JsAnyBindingPattern) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsSpread> for JsAnyCallArgument {
    fn from(node: JsSpread) -> JsAnyCallArgument {
        JsAnyCallArgument::JsSpread(node)
    }
}
impl AstNode<JsLanguage> for JsAnyCallArgument {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_SPREAD => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_SPREAD => JsAnyCallArgument::JsSpread(JsSpread { syntax }),
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyCallArgument::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyCallArgument::JsSpread(it) => &it.syntax,
            JsAnyCallArgument::JsAnyExpression(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyCallArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyCallArgument::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyCallArgument::JsSpread(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyCallArgument> for JsSyntaxNode {
    fn from(n: JsAnyCallArgument) -> JsSyntaxNode {
        match n {
            JsAnyCallArgument::JsAnyExpression(it) => it.into(),
            JsAnyCallArgument::JsSpread(it) => it.into(),
        }
    }
}
impl From<JsAnyCallArgument> for JsSyntaxElement {
    fn from(n: JsAnyCallArgument) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for JsAnyClass {
    fn from(node: JsClassDeclaration) -> JsAnyClass {
        JsAnyClass::JsClassDeclaration(node)
    }
}
impl From<JsClassExportDefaultDeclaration> for JsAnyClass {
    fn from(node: JsClassExportDefaultDeclaration) -> JsAnyClass {
        JsAnyClass::JsClassExportDefaultDeclaration(node)
    }
}
impl From<JsClassExpression> for JsAnyClass {
    fn from(node: JsClassExpression) -> JsAnyClass {
        JsAnyClass::JsClassExpression(node)
    }
}
impl AstNode<JsLanguage> for JsAnyClass {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION | JS_CLASS_EXPORT_DEFAULT_DECLARATION | JS_CLASS_EXPRESSION
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => JsAnyClass::JsClassDeclaration(JsClassDeclaration { syntax }),
            JS_CLASS_EXPORT_DEFAULT_DECLARATION => {
                JsAnyClass::JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration {
                    syntax,
                })
            }
            JS_CLASS_EXPRESSION => JsAnyClass::JsClassExpression(JsClassExpression { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyClass::JsClassDeclaration(it) => &it.syntax,
            JsAnyClass::JsClassExportDefaultDeclaration(it) => &it.syntax,
            JsAnyClass::JsClassExpression(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyClass::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClass::JsClassExportDefaultDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClass::JsClassExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyClass> for JsSyntaxNode {
    fn from(n: JsAnyClass) -> JsSyntaxNode {
        match n {
            JsAnyClass::JsClassDeclaration(it) => it.into(),
            JsAnyClass::JsClassExportDefaultDeclaration(it) => it.into(),
            JsAnyClass::JsClassExpression(it) => it.into(),
        }
    }
}
impl From<JsAnyClass> for JsSyntaxElement {
    fn from(n: JsAnyClass) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsConstructorClassMember> for JsAnyClassMember {
    fn from(node: JsConstructorClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsConstructorClassMember(node)
    }
}
impl From<JsEmptyClassMember> for JsAnyClassMember {
    fn from(node: JsEmptyClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsEmptyClassMember(node)
    }
}
impl From<JsGetterClassMember> for JsAnyClassMember {
    fn from(node: JsGetterClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsGetterClassMember(node)
    }
}
impl From<JsMethodClassMember> for JsAnyClassMember {
    fn from(node: JsMethodClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsMethodClassMember(node)
    }
}
impl From<JsPropertyClassMember> for JsAnyClassMember {
    fn from(node: JsPropertyClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsPropertyClassMember(node)
    }
}
impl From<JsSetterClassMember> for JsAnyClassMember {
    fn from(node: JsSetterClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsSetterClassMember(node)
    }
}
impl From<JsStaticInitializationBlockClassMember> for JsAnyClassMember {
    fn from(node: JsStaticInitializationBlockClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsStaticInitializationBlockClassMember(node)
    }
}
impl From<JsUnknownMember> for JsAnyClassMember {
    fn from(node: JsUnknownMember) -> JsAnyClassMember {
        JsAnyClassMember::JsUnknownMember(node)
    }
}
impl From<TsConstructorSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsConstructorSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsConstructorSignatureClassMember(node)
    }
}
impl From<TsGetterSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsGetterSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsGetterSignatureClassMember(node)
    }
}
impl From<TsIndexSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsIndexSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsIndexSignatureClassMember(node)
    }
}
impl From<TsMethodSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsMethodSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsMethodSignatureClassMember(node)
    }
}
impl From<TsPropertySignatureClassMember> for JsAnyClassMember {
    fn from(node: TsPropertySignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsPropertySignatureClassMember(node)
    }
}
impl From<TsSetterSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsSetterSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsSetterSignatureClassMember(node)
    }
}
impl AstNode<JsLanguage> for JsAnyClassMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_CONSTRUCTOR_CLASS_MEMBER
                | JS_EMPTY_CLASS_MEMBER
                | JS_GETTER_CLASS_MEMBER
                | JS_METHOD_CLASS_MEMBER
                | JS_PROPERTY_CLASS_MEMBER
                | JS_SETTER_CLASS_MEMBER
                | JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER
                | JS_UNKNOWN_MEMBER
                | TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER
                | TS_GETTER_SIGNATURE_CLASS_MEMBER
                | TS_INDEX_SIGNATURE_CLASS_MEMBER
                | TS_METHOD_SIGNATURE_CLASS_MEMBER
                | TS_PROPERTY_SIGNATURE_CLASS_MEMBER
                | TS_SETTER_SIGNATURE_CLASS_MEMBER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CONSTRUCTOR_CLASS_MEMBER => {
                JsAnyClassMember::JsConstructorClassMember(JsConstructorClassMember { syntax })
            }
            JS_EMPTY_CLASS_MEMBER => {
                JsAnyClassMember::JsEmptyClassMember(JsEmptyClassMember { syntax })
            }
            JS_GETTER_CLASS_MEMBER => {
                JsAnyClassMember::JsGetterClassMember(JsGetterClassMember { syntax })
            }
            JS_METHOD_CLASS_MEMBER => {
                JsAnyClassMember::JsMethodClassMember(JsMethodClassMember { syntax })
            }
            JS_PROPERTY_CLASS_MEMBER => {
                JsAnyClassMember::JsPropertyClassMember(JsPropertyClassMember { syntax })
            }
            JS_SETTER_CLASS_MEMBER => {
                JsAnyClassMember::JsSetterClassMember(JsSetterClassMember { syntax })
            }
            JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER => {
                JsAnyClassMember::JsStaticInitializationBlockClassMember(
                    JsStaticInitializationBlockClassMember { syntax },
                )
            }
            JS_UNKNOWN_MEMBER => JsAnyClassMember::JsUnknownMember(JsUnknownMember { syntax }),
            TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsConstructorSignatureClassMember(
                    TsConstructorSignatureClassMember { syntax },
                )
            }
            TS_GETTER_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsGetterSignatureClassMember(TsGetterSignatureClassMember {
                    syntax,
                })
            }
            TS_INDEX_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsIndexSignatureClassMember(TsIndexSignatureClassMember {
                    syntax,
                })
            }
            TS_METHOD_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsMethodSignatureClassMember(TsMethodSignatureClassMember {
                    syntax,
                })
            }
            TS_PROPERTY_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsPropertySignatureClassMember(TsPropertySignatureClassMember {
                    syntax,
                })
            }
            TS_SETTER_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsSetterSignatureClassMember(TsSetterSignatureClassMember {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyClassMember::JsConstructorClassMember(it) => &it.syntax,
            JsAnyClassMember::JsEmptyClassMember(it) => &it.syntax,
            JsAnyClassMember::JsGetterClassMember(it) => &it.syntax,
            JsAnyClassMember::JsMethodClassMember(it) => &it.syntax,
            JsAnyClassMember::JsPropertyClassMember(it) => &it.syntax,
            JsAnyClassMember::JsSetterClassMember(it) => &it.syntax,
            JsAnyClassMember::JsStaticInitializationBlockClassMember(it) => &it.syntax,
            JsAnyClassMember::JsUnknownMember(it) => &it.syntax,
            JsAnyClassMember::TsConstructorSignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsGetterSignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsIndexSignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsMethodSignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsPropertySignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsSetterSignatureClassMember(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyClassMember::JsConstructorClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsEmptyClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsGetterClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsMethodClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsPropertyClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsSetterClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsStaticInitializationBlockClassMember(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyClassMember::JsUnknownMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsConstructorSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsGetterSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsIndexSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsMethodSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsPropertySignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsSetterSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyClassMember> for JsSyntaxNode {
    fn from(n: JsAnyClassMember) -> JsSyntaxNode {
        match n {
            JsAnyClassMember::JsConstructorClassMember(it) => it.into(),
            JsAnyClassMember::JsEmptyClassMember(it) => it.into(),
            JsAnyClassMember::JsGetterClassMember(it) => it.into(),
            JsAnyClassMember::JsMethodClassMember(it) => it.into(),
            JsAnyClassMember::JsPropertyClassMember(it) => it.into(),
            JsAnyClassMember::JsSetterClassMember(it) => it.into(),
            JsAnyClassMember::JsStaticInitializationBlockClassMember(it) => it.into(),
            JsAnyClassMember::JsUnknownMember(it) => it.into(),
            JsAnyClassMember::TsConstructorSignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsGetterSignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsIndexSignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsMethodSignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsPropertySignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsSetterSignatureClassMember(it) => it.into(),
        }
    }
}
impl From<JsAnyClassMember> for JsSyntaxElement {
    fn from(n: JsAnyClassMember) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsComputedMemberName> for JsAnyClassMemberName {
    fn from(node: JsComputedMemberName) -> JsAnyClassMemberName {
        JsAnyClassMemberName::JsComputedMemberName(node)
    }
}
impl From<JsLiteralMemberName> for JsAnyClassMemberName {
    fn from(node: JsLiteralMemberName) -> JsAnyClassMemberName {
        JsAnyClassMemberName::JsLiteralMemberName(node)
    }
}
impl From<JsPrivateClassMemberName> for JsAnyClassMemberName {
    fn from(node: JsPrivateClassMemberName) -> JsAnyClassMemberName {
        JsAnyClassMemberName::JsPrivateClassMemberName(node)
    }
}
impl AstNode<JsLanguage> for JsAnyClassMemberName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_COMPUTED_MEMBER_NAME | JS_LITERAL_MEMBER_NAME | JS_PRIVATE_CLASS_MEMBER_NAME
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_COMPUTED_MEMBER_NAME => {
                JsAnyClassMemberName::JsComputedMemberName(JsComputedMemberName { syntax })
            }
            JS_LITERAL_MEMBER_NAME => {
                JsAnyClassMemberName::JsLiteralMemberName(JsLiteralMemberName { syntax })
            }
            JS_PRIVATE_CLASS_MEMBER_NAME => {
                JsAnyClassMemberName::JsPrivateClassMemberName(JsPrivateClassMemberName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyClassMemberName::JsComputedMemberName(it) => &it.syntax,
            JsAnyClassMemberName::JsLiteralMemberName(it) => &it.syntax,
            JsAnyClassMemberName::JsPrivateClassMemberName(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyClassMemberName::JsComputedMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMemberName::JsLiteralMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMemberName::JsPrivateClassMemberName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyClassMemberName> for JsSyntaxNode {
    fn from(n: JsAnyClassMemberName) -> JsSyntaxNode {
        match n {
            JsAnyClassMemberName::JsComputedMemberName(it) => it.into(),
            JsAnyClassMemberName::JsLiteralMemberName(it) => it.into(),
            JsAnyClassMemberName::JsPrivateClassMemberName(it) => it.into(),
        }
    }
}
impl From<JsAnyClassMemberName> for JsSyntaxElement {
    fn from(n: JsAnyClassMemberName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsRestParameter> for JsAnyConstructorParameter {
    fn from(node: JsRestParameter) -> JsAnyConstructorParameter {
        JsAnyConstructorParameter::JsRestParameter(node)
    }
}
impl From<TsPropertyParameter> for JsAnyConstructorParameter {
    fn from(node: TsPropertyParameter) -> JsAnyConstructorParameter {
        JsAnyConstructorParameter::TsPropertyParameter(node)
    }
}
impl AstNode<JsLanguage> for JsAnyConstructorParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_REST_PARAMETER | TS_PROPERTY_PARAMETER => true,
            k if JsAnyFormalParameter::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REST_PARAMETER => {
                JsAnyConstructorParameter::JsRestParameter(JsRestParameter { syntax })
            }
            TS_PROPERTY_PARAMETER => {
                JsAnyConstructorParameter::TsPropertyParameter(TsPropertyParameter { syntax })
            }
            _ => {
                if let Some(js_any_formal_parameter) = JsAnyFormalParameter::cast(syntax) {
                    return Some(JsAnyConstructorParameter::JsAnyFormalParameter(
                        js_any_formal_parameter,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyConstructorParameter::JsRestParameter(it) => &it.syntax,
            JsAnyConstructorParameter::TsPropertyParameter(it) => &it.syntax,
            JsAnyConstructorParameter::JsAnyFormalParameter(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyConstructorParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyConstructorParameter::JsAnyFormalParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyConstructorParameter::JsRestParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyConstructorParameter::TsPropertyParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyConstructorParameter> for JsSyntaxNode {
    fn from(n: JsAnyConstructorParameter) -> JsSyntaxNode {
        match n {
            JsAnyConstructorParameter::JsAnyFormalParameter(it) => it.into(),
            JsAnyConstructorParameter::JsRestParameter(it) => it.into(),
            JsAnyConstructorParameter::TsPropertyParameter(it) => it.into(),
        }
    }
}
impl From<JsAnyConstructorParameter> for JsSyntaxElement {
    fn from(n: JsAnyConstructorParameter) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for JsAnyDeclaration {
    fn from(node: JsClassDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::JsClassDeclaration(node)
    }
}
impl From<JsFunctionDeclaration> for JsAnyDeclaration {
    fn from(node: JsFunctionDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::JsFunctionDeclaration(node)
    }
}
impl From<JsVariableDeclaration> for JsAnyDeclaration {
    fn from(node: JsVariableDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::JsVariableDeclaration(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for JsAnyDeclaration {
    fn from(node: TsDeclareFunctionDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsEnumDeclaration> for JsAnyDeclaration {
    fn from(node: TsEnumDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsEnumDeclaration(node)
    }
}
impl From<TsExternalModuleDeclaration> for JsAnyDeclaration {
    fn from(node: TsExternalModuleDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for JsAnyDeclaration {
    fn from(node: TsGlobalDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for JsAnyDeclaration {
    fn from(node: TsImportEqualsDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for JsAnyDeclaration {
    fn from(node: TsInterfaceDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for JsAnyDeclaration {
    fn from(node: TsModuleDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for JsAnyDeclaration {
    fn from(node: TsTypeAliasDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsTypeAliasDeclaration(node)
    }
}
impl AstNode<JsLanguage> for JsAnyDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION
                | JS_FUNCTION_DECLARATION
                | JS_VARIABLE_DECLARATION
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => {
                JsAnyDeclaration::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                JsAnyDeclaration::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_VARIABLE_DECLARATION => {
                JsAnyDeclaration::JsVariableDeclaration(JsVariableDeclaration { syntax })
            }
            TS_DECLARE_FUNCTION_DECLARATION => {
                JsAnyDeclaration::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_ENUM_DECLARATION => {
                JsAnyDeclaration::TsEnumDeclaration(TsEnumDeclaration { syntax })
            }
            TS_EXTERNAL_MODULE_DECLARATION => {
                JsAnyDeclaration::TsExternalModuleDeclaration(TsExternalModuleDeclaration {
                    syntax,
                })
            }
            TS_GLOBAL_DECLARATION => {
                JsAnyDeclaration::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                JsAnyDeclaration::TsImportEqualsDeclaration(TsImportEqualsDeclaration { syntax })
            }
            TS_INTERFACE_DECLARATION => {
                JsAnyDeclaration::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                JsAnyDeclaration::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                JsAnyDeclaration::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyDeclaration::JsClassDeclaration(it) => &it.syntax,
            JsAnyDeclaration::JsFunctionDeclaration(it) => &it.syntax,
            JsAnyDeclaration::JsVariableDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsDeclareFunctionDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsEnumDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsExternalModuleDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsGlobalDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsImportEqualsDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsInterfaceDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsModuleDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyDeclaration::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::JsVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyDeclaration> for JsSyntaxNode {
    fn from(n: JsAnyDeclaration) -> JsSyntaxNode {
        match n {
            JsAnyDeclaration::JsClassDeclaration(it) => it.into(),
            JsAnyDeclaration::JsFunctionDeclaration(it) => it.into(),
            JsAnyDeclaration::JsVariableDeclaration(it) => it.into(),
            JsAnyDeclaration::TsDeclareFunctionDeclaration(it) => it.into(),
            JsAnyDeclaration::TsEnumDeclaration(it) => it.into(),
            JsAnyDeclaration::TsExternalModuleDeclaration(it) => it.into(),
            JsAnyDeclaration::TsGlobalDeclaration(it) => it.into(),
            JsAnyDeclaration::TsImportEqualsDeclaration(it) => it.into(),
            JsAnyDeclaration::TsInterfaceDeclaration(it) => it.into(),
            JsAnyDeclaration::TsModuleDeclaration(it) => it.into(),
            JsAnyDeclaration::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyDeclaration> for JsSyntaxElement {
    fn from(n: JsAnyDeclaration) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for JsAnyDeclarationClause {
    fn from(node: JsClassDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::JsClassDeclaration(node)
    }
}
impl From<JsFunctionDeclaration> for JsAnyDeclarationClause {
    fn from(node: JsFunctionDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::JsFunctionDeclaration(node)
    }
}
impl From<JsVariableDeclarationClause> for JsAnyDeclarationClause {
    fn from(node: JsVariableDeclarationClause) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::JsVariableDeclarationClause(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsDeclareFunctionDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsEnumDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsEnumDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsEnumDeclaration(node)
    }
}
impl From<TsExternalModuleDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsExternalModuleDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsGlobalDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsImportEqualsDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsInterfaceDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsModuleDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsTypeAliasDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsTypeAliasDeclaration(node)
    }
}
impl AstNode<JsLanguage> for JsAnyDeclarationClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION
                | JS_FUNCTION_DECLARATION
                | JS_VARIABLE_DECLARATION_CLAUSE
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => {
                JsAnyDeclarationClause::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                JsAnyDeclarationClause::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_VARIABLE_DECLARATION_CLAUSE => {
                JsAnyDeclarationClause::JsVariableDeclarationClause(JsVariableDeclarationClause {
                    syntax,
                })
            }
            TS_DECLARE_FUNCTION_DECLARATION => {
                JsAnyDeclarationClause::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_ENUM_DECLARATION => {
                JsAnyDeclarationClause::TsEnumDeclaration(TsEnumDeclaration { syntax })
            }
            TS_EXTERNAL_MODULE_DECLARATION => {
                JsAnyDeclarationClause::TsExternalModuleDeclaration(TsExternalModuleDeclaration {
                    syntax,
                })
            }
            TS_GLOBAL_DECLARATION => {
                JsAnyDeclarationClause::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                JsAnyDeclarationClause::TsImportEqualsDeclaration(TsImportEqualsDeclaration {
                    syntax,
                })
            }
            TS_INTERFACE_DECLARATION => {
                JsAnyDeclarationClause::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                JsAnyDeclarationClause::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                JsAnyDeclarationClause::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyDeclarationClause::JsClassDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::JsFunctionDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::JsVariableDeclarationClause(it) => &it.syntax,
            JsAnyDeclarationClause::TsDeclareFunctionDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsEnumDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsExternalModuleDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsGlobalDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsImportEqualsDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsInterfaceDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsModuleDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyDeclarationClause::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::JsVariableDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyDeclarationClause> for JsSyntaxNode {
    fn from(n: JsAnyDeclarationClause) -> JsSyntaxNode {
        match n {
            JsAnyDeclarationClause::JsClassDeclaration(it) => it.into(),
            JsAnyDeclarationClause::JsFunctionDeclaration(it) => it.into(),
            JsAnyDeclarationClause::JsVariableDeclarationClause(it) => it.into(),
            JsAnyDeclarationClause::TsDeclareFunctionDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsEnumDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsExternalModuleDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsGlobalDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsImportEqualsDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsInterfaceDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsModuleDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyDeclarationClause> for JsSyntaxElement {
    fn from(n: JsAnyDeclarationClause) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExportDefaultDeclarationClause> for JsAnyExportClause {
    fn from(node: JsExportDefaultDeclarationClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportDefaultDeclarationClause(node)
    }
}
impl From<JsExportDefaultExpressionClause> for JsAnyExportClause {
    fn from(node: JsExportDefaultExpressionClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportDefaultExpressionClause(node)
    }
}
impl From<JsExportFromClause> for JsAnyExportClause {
    fn from(node: JsExportFromClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportFromClause(node)
    }
}
impl From<JsExportNamedClause> for JsAnyExportClause {
    fn from(node: JsExportNamedClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportNamedClause(node)
    }
}
impl From<JsExportNamedFromClause> for JsAnyExportClause {
    fn from(node: JsExportNamedFromClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportNamedFromClause(node)
    }
}
impl From<TsExportAsNamespaceClause> for JsAnyExportClause {
    fn from(node: TsExportAsNamespaceClause) -> JsAnyExportClause {
        JsAnyExportClause::TsExportAsNamespaceClause(node)
    }
}
impl From<TsExportAssignmentClause> for JsAnyExportClause {
    fn from(node: TsExportAssignmentClause) -> JsAnyExportClause {
        JsAnyExportClause::TsExportAssignmentClause(node)
    }
}
impl From<TsExportDeclareClause> for JsAnyExportClause {
    fn from(node: TsExportDeclareClause) -> JsAnyExportClause {
        JsAnyExportClause::TsExportDeclareClause(node)
    }
}
impl AstNode<JsLanguage> for JsAnyExportClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_EXPORT_DEFAULT_DECLARATION_CLAUSE
            | JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE
            | JS_EXPORT_FROM_CLAUSE
            | JS_EXPORT_NAMED_CLAUSE
            | JS_EXPORT_NAMED_FROM_CLAUSE
            | TS_EXPORT_AS_NAMESPACE_CLAUSE
            | TS_EXPORT_ASSIGNMENT_CLAUSE
            | TS_EXPORT_DECLARE_CLAUSE => true,
            k if JsAnyDeclarationClause::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT_DEFAULT_DECLARATION_CLAUSE => {
                JsAnyExportClause::JsExportDefaultDeclarationClause(
                    JsExportDefaultDeclarationClause { syntax },
                )
            }
            JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE => {
                JsAnyExportClause::JsExportDefaultExpressionClause(
                    JsExportDefaultExpressionClause { syntax },
                )
            }
            JS_EXPORT_FROM_CLAUSE => {
                JsAnyExportClause::JsExportFromClause(JsExportFromClause { syntax })
            }
            JS_EXPORT_NAMED_CLAUSE => {
                JsAnyExportClause::JsExportNamedClause(JsExportNamedClause { syntax })
            }
            JS_EXPORT_NAMED_FROM_CLAUSE => {
                JsAnyExportClause::JsExportNamedFromClause(JsExportNamedFromClause { syntax })
            }
            TS_EXPORT_AS_NAMESPACE_CLAUSE => {
                JsAnyExportClause::TsExportAsNamespaceClause(TsExportAsNamespaceClause { syntax })
            }
            TS_EXPORT_ASSIGNMENT_CLAUSE => {
                JsAnyExportClause::TsExportAssignmentClause(TsExportAssignmentClause { syntax })
            }
            TS_EXPORT_DECLARE_CLAUSE => {
                JsAnyExportClause::TsExportDeclareClause(TsExportDeclareClause { syntax })
            }
            _ => {
                if let Some(js_any_declaration_clause) = JsAnyDeclarationClause::cast(syntax) {
                    return Some(JsAnyExportClause::JsAnyDeclarationClause(
                        js_any_declaration_clause,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyExportClause::JsExportDefaultDeclarationClause(it) => &it.syntax,
            JsAnyExportClause::JsExportDefaultExpressionClause(it) => &it.syntax,
            JsAnyExportClause::JsExportFromClause(it) => &it.syntax,
            JsAnyExportClause::JsExportNamedClause(it) => &it.syntax,
            JsAnyExportClause::JsExportNamedFromClause(it) => &it.syntax,
            JsAnyExportClause::TsExportAsNamespaceClause(it) => &it.syntax,
            JsAnyExportClause::TsExportAssignmentClause(it) => &it.syntax,
            JsAnyExportClause::TsExportDeclareClause(it) => &it.syntax,
            JsAnyExportClause::JsAnyDeclarationClause(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyExportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyExportClause::JsAnyDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportDefaultDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportDefaultExpressionClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportFromClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportNamedClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportNamedFromClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::TsExportAsNamespaceClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::TsExportAssignmentClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::TsExportDeclareClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyExportClause> for JsSyntaxNode {
    fn from(n: JsAnyExportClause) -> JsSyntaxNode {
        match n {
            JsAnyExportClause::JsAnyDeclarationClause(it) => it.into(),
            JsAnyExportClause::JsExportDefaultDeclarationClause(it) => it.into(),
            JsAnyExportClause::JsExportDefaultExpressionClause(it) => it.into(),
            JsAnyExportClause::JsExportFromClause(it) => it.into(),
            JsAnyExportClause::JsExportNamedClause(it) => it.into(),
            JsAnyExportClause::JsExportNamedFromClause(it) => it.into(),
            JsAnyExportClause::TsExportAsNamespaceClause(it) => it.into(),
            JsAnyExportClause::TsExportAssignmentClause(it) => it.into(),
            JsAnyExportClause::TsExportDeclareClause(it) => it.into(),
        }
    }
}
impl From<JsAnyExportClause> for JsSyntaxElement {
    fn from(n: JsAnyExportClause) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassExportDefaultDeclaration> for JsAnyExportDefaultDeclaration {
    fn from(node: JsClassExportDefaultDeclaration) -> JsAnyExportDefaultDeclaration {
        JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(node)
    }
}
impl From<JsFunctionExportDefaultDeclaration> for JsAnyExportDefaultDeclaration {
    fn from(node: JsFunctionExportDefaultDeclaration) -> JsAnyExportDefaultDeclaration {
        JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for JsAnyExportDefaultDeclaration {
    fn from(node: TsDeclareFunctionDeclaration) -> JsAnyExportDefaultDeclaration {
        JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for JsAnyExportDefaultDeclaration {
    fn from(node: TsInterfaceDeclaration) -> JsAnyExportDefaultDeclaration {
        JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(node)
    }
}
impl AstNode<JsLanguage> for JsAnyExportDefaultDeclaration {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_EXPORT_DEFAULT_DECLARATION
                | JS_FUNCTION_EXPORT_DEFAULT_DECLARATION
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_INTERFACE_DECLARATION
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_EXPORT_DEFAULT_DECLARATION => {
                JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(
                    JsClassExportDefaultDeclaration { syntax },
                )
            }
            JS_FUNCTION_EXPORT_DEFAULT_DECLARATION => {
                JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(
                    JsFunctionExportDefaultDeclaration { syntax },
                )
            }
            TS_DECLARE_FUNCTION_DECLARATION => {
                JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(
                    TsDeclareFunctionDeclaration { syntax },
                )
            }
            TS_INTERFACE_DECLARATION => {
                JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(TsInterfaceDeclaration {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => &it.syntax,
            JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => &it.syntax,
            JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(it) => &it.syntax,
            JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyExportDefaultDeclaration> for JsSyntaxNode {
    fn from(n: JsAnyExportDefaultDeclaration) -> JsSyntaxNode {
        match n {
            JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => it.into(),
            JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => it.into(),
            JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(it) => it.into(),
            JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyExportDefaultDeclaration> for JsSyntaxElement {
    fn from(n: JsAnyExportDefaultDeclaration) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExportNamedShorthandSpecifier> for JsAnyExportNamedSpecifier {
    fn from(node: JsExportNamedShorthandSpecifier) -> JsAnyExportNamedSpecifier {
        JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(node)
    }
}
impl From<JsExportNamedSpecifier> for JsAnyExportNamedSpecifier {
    fn from(node: JsExportNamedSpecifier) -> JsAnyExportNamedSpecifier {
        JsAnyExportNamedSpecifier::JsExportNamedSpecifier(node)
    }
}
impl AstNode<JsLanguage> for JsAnyExportNamedSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_EXPORT_NAMED_SHORTHAND_SPECIFIER | JS_EXPORT_NAMED_SPECIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT_NAMED_SHORTHAND_SPECIFIER => {
                JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(
                    JsExportNamedShorthandSpecifier { syntax },
                )
            }
            JS_EXPORT_NAMED_SPECIFIER => {
                JsAnyExportNamedSpecifier::JsExportNamedSpecifier(JsExportNamedSpecifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => &it.syntax,
            JsAnyExportNamedSpecifier::JsExportNamedSpecifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyExportNamedSpecifier::JsExportNamedSpecifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyExportNamedSpecifier> for JsSyntaxNode {
    fn from(n: JsAnyExportNamedSpecifier) -> JsSyntaxNode {
        match n {
            JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => it.into(),
            JsAnyExportNamedSpecifier::JsExportNamedSpecifier(it) => it.into(),
        }
    }
}
impl From<JsAnyExportNamedSpecifier> for JsSyntaxElement {
    fn from(n: JsAnyExportNamedSpecifier) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<ImportMeta> for JsAnyExpression {
    fn from(node: ImportMeta) -> JsAnyExpression {
        JsAnyExpression::ImportMeta(node)
    }
}
impl From<JsArrayExpression> for JsAnyExpression {
    fn from(node: JsArrayExpression) -> JsAnyExpression {
        JsAnyExpression::JsArrayExpression(node)
    }
}
impl From<JsArrowFunctionExpression> for JsAnyExpression {
    fn from(node: JsArrowFunctionExpression) -> JsAnyExpression {
        JsAnyExpression::JsArrowFunctionExpression(node)
    }
}
impl From<JsAssignmentExpression> for JsAnyExpression {
    fn from(node: JsAssignmentExpression) -> JsAnyExpression {
        JsAnyExpression::JsAssignmentExpression(node)
    }
}
impl From<JsAwaitExpression> for JsAnyExpression {
    fn from(node: JsAwaitExpression) -> JsAnyExpression {
        JsAnyExpression::JsAwaitExpression(node)
    }
}
impl From<JsBinaryExpression> for JsAnyExpression {
    fn from(node: JsBinaryExpression) -> JsAnyExpression {
        JsAnyExpression::JsBinaryExpression(node)
    }
}
impl From<JsCallExpression> for JsAnyExpression {
    fn from(node: JsCallExpression) -> JsAnyExpression {
        JsAnyExpression::JsCallExpression(node)
    }
}
impl From<JsClassExpression> for JsAnyExpression {
    fn from(node: JsClassExpression) -> JsAnyExpression {
        JsAnyExpression::JsClassExpression(node)
    }
}
impl From<JsComputedMemberExpression> for JsAnyExpression {
    fn from(node: JsComputedMemberExpression) -> JsAnyExpression {
        JsAnyExpression::JsComputedMemberExpression(node)
    }
}
impl From<JsConditionalExpression> for JsAnyExpression {
    fn from(node: JsConditionalExpression) -> JsAnyExpression {
        JsAnyExpression::JsConditionalExpression(node)
    }
}
impl From<JsFunctionExpression> for JsAnyExpression {
    fn from(node: JsFunctionExpression) -> JsAnyExpression {
        JsAnyExpression::JsFunctionExpression(node)
    }
}
impl From<JsIdentifierExpression> for JsAnyExpression {
    fn from(node: JsIdentifierExpression) -> JsAnyExpression {
        JsAnyExpression::JsIdentifierExpression(node)
    }
}
impl From<JsImportCallExpression> for JsAnyExpression {
    fn from(node: JsImportCallExpression) -> JsAnyExpression {
        JsAnyExpression::JsImportCallExpression(node)
    }
}
impl From<JsInExpression> for JsAnyExpression {
    fn from(node: JsInExpression) -> JsAnyExpression {
        JsAnyExpression::JsInExpression(node)
    }
}
impl From<JsInstanceofExpression> for JsAnyExpression {
    fn from(node: JsInstanceofExpression) -> JsAnyExpression {
        JsAnyExpression::JsInstanceofExpression(node)
    }
}
impl From<JsLogicalExpression> for JsAnyExpression {
    fn from(node: JsLogicalExpression) -> JsAnyExpression {
        JsAnyExpression::JsLogicalExpression(node)
    }
}
impl From<JsNewExpression> for JsAnyExpression {
    fn from(node: JsNewExpression) -> JsAnyExpression {
        JsAnyExpression::JsNewExpression(node)
    }
}
impl From<JsObjectExpression> for JsAnyExpression {
    fn from(node: JsObjectExpression) -> JsAnyExpression {
        JsAnyExpression::JsObjectExpression(node)
    }
}
impl From<JsParenthesizedExpression> for JsAnyExpression {
    fn from(node: JsParenthesizedExpression) -> JsAnyExpression {
        JsAnyExpression::JsParenthesizedExpression(node)
    }
}
impl From<JsPostUpdateExpression> for JsAnyExpression {
    fn from(node: JsPostUpdateExpression) -> JsAnyExpression {
        JsAnyExpression::JsPostUpdateExpression(node)
    }
}
impl From<JsPreUpdateExpression> for JsAnyExpression {
    fn from(node: JsPreUpdateExpression) -> JsAnyExpression {
        JsAnyExpression::JsPreUpdateExpression(node)
    }
}
impl From<JsSequenceExpression> for JsAnyExpression {
    fn from(node: JsSequenceExpression) -> JsAnyExpression {
        JsAnyExpression::JsSequenceExpression(node)
    }
}
impl From<JsStaticMemberExpression> for JsAnyExpression {
    fn from(node: JsStaticMemberExpression) -> JsAnyExpression {
        JsAnyExpression::JsStaticMemberExpression(node)
    }
}
impl From<JsSuperExpression> for JsAnyExpression {
    fn from(node: JsSuperExpression) -> JsAnyExpression {
        JsAnyExpression::JsSuperExpression(node)
    }
}
impl From<JsTemplate> for JsAnyExpression {
    fn from(node: JsTemplate) -> JsAnyExpression {
        JsAnyExpression::JsTemplate(node)
    }
}
impl From<JsThisExpression> for JsAnyExpression {
    fn from(node: JsThisExpression) -> JsAnyExpression {
        JsAnyExpression::JsThisExpression(node)
    }
}
impl From<JsUnaryExpression> for JsAnyExpression {
    fn from(node: JsUnaryExpression) -> JsAnyExpression {
        JsAnyExpression::JsUnaryExpression(node)
    }
}
impl From<JsUnknownExpression> for JsAnyExpression {
    fn from(node: JsUnknownExpression) -> JsAnyExpression {
        JsAnyExpression::JsUnknownExpression(node)
    }
}
impl From<JsYieldExpression> for JsAnyExpression {
    fn from(node: JsYieldExpression) -> JsAnyExpression {
        JsAnyExpression::JsYieldExpression(node)
    }
}
impl From<JsxTagExpression> for JsAnyExpression {
    fn from(node: JsxTagExpression) -> JsAnyExpression {
        JsAnyExpression::JsxTagExpression(node)
    }
}
impl From<NewTarget> for JsAnyExpression {
    fn from(node: NewTarget) -> JsAnyExpression {
        JsAnyExpression::NewTarget(node)
    }
}
impl From<TsAsExpression> for JsAnyExpression {
    fn from(node: TsAsExpression) -> JsAnyExpression {
        JsAnyExpression::TsAsExpression(node)
    }
}
impl From<TsNonNullAssertionExpression> for JsAnyExpression {
    fn from(node: TsNonNullAssertionExpression) -> JsAnyExpression {
        JsAnyExpression::TsNonNullAssertionExpression(node)
    }
}
impl From<TsTypeAssertionExpression> for JsAnyExpression {
    fn from(node: TsTypeAssertionExpression) -> JsAnyExpression {
        JsAnyExpression::TsTypeAssertionExpression(node)
    }
}
impl AstNode<JsLanguage> for JsAnyExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            IMPORT_META
            | JS_ARRAY_EXPRESSION
            | JS_ARROW_FUNCTION_EXPRESSION
            | JS_ASSIGNMENT_EXPRESSION
            | JS_AWAIT_EXPRESSION
            | JS_BINARY_EXPRESSION
            | JS_CALL_EXPRESSION
            | JS_CLASS_EXPRESSION
            | JS_COMPUTED_MEMBER_EXPRESSION
            | JS_CONDITIONAL_EXPRESSION
            | JS_FUNCTION_EXPRESSION
            | JS_IDENTIFIER_EXPRESSION
            | JS_IMPORT_CALL_EXPRESSION
            | JS_IN_EXPRESSION
            | JS_INSTANCEOF_EXPRESSION
            | JS_LOGICAL_EXPRESSION
            | JS_NEW_EXPRESSION
            | JS_OBJECT_EXPRESSION
            | JS_PARENTHESIZED_EXPRESSION
            | JS_POST_UPDATE_EXPRESSION
            | JS_PRE_UPDATE_EXPRESSION
            | JS_SEQUENCE_EXPRESSION
            | JS_STATIC_MEMBER_EXPRESSION
            | JS_SUPER_EXPRESSION
            | JS_TEMPLATE
            | JS_THIS_EXPRESSION
            | JS_UNARY_EXPRESSION
            | JS_UNKNOWN_EXPRESSION
            | JS_YIELD_EXPRESSION
            | JSX_TAG_EXPRESSION
            | NEW_TARGET
            | TS_AS_EXPRESSION
            | TS_NON_NULL_ASSERTION_EXPRESSION
            | TS_TYPE_ASSERTION_EXPRESSION => true,
            k if JsAnyLiteralExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IMPORT_META => JsAnyExpression::ImportMeta(ImportMeta { syntax }),
            JS_ARRAY_EXPRESSION => JsAnyExpression::JsArrayExpression(JsArrayExpression { syntax }),
            JS_ARROW_FUNCTION_EXPRESSION => {
                JsAnyExpression::JsArrowFunctionExpression(JsArrowFunctionExpression { syntax })
            }
            JS_ASSIGNMENT_EXPRESSION => {
                JsAnyExpression::JsAssignmentExpression(JsAssignmentExpression { syntax })
            }
            JS_AWAIT_EXPRESSION => JsAnyExpression::JsAwaitExpression(JsAwaitExpression { syntax }),
            JS_BINARY_EXPRESSION => {
                JsAnyExpression::JsBinaryExpression(JsBinaryExpression { syntax })
            }
            JS_CALL_EXPRESSION => JsAnyExpression::JsCallExpression(JsCallExpression { syntax }),
            JS_CLASS_EXPRESSION => JsAnyExpression::JsClassExpression(JsClassExpression { syntax }),
            JS_COMPUTED_MEMBER_EXPRESSION => {
                JsAnyExpression::JsComputedMemberExpression(JsComputedMemberExpression { syntax })
            }
            JS_CONDITIONAL_EXPRESSION => {
                JsAnyExpression::JsConditionalExpression(JsConditionalExpression { syntax })
            }
            JS_FUNCTION_EXPRESSION => {
                JsAnyExpression::JsFunctionExpression(JsFunctionExpression { syntax })
            }
            JS_IDENTIFIER_EXPRESSION => {
                JsAnyExpression::JsIdentifierExpression(JsIdentifierExpression { syntax })
            }
            JS_IMPORT_CALL_EXPRESSION => {
                JsAnyExpression::JsImportCallExpression(JsImportCallExpression { syntax })
            }
            JS_IN_EXPRESSION => JsAnyExpression::JsInExpression(JsInExpression { syntax }),
            JS_INSTANCEOF_EXPRESSION => {
                JsAnyExpression::JsInstanceofExpression(JsInstanceofExpression { syntax })
            }
            JS_LOGICAL_EXPRESSION => {
                JsAnyExpression::JsLogicalExpression(JsLogicalExpression { syntax })
            }
            JS_NEW_EXPRESSION => JsAnyExpression::JsNewExpression(JsNewExpression { syntax }),
            JS_OBJECT_EXPRESSION => {
                JsAnyExpression::JsObjectExpression(JsObjectExpression { syntax })
            }
            JS_PARENTHESIZED_EXPRESSION => {
                JsAnyExpression::JsParenthesizedExpression(JsParenthesizedExpression { syntax })
            }
            JS_POST_UPDATE_EXPRESSION => {
                JsAnyExpression::JsPostUpdateExpression(JsPostUpdateExpression { syntax })
            }
            JS_PRE_UPDATE_EXPRESSION => {
                JsAnyExpression::JsPreUpdateExpression(JsPreUpdateExpression { syntax })
            }
            JS_SEQUENCE_EXPRESSION => {
                JsAnyExpression::JsSequenceExpression(JsSequenceExpression { syntax })
            }
            JS_STATIC_MEMBER_EXPRESSION => {
                JsAnyExpression::JsStaticMemberExpression(JsStaticMemberExpression { syntax })
            }
            JS_SUPER_EXPRESSION => JsAnyExpression::JsSuperExpression(JsSuperExpression { syntax }),
            JS_TEMPLATE => JsAnyExpression::JsTemplate(JsTemplate { syntax }),
            JS_THIS_EXPRESSION => JsAnyExpression::JsThisExpression(JsThisExpression { syntax }),
            JS_UNARY_EXPRESSION => JsAnyExpression::JsUnaryExpression(JsUnaryExpression { syntax }),
            JS_UNKNOWN_EXPRESSION => {
                JsAnyExpression::JsUnknownExpression(JsUnknownExpression { syntax })
            }
            JS_YIELD_EXPRESSION => JsAnyExpression::JsYieldExpression(JsYieldExpression { syntax }),
            JSX_TAG_EXPRESSION => JsAnyExpression::JsxTagExpression(JsxTagExpression { syntax }),
            NEW_TARGET => JsAnyExpression::NewTarget(NewTarget { syntax }),
            TS_AS_EXPRESSION => JsAnyExpression::TsAsExpression(TsAsExpression { syntax }),
            TS_NON_NULL_ASSERTION_EXPRESSION => {
                JsAnyExpression::TsNonNullAssertionExpression(TsNonNullAssertionExpression {
                    syntax,
                })
            }
            TS_TYPE_ASSERTION_EXPRESSION => {
                JsAnyExpression::TsTypeAssertionExpression(TsTypeAssertionExpression { syntax })
            }
            _ => {
                if let Some(js_any_literal_expression) = JsAnyLiteralExpression::cast(syntax) {
                    return Some(JsAnyExpression::JsAnyLiteralExpression(
                        js_any_literal_expression,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyExpression::ImportMeta(it) => &it.syntax,
            JsAnyExpression::JsArrayExpression(it) => &it.syntax,
            JsAnyExpression::JsArrowFunctionExpression(it) => &it.syntax,
            JsAnyExpression::JsAssignmentExpression(it) => &it.syntax,
            JsAnyExpression::JsAwaitExpression(it) => &it.syntax,
            JsAnyExpression::JsBinaryExpression(it) => &it.syntax,
            JsAnyExpression::JsCallExpression(it) => &it.syntax,
            JsAnyExpression::JsClassExpression(it) => &it.syntax,
            JsAnyExpression::JsComputedMemberExpression(it) => &it.syntax,
            JsAnyExpression::JsConditionalExpression(it) => &it.syntax,
            JsAnyExpression::JsFunctionExpression(it) => &it.syntax,
            JsAnyExpression::JsIdentifierExpression(it) => &it.syntax,
            JsAnyExpression::JsImportCallExpression(it) => &it.syntax,
            JsAnyExpression::JsInExpression(it) => &it.syntax,
            JsAnyExpression::JsInstanceofExpression(it) => &it.syntax,
            JsAnyExpression::JsLogicalExpression(it) => &it.syntax,
            JsAnyExpression::JsNewExpression(it) => &it.syntax,
            JsAnyExpression::JsObjectExpression(it) => &it.syntax,
            JsAnyExpression::JsParenthesizedExpression(it) => &it.syntax,
            JsAnyExpression::JsPostUpdateExpression(it) => &it.syntax,
            JsAnyExpression::JsPreUpdateExpression(it) => &it.syntax,
            JsAnyExpression::JsSequenceExpression(it) => &it.syntax,
            JsAnyExpression::JsStaticMemberExpression(it) => &it.syntax,
            JsAnyExpression::JsSuperExpression(it) => &it.syntax,
            JsAnyExpression::JsTemplate(it) => &it.syntax,
            JsAnyExpression::JsThisExpression(it) => &it.syntax,
            JsAnyExpression::JsUnaryExpression(it) => &it.syntax,
            JsAnyExpression::JsUnknownExpression(it) => &it.syntax,
            JsAnyExpression::JsYieldExpression(it) => &it.syntax,
            JsAnyExpression::JsxTagExpression(it) => &it.syntax,
            JsAnyExpression::NewTarget(it) => &it.syntax,
            JsAnyExpression::TsAsExpression(it) => &it.syntax,
            JsAnyExpression::TsNonNullAssertionExpression(it) => &it.syntax,
            JsAnyExpression::TsTypeAssertionExpression(it) => &it.syntax,
            JsAnyExpression::JsAnyLiteralExpression(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyExpression::ImportMeta(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsAnyLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsArrayExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsArrowFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsAssignmentExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsAwaitExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsBinaryExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsCallExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsClassExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsComputedMemberExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsConditionalExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsIdentifierExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsImportCallExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsInExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsInstanceofExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsLogicalExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsNewExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsObjectExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsParenthesizedExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsPostUpdateExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsPreUpdateExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsSequenceExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsStaticMemberExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsSuperExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsTemplate(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsThisExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsUnaryExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsUnknownExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsYieldExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsxTagExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::NewTarget(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::TsAsExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::TsNonNullAssertionExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::TsTypeAssertionExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyExpression> for JsSyntaxNode {
    fn from(n: JsAnyExpression) -> JsSyntaxNode {
        match n {
            JsAnyExpression::ImportMeta(it) => it.into(),
            JsAnyExpression::JsAnyLiteralExpression(it) => it.into(),
            JsAnyExpression::JsArrayExpression(it) => it.into(),
            JsAnyExpression::JsArrowFunctionExpression(it) => it.into(),
            JsAnyExpression::JsAssignmentExpression(it) => it.into(),
            JsAnyExpression::JsAwaitExpression(it) => it.into(),
            JsAnyExpression::JsBinaryExpression(it) => it.into(),
            JsAnyExpression::JsCallExpression(it) => it.into(),
            JsAnyExpression::JsClassExpression(it) => it.into(),
            JsAnyExpression::JsComputedMemberExpression(it) => it.into(),
            JsAnyExpression::JsConditionalExpression(it) => it.into(),
            JsAnyExpression::JsFunctionExpression(it) => it.into(),
            JsAnyExpression::JsIdentifierExpression(it) => it.into(),
            JsAnyExpression::JsImportCallExpression(it) => it.into(),
            JsAnyExpression::JsInExpression(it) => it.into(),
            JsAnyExpression::JsInstanceofExpression(it) => it.into(),
            JsAnyExpression::JsLogicalExpression(it) => it.into(),
            JsAnyExpression::JsNewExpression(it) => it.into(),
            JsAnyExpression::JsObjectExpression(it) => it.into(),
            JsAnyExpression::JsParenthesizedExpression(it) => it.into(),
            JsAnyExpression::JsPostUpdateExpression(it) => it.into(),
            JsAnyExpression::JsPreUpdateExpression(it) => it.into(),
            JsAnyExpression::JsSequenceExpression(it) => it.into(),
            JsAnyExpression::JsStaticMemberExpression(it) => it.into(),
            JsAnyExpression::JsSuperExpression(it) => it.into(),
            JsAnyExpression::JsTemplate(it) => it.into(),
            JsAnyExpression::JsThisExpression(it) => it.into(),
            JsAnyExpression::JsUnaryExpression(it) => it.into(),
            JsAnyExpression::JsUnknownExpression(it) => it.into(),
            JsAnyExpression::JsYieldExpression(it) => it.into(),
            JsAnyExpression::JsxTagExpression(it) => it.into(),
            JsAnyExpression::NewTarget(it) => it.into(),
            JsAnyExpression::TsAsExpression(it) => it.into(),
            JsAnyExpression::TsNonNullAssertionExpression(it) => it.into(),
            JsAnyExpression::TsTypeAssertionExpression(it) => it.into(),
        }
    }
}
impl From<JsAnyExpression> for JsSyntaxElement {
    fn from(n: JsAnyExpression) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsForVariableDeclaration> for JsAnyForInOrOfInitializer {
    fn from(node: JsForVariableDeclaration) -> JsAnyForInOrOfInitializer {
        JsAnyForInOrOfInitializer::JsForVariableDeclaration(node)
    }
}
impl AstNode<JsLanguage> for JsAnyForInOrOfInitializer {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_FOR_VARIABLE_DECLARATION => true,
            k if JsAnyAssignmentPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_FOR_VARIABLE_DECLARATION => {
                JsAnyForInOrOfInitializer::JsForVariableDeclaration(JsForVariableDeclaration {
                    syntax,
                })
            }
            _ => {
                if let Some(js_any_assignment_pattern) = JsAnyAssignmentPattern::cast(syntax) {
                    return Some(JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(
                        js_any_assignment_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyForInOrOfInitializer::JsForVariableDeclaration(it) => &it.syntax,
            JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyForInOrOfInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
            JsAnyForInOrOfInitializer::JsForVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyForInOrOfInitializer> for JsSyntaxNode {
    fn from(n: JsAnyForInOrOfInitializer) -> JsSyntaxNode {
        match n {
            JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(it) => it.into(),
            JsAnyForInOrOfInitializer::JsForVariableDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyForInOrOfInitializer> for JsSyntaxElement {
    fn from(n: JsAnyForInOrOfInitializer) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsVariableDeclaration> for JsAnyForInitializer {
    fn from(node: JsVariableDeclaration) -> JsAnyForInitializer {
        JsAnyForInitializer::JsVariableDeclaration(node)
    }
}
impl AstNode<JsLanguage> for JsAnyForInitializer {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_VARIABLE_DECLARATION => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_VARIABLE_DECLARATION => {
                JsAnyForInitializer::JsVariableDeclaration(JsVariableDeclaration { syntax })
            }
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyForInitializer::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyForInitializer::JsVariableDeclaration(it) => &it.syntax,
            JsAnyForInitializer::JsAnyExpression(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyForInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyForInitializer::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyForInitializer::JsVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyForInitializer> for JsSyntaxNode {
    fn from(n: JsAnyForInitializer) -> JsSyntaxNode {
        match n {
            JsAnyForInitializer::JsAnyExpression(it) => it.into(),
            JsAnyForInitializer::JsVariableDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyForInitializer> for JsSyntaxElement {
    fn from(n: JsAnyForInitializer) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsFormalParameter> for JsAnyFormalParameter {
    fn from(node: JsFormalParameter) -> JsAnyFormalParameter {
        JsAnyFormalParameter::JsFormalParameter(node)
    }
}
impl From<JsUnknownParameter> for JsAnyFormalParameter {
    fn from(node: JsUnknownParameter) -> JsAnyFormalParameter {
        JsAnyFormalParameter::JsUnknownParameter(node)
    }
}
impl AstNode<JsLanguage> for JsAnyFormalParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_FORMAL_PARAMETER | JS_UNKNOWN_PARAMETER)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_FORMAL_PARAMETER => {
                JsAnyFormalParameter::JsFormalParameter(JsFormalParameter { syntax })
            }
            JS_UNKNOWN_PARAMETER => {
                JsAnyFormalParameter::JsUnknownParameter(JsUnknownParameter { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyFormalParameter::JsFormalParameter(it) => &it.syntax,
            JsAnyFormalParameter::JsUnknownParameter(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyFormalParameter::JsFormalParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFormalParameter::JsUnknownParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyFormalParameter> for JsSyntaxNode {
    fn from(n: JsAnyFormalParameter) -> JsSyntaxNode {
        match n {
            JsAnyFormalParameter::JsFormalParameter(it) => it.into(),
            JsAnyFormalParameter::JsUnknownParameter(it) => it.into(),
        }
    }
}
impl From<JsAnyFormalParameter> for JsSyntaxElement {
    fn from(n: JsAnyFormalParameter) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrowFunctionExpression> for JsAnyFunction {
    fn from(node: JsArrowFunctionExpression) -> JsAnyFunction {
        JsAnyFunction::JsArrowFunctionExpression(node)
    }
}
impl From<JsFunctionDeclaration> for JsAnyFunction {
    fn from(node: JsFunctionDeclaration) -> JsAnyFunction {
        JsAnyFunction::JsFunctionDeclaration(node)
    }
}
impl From<JsFunctionExportDefaultDeclaration> for JsAnyFunction {
    fn from(node: JsFunctionExportDefaultDeclaration) -> JsAnyFunction {
        JsAnyFunction::JsFunctionExportDefaultDeclaration(node)
    }
}
impl From<JsFunctionExpression> for JsAnyFunction {
    fn from(node: JsFunctionExpression) -> JsAnyFunction {
        JsAnyFunction::JsFunctionExpression(node)
    }
}
impl AstNode<JsLanguage> for JsAnyFunction {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_ARROW_FUNCTION_EXPRESSION
                | JS_FUNCTION_DECLARATION
                | JS_FUNCTION_EXPORT_DEFAULT_DECLARATION
                | JS_FUNCTION_EXPRESSION
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARROW_FUNCTION_EXPRESSION => {
                JsAnyFunction::JsArrowFunctionExpression(JsArrowFunctionExpression { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                JsAnyFunction::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_FUNCTION_EXPORT_DEFAULT_DECLARATION => {
                JsAnyFunction::JsFunctionExportDefaultDeclaration(
                    JsFunctionExportDefaultDeclaration { syntax },
                )
            }
            JS_FUNCTION_EXPRESSION => {
                JsAnyFunction::JsFunctionExpression(JsFunctionExpression { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyFunction::JsArrowFunctionExpression(it) => &it.syntax,
            JsAnyFunction::JsFunctionDeclaration(it) => &it.syntax,
            JsAnyFunction::JsFunctionExportDefaultDeclaration(it) => &it.syntax,
            JsAnyFunction::JsFunctionExpression(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyFunction::JsArrowFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFunction::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFunction::JsFunctionExportDefaultDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFunction::JsFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyFunction> for JsSyntaxNode {
    fn from(n: JsAnyFunction) -> JsSyntaxNode {
        match n {
            JsAnyFunction::JsArrowFunctionExpression(it) => it.into(),
            JsAnyFunction::JsFunctionDeclaration(it) => it.into(),
            JsAnyFunction::JsFunctionExportDefaultDeclaration(it) => it.into(),
            JsAnyFunction::JsFunctionExpression(it) => it.into(),
        }
    }
}
impl From<JsAnyFunction> for JsSyntaxElement {
    fn from(n: JsAnyFunction) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsFunctionBody> for JsAnyFunctionBody {
    fn from(node: JsFunctionBody) -> JsAnyFunctionBody {
        JsAnyFunctionBody::JsFunctionBody(node)
    }
}
impl AstNode<JsLanguage> for JsAnyFunctionBody {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_FUNCTION_BODY => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_FUNCTION_BODY => JsAnyFunctionBody::JsFunctionBody(JsFunctionBody { syntax }),
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyFunctionBody::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyFunctionBody::JsFunctionBody(it) => &it.syntax,
            JsAnyFunctionBody::JsAnyExpression(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyFunctionBody::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFunctionBody::JsFunctionBody(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyFunctionBody> for JsSyntaxNode {
    fn from(n: JsAnyFunctionBody) -> JsSyntaxNode {
        match n {
            JsAnyFunctionBody::JsAnyExpression(it) => it.into(),
            JsAnyFunctionBody::JsFunctionBody(it) => it.into(),
        }
    }
}
impl From<JsAnyFunctionBody> for JsSyntaxElement {
    fn from(n: JsAnyFunctionBody) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsImportAssertionEntry> for JsAnyImportAssertionEntry {
    fn from(node: JsImportAssertionEntry) -> JsAnyImportAssertionEntry {
        JsAnyImportAssertionEntry::JsImportAssertionEntry(node)
    }
}
impl From<JsUnknownImportAssertionEntry> for JsAnyImportAssertionEntry {
    fn from(node: JsUnknownImportAssertionEntry) -> JsAnyImportAssertionEntry {
        JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(node)
    }
}
impl AstNode<JsLanguage> for JsAnyImportAssertionEntry {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_IMPORT_ASSERTION_ENTRY | JS_UNKNOWN_IMPORT_ASSERTION_ENTRY
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IMPORT_ASSERTION_ENTRY => {
                JsAnyImportAssertionEntry::JsImportAssertionEntry(JsImportAssertionEntry { syntax })
            }
            JS_UNKNOWN_IMPORT_ASSERTION_ENTRY => {
                JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(
                    JsUnknownImportAssertionEntry { syntax },
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyImportAssertionEntry::JsImportAssertionEntry(it) => &it.syntax,
            JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyImportAssertionEntry::JsImportAssertionEntry(it) => std::fmt::Debug::fmt(it, f),
            JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyImportAssertionEntry> for JsSyntaxNode {
    fn from(n: JsAnyImportAssertionEntry) -> JsSyntaxNode {
        match n {
            JsAnyImportAssertionEntry::JsImportAssertionEntry(it) => it.into(),
            JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(it) => it.into(),
        }
    }
}
impl From<JsAnyImportAssertionEntry> for JsSyntaxElement {
    fn from(n: JsAnyImportAssertionEntry) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsImportBareClause> for JsAnyImportClause {
    fn from(node: JsImportBareClause) -> JsAnyImportClause {
        JsAnyImportClause::JsImportBareClause(node)
    }
}
impl From<JsImportDefaultClause> for JsAnyImportClause {
    fn from(node: JsImportDefaultClause) -> JsAnyImportClause {
        JsAnyImportClause::JsImportDefaultClause(node)
    }
}
impl From<JsImportNamedClause> for JsAnyImportClause {
    fn from(node: JsImportNamedClause) -> JsAnyImportClause {
        JsAnyImportClause::JsImportNamedClause(node)
    }
}
impl From<JsImportNamespaceClause> for JsAnyImportClause {
    fn from(node: JsImportNamespaceClause) -> JsAnyImportClause {
        JsAnyImportClause::JsImportNamespaceClause(node)
    }
}
impl AstNode<JsLanguage> for JsAnyImportClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_IMPORT_BARE_CLAUSE
                | JS_IMPORT_DEFAULT_CLAUSE
                | JS_IMPORT_NAMED_CLAUSE
                | JS_IMPORT_NAMESPACE_CLAUSE
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IMPORT_BARE_CLAUSE => {
                JsAnyImportClause::JsImportBareClause(JsImportBareClause { syntax })
            }
            JS_IMPORT_DEFAULT_CLAUSE => {
                JsAnyImportClause::JsImportDefaultClause(JsImportDefaultClause { syntax })
            }
            JS_IMPORT_NAMED_CLAUSE => {
                JsAnyImportClause::JsImportNamedClause(JsImportNamedClause { syntax })
            }
            JS_IMPORT_NAMESPACE_CLAUSE => {
                JsAnyImportClause::JsImportNamespaceClause(JsImportNamespaceClause { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyImportClause::JsImportBareClause(it) => &it.syntax,
            JsAnyImportClause::JsImportDefaultClause(it) => &it.syntax,
            JsAnyImportClause::JsImportNamedClause(it) => &it.syntax,
            JsAnyImportClause::JsImportNamespaceClause(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyImportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyImportClause::JsImportBareClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyImportClause::JsImportDefaultClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyImportClause::JsImportNamedClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyImportClause::JsImportNamespaceClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyImportClause> for JsSyntaxNode {
    fn from(n: JsAnyImportClause) -> JsSyntaxNode {
        match n {
            JsAnyImportClause::JsImportBareClause(it) => it.into(),
            JsAnyImportClause::JsImportDefaultClause(it) => it.into(),
            JsAnyImportClause::JsImportNamedClause(it) => it.into(),
            JsAnyImportClause::JsImportNamespaceClause(it) => it.into(),
        }
    }
}
impl From<JsAnyImportClause> for JsSyntaxElement {
    fn from(n: JsAnyImportClause) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsPrivateName> for JsAnyInProperty {
    fn from(node: JsPrivateName) -> JsAnyInProperty {
        JsAnyInProperty::JsPrivateName(node)
    }
}
impl AstNode<JsLanguage> for JsAnyInProperty {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_PRIVATE_NAME => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_PRIVATE_NAME => JsAnyInProperty::JsPrivateName(JsPrivateName { syntax }),
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyInProperty::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyInProperty::JsPrivateName(it) => &it.syntax,
            JsAnyInProperty::JsAnyExpression(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyInProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyInProperty::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyInProperty::JsPrivateName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyInProperty> for JsSyntaxNode {
    fn from(n: JsAnyInProperty) -> JsSyntaxNode {
        match n {
            JsAnyInProperty::JsAnyExpression(it) => it.into(),
            JsAnyInProperty::JsPrivateName(it) => it.into(),
        }
    }
}
impl From<JsAnyInProperty> for JsSyntaxElement {
    fn from(n: JsAnyInProperty) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBigIntLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsBigIntLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsBigIntLiteralExpression(node)
    }
}
impl From<JsBooleanLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsBooleanLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsBooleanLiteralExpression(node)
    }
}
impl From<JsNullLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsNullLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsNullLiteralExpression(node)
    }
}
impl From<JsNumberLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsNumberLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsNumberLiteralExpression(node)
    }
}
impl From<JsRegexLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsRegexLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsRegexLiteralExpression(node)
    }
}
impl From<JsStringLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsStringLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsStringLiteralExpression(node)
    }
}
impl AstNode<JsLanguage> for JsAnyLiteralExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_BIG_INT_LITERAL_EXPRESSION
                | JS_BOOLEAN_LITERAL_EXPRESSION
                | JS_NULL_LITERAL_EXPRESSION
                | JS_NUMBER_LITERAL_EXPRESSION
                | JS_REGEX_LITERAL_EXPRESSION
                | JS_STRING_LITERAL_EXPRESSION
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BIG_INT_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsBigIntLiteralExpression(JsBigIntLiteralExpression {
                    syntax,
                })
            }
            JS_BOOLEAN_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsBooleanLiteralExpression(JsBooleanLiteralExpression {
                    syntax,
                })
            }
            JS_NULL_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsNullLiteralExpression(JsNullLiteralExpression { syntax })
            }
            JS_NUMBER_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsNumberLiteralExpression(JsNumberLiteralExpression {
                    syntax,
                })
            }
            JS_REGEX_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsRegexLiteralExpression(JsRegexLiteralExpression {
                    syntax,
                })
            }
            JS_STRING_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsStringLiteralExpression(JsStringLiteralExpression {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyLiteralExpression::JsBigIntLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsBooleanLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsNullLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsNumberLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsRegexLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsStringLiteralExpression(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyLiteralExpression::JsBigIntLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsBooleanLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsNullLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsNumberLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsRegexLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsStringLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyLiteralExpression> for JsSyntaxNode {
    fn from(n: JsAnyLiteralExpression) -> JsSyntaxNode {
        match n {
            JsAnyLiteralExpression::JsBigIntLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsBooleanLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsNullLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsNumberLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsRegexLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsStringLiteralExpression(it) => it.into(),
        }
    }
}
impl From<JsAnyLiteralExpression> for JsSyntaxElement {
    fn from(n: JsAnyLiteralExpression) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for JsAnyMethodModifier {
    fn from(node: JsStaticModifier) -> JsAnyMethodModifier {
        JsAnyMethodModifier::JsStaticModifier(node)
    }
}
impl From<TsAccessibilityModifier> for JsAnyMethodModifier {
    fn from(node: TsAccessibilityModifier) -> JsAnyMethodModifier {
        JsAnyMethodModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for JsAnyMethodModifier {
    fn from(node: TsOverrideModifier) -> JsAnyMethodModifier {
        JsAnyMethodModifier::TsOverrideModifier(node)
    }
}
impl AstNode<JsLanguage> for JsAnyMethodModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER | TS_ACCESSIBILITY_MODIFIER | TS_OVERRIDE_MODIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                JsAnyMethodModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                JsAnyMethodModifier::TsAccessibilityModifier(TsAccessibilityModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                JsAnyMethodModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyMethodModifier::JsStaticModifier(it) => &it.syntax,
            JsAnyMethodModifier::TsAccessibilityModifier(it) => &it.syntax,
            JsAnyMethodModifier::TsOverrideModifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyMethodModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyMethodModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyMethodModifier::TsAccessibilityModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyMethodModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyMethodModifier> for JsSyntaxNode {
    fn from(n: JsAnyMethodModifier) -> JsSyntaxNode {
        match n {
            JsAnyMethodModifier::JsStaticModifier(it) => it.into(),
            JsAnyMethodModifier::TsAccessibilityModifier(it) => it.into(),
            JsAnyMethodModifier::TsOverrideModifier(it) => it.into(),
        }
    }
}
impl From<JsAnyMethodModifier> for JsSyntaxElement {
    fn from(n: JsAnyMethodModifier) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExport> for JsAnyModuleItem {
    fn from(node: JsExport) -> JsAnyModuleItem {
        JsAnyModuleItem::JsExport(node)
    }
}
impl From<JsImport> for JsAnyModuleItem {
    fn from(node: JsImport) -> JsAnyModuleItem {
        JsAnyModuleItem::JsImport(node)
    }
}
impl AstNode<JsLanguage> for JsAnyModuleItem {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_EXPORT | JS_IMPORT => true,
            k if JsAnyStatement::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT => JsAnyModuleItem::JsExport(JsExport { syntax }),
            JS_IMPORT => JsAnyModuleItem::JsImport(JsImport { syntax }),
            _ => {
                if let Some(js_any_statement) = JsAnyStatement::cast(syntax) {
                    return Some(JsAnyModuleItem::JsAnyStatement(js_any_statement));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyModuleItem::JsExport(it) => &it.syntax,
            JsAnyModuleItem::JsImport(it) => &it.syntax,
            JsAnyModuleItem::JsAnyStatement(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyModuleItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyModuleItem::JsAnyStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyModuleItem::JsExport(it) => std::fmt::Debug::fmt(it, f),
            JsAnyModuleItem::JsImport(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyModuleItem> for JsSyntaxNode {
    fn from(n: JsAnyModuleItem) -> JsSyntaxNode {
        match n {
            JsAnyModuleItem::JsAnyStatement(it) => it.into(),
            JsAnyModuleItem::JsExport(it) => it.into(),
            JsAnyModuleItem::JsImport(it) => it.into(),
        }
    }
}
impl From<JsAnyModuleItem> for JsSyntaxElement {
    fn from(n: JsAnyModuleItem) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsName> for JsAnyName {
    fn from(node: JsName) -> JsAnyName {
        JsAnyName::JsName(node)
    }
}
impl From<JsPrivateName> for JsAnyName {
    fn from(node: JsPrivateName) -> JsAnyName {
        JsAnyName::JsPrivateName(node)
    }
}
impl AstNode<JsLanguage> for JsAnyName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_NAME | JS_PRIVATE_NAME)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_NAME => JsAnyName::JsName(JsName { syntax }),
            JS_PRIVATE_NAME => JsAnyName::JsPrivateName(JsPrivateName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyName::JsName(it) => &it.syntax,
            JsAnyName::JsPrivateName(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyName::JsName(it) => std::fmt::Debug::fmt(it, f),
            JsAnyName::JsPrivateName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyName> for JsSyntaxNode {
    fn from(n: JsAnyName) -> JsSyntaxNode {
        match n {
            JsAnyName::JsName(it) => it.into(),
            JsAnyName::JsPrivateName(it) => it.into(),
        }
    }
}
impl From<JsAnyName> for JsSyntaxElement {
    fn from(n: JsAnyName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsNamedImportSpecifiers> for JsAnyNamedImport {
    fn from(node: JsNamedImportSpecifiers) -> JsAnyNamedImport {
        JsAnyNamedImport::JsNamedImportSpecifiers(node)
    }
}
impl From<JsNamespaceImportSpecifier> for JsAnyNamedImport {
    fn from(node: JsNamespaceImportSpecifier) -> JsAnyNamedImport {
        JsAnyNamedImport::JsNamespaceImportSpecifier(node)
    }
}
impl AstNode<JsLanguage> for JsAnyNamedImport {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_NAMED_IMPORT_SPECIFIERS | JS_NAMESPACE_IMPORT_SPECIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_NAMED_IMPORT_SPECIFIERS => {
                JsAnyNamedImport::JsNamedImportSpecifiers(JsNamedImportSpecifiers { syntax })
            }
            JS_NAMESPACE_IMPORT_SPECIFIER => {
                JsAnyNamedImport::JsNamespaceImportSpecifier(JsNamespaceImportSpecifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyNamedImport::JsNamedImportSpecifiers(it) => &it.syntax,
            JsAnyNamedImport::JsNamespaceImportSpecifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyNamedImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyNamedImport::JsNamedImportSpecifiers(it) => std::fmt::Debug::fmt(it, f),
            JsAnyNamedImport::JsNamespaceImportSpecifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyNamedImport> for JsSyntaxNode {
    fn from(n: JsAnyNamedImport) -> JsSyntaxNode {
        match n {
            JsAnyNamedImport::JsNamedImportSpecifiers(it) => it.into(),
            JsAnyNamedImport::JsNamespaceImportSpecifier(it) => it.into(),
        }
    }
}
impl From<JsAnyNamedImport> for JsSyntaxElement {
    fn from(n: JsAnyNamedImport) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsNamedImportSpecifier> for JsAnyNamedImportSpecifier {
    fn from(node: JsNamedImportSpecifier) -> JsAnyNamedImportSpecifier {
        JsAnyNamedImportSpecifier::JsNamedImportSpecifier(node)
    }
}
impl From<JsShorthandNamedImportSpecifier> for JsAnyNamedImportSpecifier {
    fn from(node: JsShorthandNamedImportSpecifier) -> JsAnyNamedImportSpecifier {
        JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(node)
    }
}
impl From<JsUnknownNamedImportSpecifier> for JsAnyNamedImportSpecifier {
    fn from(node: JsUnknownNamedImportSpecifier) -> JsAnyNamedImportSpecifier {
        JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(node)
    }
}
impl AstNode<JsLanguage> for JsAnyNamedImportSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_NAMED_IMPORT_SPECIFIER
                | JS_SHORTHAND_NAMED_IMPORT_SPECIFIER
                | JS_UNKNOWN_NAMED_IMPORT_SPECIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_NAMED_IMPORT_SPECIFIER => {
                JsAnyNamedImportSpecifier::JsNamedImportSpecifier(JsNamedImportSpecifier { syntax })
            }
            JS_SHORTHAND_NAMED_IMPORT_SPECIFIER => {
                JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(
                    JsShorthandNamedImportSpecifier { syntax },
                )
            }
            JS_UNKNOWN_NAMED_IMPORT_SPECIFIER => {
                JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(
                    JsUnknownNamedImportSpecifier { syntax },
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyNamedImportSpecifier::JsNamedImportSpecifier(it) => &it.syntax,
            JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => &it.syntax,
            JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyNamedImportSpecifier::JsNamedImportSpecifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyNamedImportSpecifier> for JsSyntaxNode {
    fn from(n: JsAnyNamedImportSpecifier) -> JsSyntaxNode {
        match n {
            JsAnyNamedImportSpecifier::JsNamedImportSpecifier(it) => it.into(),
            JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => it.into(),
            JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(it) => it.into(),
        }
    }
}
impl From<JsAnyNamedImportSpecifier> for JsSyntaxElement {
    fn from(n: JsAnyNamedImportSpecifier) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsObjectAssignmentPatternProperty> for JsAnyObjectAssignmentPatternMember {
    fn from(node: JsObjectAssignmentPatternProperty) -> JsAnyObjectAssignmentPatternMember {
        JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(node)
    }
}
impl From<JsObjectAssignmentPatternRest> for JsAnyObjectAssignmentPatternMember {
    fn from(node: JsObjectAssignmentPatternRest) -> JsAnyObjectAssignmentPatternMember {
        JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(node)
    }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for JsAnyObjectAssignmentPatternMember {
    fn from(
        node: JsObjectAssignmentPatternShorthandProperty,
    ) -> JsAnyObjectAssignmentPatternMember {
        JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(node)
    }
}
impl From<JsUnknownAssignment> for JsAnyObjectAssignmentPatternMember {
    fn from(node: JsUnknownAssignment) -> JsAnyObjectAssignmentPatternMember {
        JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(node)
    }
}
impl AstNode<JsLanguage> for JsAnyObjectAssignmentPatternMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY
                | JS_OBJECT_ASSIGNMENT_PATTERN_REST
                | JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY
                | JS_UNKNOWN_ASSIGNMENT
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY => {
                JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(
                    JsObjectAssignmentPatternProperty { syntax },
                )
            }
            JS_OBJECT_ASSIGNMENT_PATTERN_REST => {
                JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(
                    JsObjectAssignmentPatternRest { syntax },
                )
            }
            JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY => {
                JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(
                    JsObjectAssignmentPatternShorthandProperty { syntax },
                )
            }
            JS_UNKNOWN_ASSIGNMENT => {
                JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(JsUnknownAssignment {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => &it.syntax,
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => &it.syntax,
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                &it.syntax
            }
            JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyObjectAssignmentPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyObjectAssignmentPatternMember> for JsSyntaxNode {
    fn from(n: JsAnyObjectAssignmentPatternMember) -> JsSyntaxNode {
        match n {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => it.into(),
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => it.into(),
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                it.into()
            }
            JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(it) => it.into(),
        }
    }
}
impl From<JsAnyObjectAssignmentPatternMember> for JsSyntaxElement {
    fn from(n: JsAnyObjectAssignmentPatternMember) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsIdentifierBinding> for JsAnyObjectBindingPatternMember {
    fn from(node: JsIdentifierBinding) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsIdentifierBinding(node)
    }
}
impl From<JsObjectBindingPatternProperty> for JsAnyObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternProperty) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(node)
    }
}
impl From<JsObjectBindingPatternRest> for JsAnyObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternRest) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(node)
    }
}
impl From<JsObjectBindingPatternShorthandProperty> for JsAnyObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternShorthandProperty) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(node)
    }
}
impl From<JsUnknownBinding> for JsAnyObjectBindingPatternMember {
    fn from(node: JsUnknownBinding) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsUnknownBinding(node)
    }
}
impl AstNode<JsLanguage> for JsAnyObjectBindingPatternMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_IDENTIFIER_BINDING
                | JS_OBJECT_BINDING_PATTERN_PROPERTY
                | JS_OBJECT_BINDING_PATTERN_REST
                | JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY
                | JS_UNKNOWN_BINDING
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IDENTIFIER_BINDING => {
                JsAnyObjectBindingPatternMember::JsIdentifierBinding(JsIdentifierBinding { syntax })
            }
            JS_OBJECT_BINDING_PATTERN_PROPERTY => {
                JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(
                    JsObjectBindingPatternProperty { syntax },
                )
            }
            JS_OBJECT_BINDING_PATTERN_REST => {
                JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(
                    JsObjectBindingPatternRest { syntax },
                )
            }
            JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY => {
                JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(
                    JsObjectBindingPatternShorthandProperty { syntax },
                )
            }
            JS_UNKNOWN_BINDING => {
                JsAnyObjectBindingPatternMember::JsUnknownBinding(JsUnknownBinding { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyObjectBindingPatternMember::JsIdentifierBinding(it) => &it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => &it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(it) => &it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                &it.syntax
            }
            JsAnyObjectBindingPatternMember::JsUnknownBinding(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyObjectBindingPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyObjectBindingPatternMember::JsIdentifierBinding(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectBindingPatternMember::JsUnknownBinding(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyObjectBindingPatternMember> for JsSyntaxNode {
    fn from(n: JsAnyObjectBindingPatternMember) -> JsSyntaxNode {
        match n {
            JsAnyObjectBindingPatternMember::JsIdentifierBinding(it) => it.into(),
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => it.into(),
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(it) => it.into(),
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                it.into()
            }
            JsAnyObjectBindingPatternMember::JsUnknownBinding(it) => it.into(),
        }
    }
}
impl From<JsAnyObjectBindingPatternMember> for JsSyntaxElement {
    fn from(n: JsAnyObjectBindingPatternMember) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsGetterObjectMember> for JsAnyObjectMember {
    fn from(node: JsGetterObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsGetterObjectMember(node)
    }
}
impl From<JsMethodObjectMember> for JsAnyObjectMember {
    fn from(node: JsMethodObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsMethodObjectMember(node)
    }
}
impl From<JsPropertyObjectMember> for JsAnyObjectMember {
    fn from(node: JsPropertyObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsPropertyObjectMember(node)
    }
}
impl From<JsSetterObjectMember> for JsAnyObjectMember {
    fn from(node: JsSetterObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsSetterObjectMember(node)
    }
}
impl From<JsShorthandPropertyObjectMember> for JsAnyObjectMember {
    fn from(node: JsShorthandPropertyObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsShorthandPropertyObjectMember(node)
    }
}
impl From<JsSpread> for JsAnyObjectMember {
    fn from(node: JsSpread) -> JsAnyObjectMember {
        JsAnyObjectMember::JsSpread(node)
    }
}
impl From<JsUnknownMember> for JsAnyObjectMember {
    fn from(node: JsUnknownMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsUnknownMember(node)
    }
}
impl AstNode<JsLanguage> for JsAnyObjectMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_GETTER_OBJECT_MEMBER
                | JS_METHOD_OBJECT_MEMBER
                | JS_PROPERTY_OBJECT_MEMBER
                | JS_SETTER_OBJECT_MEMBER
                | JS_SHORTHAND_PROPERTY_OBJECT_MEMBER
                | JS_SPREAD
                | JS_UNKNOWN_MEMBER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_GETTER_OBJECT_MEMBER => {
                JsAnyObjectMember::JsGetterObjectMember(JsGetterObjectMember { syntax })
            }
            JS_METHOD_OBJECT_MEMBER => {
                JsAnyObjectMember::JsMethodObjectMember(JsMethodObjectMember { syntax })
            }
            JS_PROPERTY_OBJECT_MEMBER => {
                JsAnyObjectMember::JsPropertyObjectMember(JsPropertyObjectMember { syntax })
            }
            JS_SETTER_OBJECT_MEMBER => {
                JsAnyObjectMember::JsSetterObjectMember(JsSetterObjectMember { syntax })
            }
            JS_SHORTHAND_PROPERTY_OBJECT_MEMBER => {
                JsAnyObjectMember::JsShorthandPropertyObjectMember(
                    JsShorthandPropertyObjectMember { syntax },
                )
            }
            JS_SPREAD => JsAnyObjectMember::JsSpread(JsSpread { syntax }),
            JS_UNKNOWN_MEMBER => JsAnyObjectMember::JsUnknownMember(JsUnknownMember { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyObjectMember::JsGetterObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsMethodObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsPropertyObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsSetterObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsShorthandPropertyObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsSpread(it) => &it.syntax,
            JsAnyObjectMember::JsUnknownMember(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyObjectMember::JsGetterObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsMethodObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsPropertyObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsSetterObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsShorthandPropertyObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsSpread(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsUnknownMember(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyObjectMember> for JsSyntaxNode {
    fn from(n: JsAnyObjectMember) -> JsSyntaxNode {
        match n {
            JsAnyObjectMember::JsGetterObjectMember(it) => it.into(),
            JsAnyObjectMember::JsMethodObjectMember(it) => it.into(),
            JsAnyObjectMember::JsPropertyObjectMember(it) => it.into(),
            JsAnyObjectMember::JsSetterObjectMember(it) => it.into(),
            JsAnyObjectMember::JsShorthandPropertyObjectMember(it) => it.into(),
            JsAnyObjectMember::JsSpread(it) => it.into(),
            JsAnyObjectMember::JsUnknownMember(it) => it.into(),
        }
    }
}
impl From<JsAnyObjectMember> for JsSyntaxElement {
    fn from(n: JsAnyObjectMember) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsComputedMemberName> for JsAnyObjectMemberName {
    fn from(node: JsComputedMemberName) -> JsAnyObjectMemberName {
        JsAnyObjectMemberName::JsComputedMemberName(node)
    }
}
impl From<JsLiteralMemberName> for JsAnyObjectMemberName {
    fn from(node: JsLiteralMemberName) -> JsAnyObjectMemberName {
        JsAnyObjectMemberName::JsLiteralMemberName(node)
    }
}
impl AstNode<JsLanguage> for JsAnyObjectMemberName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_COMPUTED_MEMBER_NAME | JS_LITERAL_MEMBER_NAME)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_COMPUTED_MEMBER_NAME => {
                JsAnyObjectMemberName::JsComputedMemberName(JsComputedMemberName { syntax })
            }
            JS_LITERAL_MEMBER_NAME => {
                JsAnyObjectMemberName::JsLiteralMemberName(JsLiteralMemberName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyObjectMemberName::JsComputedMemberName(it) => &it.syntax,
            JsAnyObjectMemberName::JsLiteralMemberName(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyObjectMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyObjectMemberName::JsComputedMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMemberName::JsLiteralMemberName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyObjectMemberName> for JsSyntaxNode {
    fn from(n: JsAnyObjectMemberName) -> JsSyntaxNode {
        match n {
            JsAnyObjectMemberName::JsComputedMemberName(it) => it.into(),
            JsAnyObjectMemberName::JsLiteralMemberName(it) => it.into(),
        }
    }
}
impl From<JsAnyObjectMemberName> for JsSyntaxElement {
    fn from(n: JsAnyObjectMemberName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsRestParameter> for JsAnyParameter {
    fn from(node: JsRestParameter) -> JsAnyParameter {
        JsAnyParameter::JsRestParameter(node)
    }
}
impl From<TsThisParameter> for JsAnyParameter {
    fn from(node: TsThisParameter) -> JsAnyParameter {
        JsAnyParameter::TsThisParameter(node)
    }
}
impl AstNode<JsLanguage> for JsAnyParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JS_REST_PARAMETER | TS_THIS_PARAMETER => true,
            k if JsAnyFormalParameter::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REST_PARAMETER => JsAnyParameter::JsRestParameter(JsRestParameter { syntax }),
            TS_THIS_PARAMETER => JsAnyParameter::TsThisParameter(TsThisParameter { syntax }),
            _ => {
                if let Some(js_any_formal_parameter) = JsAnyFormalParameter::cast(syntax) {
                    return Some(JsAnyParameter::JsAnyFormalParameter(
                        js_any_formal_parameter,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyParameter::JsRestParameter(it) => &it.syntax,
            JsAnyParameter::TsThisParameter(it) => &it.syntax,
            JsAnyParameter::JsAnyFormalParameter(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyParameter::JsAnyFormalParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyParameter::JsRestParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyParameter::TsThisParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyParameter> for JsSyntaxNode {
    fn from(n: JsAnyParameter) -> JsSyntaxNode {
        match n {
            JsAnyParameter::JsAnyFormalParameter(it) => it.into(),
            JsAnyParameter::JsRestParameter(it) => it.into(),
            JsAnyParameter::TsThisParameter(it) => it.into(),
        }
    }
}
impl From<JsAnyParameter> for JsSyntaxElement {
    fn from(n: JsAnyParameter) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for JsAnyPropertyModifier {
    fn from(node: JsStaticModifier) -> JsAnyPropertyModifier {
        JsAnyPropertyModifier::JsStaticModifier(node)
    }
}
impl From<TsAccessibilityModifier> for JsAnyPropertyModifier {
    fn from(node: TsAccessibilityModifier) -> JsAnyPropertyModifier {
        JsAnyPropertyModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for JsAnyPropertyModifier {
    fn from(node: TsOverrideModifier) -> JsAnyPropertyModifier {
        JsAnyPropertyModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for JsAnyPropertyModifier {
    fn from(node: TsReadonlyModifier) -> JsAnyPropertyModifier {
        JsAnyPropertyModifier::TsReadonlyModifier(node)
    }
}
impl AstNode<JsLanguage> for JsAnyPropertyModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_OVERRIDE_MODIFIER
                | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                JsAnyPropertyModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                JsAnyPropertyModifier::TsAccessibilityModifier(TsAccessibilityModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                JsAnyPropertyModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                JsAnyPropertyModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyPropertyModifier::JsStaticModifier(it) => &it.syntax,
            JsAnyPropertyModifier::TsAccessibilityModifier(it) => &it.syntax,
            JsAnyPropertyModifier::TsOverrideModifier(it) => &it.syntax,
            JsAnyPropertyModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyPropertyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyPropertyModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyPropertyModifier::TsAccessibilityModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyPropertyModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyPropertyModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyPropertyModifier> for JsSyntaxNode {
    fn from(n: JsAnyPropertyModifier) -> JsSyntaxNode {
        match n {
            JsAnyPropertyModifier::JsStaticModifier(it) => it.into(),
            JsAnyPropertyModifier::TsAccessibilityModifier(it) => it.into(),
            JsAnyPropertyModifier::TsOverrideModifier(it) => it.into(),
            JsAnyPropertyModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<JsAnyPropertyModifier> for JsSyntaxElement {
    fn from(n: JsAnyPropertyModifier) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExpressionSnipped> for JsAnyRoot {
    fn from(node: JsExpressionSnipped) -> JsAnyRoot {
        JsAnyRoot::JsExpressionSnipped(node)
    }
}
impl From<JsModule> for JsAnyRoot {
    fn from(node: JsModule) -> JsAnyRoot {
        JsAnyRoot::JsModule(node)
    }
}
impl From<JsScript> for JsAnyRoot {
    fn from(node: JsScript) -> JsAnyRoot {
        JsAnyRoot::JsScript(node)
    }
}
impl AstNode<JsLanguage> for JsAnyRoot {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_EXPRESSION_SNIPPED | JS_MODULE | JS_SCRIPT)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPRESSION_SNIPPED => JsAnyRoot::JsExpressionSnipped(JsExpressionSnipped { syntax }),
            JS_MODULE => JsAnyRoot::JsModule(JsModule { syntax }),
            JS_SCRIPT => JsAnyRoot::JsScript(JsScript { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyRoot::JsExpressionSnipped(it) => &it.syntax,
            JsAnyRoot::JsModule(it) => &it.syntax,
            JsAnyRoot::JsScript(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyRoot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyRoot::JsExpressionSnipped(it) => std::fmt::Debug::fmt(it, f),
            JsAnyRoot::JsModule(it) => std::fmt::Debug::fmt(it, f),
            JsAnyRoot::JsScript(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyRoot> for JsSyntaxNode {
    fn from(n: JsAnyRoot) -> JsSyntaxNode {
        match n {
            JsAnyRoot::JsExpressionSnipped(it) => it.into(),
            JsAnyRoot::JsModule(it) => it.into(),
            JsAnyRoot::JsScript(it) => it.into(),
        }
    }
}
impl From<JsAnyRoot> for JsSyntaxElement {
    fn from(n: JsAnyRoot) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBlockStatement> for JsAnyStatement {
    fn from(node: JsBlockStatement) -> JsAnyStatement {
        JsAnyStatement::JsBlockStatement(node)
    }
}
impl From<JsBreakStatement> for JsAnyStatement {
    fn from(node: JsBreakStatement) -> JsAnyStatement {
        JsAnyStatement::JsBreakStatement(node)
    }
}
impl From<JsClassDeclaration> for JsAnyStatement {
    fn from(node: JsClassDeclaration) -> JsAnyStatement {
        JsAnyStatement::JsClassDeclaration(node)
    }
}
impl From<JsContinueStatement> for JsAnyStatement {
    fn from(node: JsContinueStatement) -> JsAnyStatement {
        JsAnyStatement::JsContinueStatement(node)
    }
}
impl From<JsDebuggerStatement> for JsAnyStatement {
    fn from(node: JsDebuggerStatement) -> JsAnyStatement {
        JsAnyStatement::JsDebuggerStatement(node)
    }
}
impl From<JsDoWhileStatement> for JsAnyStatement {
    fn from(node: JsDoWhileStatement) -> JsAnyStatement {
        JsAnyStatement::JsDoWhileStatement(node)
    }
}
impl From<JsEmptyStatement> for JsAnyStatement {
    fn from(node: JsEmptyStatement) -> JsAnyStatement {
        JsAnyStatement::JsEmptyStatement(node)
    }
}
impl From<JsExpressionStatement> for JsAnyStatement {
    fn from(node: JsExpressionStatement) -> JsAnyStatement {
        JsAnyStatement::JsExpressionStatement(node)
    }
}
impl From<JsForInStatement> for JsAnyStatement {
    fn from(node: JsForInStatement) -> JsAnyStatement {
        JsAnyStatement::JsForInStatement(node)
    }
}
impl From<JsForOfStatement> for JsAnyStatement {
    fn from(node: JsForOfStatement) -> JsAnyStatement {
        JsAnyStatement::JsForOfStatement(node)
    }
}
impl From<JsForStatement> for JsAnyStatement {
    fn from(node: JsForStatement) -> JsAnyStatement {
        JsAnyStatement::JsForStatement(node)
    }
}
impl From<JsFunctionDeclaration> for JsAnyStatement {
    fn from(node: JsFunctionDeclaration) -> JsAnyStatement {
        JsAnyStatement::JsFunctionDeclaration(node)
    }
}
impl From<JsIfStatement> for JsAnyStatement {
    fn from(node: JsIfStatement) -> JsAnyStatement {
        JsAnyStatement::JsIfStatement(node)
    }
}
impl From<JsLabeledStatement> for JsAnyStatement {
    fn from(node: JsLabeledStatement) -> JsAnyStatement {
        JsAnyStatement::JsLabeledStatement(node)
    }
}
impl From<JsReturnStatement> for JsAnyStatement {
    fn from(node: JsReturnStatement) -> JsAnyStatement {
        JsAnyStatement::JsReturnStatement(node)
    }
}
impl From<JsSwitchStatement> for JsAnyStatement {
    fn from(node: JsSwitchStatement) -> JsAnyStatement {
        JsAnyStatement::JsSwitchStatement(node)
    }
}
impl From<JsThrowStatement> for JsAnyStatement {
    fn from(node: JsThrowStatement) -> JsAnyStatement {
        JsAnyStatement::JsThrowStatement(node)
    }
}
impl From<JsTryFinallyStatement> for JsAnyStatement {
    fn from(node: JsTryFinallyStatement) -> JsAnyStatement {
        JsAnyStatement::JsTryFinallyStatement(node)
    }
}
impl From<JsTryStatement> for JsAnyStatement {
    fn from(node: JsTryStatement) -> JsAnyStatement {
        JsAnyStatement::JsTryStatement(node)
    }
}
impl From<JsUnknownStatement> for JsAnyStatement {
    fn from(node: JsUnknownStatement) -> JsAnyStatement {
        JsAnyStatement::JsUnknownStatement(node)
    }
}
impl From<JsVariableStatement> for JsAnyStatement {
    fn from(node: JsVariableStatement) -> JsAnyStatement {
        JsAnyStatement::JsVariableStatement(node)
    }
}
impl From<JsWhileStatement> for JsAnyStatement {
    fn from(node: JsWhileStatement) -> JsAnyStatement {
        JsAnyStatement::JsWhileStatement(node)
    }
}
impl From<JsWithStatement> for JsAnyStatement {
    fn from(node: JsWithStatement) -> JsAnyStatement {
        JsAnyStatement::JsWithStatement(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for JsAnyStatement {
    fn from(node: TsDeclareFunctionDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsDeclareStatement> for JsAnyStatement {
    fn from(node: TsDeclareStatement) -> JsAnyStatement {
        JsAnyStatement::TsDeclareStatement(node)
    }
}
impl From<TsEnumDeclaration> for JsAnyStatement {
    fn from(node: TsEnumDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsEnumDeclaration(node)
    }
}
impl From<TsExternalModuleDeclaration> for JsAnyStatement {
    fn from(node: TsExternalModuleDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for JsAnyStatement {
    fn from(node: TsGlobalDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for JsAnyStatement {
    fn from(node: TsImportEqualsDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for JsAnyStatement {
    fn from(node: TsInterfaceDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for JsAnyStatement {
    fn from(node: TsModuleDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for JsAnyStatement {
    fn from(node: TsTypeAliasDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsTypeAliasDeclaration(node)
    }
}
impl AstNode<JsLanguage> for JsAnyStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_BLOCK_STATEMENT
                | JS_BREAK_STATEMENT
                | JS_CLASS_DECLARATION
                | JS_CONTINUE_STATEMENT
                | JS_DEBUGGER_STATEMENT
                | JS_DO_WHILE_STATEMENT
                | JS_EMPTY_STATEMENT
                | JS_EXPRESSION_STATEMENT
                | JS_FOR_IN_STATEMENT
                | JS_FOR_OF_STATEMENT
                | JS_FOR_STATEMENT
                | JS_FUNCTION_DECLARATION
                | JS_IF_STATEMENT
                | JS_LABELED_STATEMENT
                | JS_RETURN_STATEMENT
                | JS_SWITCH_STATEMENT
                | JS_THROW_STATEMENT
                | JS_TRY_FINALLY_STATEMENT
                | JS_TRY_STATEMENT
                | JS_UNKNOWN_STATEMENT
                | JS_VARIABLE_STATEMENT
                | JS_WHILE_STATEMENT
                | JS_WITH_STATEMENT
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_DECLARE_STATEMENT
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BLOCK_STATEMENT => JsAnyStatement::JsBlockStatement(JsBlockStatement { syntax }),
            JS_BREAK_STATEMENT => JsAnyStatement::JsBreakStatement(JsBreakStatement { syntax }),
            JS_CLASS_DECLARATION => {
                JsAnyStatement::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_CONTINUE_STATEMENT => {
                JsAnyStatement::JsContinueStatement(JsContinueStatement { syntax })
            }
            JS_DEBUGGER_STATEMENT => {
                JsAnyStatement::JsDebuggerStatement(JsDebuggerStatement { syntax })
            }
            JS_DO_WHILE_STATEMENT => {
                JsAnyStatement::JsDoWhileStatement(JsDoWhileStatement { syntax })
            }
            JS_EMPTY_STATEMENT => JsAnyStatement::JsEmptyStatement(JsEmptyStatement { syntax }),
            JS_EXPRESSION_STATEMENT => {
                JsAnyStatement::JsExpressionStatement(JsExpressionStatement { syntax })
            }
            JS_FOR_IN_STATEMENT => JsAnyStatement::JsForInStatement(JsForInStatement { syntax }),
            JS_FOR_OF_STATEMENT => JsAnyStatement::JsForOfStatement(JsForOfStatement { syntax }),
            JS_FOR_STATEMENT => JsAnyStatement::JsForStatement(JsForStatement { syntax }),
            JS_FUNCTION_DECLARATION => {
                JsAnyStatement::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_IF_STATEMENT => JsAnyStatement::JsIfStatement(JsIfStatement { syntax }),
            JS_LABELED_STATEMENT => {
                JsAnyStatement::JsLabeledStatement(JsLabeledStatement { syntax })
            }
            JS_RETURN_STATEMENT => JsAnyStatement::JsReturnStatement(JsReturnStatement { syntax }),
            JS_SWITCH_STATEMENT => JsAnyStatement::JsSwitchStatement(JsSwitchStatement { syntax }),
            JS_THROW_STATEMENT => JsAnyStatement::JsThrowStatement(JsThrowStatement { syntax }),
            JS_TRY_FINALLY_STATEMENT => {
                JsAnyStatement::JsTryFinallyStatement(JsTryFinallyStatement { syntax })
            }
            JS_TRY_STATEMENT => JsAnyStatement::JsTryStatement(JsTryStatement { syntax }),
            JS_UNKNOWN_STATEMENT => {
                JsAnyStatement::JsUnknownStatement(JsUnknownStatement { syntax })
            }
            JS_VARIABLE_STATEMENT => {
                JsAnyStatement::JsVariableStatement(JsVariableStatement { syntax })
            }
            JS_WHILE_STATEMENT => JsAnyStatement::JsWhileStatement(JsWhileStatement { syntax }),
            JS_WITH_STATEMENT => JsAnyStatement::JsWithStatement(JsWithStatement { syntax }),
            TS_DECLARE_FUNCTION_DECLARATION => {
                JsAnyStatement::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_DECLARE_STATEMENT => {
                JsAnyStatement::TsDeclareStatement(TsDeclareStatement { syntax })
            }
            TS_ENUM_DECLARATION => JsAnyStatement::TsEnumDeclaration(TsEnumDeclaration { syntax }),
            TS_EXTERNAL_MODULE_DECLARATION => {
                JsAnyStatement::TsExternalModuleDeclaration(TsExternalModuleDeclaration { syntax })
            }
            TS_GLOBAL_DECLARATION => {
                JsAnyStatement::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                JsAnyStatement::TsImportEqualsDeclaration(TsImportEqualsDeclaration { syntax })
            }
            TS_INTERFACE_DECLARATION => {
                JsAnyStatement::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                JsAnyStatement::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                JsAnyStatement::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyStatement::JsBlockStatement(it) => &it.syntax,
            JsAnyStatement::JsBreakStatement(it) => &it.syntax,
            JsAnyStatement::JsClassDeclaration(it) => &it.syntax,
            JsAnyStatement::JsContinueStatement(it) => &it.syntax,
            JsAnyStatement::JsDebuggerStatement(it) => &it.syntax,
            JsAnyStatement::JsDoWhileStatement(it) => &it.syntax,
            JsAnyStatement::JsEmptyStatement(it) => &it.syntax,
            JsAnyStatement::JsExpressionStatement(it) => &it.syntax,
            JsAnyStatement::JsForInStatement(it) => &it.syntax,
            JsAnyStatement::JsForOfStatement(it) => &it.syntax,
            JsAnyStatement::JsForStatement(it) => &it.syntax,
            JsAnyStatement::JsFunctionDeclaration(it) => &it.syntax,
            JsAnyStatement::JsIfStatement(it) => &it.syntax,
            JsAnyStatement::JsLabeledStatement(it) => &it.syntax,
            JsAnyStatement::JsReturnStatement(it) => &it.syntax,
            JsAnyStatement::JsSwitchStatement(it) => &it.syntax,
            JsAnyStatement::JsThrowStatement(it) => &it.syntax,
            JsAnyStatement::JsTryFinallyStatement(it) => &it.syntax,
            JsAnyStatement::JsTryStatement(it) => &it.syntax,
            JsAnyStatement::JsUnknownStatement(it) => &it.syntax,
            JsAnyStatement::JsVariableStatement(it) => &it.syntax,
            JsAnyStatement::JsWhileStatement(it) => &it.syntax,
            JsAnyStatement::JsWithStatement(it) => &it.syntax,
            JsAnyStatement::TsDeclareFunctionDeclaration(it) => &it.syntax,
            JsAnyStatement::TsDeclareStatement(it) => &it.syntax,
            JsAnyStatement::TsEnumDeclaration(it) => &it.syntax,
            JsAnyStatement::TsExternalModuleDeclaration(it) => &it.syntax,
            JsAnyStatement::TsGlobalDeclaration(it) => &it.syntax,
            JsAnyStatement::TsImportEqualsDeclaration(it) => &it.syntax,
            JsAnyStatement::TsInterfaceDeclaration(it) => &it.syntax,
            JsAnyStatement::TsModuleDeclaration(it) => &it.syntax,
            JsAnyStatement::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyStatement::JsBlockStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsBreakStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsContinueStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsDebuggerStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsDoWhileStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsEmptyStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsExpressionStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsForInStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsForOfStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsForStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsIfStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsLabeledStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsReturnStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsSwitchStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsThrowStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsTryFinallyStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsTryStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsUnknownStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsVariableStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsWhileStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsWithStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsDeclareStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyStatement> for JsSyntaxNode {
    fn from(n: JsAnyStatement) -> JsSyntaxNode {
        match n {
            JsAnyStatement::JsBlockStatement(it) => it.into(),
            JsAnyStatement::JsBreakStatement(it) => it.into(),
            JsAnyStatement::JsClassDeclaration(it) => it.into(),
            JsAnyStatement::JsContinueStatement(it) => it.into(),
            JsAnyStatement::JsDebuggerStatement(it) => it.into(),
            JsAnyStatement::JsDoWhileStatement(it) => it.into(),
            JsAnyStatement::JsEmptyStatement(it) => it.into(),
            JsAnyStatement::JsExpressionStatement(it) => it.into(),
            JsAnyStatement::JsForInStatement(it) => it.into(),
            JsAnyStatement::JsForOfStatement(it) => it.into(),
            JsAnyStatement::JsForStatement(it) => it.into(),
            JsAnyStatement::JsFunctionDeclaration(it) => it.into(),
            JsAnyStatement::JsIfStatement(it) => it.into(),
            JsAnyStatement::JsLabeledStatement(it) => it.into(),
            JsAnyStatement::JsReturnStatement(it) => it.into(),
            JsAnyStatement::JsSwitchStatement(it) => it.into(),
            JsAnyStatement::JsThrowStatement(it) => it.into(),
            JsAnyStatement::JsTryFinallyStatement(it) => it.into(),
            JsAnyStatement::JsTryStatement(it) => it.into(),
            JsAnyStatement::JsUnknownStatement(it) => it.into(),
            JsAnyStatement::JsVariableStatement(it) => it.into(),
            JsAnyStatement::JsWhileStatement(it) => it.into(),
            JsAnyStatement::JsWithStatement(it) => it.into(),
            JsAnyStatement::TsDeclareFunctionDeclaration(it) => it.into(),
            JsAnyStatement::TsDeclareStatement(it) => it.into(),
            JsAnyStatement::TsEnumDeclaration(it) => it.into(),
            JsAnyStatement::TsExternalModuleDeclaration(it) => it.into(),
            JsAnyStatement::TsGlobalDeclaration(it) => it.into(),
            JsAnyStatement::TsImportEqualsDeclaration(it) => it.into(),
            JsAnyStatement::TsInterfaceDeclaration(it) => it.into(),
            JsAnyStatement::TsModuleDeclaration(it) => it.into(),
            JsAnyStatement::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyStatement> for JsSyntaxElement {
    fn from(n: JsAnyStatement) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsCaseClause> for JsAnySwitchClause {
    fn from(node: JsCaseClause) -> JsAnySwitchClause {
        JsAnySwitchClause::JsCaseClause(node)
    }
}
impl From<JsDefaultClause> for JsAnySwitchClause {
    fn from(node: JsDefaultClause) -> JsAnySwitchClause {
        JsAnySwitchClause::JsDefaultClause(node)
    }
}
impl AstNode<JsLanguage> for JsAnySwitchClause {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_CASE_CLAUSE | JS_DEFAULT_CLAUSE)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CASE_CLAUSE => JsAnySwitchClause::JsCaseClause(JsCaseClause { syntax }),
            JS_DEFAULT_CLAUSE => JsAnySwitchClause::JsDefaultClause(JsDefaultClause { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnySwitchClause::JsCaseClause(it) => &it.syntax,
            JsAnySwitchClause::JsDefaultClause(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnySwitchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnySwitchClause::JsCaseClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnySwitchClause::JsDefaultClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnySwitchClause> for JsSyntaxNode {
    fn from(n: JsAnySwitchClause) -> JsSyntaxNode {
        match n {
            JsAnySwitchClause::JsCaseClause(it) => it.into(),
            JsAnySwitchClause::JsDefaultClause(it) => it.into(),
        }
    }
}
impl From<JsAnySwitchClause> for JsSyntaxElement {
    fn from(n: JsAnySwitchClause) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsTemplateChunkElement> for JsAnyTemplateElement {
    fn from(node: JsTemplateChunkElement) -> JsAnyTemplateElement {
        JsAnyTemplateElement::JsTemplateChunkElement(node)
    }
}
impl From<JsTemplateElement> for JsAnyTemplateElement {
    fn from(node: JsTemplateElement) -> JsAnyTemplateElement {
        JsAnyTemplateElement::JsTemplateElement(node)
    }
}
impl AstNode<JsLanguage> for JsAnyTemplateElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_TEMPLATE_CHUNK_ELEMENT | JS_TEMPLATE_ELEMENT)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_TEMPLATE_CHUNK_ELEMENT => {
                JsAnyTemplateElement::JsTemplateChunkElement(JsTemplateChunkElement { syntax })
            }
            JS_TEMPLATE_ELEMENT => {
                JsAnyTemplateElement::JsTemplateElement(JsTemplateElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsAnyTemplateElement::JsTemplateChunkElement(it) => &it.syntax,
            JsAnyTemplateElement::JsTemplateElement(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyTemplateElement::JsTemplateChunkElement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyTemplateElement::JsTemplateElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyTemplateElement> for JsSyntaxNode {
    fn from(n: JsAnyTemplateElement) -> JsSyntaxNode {
        match n {
            JsAnyTemplateElement::JsTemplateChunkElement(it) => it.into(),
            JsAnyTemplateElement::JsTemplateElement(it) => it.into(),
        }
    }
}
impl From<JsAnyTemplateElement> for JsSyntaxElement {
    fn from(n: JsAnyTemplateElement) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxAttribute> for JsxAnyAttribute {
    fn from(node: JsxAttribute) -> JsxAnyAttribute {
        JsxAnyAttribute::JsxAttribute(node)
    }
}
impl From<JsxSpreadAttribute> for JsxAnyAttribute {
    fn from(node: JsxSpreadAttribute) -> JsxAnyAttribute {
        JsxAnyAttribute::JsxSpreadAttribute(node)
    }
}
impl AstNode<JsLanguage> for JsxAnyAttribute {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JSX_ATTRIBUTE | JSX_SPREAD_ATTRIBUTE)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ATTRIBUTE => JsxAnyAttribute::JsxAttribute(JsxAttribute { syntax }),
            JSX_SPREAD_ATTRIBUTE => {
                JsxAnyAttribute::JsxSpreadAttribute(JsxSpreadAttribute { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsxAnyAttribute::JsxAttribute(it) => &it.syntax,
            JsxAnyAttribute::JsxSpreadAttribute(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyAttribute::JsxAttribute(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyAttribute::JsxSpreadAttribute(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyAttribute> for JsSyntaxNode {
    fn from(n: JsxAnyAttribute) -> JsSyntaxNode {
        match n {
            JsxAnyAttribute::JsxAttribute(it) => it.into(),
            JsxAnyAttribute::JsxSpreadAttribute(it) => it.into(),
        }
    }
}
impl From<JsxAnyAttribute> for JsSyntaxElement {
    fn from(n: JsxAnyAttribute) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxName> for JsxAnyAttributeName {
    fn from(node: JsxName) -> JsxAnyAttributeName {
        JsxAnyAttributeName::JsxName(node)
    }
}
impl From<JsxNamespaceName> for JsxAnyAttributeName {
    fn from(node: JsxNamespaceName) -> JsxAnyAttributeName {
        JsxAnyAttributeName::JsxNamespaceName(node)
    }
}
impl AstNode<JsLanguage> for JsxAnyAttributeName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JSX_NAME | JSX_NAMESPACE_NAME)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_NAME => JsxAnyAttributeName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => {
                JsxAnyAttributeName::JsxNamespaceName(JsxNamespaceName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsxAnyAttributeName::JsxName(it) => &it.syntax,
            JsxAnyAttributeName::JsxNamespaceName(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyAttributeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyAttributeName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyAttributeName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyAttributeName> for JsSyntaxNode {
    fn from(n: JsxAnyAttributeName) -> JsSyntaxNode {
        match n {
            JsxAnyAttributeName::JsxName(it) => it.into(),
            JsxAnyAttributeName::JsxNamespaceName(it) => it.into(),
        }
    }
}
impl From<JsxAnyAttributeName> for JsSyntaxElement {
    fn from(n: JsxAnyAttributeName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxExpressionAttributeValue> for JsxAnyAttributeValue {
    fn from(node: JsxExpressionAttributeValue) -> JsxAnyAttributeValue {
        JsxAnyAttributeValue::JsxExpressionAttributeValue(node)
    }
}
impl From<JsxString> for JsxAnyAttributeValue {
    fn from(node: JsxString) -> JsxAnyAttributeValue {
        JsxAnyAttributeValue::JsxString(node)
    }
}
impl AstNode<JsLanguage> for JsxAnyAttributeValue {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            JSX_EXPRESSION_ATTRIBUTE_VALUE | JSX_STRING => true,
            k if JsxAnyTag::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_EXPRESSION_ATTRIBUTE_VALUE => {
                JsxAnyAttributeValue::JsxExpressionAttributeValue(JsxExpressionAttributeValue {
                    syntax,
                })
            }
            JSX_STRING => JsxAnyAttributeValue::JsxString(JsxString { syntax }),
            _ => {
                if let Some(jsx_any_tag) = JsxAnyTag::cast(syntax) {
                    return Some(JsxAnyAttributeValue::JsxAnyTag(jsx_any_tag));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsxAnyAttributeValue::JsxExpressionAttributeValue(it) => &it.syntax,
            JsxAnyAttributeValue::JsxString(it) => &it.syntax,
            JsxAnyAttributeValue::JsxAnyTag(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for JsxAnyAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyAttributeValue::JsxAnyTag(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyAttributeValue::JsxExpressionAttributeValue(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyAttributeValue::JsxString(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyAttributeValue> for JsSyntaxNode {
    fn from(n: JsxAnyAttributeValue) -> JsSyntaxNode {
        match n {
            JsxAnyAttributeValue::JsxAnyTag(it) => it.into(),
            JsxAnyAttributeValue::JsxExpressionAttributeValue(it) => it.into(),
            JsxAnyAttributeValue::JsxString(it) => it.into(),
        }
    }
}
impl From<JsxAnyAttributeValue> for JsSyntaxElement {
    fn from(n: JsxAnyAttributeValue) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxElement> for JsxAnyChild {
    fn from(node: JsxElement) -> JsxAnyChild {
        JsxAnyChild::JsxElement(node)
    }
}
impl From<JsxExpressionChild> for JsxAnyChild {
    fn from(node: JsxExpressionChild) -> JsxAnyChild {
        JsxAnyChild::JsxExpressionChild(node)
    }
}
impl From<JsxFragment> for JsxAnyChild {
    fn from(node: JsxFragment) -> JsxAnyChild {
        JsxAnyChild::JsxFragment(node)
    }
}
impl From<JsxSelfClosingElement> for JsxAnyChild {
    fn from(node: JsxSelfClosingElement) -> JsxAnyChild {
        JsxAnyChild::JsxSelfClosingElement(node)
    }
}
impl From<JsxSpreadChild> for JsxAnyChild {
    fn from(node: JsxSpreadChild) -> JsxAnyChild {
        JsxAnyChild::JsxSpreadChild(node)
    }
}
impl From<JsxText> for JsxAnyChild {
    fn from(node: JsxText) -> JsxAnyChild {
        JsxAnyChild::JsxText(node)
    }
}
impl AstNode<JsLanguage> for JsxAnyChild {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JSX_ELEMENT
                | JSX_EXPRESSION_CHILD
                | JSX_FRAGMENT
                | JSX_SELF_CLOSING_ELEMENT
                | JSX_SPREAD_CHILD
                | JSX_TEXT
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ELEMENT => JsxAnyChild::JsxElement(JsxElement { syntax }),
            JSX_EXPRESSION_CHILD => JsxAnyChild::JsxExpressionChild(JsxExpressionChild { syntax }),
            JSX_FRAGMENT => JsxAnyChild::JsxFragment(JsxFragment { syntax }),
            JSX_SELF_CLOSING_ELEMENT => {
                JsxAnyChild::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
            }
            JSX_SPREAD_CHILD => JsxAnyChild::JsxSpreadChild(JsxSpreadChild { syntax }),
            JSX_TEXT => JsxAnyChild::JsxText(JsxText { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsxAnyChild::JsxElement(it) => &it.syntax,
            JsxAnyChild::JsxExpressionChild(it) => &it.syntax,
            JsxAnyChild::JsxFragment(it) => &it.syntax,
            JsxAnyChild::JsxSelfClosingElement(it) => &it.syntax,
            JsxAnyChild::JsxSpreadChild(it) => &it.syntax,
            JsxAnyChild::JsxText(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyChild::JsxElement(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxExpressionChild(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxFragment(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxSelfClosingElement(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxSpreadChild(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxText(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyChild> for JsSyntaxNode {
    fn from(n: JsxAnyChild) -> JsSyntaxNode {
        match n {
            JsxAnyChild::JsxElement(it) => it.into(),
            JsxAnyChild::JsxExpressionChild(it) => it.into(),
            JsxAnyChild::JsxFragment(it) => it.into(),
            JsxAnyChild::JsxSelfClosingElement(it) => it.into(),
            JsxAnyChild::JsxSpreadChild(it) => it.into(),
            JsxAnyChild::JsxText(it) => it.into(),
        }
    }
}
impl From<JsxAnyChild> for JsSyntaxElement {
    fn from(n: JsxAnyChild) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxMemberName> for JsxAnyElementName {
    fn from(node: JsxMemberName) -> JsxAnyElementName {
        JsxAnyElementName::JsxMemberName(node)
    }
}
impl From<JsxName> for JsxAnyElementName {
    fn from(node: JsxName) -> JsxAnyElementName {
        JsxAnyElementName::JsxName(node)
    }
}
impl From<JsxNamespaceName> for JsxAnyElementName {
    fn from(node: JsxNamespaceName) -> JsxAnyElementName {
        JsxAnyElementName::JsxNamespaceName(node)
    }
}
impl From<JsxReferenceIdentifier> for JsxAnyElementName {
    fn from(node: JsxReferenceIdentifier) -> JsxAnyElementName {
        JsxAnyElementName::JsxReferenceIdentifier(node)
    }
}
impl AstNode<JsLanguage> for JsxAnyElementName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JSX_MEMBER_NAME | JSX_NAME | JSX_NAMESPACE_NAME | JSX_REFERENCE_IDENTIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_MEMBER_NAME => JsxAnyElementName::JsxMemberName(JsxMemberName { syntax }),
            JSX_NAME => JsxAnyElementName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => JsxAnyElementName::JsxNamespaceName(JsxNamespaceName { syntax }),
            JSX_REFERENCE_IDENTIFIER => {
                JsxAnyElementName::JsxReferenceIdentifier(JsxReferenceIdentifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsxAnyElementName::JsxMemberName(it) => &it.syntax,
            JsxAnyElementName::JsxName(it) => &it.syntax,
            JsxAnyElementName::JsxNamespaceName(it) => &it.syntax,
            JsxAnyElementName::JsxReferenceIdentifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyElementName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyElementName::JsxMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyElementName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyElementName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyElementName::JsxReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyElementName> for JsSyntaxNode {
    fn from(n: JsxAnyElementName) -> JsSyntaxNode {
        match n {
            JsxAnyElementName::JsxMemberName(it) => it.into(),
            JsxAnyElementName::JsxName(it) => it.into(),
            JsxAnyElementName::JsxNamespaceName(it) => it.into(),
            JsxAnyElementName::JsxReferenceIdentifier(it) => it.into(),
        }
    }
}
impl From<JsxAnyElementName> for JsSyntaxElement {
    fn from(n: JsxAnyElementName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxName> for JsxAnyName {
    fn from(node: JsxName) -> JsxAnyName {
        JsxAnyName::JsxName(node)
    }
}
impl From<JsxNamespaceName> for JsxAnyName {
    fn from(node: JsxNamespaceName) -> JsxAnyName {
        JsxAnyName::JsxNamespaceName(node)
    }
}
impl AstNode<JsLanguage> for JsxAnyName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JSX_NAME | JSX_NAMESPACE_NAME)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_NAME => JsxAnyName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => JsxAnyName::JsxNamespaceName(JsxNamespaceName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsxAnyName::JsxName(it) => &it.syntax,
            JsxAnyName::JsxNamespaceName(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyName> for JsSyntaxNode {
    fn from(n: JsxAnyName) -> JsSyntaxNode {
        match n {
            JsxAnyName::JsxName(it) => it.into(),
            JsxAnyName::JsxNamespaceName(it) => it.into(),
        }
    }
}
impl From<JsxAnyName> for JsSyntaxElement {
    fn from(n: JsxAnyName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxMemberName> for JsxAnyObjectName {
    fn from(node: JsxMemberName) -> JsxAnyObjectName {
        JsxAnyObjectName::JsxMemberName(node)
    }
}
impl From<JsxNamespaceName> for JsxAnyObjectName {
    fn from(node: JsxNamespaceName) -> JsxAnyObjectName {
        JsxAnyObjectName::JsxNamespaceName(node)
    }
}
impl From<JsxReferenceIdentifier> for JsxAnyObjectName {
    fn from(node: JsxReferenceIdentifier) -> JsxAnyObjectName {
        JsxAnyObjectName::JsxReferenceIdentifier(node)
    }
}
impl AstNode<JsLanguage> for JsxAnyObjectName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JSX_MEMBER_NAME | JSX_NAMESPACE_NAME | JSX_REFERENCE_IDENTIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_MEMBER_NAME => JsxAnyObjectName::JsxMemberName(JsxMemberName { syntax }),
            JSX_NAMESPACE_NAME => JsxAnyObjectName::JsxNamespaceName(JsxNamespaceName { syntax }),
            JSX_REFERENCE_IDENTIFIER => {
                JsxAnyObjectName::JsxReferenceIdentifier(JsxReferenceIdentifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsxAnyObjectName::JsxMemberName(it) => &it.syntax,
            JsxAnyObjectName::JsxNamespaceName(it) => &it.syntax,
            JsxAnyObjectName::JsxReferenceIdentifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyObjectName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyObjectName::JsxMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyObjectName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyObjectName::JsxReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyObjectName> for JsSyntaxNode {
    fn from(n: JsxAnyObjectName) -> JsSyntaxNode {
        match n {
            JsxAnyObjectName::JsxMemberName(it) => it.into(),
            JsxAnyObjectName::JsxNamespaceName(it) => it.into(),
            JsxAnyObjectName::JsxReferenceIdentifier(it) => it.into(),
        }
    }
}
impl From<JsxAnyObjectName> for JsSyntaxElement {
    fn from(n: JsxAnyObjectName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxElement> for JsxAnyTag {
    fn from(node: JsxElement) -> JsxAnyTag {
        JsxAnyTag::JsxElement(node)
    }
}
impl From<JsxFragment> for JsxAnyTag {
    fn from(node: JsxFragment) -> JsxAnyTag {
        JsxAnyTag::JsxFragment(node)
    }
}
impl From<JsxSelfClosingElement> for JsxAnyTag {
    fn from(node: JsxSelfClosingElement) -> JsxAnyTag {
        JsxAnyTag::JsxSelfClosingElement(node)
    }
}
impl AstNode<JsLanguage> for JsxAnyTag {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JSX_ELEMENT | JSX_FRAGMENT | JSX_SELF_CLOSING_ELEMENT)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ELEMENT => JsxAnyTag::JsxElement(JsxElement { syntax }),
            JSX_FRAGMENT => JsxAnyTag::JsxFragment(JsxFragment { syntax }),
            JSX_SELF_CLOSING_ELEMENT => {
                JsxAnyTag::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            JsxAnyTag::JsxElement(it) => &it.syntax,
            JsxAnyTag::JsxFragment(it) => &it.syntax,
            JsxAnyTag::JsxSelfClosingElement(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyTag::JsxElement(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyTag::JsxFragment(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyTag::JsxSelfClosingElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyTag> for JsSyntaxNode {
    fn from(n: JsxAnyTag) -> JsSyntaxNode {
        match n {
            JsxAnyTag::JsxElement(it) => it.into(),
            JsxAnyTag::JsxFragment(it) => it.into(),
            JsxAnyTag::JsxSelfClosingElement(it) => it.into(),
        }
    }
}
impl From<JsxAnyTag> for JsSyntaxElement {
    fn from(n: JsxAnyTag) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsEmptyExternalModuleDeclarationBody> for TsAnyExternalModuleDeclarationBody {
    fn from(node: TsEmptyExternalModuleDeclarationBody) -> TsAnyExternalModuleDeclarationBody {
        TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(node)
    }
}
impl From<TsModuleBlock> for TsAnyExternalModuleDeclarationBody {
    fn from(node: TsModuleBlock) -> TsAnyExternalModuleDeclarationBody {
        TsAnyExternalModuleDeclarationBody::TsModuleBlock(node)
    }
}
impl AstNode<JsLanguage> for TsAnyExternalModuleDeclarationBody {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY | TS_MODULE_BLOCK
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY => {
                TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(
                    TsEmptyExternalModuleDeclarationBody { syntax },
                )
            }
            TS_MODULE_BLOCK => {
                TsAnyExternalModuleDeclarationBody::TsModuleBlock(TsModuleBlock { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                &it.syntax
            }
            TsAnyExternalModuleDeclarationBody::TsModuleBlock(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyExternalModuleDeclarationBody::TsModuleBlock(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyExternalModuleDeclarationBody> for JsSyntaxNode {
    fn from(n: TsAnyExternalModuleDeclarationBody) -> JsSyntaxNode {
        match n {
            TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                it.into()
            }
            TsAnyExternalModuleDeclarationBody::TsModuleBlock(it) => it.into(),
        }
    }
}
impl From<TsAnyExternalModuleDeclarationBody> for JsSyntaxElement {
    fn from(n: TsAnyExternalModuleDeclarationBody) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for TsAnyIndexSignatureModifier {
    fn from(node: JsStaticModifier) -> TsAnyIndexSignatureModifier {
        TsAnyIndexSignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsReadonlyModifier> for TsAnyIndexSignatureModifier {
    fn from(node: TsReadonlyModifier) -> TsAnyIndexSignatureModifier {
        TsAnyIndexSignatureModifier::TsReadonlyModifier(node)
    }
}
impl AstNode<JsLanguage> for TsAnyIndexSignatureModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_STATIC_MODIFIER | TS_READONLY_MODIFIER)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                TsAnyIndexSignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                TsAnyIndexSignatureModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyIndexSignatureModifier::JsStaticModifier(it) => &it.syntax,
            TsAnyIndexSignatureModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyIndexSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyIndexSignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyIndexSignatureModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyIndexSignatureModifier> for JsSyntaxNode {
    fn from(n: TsAnyIndexSignatureModifier) -> JsSyntaxNode {
        match n {
            TsAnyIndexSignatureModifier::JsStaticModifier(it) => it.into(),
            TsAnyIndexSignatureModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<TsAnyIndexSignatureModifier> for JsSyntaxElement {
    fn from(n: TsAnyIndexSignatureModifier) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for TsAnyMethodSignatureModifier {
    fn from(node: JsStaticModifier) -> TsAnyMethodSignatureModifier {
        TsAnyMethodSignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsAbstractModifier> for TsAnyMethodSignatureModifier {
    fn from(node: TsAbstractModifier) -> TsAnyMethodSignatureModifier {
        TsAnyMethodSignatureModifier::TsAbstractModifier(node)
    }
}
impl From<TsAccessibilityModifier> for TsAnyMethodSignatureModifier {
    fn from(node: TsAccessibilityModifier) -> TsAnyMethodSignatureModifier {
        TsAnyMethodSignatureModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for TsAnyMethodSignatureModifier {
    fn from(node: TsOverrideModifier) -> TsAnyMethodSignatureModifier {
        TsAnyMethodSignatureModifier::TsOverrideModifier(node)
    }
}
impl AstNode<JsLanguage> for TsAnyMethodSignatureModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER
                | TS_ABSTRACT_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_OVERRIDE_MODIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                TsAnyMethodSignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ABSTRACT_MODIFIER => {
                TsAnyMethodSignatureModifier::TsAbstractModifier(TsAbstractModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                TsAnyMethodSignatureModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_OVERRIDE_MODIFIER => {
                TsAnyMethodSignatureModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyMethodSignatureModifier::JsStaticModifier(it) => &it.syntax,
            TsAnyMethodSignatureModifier::TsAbstractModifier(it) => &it.syntax,
            TsAnyMethodSignatureModifier::TsAccessibilityModifier(it) => &it.syntax,
            TsAnyMethodSignatureModifier::TsOverrideModifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyMethodSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyMethodSignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyMethodSignatureModifier::TsAbstractModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyMethodSignatureModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyMethodSignatureModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyMethodSignatureModifier> for JsSyntaxNode {
    fn from(n: TsAnyMethodSignatureModifier) -> JsSyntaxNode {
        match n {
            TsAnyMethodSignatureModifier::JsStaticModifier(it) => it.into(),
            TsAnyMethodSignatureModifier::TsAbstractModifier(it) => it.into(),
            TsAnyMethodSignatureModifier::TsAccessibilityModifier(it) => it.into(),
            TsAnyMethodSignatureModifier::TsOverrideModifier(it) => it.into(),
        }
    }
}
impl From<TsAnyMethodSignatureModifier> for JsSyntaxElement {
    fn from(n: TsAnyMethodSignatureModifier) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsIdentifierBinding> for TsAnyModuleName {
    fn from(node: TsIdentifierBinding) -> TsAnyModuleName {
        TsAnyModuleName::TsIdentifierBinding(node)
    }
}
impl From<TsQualifiedModuleName> for TsAnyModuleName {
    fn from(node: TsQualifiedModuleName) -> TsAnyModuleName {
        TsAnyModuleName::TsQualifiedModuleName(node)
    }
}
impl AstNode<JsLanguage> for TsAnyModuleName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, TS_IDENTIFIER_BINDING | TS_QUALIFIED_MODULE_NAME)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_IDENTIFIER_BINDING => {
                TsAnyModuleName::TsIdentifierBinding(TsIdentifierBinding { syntax })
            }
            TS_QUALIFIED_MODULE_NAME => {
                TsAnyModuleName::TsQualifiedModuleName(TsQualifiedModuleName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyModuleName::TsIdentifierBinding(it) => &it.syntax,
            TsAnyModuleName::TsQualifiedModuleName(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyModuleName::TsIdentifierBinding(it) => std::fmt::Debug::fmt(it, f),
            TsAnyModuleName::TsQualifiedModuleName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyModuleName> for JsSyntaxNode {
    fn from(n: TsAnyModuleName) -> JsSyntaxNode {
        match n {
            TsAnyModuleName::TsIdentifierBinding(it) => it.into(),
            TsAnyModuleName::TsQualifiedModuleName(it) => it.into(),
        }
    }
}
impl From<TsAnyModuleName> for JsSyntaxElement {
    fn from(n: TsAnyModuleName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsExternalModuleReference> for TsAnyModuleReference {
    fn from(node: TsExternalModuleReference) -> TsAnyModuleReference {
        TsAnyModuleReference::TsExternalModuleReference(node)
    }
}
impl AstNode<JsLanguage> for TsAnyModuleReference {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            TS_EXTERNAL_MODULE_REFERENCE => true,
            k if TsAnyName::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_EXTERNAL_MODULE_REFERENCE => {
                TsAnyModuleReference::TsExternalModuleReference(TsExternalModuleReference {
                    syntax,
                })
            }
            _ => {
                if let Some(ts_any_name) = TsAnyName::cast(syntax) {
                    return Some(TsAnyModuleReference::TsAnyName(ts_any_name));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyModuleReference::TsExternalModuleReference(it) => &it.syntax,
            TsAnyModuleReference::TsAnyName(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for TsAnyModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyModuleReference::TsAnyName(it) => std::fmt::Debug::fmt(it, f),
            TsAnyModuleReference::TsExternalModuleReference(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyModuleReference> for JsSyntaxNode {
    fn from(n: TsAnyModuleReference) -> JsSyntaxNode {
        match n {
            TsAnyModuleReference::TsAnyName(it) => it.into(),
            TsAnyModuleReference::TsExternalModuleReference(it) => it.into(),
        }
    }
}
impl From<TsAnyModuleReference> for JsSyntaxElement {
    fn from(n: TsAnyModuleReference) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsReferenceIdentifier> for TsAnyName {
    fn from(node: JsReferenceIdentifier) -> TsAnyName {
        TsAnyName::JsReferenceIdentifier(node)
    }
}
impl From<TsQualifiedName> for TsAnyName {
    fn from(node: TsQualifiedName) -> TsAnyName {
        TsAnyName::TsQualifiedName(node)
    }
}
impl AstNode<JsLanguage> for TsAnyName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_REFERENCE_IDENTIFIER | TS_QUALIFIED_NAME)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REFERENCE_IDENTIFIER => {
                TsAnyName::JsReferenceIdentifier(JsReferenceIdentifier { syntax })
            }
            TS_QUALIFIED_NAME => TsAnyName::TsQualifiedName(TsQualifiedName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyName::JsReferenceIdentifier(it) => &it.syntax,
            TsAnyName::TsQualifiedName(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyName::JsReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyName::TsQualifiedName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyName> for JsSyntaxNode {
    fn from(n: TsAnyName) -> JsSyntaxNode {
        match n {
            TsAnyName::JsReferenceIdentifier(it) => it.into(),
            TsAnyName::TsQualifiedName(it) => it.into(),
        }
    }
}
impl From<TsAnyName> for JsSyntaxElement {
    fn from(n: TsAnyName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsDefinitePropertyAnnotation> for TsAnyPropertyAnnotation {
    fn from(node: TsDefinitePropertyAnnotation) -> TsAnyPropertyAnnotation {
        TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(node)
    }
}
impl From<TsOptionalPropertyAnnotation> for TsAnyPropertyAnnotation {
    fn from(node: TsOptionalPropertyAnnotation) -> TsAnyPropertyAnnotation {
        TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for TsAnyPropertyAnnotation {
    fn from(node: TsTypeAnnotation) -> TsAnyPropertyAnnotation {
        TsAnyPropertyAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode<JsLanguage> for TsAnyPropertyAnnotation {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            TS_DEFINITE_PROPERTY_ANNOTATION | TS_OPTIONAL_PROPERTY_ANNOTATION | TS_TYPE_ANNOTATION
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_DEFINITE_PROPERTY_ANNOTATION => {
                TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(
                    TsDefinitePropertyAnnotation { syntax },
                )
            }
            TS_OPTIONAL_PROPERTY_ANNOTATION => {
                TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(
                    TsOptionalPropertyAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                TsAnyPropertyAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(it) => &it.syntax,
            TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(it) => &it.syntax,
            TsAnyPropertyAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertyAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyPropertyAnnotation> for JsSyntaxNode {
    fn from(n: TsAnyPropertyAnnotation) -> JsSyntaxNode {
        match n {
            TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(it) => it.into(),
            TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(it) => it.into(),
            TsAnyPropertyAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<TsAnyPropertyAnnotation> for JsSyntaxElement {
    fn from(n: TsAnyPropertyAnnotation) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAccessibilityModifier> for TsAnyPropertyParameterModifier {
    fn from(node: TsAccessibilityModifier) -> TsAnyPropertyParameterModifier {
        TsAnyPropertyParameterModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for TsAnyPropertyParameterModifier {
    fn from(node: TsOverrideModifier) -> TsAnyPropertyParameterModifier {
        TsAnyPropertyParameterModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for TsAnyPropertyParameterModifier {
    fn from(node: TsReadonlyModifier) -> TsAnyPropertyParameterModifier {
        TsAnyPropertyParameterModifier::TsReadonlyModifier(node)
    }
}
impl AstNode<JsLanguage> for TsAnyPropertyParameterModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            TS_ACCESSIBILITY_MODIFIER | TS_OVERRIDE_MODIFIER | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ACCESSIBILITY_MODIFIER => {
                TsAnyPropertyParameterModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_OVERRIDE_MODIFIER => {
                TsAnyPropertyParameterModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                TsAnyPropertyParameterModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyPropertyParameterModifier::TsAccessibilityModifier(it) => &it.syntax,
            TsAnyPropertyParameterModifier::TsOverrideModifier(it) => &it.syntax,
            TsAnyPropertyParameterModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyPropertyParameterModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyPropertyParameterModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertyParameterModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertyParameterModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyPropertyParameterModifier> for JsSyntaxNode {
    fn from(n: TsAnyPropertyParameterModifier) -> JsSyntaxNode {
        match n {
            TsAnyPropertyParameterModifier::TsAccessibilityModifier(it) => it.into(),
            TsAnyPropertyParameterModifier::TsOverrideModifier(it) => it.into(),
            TsAnyPropertyParameterModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<TsAnyPropertyParameterModifier> for JsSyntaxElement {
    fn from(n: TsAnyPropertyParameterModifier) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsOptionalPropertyAnnotation> for TsAnyPropertySignatureAnnotation {
    fn from(node: TsOptionalPropertyAnnotation) -> TsAnyPropertySignatureAnnotation {
        TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for TsAnyPropertySignatureAnnotation {
    fn from(node: TsTypeAnnotation) -> TsAnyPropertySignatureAnnotation {
        TsAnyPropertySignatureAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode<JsLanguage> for TsAnyPropertySignatureAnnotation {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, TS_OPTIONAL_PROPERTY_ANNOTATION | TS_TYPE_ANNOTATION)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_OPTIONAL_PROPERTY_ANNOTATION => {
                TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(
                    TsOptionalPropertyAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                TsAnyPropertySignatureAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => &it.syntax,
            TsAnyPropertySignatureAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyPropertySignatureAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertySignatureAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyPropertySignatureAnnotation> for JsSyntaxNode {
    fn from(n: TsAnyPropertySignatureAnnotation) -> JsSyntaxNode {
        match n {
            TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => it.into(),
            TsAnyPropertySignatureAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<TsAnyPropertySignatureAnnotation> for JsSyntaxElement {
    fn from(n: TsAnyPropertySignatureAnnotation) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for TsAnyPropertySignatureModifier {
    fn from(node: JsStaticModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsAbstractModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsAbstractModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsAbstractModifier(node)
    }
}
impl From<TsAccessibilityModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsAccessibilityModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsDeclareModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsDeclareModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsDeclareModifier(node)
    }
}
impl From<TsOverrideModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsOverrideModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsReadonlyModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsReadonlyModifier(node)
    }
}
impl AstNode<JsLanguage> for TsAnyPropertySignatureModifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER
                | TS_ABSTRACT_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_DECLARE_MODIFIER
                | TS_OVERRIDE_MODIFIER
                | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                TsAnyPropertySignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ABSTRACT_MODIFIER => {
                TsAnyPropertySignatureModifier::TsAbstractModifier(TsAbstractModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                TsAnyPropertySignatureModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_DECLARE_MODIFIER => {
                TsAnyPropertySignatureModifier::TsDeclareModifier(TsDeclareModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                TsAnyPropertySignatureModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                TsAnyPropertySignatureModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyPropertySignatureModifier::JsStaticModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsAbstractModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsAccessibilityModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsDeclareModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsOverrideModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyPropertySignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyPropertySignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertySignatureModifier::TsAbstractModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertySignatureModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertySignatureModifier::TsDeclareModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertySignatureModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertySignatureModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyPropertySignatureModifier> for JsSyntaxNode {
    fn from(n: TsAnyPropertySignatureModifier) -> JsSyntaxNode {
        match n {
            TsAnyPropertySignatureModifier::JsStaticModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsAbstractModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsAccessibilityModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsDeclareModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsOverrideModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<TsAnyPropertySignatureModifier> for JsSyntaxElement {
    fn from(n: TsAnyPropertySignatureModifier) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAssertsReturnType> for TsAnyReturnType {
    fn from(node: TsAssertsReturnType) -> TsAnyReturnType {
        TsAnyReturnType::TsAssertsReturnType(node)
    }
}
impl From<TsPredicateReturnType> for TsAnyReturnType {
    fn from(node: TsPredicateReturnType) -> TsAnyReturnType {
        TsAnyReturnType::TsPredicateReturnType(node)
    }
}
impl AstNode<JsLanguage> for TsAnyReturnType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            TS_ASSERTS_RETURN_TYPE | TS_PREDICATE_RETURN_TYPE => true,
            k if TsType::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ASSERTS_RETURN_TYPE => {
                TsAnyReturnType::TsAssertsReturnType(TsAssertsReturnType { syntax })
            }
            TS_PREDICATE_RETURN_TYPE => {
                TsAnyReturnType::TsPredicateReturnType(TsPredicateReturnType { syntax })
            }
            _ => {
                if let Some(ts_type) = TsType::cast(syntax) {
                    return Some(TsAnyReturnType::TsType(ts_type));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyReturnType::TsAssertsReturnType(it) => &it.syntax,
            TsAnyReturnType::TsPredicateReturnType(it) => &it.syntax,
            TsAnyReturnType::TsType(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for TsAnyReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyReturnType::TsAssertsReturnType(it) => std::fmt::Debug::fmt(it, f),
            TsAnyReturnType::TsPredicateReturnType(it) => std::fmt::Debug::fmt(it, f),
            TsAnyReturnType::TsType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyReturnType> for JsSyntaxNode {
    fn from(n: TsAnyReturnType) -> JsSyntaxNode {
        match n {
            TsAnyReturnType::TsAssertsReturnType(it) => it.into(),
            TsAnyReturnType::TsPredicateReturnType(it) => it.into(),
            TsAnyReturnType::TsType(it) => it.into(),
        }
    }
}
impl From<TsAnyReturnType> for JsSyntaxElement {
    fn from(n: TsAnyReturnType) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsTemplateChunkElement> for TsAnyTemplateElement {
    fn from(node: TsTemplateChunkElement) -> TsAnyTemplateElement {
        TsAnyTemplateElement::TsTemplateChunkElement(node)
    }
}
impl From<TsTemplateElement> for TsAnyTemplateElement {
    fn from(node: TsTemplateElement) -> TsAnyTemplateElement {
        TsAnyTemplateElement::TsTemplateElement(node)
    }
}
impl AstNode<JsLanguage> for TsAnyTemplateElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, TS_TEMPLATE_CHUNK_ELEMENT | TS_TEMPLATE_ELEMENT)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_TEMPLATE_CHUNK_ELEMENT => {
                TsAnyTemplateElement::TsTemplateChunkElement(TsTemplateChunkElement { syntax })
            }
            TS_TEMPLATE_ELEMENT => {
                TsAnyTemplateElement::TsTemplateElement(TsTemplateElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyTemplateElement::TsTemplateChunkElement(it) => &it.syntax,
            TsAnyTemplateElement::TsTemplateElement(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyTemplateElement::TsTemplateChunkElement(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTemplateElement::TsTemplateElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyTemplateElement> for JsSyntaxNode {
    fn from(n: TsAnyTemplateElement) -> JsSyntaxNode {
        match n {
            TsAnyTemplateElement::TsTemplateChunkElement(it) => it.into(),
            TsAnyTemplateElement::TsTemplateElement(it) => it.into(),
        }
    }
}
impl From<TsAnyTemplateElement> for JsSyntaxElement {
    fn from(n: TsAnyTemplateElement) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsNamedTupleTypeElement> for TsAnyTupleTypeElement {
    fn from(node: TsNamedTupleTypeElement) -> TsAnyTupleTypeElement {
        TsAnyTupleTypeElement::TsNamedTupleTypeElement(node)
    }
}
impl From<TsOptionalTupleTypeElement> for TsAnyTupleTypeElement {
    fn from(node: TsOptionalTupleTypeElement) -> TsAnyTupleTypeElement {
        TsAnyTupleTypeElement::TsOptionalTupleTypeElement(node)
    }
}
impl From<TsRestTupleTypeElement> for TsAnyTupleTypeElement {
    fn from(node: TsRestTupleTypeElement) -> TsAnyTupleTypeElement {
        TsAnyTupleTypeElement::TsRestTupleTypeElement(node)
    }
}
impl AstNode<JsLanguage> for TsAnyTupleTypeElement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        match kind {
            TS_NAMED_TUPLE_TYPE_ELEMENT
            | TS_OPTIONAL_TUPLE_TYPE_ELEMENT
            | TS_REST_TUPLE_TYPE_ELEMENT => true,
            k if TsType::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_NAMED_TUPLE_TYPE_ELEMENT => {
                TsAnyTupleTypeElement::TsNamedTupleTypeElement(TsNamedTupleTypeElement { syntax })
            }
            TS_OPTIONAL_TUPLE_TYPE_ELEMENT => {
                TsAnyTupleTypeElement::TsOptionalTupleTypeElement(TsOptionalTupleTypeElement {
                    syntax,
                })
            }
            TS_REST_TUPLE_TYPE_ELEMENT => {
                TsAnyTupleTypeElement::TsRestTupleTypeElement(TsRestTupleTypeElement { syntax })
            }
            _ => {
                if let Some(ts_type) = TsType::cast(syntax) {
                    return Some(TsAnyTupleTypeElement::TsType(ts_type));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyTupleTypeElement::TsNamedTupleTypeElement(it) => &it.syntax,
            TsAnyTupleTypeElement::TsOptionalTupleTypeElement(it) => &it.syntax,
            TsAnyTupleTypeElement::TsRestTupleTypeElement(it) => &it.syntax,
            TsAnyTupleTypeElement::TsType(it) => it.syntax(),
        }
    }
}
impl std::fmt::Debug for TsAnyTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyTupleTypeElement::TsNamedTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTupleTypeElement::TsOptionalTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTupleTypeElement::TsRestTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTupleTypeElement::TsType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyTupleTypeElement> for JsSyntaxNode {
    fn from(n: TsAnyTupleTypeElement) -> JsSyntaxNode {
        match n {
            TsAnyTupleTypeElement::TsNamedTupleTypeElement(it) => it.into(),
            TsAnyTupleTypeElement::TsOptionalTupleTypeElement(it) => it.into(),
            TsAnyTupleTypeElement::TsRestTupleTypeElement(it) => it.into(),
            TsAnyTupleTypeElement::TsType(it) => it.into(),
        }
    }
}
impl From<TsAnyTupleTypeElement> for JsSyntaxElement {
    fn from(n: TsAnyTupleTypeElement) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsUnknownMember> for TsAnyTypeMember {
    fn from(node: JsUnknownMember) -> TsAnyTypeMember {
        TsAnyTypeMember::JsUnknownMember(node)
    }
}
impl From<TsCallSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsCallSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsCallSignatureTypeMember(node)
    }
}
impl From<TsConstructSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsConstructSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsConstructSignatureTypeMember(node)
    }
}
impl From<TsGetterSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsGetterSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsGetterSignatureTypeMember(node)
    }
}
impl From<TsIndexSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsIndexSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsIndexSignatureTypeMember(node)
    }
}
impl From<TsMethodSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsMethodSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsMethodSignatureTypeMember(node)
    }
}
impl From<TsPropertySignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsPropertySignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsPropertySignatureTypeMember(node)
    }
}
impl From<TsSetterSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsSetterSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsSetterSignatureTypeMember(node)
    }
}
impl AstNode<JsLanguage> for TsAnyTypeMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            JS_UNKNOWN_MEMBER
                | TS_CALL_SIGNATURE_TYPE_MEMBER
                | TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER
                | TS_GETTER_SIGNATURE_TYPE_MEMBER
                | TS_INDEX_SIGNATURE_TYPE_MEMBER
                | TS_METHOD_SIGNATURE_TYPE_MEMBER
                | TS_PROPERTY_SIGNATURE_TYPE_MEMBER
                | TS_SETTER_SIGNATURE_TYPE_MEMBER
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_UNKNOWN_MEMBER => TsAnyTypeMember::JsUnknownMember(JsUnknownMember { syntax }),
            TS_CALL_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsCallSignatureTypeMember(TsCallSignatureTypeMember { syntax })
            }
            TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsConstructSignatureTypeMember(TsConstructSignatureTypeMember {
                    syntax,
                })
            }
            TS_GETTER_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsGetterSignatureTypeMember(TsGetterSignatureTypeMember { syntax })
            }
            TS_INDEX_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsIndexSignatureTypeMember(TsIndexSignatureTypeMember { syntax })
            }
            TS_METHOD_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsMethodSignatureTypeMember(TsMethodSignatureTypeMember { syntax })
            }
            TS_PROPERTY_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsPropertySignatureTypeMember(TsPropertySignatureTypeMember {
                    syntax,
                })
            }
            TS_SETTER_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsSetterSignatureTypeMember(TsSetterSignatureTypeMember { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyTypeMember::JsUnknownMember(it) => &it.syntax,
            TsAnyTypeMember::TsCallSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsConstructSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsGetterSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsIndexSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsMethodSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsPropertySignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsSetterSignatureTypeMember(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyTypeMember::JsUnknownMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsCallSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsConstructSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsGetterSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsIndexSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsMethodSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsPropertySignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsSetterSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyTypeMember> for JsSyntaxNode {
    fn from(n: TsAnyTypeMember) -> JsSyntaxNode {
        match n {
            TsAnyTypeMember::JsUnknownMember(it) => it.into(),
            TsAnyTypeMember::TsCallSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsConstructSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsGetterSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsIndexSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsMethodSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsPropertySignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsSetterSignatureTypeMember(it) => it.into(),
        }
    }
}
impl From<TsAnyTypeMember> for JsSyntaxElement {
    fn from(n: TsAnyTypeMember) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<JsReferenceIdentifier> for TsAnyTypePredicateParameterName {
    fn from(node: JsReferenceIdentifier) -> TsAnyTypePredicateParameterName {
        TsAnyTypePredicateParameterName::JsReferenceIdentifier(node)
    }
}
impl From<TsThisType> for TsAnyTypePredicateParameterName {
    fn from(node: TsThisType) -> TsAnyTypePredicateParameterName {
        TsAnyTypePredicateParameterName::TsThisType(node)
    }
}
impl AstNode<JsLanguage> for TsAnyTypePredicateParameterName {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, JS_REFERENCE_IDENTIFIER | TS_THIS_TYPE)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REFERENCE_IDENTIFIER => {
                TsAnyTypePredicateParameterName::JsReferenceIdentifier(JsReferenceIdentifier {
                    syntax,
                })
            }
            TS_THIS_TYPE => TsAnyTypePredicateParameterName::TsThisType(TsThisType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyTypePredicateParameterName::JsReferenceIdentifier(it) => &it.syntax,
            TsAnyTypePredicateParameterName::TsThisType(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyTypePredicateParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyTypePredicateParameterName::JsReferenceIdentifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyTypePredicateParameterName::TsThisType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyTypePredicateParameterName> for JsSyntaxNode {
    fn from(n: TsAnyTypePredicateParameterName) -> JsSyntaxNode {
        match n {
            TsAnyTypePredicateParameterName::JsReferenceIdentifier(it) => it.into(),
            TsAnyTypePredicateParameterName::TsThisType(it) => it.into(),
        }
    }
}
impl From<TsAnyTypePredicateParameterName> for JsSyntaxElement {
    fn from(n: TsAnyTypePredicateParameterName) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsDefiniteVariableAnnotation> for TsAnyVariableAnnotation {
    fn from(node: TsDefiniteVariableAnnotation) -> TsAnyVariableAnnotation {
        TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for TsAnyVariableAnnotation {
    fn from(node: TsTypeAnnotation) -> TsAnyVariableAnnotation {
        TsAnyVariableAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode<JsLanguage> for TsAnyVariableAnnotation {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(kind, TS_DEFINITE_VARIABLE_ANNOTATION | TS_TYPE_ANNOTATION)
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_DEFINITE_VARIABLE_ANNOTATION => {
                TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(
                    TsDefiniteVariableAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                TsAnyVariableAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(it) => &it.syntax,
            TsAnyVariableAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyVariableAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyVariableAnnotation> for JsSyntaxNode {
    fn from(n: TsAnyVariableAnnotation) -> JsSyntaxNode {
        match n {
            TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(it) => it.into(),
            TsAnyVariableAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<TsAnyVariableAnnotation> for JsSyntaxElement {
    fn from(n: TsAnyVariableAnnotation) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAnyType> for TsType {
    fn from(node: TsAnyType) -> TsType {
        TsType::TsAnyType(node)
    }
}
impl From<TsArrayType> for TsType {
    fn from(node: TsArrayType) -> TsType {
        TsType::TsArrayType(node)
    }
}
impl From<TsBigIntLiteralType> for TsType {
    fn from(node: TsBigIntLiteralType) -> TsType {
        TsType::TsBigIntLiteralType(node)
    }
}
impl From<TsBigintType> for TsType {
    fn from(node: TsBigintType) -> TsType {
        TsType::TsBigintType(node)
    }
}
impl From<TsBooleanLiteralType> for TsType {
    fn from(node: TsBooleanLiteralType) -> TsType {
        TsType::TsBooleanLiteralType(node)
    }
}
impl From<TsBooleanType> for TsType {
    fn from(node: TsBooleanType) -> TsType {
        TsType::TsBooleanType(node)
    }
}
impl From<TsConditionalType> for TsType {
    fn from(node: TsConditionalType) -> TsType {
        TsType::TsConditionalType(node)
    }
}
impl From<TsConstructorType> for TsType {
    fn from(node: TsConstructorType) -> TsType {
        TsType::TsConstructorType(node)
    }
}
impl From<TsFunctionType> for TsType {
    fn from(node: TsFunctionType) -> TsType {
        TsType::TsFunctionType(node)
    }
}
impl From<TsImportType> for TsType {
    fn from(node: TsImportType) -> TsType {
        TsType::TsImportType(node)
    }
}
impl From<TsIndexedAccessType> for TsType {
    fn from(node: TsIndexedAccessType) -> TsType {
        TsType::TsIndexedAccessType(node)
    }
}
impl From<TsInferType> for TsType {
    fn from(node: TsInferType) -> TsType {
        TsType::TsInferType(node)
    }
}
impl From<TsIntersectionType> for TsType {
    fn from(node: TsIntersectionType) -> TsType {
        TsType::TsIntersectionType(node)
    }
}
impl From<TsMappedType> for TsType {
    fn from(node: TsMappedType) -> TsType {
        TsType::TsMappedType(node)
    }
}
impl From<TsNeverType> for TsType {
    fn from(node: TsNeverType) -> TsType {
        TsType::TsNeverType(node)
    }
}
impl From<TsNonPrimitiveType> for TsType {
    fn from(node: TsNonPrimitiveType) -> TsType {
        TsType::TsNonPrimitiveType(node)
    }
}
impl From<TsNullLiteralType> for TsType {
    fn from(node: TsNullLiteralType) -> TsType {
        TsType::TsNullLiteralType(node)
    }
}
impl From<TsNumberLiteralType> for TsType {
    fn from(node: TsNumberLiteralType) -> TsType {
        TsType::TsNumberLiteralType(node)
    }
}
impl From<TsNumberType> for TsType {
    fn from(node: TsNumberType) -> TsType {
        TsType::TsNumberType(node)
    }
}
impl From<TsObjectType> for TsType {
    fn from(node: TsObjectType) -> TsType {
        TsType::TsObjectType(node)
    }
}
impl From<TsParenthesizedType> for TsType {
    fn from(node: TsParenthesizedType) -> TsType {
        TsType::TsParenthesizedType(node)
    }
}
impl From<TsReferenceType> for TsType {
    fn from(node: TsReferenceType) -> TsType {
        TsType::TsReferenceType(node)
    }
}
impl From<TsStringLiteralType> for TsType {
    fn from(node: TsStringLiteralType) -> TsType {
        TsType::TsStringLiteralType(node)
    }
}
impl From<TsStringType> for TsType {
    fn from(node: TsStringType) -> TsType {
        TsType::TsStringType(node)
    }
}
impl From<TsSymbolType> for TsType {
    fn from(node: TsSymbolType) -> TsType {
        TsType::TsSymbolType(node)
    }
}
impl From<TsTemplateLiteralType> for TsType {
    fn from(node: TsTemplateLiteralType) -> TsType {
        TsType::TsTemplateLiteralType(node)
    }
}
impl From<TsThisType> for TsType {
    fn from(node: TsThisType) -> TsType {
        TsType::TsThisType(node)
    }
}
impl From<TsTupleType> for TsType {
    fn from(node: TsTupleType) -> TsType {
        TsType::TsTupleType(node)
    }
}
impl From<TsTypeOperatorType> for TsType {
    fn from(node: TsTypeOperatorType) -> TsType {
        TsType::TsTypeOperatorType(node)
    }
}
impl From<TsTypeofType> for TsType {
    fn from(node: TsTypeofType) -> TsType {
        TsType::TsTypeofType(node)
    }
}
impl From<TsUndefinedType> for TsType {
    fn from(node: TsUndefinedType) -> TsType {
        TsType::TsUndefinedType(node)
    }
}
impl From<TsUnionType> for TsType {
    fn from(node: TsUnionType) -> TsType {
        TsType::TsUnionType(node)
    }
}
impl From<TsUnknownType> for TsType {
    fn from(node: TsUnknownType) -> TsType {
        TsType::TsUnknownType(node)
    }
}
impl From<TsVoidType> for TsType {
    fn from(node: TsVoidType) -> TsType {
        TsType::TsVoidType(node)
    }
}
impl AstNode<JsLanguage> for TsType {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        matches!(
            kind,
            TS_ANY_TYPE
                | TS_ARRAY_TYPE
                | TS_BIG_INT_LITERAL_TYPE
                | TS_BIGINT_TYPE
                | TS_BOOLEAN_LITERAL_TYPE
                | TS_BOOLEAN_TYPE
                | TS_CONDITIONAL_TYPE
                | TS_CONSTRUCTOR_TYPE
                | TS_FUNCTION_TYPE
                | TS_IMPORT_TYPE
                | TS_INDEXED_ACCESS_TYPE
                | TS_INFER_TYPE
                | TS_INTERSECTION_TYPE
                | TS_MAPPED_TYPE
                | TS_NEVER_TYPE
                | TS_NON_PRIMITIVE_TYPE
                | TS_NULL_LITERAL_TYPE
                | TS_NUMBER_LITERAL_TYPE
                | TS_NUMBER_TYPE
                | TS_OBJECT_TYPE
                | TS_PARENTHESIZED_TYPE
                | TS_REFERENCE_TYPE
                | TS_STRING_LITERAL_TYPE
                | TS_STRING_TYPE
                | TS_SYMBOL_TYPE
                | TS_TEMPLATE_LITERAL_TYPE
                | TS_THIS_TYPE
                | TS_TUPLE_TYPE
                | TS_TYPE_OPERATOR_TYPE
                | TS_TYPEOF_TYPE
                | TS_UNDEFINED_TYPE
                | TS_UNION_TYPE
                | TS_UNKNOWN_TYPE
                | TS_VOID_TYPE
        )
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ANY_TYPE => TsType::TsAnyType(TsAnyType { syntax }),
            TS_ARRAY_TYPE => TsType::TsArrayType(TsArrayType { syntax }),
            TS_BIG_INT_LITERAL_TYPE => TsType::TsBigIntLiteralType(TsBigIntLiteralType { syntax }),
            TS_BIGINT_TYPE => TsType::TsBigintType(TsBigintType { syntax }),
            TS_BOOLEAN_LITERAL_TYPE => {
                TsType::TsBooleanLiteralType(TsBooleanLiteralType { syntax })
            }
            TS_BOOLEAN_TYPE => TsType::TsBooleanType(TsBooleanType { syntax }),
            TS_CONDITIONAL_TYPE => TsType::TsConditionalType(TsConditionalType { syntax }),
            TS_CONSTRUCTOR_TYPE => TsType::TsConstructorType(TsConstructorType { syntax }),
            TS_FUNCTION_TYPE => TsType::TsFunctionType(TsFunctionType { syntax }),
            TS_IMPORT_TYPE => TsType::TsImportType(TsImportType { syntax }),
            TS_INDEXED_ACCESS_TYPE => TsType::TsIndexedAccessType(TsIndexedAccessType { syntax }),
            TS_INFER_TYPE => TsType::TsInferType(TsInferType { syntax }),
            TS_INTERSECTION_TYPE => TsType::TsIntersectionType(TsIntersectionType { syntax }),
            TS_MAPPED_TYPE => TsType::TsMappedType(TsMappedType { syntax }),
            TS_NEVER_TYPE => TsType::TsNeverType(TsNeverType { syntax }),
            TS_NON_PRIMITIVE_TYPE => TsType::TsNonPrimitiveType(TsNonPrimitiveType { syntax }),
            TS_NULL_LITERAL_TYPE => TsType::TsNullLiteralType(TsNullLiteralType { syntax }),
            TS_NUMBER_LITERAL_TYPE => TsType::TsNumberLiteralType(TsNumberLiteralType { syntax }),
            TS_NUMBER_TYPE => TsType::TsNumberType(TsNumberType { syntax }),
            TS_OBJECT_TYPE => TsType::TsObjectType(TsObjectType { syntax }),
            TS_PARENTHESIZED_TYPE => TsType::TsParenthesizedType(TsParenthesizedType { syntax }),
            TS_REFERENCE_TYPE => TsType::TsReferenceType(TsReferenceType { syntax }),
            TS_STRING_LITERAL_TYPE => TsType::TsStringLiteralType(TsStringLiteralType { syntax }),
            TS_STRING_TYPE => TsType::TsStringType(TsStringType { syntax }),
            TS_SYMBOL_TYPE => TsType::TsSymbolType(TsSymbolType { syntax }),
            TS_TEMPLATE_LITERAL_TYPE => {
                TsType::TsTemplateLiteralType(TsTemplateLiteralType { syntax })
            }
            TS_THIS_TYPE => TsType::TsThisType(TsThisType { syntax }),
            TS_TUPLE_TYPE => TsType::TsTupleType(TsTupleType { syntax }),
            TS_TYPE_OPERATOR_TYPE => TsType::TsTypeOperatorType(TsTypeOperatorType { syntax }),
            TS_TYPEOF_TYPE => TsType::TsTypeofType(TsTypeofType { syntax }),
            TS_UNDEFINED_TYPE => TsType::TsUndefinedType(TsUndefinedType { syntax }),
            TS_UNION_TYPE => TsType::TsUnionType(TsUnionType { syntax }),
            TS_UNKNOWN_TYPE => TsType::TsUnknownType(TsUnknownType { syntax }),
            TS_VOID_TYPE => TsType::TsVoidType(TsVoidType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &JsSyntaxNode {
        match self {
            TsType::TsAnyType(it) => &it.syntax,
            TsType::TsArrayType(it) => &it.syntax,
            TsType::TsBigIntLiteralType(it) => &it.syntax,
            TsType::TsBigintType(it) => &it.syntax,
            TsType::TsBooleanLiteralType(it) => &it.syntax,
            TsType::TsBooleanType(it) => &it.syntax,
            TsType::TsConditionalType(it) => &it.syntax,
            TsType::TsConstructorType(it) => &it.syntax,
            TsType::TsFunctionType(it) => &it.syntax,
            TsType::TsImportType(it) => &it.syntax,
            TsType::TsIndexedAccessType(it) => &it.syntax,
            TsType::TsInferType(it) => &it.syntax,
            TsType::TsIntersectionType(it) => &it.syntax,
            TsType::TsMappedType(it) => &it.syntax,
            TsType::TsNeverType(it) => &it.syntax,
            TsType::TsNonPrimitiveType(it) => &it.syntax,
            TsType::TsNullLiteralType(it) => &it.syntax,
            TsType::TsNumberLiteralType(it) => &it.syntax,
            TsType::TsNumberType(it) => &it.syntax,
            TsType::TsObjectType(it) => &it.syntax,
            TsType::TsParenthesizedType(it) => &it.syntax,
            TsType::TsReferenceType(it) => &it.syntax,
            TsType::TsStringLiteralType(it) => &it.syntax,
            TsType::TsStringType(it) => &it.syntax,
            TsType::TsSymbolType(it) => &it.syntax,
            TsType::TsTemplateLiteralType(it) => &it.syntax,
            TsType::TsThisType(it) => &it.syntax,
            TsType::TsTupleType(it) => &it.syntax,
            TsType::TsTypeOperatorType(it) => &it.syntax,
            TsType::TsTypeofType(it) => &it.syntax,
            TsType::TsUndefinedType(it) => &it.syntax,
            TsType::TsUnionType(it) => &it.syntax,
            TsType::TsUnknownType(it) => &it.syntax,
            TsType::TsVoidType(it) => &it.syntax,
        }
    }
}
impl std::fmt::Debug for TsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsType::TsAnyType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsArrayType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsBigIntLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsBigintType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsBooleanLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsBooleanType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsConditionalType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsConstructorType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsFunctionType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsImportType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsIndexedAccessType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsInferType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsIntersectionType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsMappedType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNeverType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNonPrimitiveType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNullLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNumberLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNumberType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsObjectType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsParenthesizedType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsReferenceType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsStringLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsStringType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsSymbolType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsTemplateLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsThisType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsTupleType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsTypeOperatorType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsTypeofType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsUndefinedType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsUnionType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsUnknownType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsVoidType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsType> for JsSyntaxNode {
    fn from(n: TsType) -> JsSyntaxNode {
        match n {
            TsType::TsAnyType(it) => it.into(),
            TsType::TsArrayType(it) => it.into(),
            TsType::TsBigIntLiteralType(it) => it.into(),
            TsType::TsBigintType(it) => it.into(),
            TsType::TsBooleanLiteralType(it) => it.into(),
            TsType::TsBooleanType(it) => it.into(),
            TsType::TsConditionalType(it) => it.into(),
            TsType::TsConstructorType(it) => it.into(),
            TsType::TsFunctionType(it) => it.into(),
            TsType::TsImportType(it) => it.into(),
            TsType::TsIndexedAccessType(it) => it.into(),
            TsType::TsInferType(it) => it.into(),
            TsType::TsIntersectionType(it) => it.into(),
            TsType::TsMappedType(it) => it.into(),
            TsType::TsNeverType(it) => it.into(),
            TsType::TsNonPrimitiveType(it) => it.into(),
            TsType::TsNullLiteralType(it) => it.into(),
            TsType::TsNumberLiteralType(it) => it.into(),
            TsType::TsNumberType(it) => it.into(),
            TsType::TsObjectType(it) => it.into(),
            TsType::TsParenthesizedType(it) => it.into(),
            TsType::TsReferenceType(it) => it.into(),
            TsType::TsStringLiteralType(it) => it.into(),
            TsType::TsStringType(it) => it.into(),
            TsType::TsSymbolType(it) => it.into(),
            TsType::TsTemplateLiteralType(it) => it.into(),
            TsType::TsThisType(it) => it.into(),
            TsType::TsTupleType(it) => it.into(),
            TsType::TsTypeOperatorType(it) => it.into(),
            TsType::TsTypeofType(it) => it.into(),
            TsType::TsUndefinedType(it) => it.into(),
            TsType::TsUnionType(it) => it.into(),
            TsType::TsUnknownType(it) => it.into(),
            TsType::TsVoidType(it) => it.into(),
        }
    }
}
impl From<TsType> for JsSyntaxElement {
    fn from(n: TsType) -> JsSyntaxElement {
        let node: JsSyntaxNode = n.into();
        node.into()
    }
}
impl std::fmt::Display for JsAnyArrayAssignmentPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyArrayBindingPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyArrayElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyArrowFunctionParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyCallArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyConstructorParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyExportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyForInOrOfInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyForInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyImportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyInProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyMethodModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyModuleItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyNamedImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyObjectAssignmentPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyObjectBindingPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyObjectMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyPropertyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyRoot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnySwitchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyAttributeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyElementName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyObjectName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyIndexSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyMethodSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyPropertyParameterModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyPropertySignatureAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyPropertySignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyTypePredicateParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImportMeta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayAssignmentPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayBindingPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayHole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrowFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAssignmentExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAssignmentWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAwaitExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBigIntLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBinaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBindingPatternWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBlockStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBooleanLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBreakStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCallArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCaseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCatchDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConditionalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConstructorClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConstructorParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsContinueStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDebuggerStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDefaultImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDoWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsElseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsEmptyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsEmptyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportDefaultDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportDefaultExpressionClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedFromSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedShorthandSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExpressionSnipped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExpressionStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFinallyClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForInStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForOfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsGetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsGetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportAssertion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportBareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInstanceofExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLabeledStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLiteralExportName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLiteralMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLogicalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsMethodClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsMethodObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsModuleSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamedImportSpecifiers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamespaceImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNewExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNullLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNumberLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParenthesizedAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParenthesizedExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPostUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPreUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPrivateClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPrivateName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPropertyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsRegexLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsRestParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsReturnStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSequenceExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsShorthandNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsShorthandPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSpread {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticInitializationBlockClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStringLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSuperExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSwitchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsThisExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsThrowStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTryFinallyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTryStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsUnaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclarator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsWithStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsYieldArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsYieldExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAttributeInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxClosingFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxExpressionAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxExpressionChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxNamespaceName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxOpeningElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxOpeningFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSelfClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSpreadAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSpreadChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxTagExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NewTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAbstractModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAccessibilityModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAsAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAsExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAssertsCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAssertsReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBigIntLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBigintType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBooleanLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBooleanType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsCallSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConditionalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructorSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefaultTypeClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefinitePropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefiniteVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEmptyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEnumDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEnumMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportAsNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportAssignmentClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportDeclareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExternalModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExternalModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsFunctionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGlobalDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImplementsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportEqualsDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportTypeQualifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexedAccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInterfaceDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIntersectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeOptionalModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeReadonlyModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMethodSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMethodSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsModuleBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNameWithTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNamedTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonNullAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonNullAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonPrimitiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNullLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNumberLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNumberType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsObjectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOptionalPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOptionalTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOverrideModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsParenthesizedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPredicateReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertySignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertySignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsQualifiedModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsQualifiedName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReadonlyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReferenceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsRestTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReturnTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsStringLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsStringType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSymbolType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsThisParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsThisType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAliasDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeConstraintClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeOperatorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeofType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUndefinedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUnionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUnknownType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsVoidType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknown {
    syntax: JsSyntaxNode,
}
impl JsUnknown {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknown {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknown {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknown")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknown> for JsSyntaxNode {
    fn from(n: JsUnknown) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknown> for JsSyntaxElement {
    fn from(n: JsUnknown) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknownAssignment {
    syntax: JsSyntaxNode,
}
impl JsUnknownAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknownAssignment {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN_ASSIGNMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknownAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownAssignment")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownAssignment> for JsSyntaxNode {
    fn from(n: JsUnknownAssignment) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknownAssignment> for JsSyntaxElement {
    fn from(n: JsUnknownAssignment) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknownBinding {
    syntax: JsSyntaxNode,
}
impl JsUnknownBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknownBinding {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN_BINDING
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknownBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownBinding")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownBinding> for JsSyntaxNode {
    fn from(n: JsUnknownBinding) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknownBinding> for JsSyntaxElement {
    fn from(n: JsUnknownBinding) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknownExpression {
    syntax: JsSyntaxNode,
}
impl JsUnknownExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknownExpression {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN_EXPRESSION
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknownExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownExpression")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownExpression> for JsSyntaxNode {
    fn from(n: JsUnknownExpression) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknownExpression> for JsSyntaxElement {
    fn from(n: JsUnknownExpression) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknownImportAssertionEntry {
    syntax: JsSyntaxNode,
}
impl JsUnknownImportAssertionEntry {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknownImportAssertionEntry {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN_IMPORT_ASSERTION_ENTRY
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknownImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownImportAssertionEntry")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownImportAssertionEntry> for JsSyntaxNode {
    fn from(n: JsUnknownImportAssertionEntry) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknownImportAssertionEntry> for JsSyntaxElement {
    fn from(n: JsUnknownImportAssertionEntry) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknownMember {
    syntax: JsSyntaxNode,
}
impl JsUnknownMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknownMember {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN_MEMBER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknownMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownMember")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownMember> for JsSyntaxNode {
    fn from(n: JsUnknownMember) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknownMember> for JsSyntaxElement {
    fn from(n: JsUnknownMember) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknownNamedImportSpecifier {
    syntax: JsSyntaxNode,
}
impl JsUnknownNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknownNamedImportSpecifier {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN_NAMED_IMPORT_SPECIFIER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknownNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownNamedImportSpecifier")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownNamedImportSpecifier> for JsSyntaxNode {
    fn from(n: JsUnknownNamedImportSpecifier) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknownNamedImportSpecifier> for JsSyntaxElement {
    fn from(n: JsUnknownNamedImportSpecifier) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknownParameter {
    syntax: JsSyntaxNode,
}
impl JsUnknownParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknownParameter {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN_PARAMETER
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknownParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownParameter")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownParameter> for JsSyntaxNode {
    fn from(n: JsUnknownParameter) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknownParameter> for JsSyntaxElement {
    fn from(n: JsUnknownParameter) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnknownStatement {
    syntax: JsSyntaxNode,
}
impl JsUnknownStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self { syntax }
    }
    pub fn items(&self) -> JsSyntaxElementChildren {
        support::elements(&self.syntax)
    }
}
impl AstNode<JsLanguage> for JsUnknownStatement {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_UNKNOWN_STATEMENT
    }
    fn cast(syntax: JsSyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Debug for JsUnknownStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownStatement")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownStatement> for JsSyntaxNode {
    fn from(n: JsUnknownStatement) -> JsSyntaxNode {
        n.syntax
    }
}
impl From<JsUnknownStatement> for JsSyntaxElement {
    fn from(n: JsUnknownStatement) -> JsSyntaxElement {
        n.syntax.into()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayAssignmentPatternElementList {
    syntax_list: JsSyntaxList,
}
impl JsArrayAssignmentPatternElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsArrayAssignmentPatternElementList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_ASSIGNMENT_PATTERN_ELEMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsArrayAssignmentPatternElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayAssignmentPatternElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyArrayAssignmentPatternElement>
    for JsArrayAssignmentPatternElementList
{
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsArrayAssignmentPatternElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayAssignmentPatternElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayAssignmentPatternElementList {
    type Item = SyntaxResult<JsAnyArrayAssignmentPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyArrayAssignmentPatternElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsArrayAssignmentPatternElementList {
    type Item = SyntaxResult<JsAnyArrayAssignmentPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyArrayAssignmentPatternElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayBindingPatternElementList {
    syntax_list: JsSyntaxList,
}
impl JsArrayBindingPatternElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsArrayBindingPatternElementList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_BINDING_PATTERN_ELEMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsArrayBindingPatternElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayBindingPatternElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyArrayBindingPatternElement>
    for JsArrayBindingPatternElementList
{
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsArrayBindingPatternElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayBindingPatternElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayBindingPatternElementList {
    type Item = SyntaxResult<JsAnyArrayBindingPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyArrayBindingPatternElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsArrayBindingPatternElementList {
    type Item = SyntaxResult<JsAnyArrayBindingPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyArrayBindingPatternElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayElementList {
    syntax_list: JsSyntaxList,
}
impl JsArrayElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsArrayElementList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_ARRAY_ELEMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsArrayElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyArrayElement> for JsArrayElementList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsArrayElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayElementList {
    type Item = SyntaxResult<JsAnyArrayElement>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyArrayElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsArrayElementList {
    type Item = SyntaxResult<JsAnyArrayElement>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyArrayElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsCallArgumentList {
    syntax_list: JsSyntaxList,
}
impl JsCallArgumentList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsCallArgumentList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CALL_ARGUMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsCallArgumentList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsCallArgumentList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyCallArgument> for JsCallArgumentList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsCallArgumentList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsCallArgumentList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsCallArgumentList {
    type Item = SyntaxResult<JsAnyCallArgument>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyCallArgument>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsCallArgumentList {
    type Item = SyntaxResult<JsAnyCallArgument>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyCallArgument>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsClassMemberList {
    syntax_list: JsSyntaxList,
}
impl JsClassMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsClassMemberList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CLASS_MEMBER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsClassMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsClassMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsAnyClassMember> for JsClassMemberList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsClassMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsClassMemberList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsClassMemberList {
    type Item = JsAnyClassMember;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyClassMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsClassMemberList {
    type Item = JsAnyClassMember;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyClassMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsConstructorModifierList {
    syntax_list: JsSyntaxList,
}
impl JsConstructorModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsConstructorModifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CONSTRUCTOR_MODIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsConstructorModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsConstructorModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, TsAccessibilityModifier> for JsConstructorModifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsConstructorModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsConstructorModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsConstructorModifierList {
    type Item = TsAccessibilityModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAccessibilityModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsConstructorModifierList {
    type Item = TsAccessibilityModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAccessibilityModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsConstructorParameterList {
    syntax_list: JsSyntaxList,
}
impl JsConstructorParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsConstructorParameterList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_CONSTRUCTOR_PARAMETER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsConstructorParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsConstructorParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyConstructorParameter> for JsConstructorParameterList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsConstructorParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsConstructorParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsConstructorParameterList {
    type Item = SyntaxResult<JsAnyConstructorParameter>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyConstructorParameter>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsConstructorParameterList {
    type Item = SyntaxResult<JsAnyConstructorParameter>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyConstructorParameter>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsDirectiveList {
    syntax_list: JsSyntaxList,
}
impl JsDirectiveList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsDirectiveList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_DIRECTIVE_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsDirectiveList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsDirectiveList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsDirective> for JsDirectiveList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsDirectiveList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsDirectiveList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsDirectiveList {
    type Item = JsDirective;
    type IntoIter = AstNodeListIterator<JsLanguage, JsDirective>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsDirectiveList {
    type Item = JsDirective;
    type IntoIter = AstNodeListIterator<JsLanguage, JsDirective>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsExportNamedFromSpecifierList {
    syntax_list: JsSyntaxList,
}
impl JsExportNamedFromSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsExportNamedFromSpecifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_NAMED_FROM_SPECIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsExportNamedFromSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsExportNamedFromSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsExportNamedFromSpecifier> for JsExportNamedFromSpecifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsExportNamedFromSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsExportNamedFromSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsExportNamedFromSpecifierList {
    type Item = SyntaxResult<JsExportNamedFromSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsExportNamedFromSpecifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsExportNamedFromSpecifierList {
    type Item = SyntaxResult<JsExportNamedFromSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsExportNamedFromSpecifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsExportNamedSpecifierList {
    syntax_list: JsSyntaxList,
}
impl JsExportNamedSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsExportNamedSpecifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_EXPORT_NAMED_SPECIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsExportNamedSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsExportNamedSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyExportNamedSpecifier> for JsExportNamedSpecifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsExportNamedSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsExportNamedSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsExportNamedSpecifierList {
    type Item = SyntaxResult<JsAnyExportNamedSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyExportNamedSpecifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsExportNamedSpecifierList {
    type Item = SyntaxResult<JsAnyExportNamedSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyExportNamedSpecifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsImportAssertionEntryList {
    syntax_list: JsSyntaxList,
}
impl JsImportAssertionEntryList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsImportAssertionEntryList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_IMPORT_ASSERTION_ENTRY_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsImportAssertionEntryList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsImportAssertionEntryList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyImportAssertionEntry> for JsImportAssertionEntryList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsImportAssertionEntryList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsImportAssertionEntryList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsImportAssertionEntryList {
    type Item = SyntaxResult<JsAnyImportAssertionEntry>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyImportAssertionEntry>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsImportAssertionEntryList {
    type Item = SyntaxResult<JsAnyImportAssertionEntry>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyImportAssertionEntry>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsMethodModifierList {
    syntax_list: JsSyntaxList,
}
impl JsMethodModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsMethodModifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_METHOD_MODIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsMethodModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsMethodModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsAnyMethodModifier> for JsMethodModifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsMethodModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsMethodModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsMethodModifierList {
    type Item = JsAnyMethodModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyMethodModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsMethodModifierList {
    type Item = JsAnyMethodModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyMethodModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsModuleItemList {
    syntax_list: JsSyntaxList,
}
impl JsModuleItemList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsModuleItemList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_MODULE_ITEM_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsModuleItemList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsModuleItemList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsAnyModuleItem> for JsModuleItemList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsModuleItemList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsModuleItemList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsModuleItemList {
    type Item = JsAnyModuleItem;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyModuleItem>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsModuleItemList {
    type Item = JsAnyModuleItem;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyModuleItem>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsNamedImportSpecifierList {
    syntax_list: JsSyntaxList,
}
impl JsNamedImportSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsNamedImportSpecifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_NAMED_IMPORT_SPECIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsNamedImportSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsNamedImportSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyNamedImportSpecifier> for JsNamedImportSpecifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsNamedImportSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsNamedImportSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsNamedImportSpecifierList {
    type Item = SyntaxResult<JsAnyNamedImportSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyNamedImportSpecifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsNamedImportSpecifierList {
    type Item = SyntaxResult<JsAnyNamedImportSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyNamedImportSpecifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectAssignmentPatternPropertyList {
    syntax_list: JsSyntaxList,
}
impl JsObjectAssignmentPatternPropertyList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsObjectAssignmentPatternPropertyList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsObjectAssignmentPatternPropertyList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectAssignmentPatternPropertyList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyObjectAssignmentPatternMember>
    for JsObjectAssignmentPatternPropertyList
{
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsObjectAssignmentPatternPropertyList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectAssignmentPatternPropertyList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectAssignmentPatternPropertyList {
    type Item = SyntaxResult<JsAnyObjectAssignmentPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyObjectAssignmentPatternMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsObjectAssignmentPatternPropertyList {
    type Item = SyntaxResult<JsAnyObjectAssignmentPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyObjectAssignmentPatternMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectBindingPatternPropertyList {
    syntax_list: JsSyntaxList,
}
impl JsObjectBindingPatternPropertyList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsObjectBindingPatternPropertyList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_BINDING_PATTERN_PROPERTY_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsObjectBindingPatternPropertyList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectBindingPatternPropertyList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyObjectBindingPatternMember>
    for JsObjectBindingPatternPropertyList
{
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsObjectBindingPatternPropertyList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectBindingPatternPropertyList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectBindingPatternPropertyList {
    type Item = SyntaxResult<JsAnyObjectBindingPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyObjectBindingPatternMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsObjectBindingPatternPropertyList {
    type Item = SyntaxResult<JsAnyObjectBindingPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyObjectBindingPatternMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectMemberList {
    syntax_list: JsSyntaxList,
}
impl JsObjectMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsObjectMemberList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_OBJECT_MEMBER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsObjectMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyObjectMember> for JsObjectMemberList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsObjectMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectMemberList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectMemberList {
    type Item = SyntaxResult<JsAnyObjectMember>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyObjectMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsObjectMemberList {
    type Item = SyntaxResult<JsAnyObjectMember>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyObjectMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsParameterList {
    syntax_list: JsSyntaxList,
}
impl JsParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsParameterList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PARAMETER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsAnyParameter> for JsParameterList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsParameterList {
    type Item = SyntaxResult<JsAnyParameter>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyParameter>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsParameterList {
    type Item = SyntaxResult<JsAnyParameter>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsAnyParameter>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsPropertyModifierList {
    syntax_list: JsSyntaxList,
}
impl JsPropertyModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsPropertyModifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_PROPERTY_MODIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsPropertyModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsPropertyModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsAnyPropertyModifier> for JsPropertyModifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsPropertyModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsPropertyModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsPropertyModifierList {
    type Item = JsAnyPropertyModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyPropertyModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsPropertyModifierList {
    type Item = JsAnyPropertyModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyPropertyModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsStatementList {
    syntax_list: JsSyntaxList,
}
impl JsStatementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsStatementList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_STATEMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsStatementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsStatementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsAnyStatement> for JsStatementList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsStatementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsStatementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsStatementList {
    type Item = JsAnyStatement;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyStatement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsStatementList {
    type Item = JsAnyStatement;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyStatement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsSwitchCaseList {
    syntax_list: JsSyntaxList,
}
impl JsSwitchCaseList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsSwitchCaseList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_SWITCH_CASE_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsSwitchCaseList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsSwitchCaseList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsAnySwitchClause> for JsSwitchCaseList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsSwitchCaseList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsSwitchCaseList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsSwitchCaseList {
    type Item = JsAnySwitchClause;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnySwitchClause>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsSwitchCaseList {
    type Item = JsAnySwitchClause;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnySwitchClause>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsTemplateElementList {
    syntax_list: JsSyntaxList,
}
impl JsTemplateElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsTemplateElementList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_TEMPLATE_ELEMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsTemplateElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsTemplateElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsAnyTemplateElement> for JsTemplateElementList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsTemplateElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsTemplateElementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsTemplateElementList {
    type Item = JsAnyTemplateElement;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyTemplateElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsTemplateElementList {
    type Item = JsAnyTemplateElement;
    type IntoIter = AstNodeListIterator<JsLanguage, JsAnyTemplateElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsVariableDeclaratorList {
    syntax_list: JsSyntaxList,
}
impl JsVariableDeclaratorList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsVariableDeclaratorList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JS_VARIABLE_DECLARATOR_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsVariableDeclaratorList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsVariableDeclaratorList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, JsVariableDeclarator> for JsVariableDeclaratorList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsVariableDeclaratorList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsVariableDeclaratorList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsVariableDeclaratorList {
    type Item = SyntaxResult<JsVariableDeclarator>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsVariableDeclarator>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &JsVariableDeclaratorList {
    type Item = SyntaxResult<JsVariableDeclarator>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, JsVariableDeclarator>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsxAttributeList {
    syntax_list: JsSyntaxList,
}
impl JsxAttributeList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsxAttributeList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_ATTRIBUTE_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsxAttributeList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsxAttributeList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsxAnyAttribute> for JsxAttributeList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsxAttributeList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsxAttributeList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsxAttributeList {
    type Item = JsxAnyAttribute;
    type IntoIter = AstNodeListIterator<JsLanguage, JsxAnyAttribute>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsxAttributeList {
    type Item = JsxAnyAttribute;
    type IntoIter = AstNodeListIterator<JsLanguage, JsxAnyAttribute>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsxChildList {
    syntax_list: JsSyntaxList,
}
impl JsxChildList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for JsxChildList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == JSX_CHILD_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<JsxChildList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsxChildList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, JsxAnyChild> for JsxChildList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for JsxChildList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsxChildList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsxChildList {
    type Item = JsxAnyChild;
    type IntoIter = AstNodeListIterator<JsLanguage, JsxAnyChild>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for JsxChildList {
    type Item = JsxAnyChild;
    type IntoIter = AstNodeListIterator<JsLanguage, JsxAnyChild>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsEnumMemberList {
    syntax_list: JsSyntaxList,
}
impl TsEnumMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsEnumMemberList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_ENUM_MEMBER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsEnumMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsEnumMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, TsEnumMember> for TsEnumMemberList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsEnumMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsEnumMemberList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsEnumMemberList {
    type Item = SyntaxResult<TsEnumMember>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsEnumMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &TsEnumMemberList {
    type Item = SyntaxResult<TsEnumMember>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsEnumMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsIndexSignatureModifierList {
    syntax_list: JsSyntaxList,
}
impl TsIndexSignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsIndexSignatureModifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INDEX_SIGNATURE_MODIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsIndexSignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsIndexSignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, TsAnyIndexSignatureModifier> for TsIndexSignatureModifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsIndexSignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsIndexSignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsIndexSignatureModifierList {
    type Item = TsAnyIndexSignatureModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyIndexSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for TsIndexSignatureModifierList {
    type Item = TsAnyIndexSignatureModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyIndexSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsIntersectionTypeElementList {
    syntax_list: JsSyntaxList,
}
impl TsIntersectionTypeElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsIntersectionTypeElementList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_INTERSECTION_TYPE_ELEMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsIntersectionTypeElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsIntersectionTypeElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, TsType> for TsIntersectionTypeElementList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsIntersectionTypeElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsIntersectionTypeElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsIntersectionTypeElementList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsType>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &TsIntersectionTypeElementList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsType>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsMethodSignatureModifierList {
    syntax_list: JsSyntaxList,
}
impl TsMethodSignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsMethodSignatureModifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_METHOD_SIGNATURE_MODIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsMethodSignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsMethodSignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, TsAnyMethodSignatureModifier> for TsMethodSignatureModifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsMethodSignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsMethodSignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsMethodSignatureModifierList {
    type Item = TsAnyMethodSignatureModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyMethodSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for TsMethodSignatureModifierList {
    type Item = TsAnyMethodSignatureModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyMethodSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsPropertyParameterModifierList {
    syntax_list: JsSyntaxList,
}
impl TsPropertyParameterModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsPropertyParameterModifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_PROPERTY_PARAMETER_MODIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsPropertyParameterModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsPropertyParameterModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, TsAnyPropertyParameterModifier> for TsPropertyParameterModifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsPropertyParameterModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsPropertyParameterModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsPropertyParameterModifierList {
    type Item = TsAnyPropertyParameterModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyPropertyParameterModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for TsPropertyParameterModifierList {
    type Item = TsAnyPropertyParameterModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyPropertyParameterModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsPropertySignatureModifierList {
    syntax_list: JsSyntaxList,
}
impl TsPropertySignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsPropertySignatureModifierList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_PROPERTY_SIGNATURE_MODIFIER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsPropertySignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsPropertySignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, TsAnyPropertySignatureModifier> for TsPropertySignatureModifierList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsPropertySignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsPropertySignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsPropertySignatureModifierList {
    type Item = TsAnyPropertySignatureModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyPropertySignatureModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for TsPropertySignatureModifierList {
    type Item = TsAnyPropertySignatureModifier;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyPropertySignatureModifier>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTemplateElementList {
    syntax_list: JsSyntaxList,
}
impl TsTemplateElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsTemplateElementList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TEMPLATE_ELEMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsTemplateElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTemplateElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, TsAnyTemplateElement> for TsTemplateElementList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsTemplateElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTemplateElementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsTemplateElementList {
    type Item = TsAnyTemplateElement;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyTemplateElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for TsTemplateElementList {
    type Item = TsAnyTemplateElement;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyTemplateElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTupleTypeElementList {
    syntax_list: JsSyntaxList,
}
impl TsTupleTypeElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsTupleTypeElementList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TUPLE_TYPE_ELEMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsTupleTypeElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTupleTypeElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, TsAnyTupleTypeElement> for TsTupleTypeElementList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsTupleTypeElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTupleTypeElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTupleTypeElementList {
    type Item = SyntaxResult<TsAnyTupleTypeElement>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsAnyTupleTypeElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &TsTupleTypeElementList {
    type Item = SyntaxResult<TsAnyTupleTypeElement>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsAnyTupleTypeElement>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeArgumentList {
    syntax_list: JsSyntaxList,
}
impl TsTypeArgumentList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsTypeArgumentList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_ARGUMENT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsTypeArgumentList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeArgumentList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, TsType> for TsTypeArgumentList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsTypeArgumentList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeArgumentList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeArgumentList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsType>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &TsTypeArgumentList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsType>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeList {
    syntax_list: JsSyntaxList,
}
impl TsTypeList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsTypeList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsTypeList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, TsNameWithTypeArguments> for TsTypeList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsTypeList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeList {
    type Item = SyntaxResult<TsNameWithTypeArguments>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsNameWithTypeArguments>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &TsTypeList {
    type Item = SyntaxResult<TsNameWithTypeArguments>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsNameWithTypeArguments>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeMemberList {
    syntax_list: JsSyntaxList,
}
impl TsTypeMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsTypeMemberList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_MEMBER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsTypeMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstNodeList<JsLanguage, TsAnyTypeMember> for TsTypeMemberList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsTypeMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeMemberList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsTypeMemberList {
    type Item = TsAnyTypeMember;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyTypeMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for TsTypeMemberList {
    type Item = TsAnyTypeMember;
    type IntoIter = AstNodeListIterator<JsLanguage, TsAnyTypeMember>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeParameterList {
    syntax_list: JsSyntaxList,
}
impl TsTypeParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsTypeParameterList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_TYPE_PARAMETER_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsTypeParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, TsTypeParameter> for TsTypeParameterList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsTypeParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeParameterList {
    type Item = SyntaxResult<TsTypeParameter>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsTypeParameter>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &TsTypeParameterList {
    type Item = SyntaxResult<TsTypeParameter>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsTypeParameter>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsUnionTypeVariantList {
    syntax_list: JsSyntaxList,
}
impl TsUnionTypeVariantList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: JsSyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode<JsLanguage> for TsUnionTypeVariantList {
    fn can_cast(kind: JsSyntaxKind) -> bool {
        kind == TS_UNION_TYPE_VARIANT_LIST
    }
    fn cast(syntax: JsSyntaxNode) -> Option<TsUnionTypeVariantList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsUnionTypeVariantList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &JsSyntaxNode {
        self.syntax_list.node()
    }
}
impl AstSeparatedList<JsLanguage, TsType> for TsUnionTypeVariantList {
    fn syntax_list(&self) -> &JsSyntaxList {
        &self.syntax_list
    }
}
impl Debug for TsUnionTypeVariantList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsUnionTypeVariantList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsUnionTypeVariantList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsType>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
impl IntoIterator for &TsUnionTypeVariantList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<JsLanguage, TsType>;
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
pub struct DebugSyntaxElement(pub(crate) JsSyntaxElement);
impl Debug for DebugSyntaxElement {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match &self.0 {
            NodeOrToken::Node(node) => match node.kind() {
                IMPORT_META => std::fmt::Debug::fmt(&ImportMeta::cast(node.clone()).unwrap(), f),
                JS_ARRAY_ASSIGNMENT_PATTERN => {
                    std::fmt::Debug::fmt(&JsArrayAssignmentPattern::cast(node.clone()).unwrap(), f)
                }
                JS_ARRAY_ASSIGNMENT_PATTERN_ELEMENT_LIST => std::fmt::Debug::fmt(
                    &JsArrayAssignmentPatternElementList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT => std::fmt::Debug::fmt(
                    &JsArrayAssignmentPatternRestElement::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_ARRAY_BINDING_PATTERN => {
                    std::fmt::Debug::fmt(&JsArrayBindingPattern::cast(node.clone()).unwrap(), f)
                }
                JS_ARRAY_BINDING_PATTERN_ELEMENT_LIST => std::fmt::Debug::fmt(
                    &JsArrayBindingPatternElementList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_ARRAY_BINDING_PATTERN_REST_ELEMENT => std::fmt::Debug::fmt(
                    &JsArrayBindingPatternRestElement::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_ARRAY_ELEMENT_LIST => {
                    std::fmt::Debug::fmt(&JsArrayElementList::cast(node.clone()).unwrap(), f)
                }
                JS_ARRAY_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsArrayExpression::cast(node.clone()).unwrap(), f)
                }
                JS_ARRAY_HOLE => std::fmt::Debug::fmt(&JsArrayHole::cast(node.clone()).unwrap(), f),
                JS_ARROW_FUNCTION_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsArrowFunctionExpression::cast(node.clone()).unwrap(), f)
                }
                JS_ASSIGNMENT_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsAssignmentExpression::cast(node.clone()).unwrap(), f)
                }
                JS_ASSIGNMENT_WITH_DEFAULT => {
                    std::fmt::Debug::fmt(&JsAssignmentWithDefault::cast(node.clone()).unwrap(), f)
                }
                JS_AWAIT_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsAwaitExpression::cast(node.clone()).unwrap(), f)
                }
                JS_BIG_INT_LITERAL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsBigIntLiteralExpression::cast(node.clone()).unwrap(), f)
                }
                JS_BINARY_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsBinaryExpression::cast(node.clone()).unwrap(), f)
                }
                JS_BINDING_PATTERN_WITH_DEFAULT => std::fmt::Debug::fmt(
                    &JsBindingPatternWithDefault::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_BLOCK_STATEMENT => {
                    std::fmt::Debug::fmt(&JsBlockStatement::cast(node.clone()).unwrap(), f)
                }
                JS_BOOLEAN_LITERAL_EXPRESSION => std::fmt::Debug::fmt(
                    &JsBooleanLiteralExpression::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_BREAK_STATEMENT => {
                    std::fmt::Debug::fmt(&JsBreakStatement::cast(node.clone()).unwrap(), f)
                }
                JS_CALL_ARGUMENT_LIST => {
                    std::fmt::Debug::fmt(&JsCallArgumentList::cast(node.clone()).unwrap(), f)
                }
                JS_CALL_ARGUMENTS => {
                    std::fmt::Debug::fmt(&JsCallArguments::cast(node.clone()).unwrap(), f)
                }
                JS_CALL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsCallExpression::cast(node.clone()).unwrap(), f)
                }
                JS_CASE_CLAUSE => {
                    std::fmt::Debug::fmt(&JsCaseClause::cast(node.clone()).unwrap(), f)
                }
                JS_CATCH_CLAUSE => {
                    std::fmt::Debug::fmt(&JsCatchClause::cast(node.clone()).unwrap(), f)
                }
                JS_CATCH_DECLARATION => {
                    std::fmt::Debug::fmt(&JsCatchDeclaration::cast(node.clone()).unwrap(), f)
                }
                JS_CLASS_DECLARATION => {
                    std::fmt::Debug::fmt(&JsClassDeclaration::cast(node.clone()).unwrap(), f)
                }
                JS_CLASS_EXPORT_DEFAULT_DECLARATION => std::fmt::Debug::fmt(
                    &JsClassExportDefaultDeclaration::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_CLASS_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsClassExpression::cast(node.clone()).unwrap(), f)
                }
                JS_CLASS_MEMBER_LIST => {
                    std::fmt::Debug::fmt(&JsClassMemberList::cast(node.clone()).unwrap(), f)
                }
                JS_COMPUTED_MEMBER_ASSIGNMENT => std::fmt::Debug::fmt(
                    &JsComputedMemberAssignment::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_COMPUTED_MEMBER_EXPRESSION => std::fmt::Debug::fmt(
                    &JsComputedMemberExpression::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_COMPUTED_MEMBER_NAME => {
                    std::fmt::Debug::fmt(&JsComputedMemberName::cast(node.clone()).unwrap(), f)
                }
                JS_CONDITIONAL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsConditionalExpression::cast(node.clone()).unwrap(), f)
                }
                JS_CONSTRUCTOR_CLASS_MEMBER => {
                    std::fmt::Debug::fmt(&JsConstructorClassMember::cast(node.clone()).unwrap(), f)
                }
                JS_CONSTRUCTOR_MODIFIER_LIST => {
                    std::fmt::Debug::fmt(&JsConstructorModifierList::cast(node.clone()).unwrap(), f)
                }
                JS_CONSTRUCTOR_PARAMETER_LIST => std::fmt::Debug::fmt(
                    &JsConstructorParameterList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_CONSTRUCTOR_PARAMETERS => {
                    std::fmt::Debug::fmt(&JsConstructorParameters::cast(node.clone()).unwrap(), f)
                }
                JS_CONTINUE_STATEMENT => {
                    std::fmt::Debug::fmt(&JsContinueStatement::cast(node.clone()).unwrap(), f)
                }
                JS_DEBUGGER_STATEMENT => {
                    std::fmt::Debug::fmt(&JsDebuggerStatement::cast(node.clone()).unwrap(), f)
                }
                JS_DEFAULT_CLAUSE => {
                    std::fmt::Debug::fmt(&JsDefaultClause::cast(node.clone()).unwrap(), f)
                }
                JS_DEFAULT_IMPORT_SPECIFIER => {
                    std::fmt::Debug::fmt(&JsDefaultImportSpecifier::cast(node.clone()).unwrap(), f)
                }
                JS_DIRECTIVE => std::fmt::Debug::fmt(&JsDirective::cast(node.clone()).unwrap(), f),
                JS_DIRECTIVE_LIST => {
                    std::fmt::Debug::fmt(&JsDirectiveList::cast(node.clone()).unwrap(), f)
                }
                JS_DO_WHILE_STATEMENT => {
                    std::fmt::Debug::fmt(&JsDoWhileStatement::cast(node.clone()).unwrap(), f)
                }
                JS_ELSE_CLAUSE => {
                    std::fmt::Debug::fmt(&JsElseClause::cast(node.clone()).unwrap(), f)
                }
                JS_EMPTY_CLASS_MEMBER => {
                    std::fmt::Debug::fmt(&JsEmptyClassMember::cast(node.clone()).unwrap(), f)
                }
                JS_EMPTY_STATEMENT => {
                    std::fmt::Debug::fmt(&JsEmptyStatement::cast(node.clone()).unwrap(), f)
                }
                JS_EXPORT => std::fmt::Debug::fmt(&JsExport::cast(node.clone()).unwrap(), f),
                JS_EXPORT_AS_CLAUSE => {
                    std::fmt::Debug::fmt(&JsExportAsClause::cast(node.clone()).unwrap(), f)
                }
                JS_EXPORT_DEFAULT_DECLARATION_CLAUSE => std::fmt::Debug::fmt(
                    &JsExportDefaultDeclarationClause::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE => std::fmt::Debug::fmt(
                    &JsExportDefaultExpressionClause::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_EXPORT_FROM_CLAUSE => {
                    std::fmt::Debug::fmt(&JsExportFromClause::cast(node.clone()).unwrap(), f)
                }
                JS_EXPORT_NAMED_CLAUSE => {
                    std::fmt::Debug::fmt(&JsExportNamedClause::cast(node.clone()).unwrap(), f)
                }
                JS_EXPORT_NAMED_FROM_CLAUSE => {
                    std::fmt::Debug::fmt(&JsExportNamedFromClause::cast(node.clone()).unwrap(), f)
                }
                JS_EXPORT_NAMED_FROM_SPECIFIER => std::fmt::Debug::fmt(
                    &JsExportNamedFromSpecifier::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_EXPORT_NAMED_FROM_SPECIFIER_LIST => std::fmt::Debug::fmt(
                    &JsExportNamedFromSpecifierList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_EXPORT_NAMED_SHORTHAND_SPECIFIER => std::fmt::Debug::fmt(
                    &JsExportNamedShorthandSpecifier::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_EXPORT_NAMED_SPECIFIER => {
                    std::fmt::Debug::fmt(&JsExportNamedSpecifier::cast(node.clone()).unwrap(), f)
                }
                JS_EXPORT_NAMED_SPECIFIER_LIST => std::fmt::Debug::fmt(
                    &JsExportNamedSpecifierList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_EXPRESSION_SNIPPED => {
                    std::fmt::Debug::fmt(&JsExpressionSnipped::cast(node.clone()).unwrap(), f)
                }
                JS_EXPRESSION_STATEMENT => {
                    std::fmt::Debug::fmt(&JsExpressionStatement::cast(node.clone()).unwrap(), f)
                }
                JS_EXTENDS_CLAUSE => {
                    std::fmt::Debug::fmt(&JsExtendsClause::cast(node.clone()).unwrap(), f)
                }
                JS_FINALLY_CLAUSE => {
                    std::fmt::Debug::fmt(&JsFinallyClause::cast(node.clone()).unwrap(), f)
                }
                JS_FOR_IN_STATEMENT => {
                    std::fmt::Debug::fmt(&JsForInStatement::cast(node.clone()).unwrap(), f)
                }
                JS_FOR_OF_STATEMENT => {
                    std::fmt::Debug::fmt(&JsForOfStatement::cast(node.clone()).unwrap(), f)
                }
                JS_FOR_STATEMENT => {
                    std::fmt::Debug::fmt(&JsForStatement::cast(node.clone()).unwrap(), f)
                }
                JS_FOR_VARIABLE_DECLARATION => {
                    std::fmt::Debug::fmt(&JsForVariableDeclaration::cast(node.clone()).unwrap(), f)
                }
                JS_FORMAL_PARAMETER => {
                    std::fmt::Debug::fmt(&JsFormalParameter::cast(node.clone()).unwrap(), f)
                }
                JS_FUNCTION_BODY => {
                    std::fmt::Debug::fmt(&JsFunctionBody::cast(node.clone()).unwrap(), f)
                }
                JS_FUNCTION_DECLARATION => {
                    std::fmt::Debug::fmt(&JsFunctionDeclaration::cast(node.clone()).unwrap(), f)
                }
                JS_FUNCTION_EXPORT_DEFAULT_DECLARATION => std::fmt::Debug::fmt(
                    &JsFunctionExportDefaultDeclaration::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_FUNCTION_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsFunctionExpression::cast(node.clone()).unwrap(), f)
                }
                JS_GETTER_CLASS_MEMBER => {
                    std::fmt::Debug::fmt(&JsGetterClassMember::cast(node.clone()).unwrap(), f)
                }
                JS_GETTER_OBJECT_MEMBER => {
                    std::fmt::Debug::fmt(&JsGetterObjectMember::cast(node.clone()).unwrap(), f)
                }
                JS_IDENTIFIER_ASSIGNMENT => {
                    std::fmt::Debug::fmt(&JsIdentifierAssignment::cast(node.clone()).unwrap(), f)
                }
                JS_IDENTIFIER_BINDING => {
                    std::fmt::Debug::fmt(&JsIdentifierBinding::cast(node.clone()).unwrap(), f)
                }
                JS_IDENTIFIER_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsIdentifierExpression::cast(node.clone()).unwrap(), f)
                }
                JS_IF_STATEMENT => {
                    std::fmt::Debug::fmt(&JsIfStatement::cast(node.clone()).unwrap(), f)
                }
                JS_IMPORT => std::fmt::Debug::fmt(&JsImport::cast(node.clone()).unwrap(), f),
                JS_IMPORT_ASSERTION => {
                    std::fmt::Debug::fmt(&JsImportAssertion::cast(node.clone()).unwrap(), f)
                }
                JS_IMPORT_ASSERTION_ENTRY => {
                    std::fmt::Debug::fmt(&JsImportAssertionEntry::cast(node.clone()).unwrap(), f)
                }
                JS_IMPORT_ASSERTION_ENTRY_LIST => std::fmt::Debug::fmt(
                    &JsImportAssertionEntryList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_IMPORT_BARE_CLAUSE => {
                    std::fmt::Debug::fmt(&JsImportBareClause::cast(node.clone()).unwrap(), f)
                }
                JS_IMPORT_CALL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsImportCallExpression::cast(node.clone()).unwrap(), f)
                }
                JS_IMPORT_DEFAULT_CLAUSE => {
                    std::fmt::Debug::fmt(&JsImportDefaultClause::cast(node.clone()).unwrap(), f)
                }
                JS_IMPORT_NAMED_CLAUSE => {
                    std::fmt::Debug::fmt(&JsImportNamedClause::cast(node.clone()).unwrap(), f)
                }
                JS_IMPORT_NAMESPACE_CLAUSE => {
                    std::fmt::Debug::fmt(&JsImportNamespaceClause::cast(node.clone()).unwrap(), f)
                }
                JS_IN_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsInExpression::cast(node.clone()).unwrap(), f)
                }
                JS_INITIALIZER_CLAUSE => {
                    std::fmt::Debug::fmt(&JsInitializerClause::cast(node.clone()).unwrap(), f)
                }
                JS_INSTANCEOF_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsInstanceofExpression::cast(node.clone()).unwrap(), f)
                }
                JS_LABELED_STATEMENT => {
                    std::fmt::Debug::fmt(&JsLabeledStatement::cast(node.clone()).unwrap(), f)
                }
                JS_LITERAL_EXPORT_NAME => {
                    std::fmt::Debug::fmt(&JsLiteralExportName::cast(node.clone()).unwrap(), f)
                }
                JS_LITERAL_MEMBER_NAME => {
                    std::fmt::Debug::fmt(&JsLiteralMemberName::cast(node.clone()).unwrap(), f)
                }
                JS_LOGICAL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsLogicalExpression::cast(node.clone()).unwrap(), f)
                }
                JS_METHOD_CLASS_MEMBER => {
                    std::fmt::Debug::fmt(&JsMethodClassMember::cast(node.clone()).unwrap(), f)
                }
                JS_METHOD_MODIFIER_LIST => {
                    std::fmt::Debug::fmt(&JsMethodModifierList::cast(node.clone()).unwrap(), f)
                }
                JS_METHOD_OBJECT_MEMBER => {
                    std::fmt::Debug::fmt(&JsMethodObjectMember::cast(node.clone()).unwrap(), f)
                }
                JS_MODULE => std::fmt::Debug::fmt(&JsModule::cast(node.clone()).unwrap(), f),
                JS_MODULE_ITEM_LIST => {
                    std::fmt::Debug::fmt(&JsModuleItemList::cast(node.clone()).unwrap(), f)
                }
                JS_MODULE_SOURCE => {
                    std::fmt::Debug::fmt(&JsModuleSource::cast(node.clone()).unwrap(), f)
                }
                JS_NAME => std::fmt::Debug::fmt(&JsName::cast(node.clone()).unwrap(), f),
                JS_NAMED_IMPORT_SPECIFIER => {
                    std::fmt::Debug::fmt(&JsNamedImportSpecifier::cast(node.clone()).unwrap(), f)
                }
                JS_NAMED_IMPORT_SPECIFIER_LIST => std::fmt::Debug::fmt(
                    &JsNamedImportSpecifierList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_NAMED_IMPORT_SPECIFIERS => {
                    std::fmt::Debug::fmt(&JsNamedImportSpecifiers::cast(node.clone()).unwrap(), f)
                }
                JS_NAMESPACE_IMPORT_SPECIFIER => std::fmt::Debug::fmt(
                    &JsNamespaceImportSpecifier::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_NEW_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsNewExpression::cast(node.clone()).unwrap(), f)
                }
                JS_NULL_LITERAL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsNullLiteralExpression::cast(node.clone()).unwrap(), f)
                }
                JS_NUMBER_LITERAL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsNumberLiteralExpression::cast(node.clone()).unwrap(), f)
                }
                JS_OBJECT_ASSIGNMENT_PATTERN => {
                    std::fmt::Debug::fmt(&JsObjectAssignmentPattern::cast(node.clone()).unwrap(), f)
                }
                JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY => std::fmt::Debug::fmt(
                    &JsObjectAssignmentPatternProperty::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY_LIST => std::fmt::Debug::fmt(
                    &JsObjectAssignmentPatternPropertyList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_OBJECT_ASSIGNMENT_PATTERN_REST => std::fmt::Debug::fmt(
                    &JsObjectAssignmentPatternRest::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY => std::fmt::Debug::fmt(
                    &JsObjectAssignmentPatternShorthandProperty::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_OBJECT_BINDING_PATTERN => {
                    std::fmt::Debug::fmt(&JsObjectBindingPattern::cast(node.clone()).unwrap(), f)
                }
                JS_OBJECT_BINDING_PATTERN_PROPERTY => std::fmt::Debug::fmt(
                    &JsObjectBindingPatternProperty::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_OBJECT_BINDING_PATTERN_PROPERTY_LIST => std::fmt::Debug::fmt(
                    &JsObjectBindingPatternPropertyList::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_OBJECT_BINDING_PATTERN_REST => std::fmt::Debug::fmt(
                    &JsObjectBindingPatternRest::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY => std::fmt::Debug::fmt(
                    &JsObjectBindingPatternShorthandProperty::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_OBJECT_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsObjectExpression::cast(node.clone()).unwrap(), f)
                }
                JS_OBJECT_MEMBER_LIST => {
                    std::fmt::Debug::fmt(&JsObjectMemberList::cast(node.clone()).unwrap(), f)
                }
                JS_PARAMETER_LIST => {
                    std::fmt::Debug::fmt(&JsParameterList::cast(node.clone()).unwrap(), f)
                }
                JS_PARAMETERS => {
                    std::fmt::Debug::fmt(&JsParameters::cast(node.clone()).unwrap(), f)
                }
                JS_PARENTHESIZED_ASSIGNMENT => {
                    std::fmt::Debug::fmt(&JsParenthesizedAssignment::cast(node.clone()).unwrap(), f)
                }
                JS_PARENTHESIZED_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsParenthesizedExpression::cast(node.clone()).unwrap(), f)
                }
                JS_POST_UPDATE_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsPostUpdateExpression::cast(node.clone()).unwrap(), f)
                }
                JS_PRE_UPDATE_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsPreUpdateExpression::cast(node.clone()).unwrap(), f)
                }
                JS_PRIVATE_CLASS_MEMBER_NAME => {
                    std::fmt::Debug::fmt(&JsPrivateClassMemberName::cast(node.clone()).unwrap(), f)
                }
                JS_PRIVATE_NAME => {
                    std::fmt::Debug::fmt(&JsPrivateName::cast(node.clone()).unwrap(), f)
                }
                JS_PROPERTY_CLASS_MEMBER => {
                    std::fmt::Debug::fmt(&JsPropertyClassMember::cast(node.clone()).unwrap(), f)
                }
                JS_PROPERTY_MODIFIER_LIST => {
                    std::fmt::Debug::fmt(&JsPropertyModifierList::cast(node.clone()).unwrap(), f)
                }
                JS_PROPERTY_OBJECT_MEMBER => {
                    std::fmt::Debug::fmt(&JsPropertyObjectMember::cast(node.clone()).unwrap(), f)
                }
                JS_REFERENCE_IDENTIFIER => {
                    std::fmt::Debug::fmt(&JsReferenceIdentifier::cast(node.clone()).unwrap(), f)
                }
                JS_REGEX_LITERAL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsRegexLiteralExpression::cast(node.clone()).unwrap(), f)
                }
                JS_REST_PARAMETER => {
                    std::fmt::Debug::fmt(&JsRestParameter::cast(node.clone()).unwrap(), f)
                }
                JS_RETURN_STATEMENT => {
                    std::fmt::Debug::fmt(&JsReturnStatement::cast(node.clone()).unwrap(), f)
                }
                JS_SCRIPT => std::fmt::Debug::fmt(&JsScript::cast(node.clone()).unwrap(), f),
                JS_SEQUENCE_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsSequenceExpression::cast(node.clone()).unwrap(), f)
                }
                JS_SETTER_CLASS_MEMBER => {
                    std::fmt::Debug::fmt(&JsSetterClassMember::cast(node.clone()).unwrap(), f)
                }
                JS_SETTER_OBJECT_MEMBER => {
                    std::fmt::Debug::fmt(&JsSetterObjectMember::cast(node.clone()).unwrap(), f)
                }
                JS_SHORTHAND_NAMED_IMPORT_SPECIFIER => std::fmt::Debug::fmt(
                    &JsShorthandNamedImportSpecifier::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_SHORTHAND_PROPERTY_OBJECT_MEMBER => std::fmt::Debug::fmt(
                    &JsShorthandPropertyObjectMember::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_SPREAD => std::fmt::Debug::fmt(&JsSpread::cast(node.clone()).unwrap(), f),
                JS_STATEMENT_LIST => {
                    std::fmt::Debug::fmt(&JsStatementList::cast(node.clone()).unwrap(), f)
                }
                JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER => std::fmt::Debug::fmt(
                    &JsStaticInitializationBlockClassMember::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_STATIC_MEMBER_ASSIGNMENT => {
                    std::fmt::Debug::fmt(&JsStaticMemberAssignment::cast(node.clone()).unwrap(), f)
                }
                JS_STATIC_MEMBER_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsStaticMemberExpression::cast(node.clone()).unwrap(), f)
                }
                JS_STATIC_MODIFIER => {
                    std::fmt::Debug::fmt(&JsStaticModifier::cast(node.clone()).unwrap(), f)
                }
                JS_STRING_LITERAL_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsStringLiteralExpression::cast(node.clone()).unwrap(), f)
                }
                JS_SUPER_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsSuperExpression::cast(node.clone()).unwrap(), f)
                }
                JS_SWITCH_CASE_LIST => {
                    std::fmt::Debug::fmt(&JsSwitchCaseList::cast(node.clone()).unwrap(), f)
                }
                JS_SWITCH_STATEMENT => {
                    std::fmt::Debug::fmt(&JsSwitchStatement::cast(node.clone()).unwrap(), f)
                }
                JS_TEMPLATE => std::fmt::Debug::fmt(&JsTemplate::cast(node.clone()).unwrap(), f),
                JS_TEMPLATE_CHUNK_ELEMENT => {
                    std::fmt::Debug::fmt(&JsTemplateChunkElement::cast(node.clone()).unwrap(), f)
                }
                JS_TEMPLATE_ELEMENT => {
                    std::fmt::Debug::fmt(&JsTemplateElement::cast(node.clone()).unwrap(), f)
                }
                JS_TEMPLATE_ELEMENT_LIST => {
                    std::fmt::Debug::fmt(&JsTemplateElementList::cast(node.clone()).unwrap(), f)
                }
                JS_THIS_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsThisExpression::cast(node.clone()).unwrap(), f)
                }
                JS_THROW_STATEMENT => {
                    std::fmt::Debug::fmt(&JsThrowStatement::cast(node.clone()).unwrap(), f)
                }
                JS_TRY_FINALLY_STATEMENT => {
                    std::fmt::Debug::fmt(&JsTryFinallyStatement::cast(node.clone()).unwrap(), f)
                }
                JS_TRY_STATEMENT => {
                    std::fmt::Debug::fmt(&JsTryStatement::cast(node.clone()).unwrap(), f)
                }
                JS_UNARY_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsUnaryExpression::cast(node.clone()).unwrap(), f)
                }
                JS_UNKNOWN => std::fmt::Debug::fmt(&JsUnknown::cast(node.clone()).unwrap(), f),
                JS_UNKNOWN_ASSIGNMENT => {
                    std::fmt::Debug::fmt(&JsUnknownAssignment::cast(node.clone()).unwrap(), f)
                }
                JS_UNKNOWN_BINDING => {
                    std::fmt::Debug::fmt(&JsUnknownBinding::cast(node.clone()).unwrap(), f)
                }
                JS_UNKNOWN_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsUnknownExpression::cast(node.clone()).unwrap(), f)
                }
                JS_UNKNOWN_IMPORT_ASSERTION_ENTRY => std::fmt::Debug::fmt(
                    &JsUnknownImportAssertionEntry::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_UNKNOWN_MEMBER => {
                    std::fmt::Debug::fmt(&JsUnknownMember::cast(node.clone()).unwrap(), f)
                }
                JS_UNKNOWN_NAMED_IMPORT_SPECIFIER => std::fmt::Debug::fmt(
                    &JsUnknownNamedImportSpecifier::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_UNKNOWN_PARAMETER => {
                    std::fmt::Debug::fmt(&JsUnknownParameter::cast(node.clone()).unwrap(), f)
                }
                JS_UNKNOWN_STATEMENT => {
                    std::fmt::Debug::fmt(&JsUnknownStatement::cast(node.clone()).unwrap(), f)
                }
                JS_VARIABLE_DECLARATION => {
                    std::fmt::Debug::fmt(&JsVariableDeclaration::cast(node.clone()).unwrap(), f)
                }
                JS_VARIABLE_DECLARATION_CLAUSE => std::fmt::Debug::fmt(
                    &JsVariableDeclarationClause::cast(node.clone()).unwrap(),
                    f,
                ),
                JS_VARIABLE_DECLARATOR => {
                    std::fmt::Debug::fmt(&JsVariableDeclarator::cast(node.clone()).unwrap(), f)
                }
                JS_VARIABLE_DECLARATOR_LIST => {
                    std::fmt::Debug::fmt(&JsVariableDeclaratorList::cast(node.clone()).unwrap(), f)
                }
                JS_VARIABLE_STATEMENT => {
                    std::fmt::Debug::fmt(&JsVariableStatement::cast(node.clone()).unwrap(), f)
                }
                JS_WHILE_STATEMENT => {
                    std::fmt::Debug::fmt(&JsWhileStatement::cast(node.clone()).unwrap(), f)
                }
                JS_WITH_STATEMENT => {
                    std::fmt::Debug::fmt(&JsWithStatement::cast(node.clone()).unwrap(), f)
                }
                JS_YIELD_ARGUMENT => {
                    std::fmt::Debug::fmt(&JsYieldArgument::cast(node.clone()).unwrap(), f)
                }
                JS_YIELD_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsYieldExpression::cast(node.clone()).unwrap(), f)
                }
                JSX_ATTRIBUTE => {
                    std::fmt::Debug::fmt(&JsxAttribute::cast(node.clone()).unwrap(), f)
                }
                JSX_ATTRIBUTE_INITIALIZER_CLAUSE => std::fmt::Debug::fmt(
                    &JsxAttributeInitializerClause::cast(node.clone()).unwrap(),
                    f,
                ),
                JSX_ATTRIBUTE_LIST => {
                    std::fmt::Debug::fmt(&JsxAttributeList::cast(node.clone()).unwrap(), f)
                }
                JSX_CHILD_LIST => {
                    std::fmt::Debug::fmt(&JsxChildList::cast(node.clone()).unwrap(), f)
                }
                JSX_CLOSING_ELEMENT => {
                    std::fmt::Debug::fmt(&JsxClosingElement::cast(node.clone()).unwrap(), f)
                }
                JSX_CLOSING_FRAGMENT => {
                    std::fmt::Debug::fmt(&JsxClosingFragment::cast(node.clone()).unwrap(), f)
                }
                JSX_ELEMENT => std::fmt::Debug::fmt(&JsxElement::cast(node.clone()).unwrap(), f),
                JSX_EXPRESSION_ATTRIBUTE_VALUE => std::fmt::Debug::fmt(
                    &JsxExpressionAttributeValue::cast(node.clone()).unwrap(),
                    f,
                ),
                JSX_EXPRESSION_CHILD => {
                    std::fmt::Debug::fmt(&JsxExpressionChild::cast(node.clone()).unwrap(), f)
                }
                JSX_FRAGMENT => std::fmt::Debug::fmt(&JsxFragment::cast(node.clone()).unwrap(), f),
                JSX_MEMBER_NAME => {
                    std::fmt::Debug::fmt(&JsxMemberName::cast(node.clone()).unwrap(), f)
                }
                JSX_NAME => std::fmt::Debug::fmt(&JsxName::cast(node.clone()).unwrap(), f),
                JSX_NAMESPACE_NAME => {
                    std::fmt::Debug::fmt(&JsxNamespaceName::cast(node.clone()).unwrap(), f)
                }
                JSX_OPENING_ELEMENT => {
                    std::fmt::Debug::fmt(&JsxOpeningElement::cast(node.clone()).unwrap(), f)
                }
                JSX_OPENING_FRAGMENT => {
                    std::fmt::Debug::fmt(&JsxOpeningFragment::cast(node.clone()).unwrap(), f)
                }
                JSX_REFERENCE_IDENTIFIER => {
                    std::fmt::Debug::fmt(&JsxReferenceIdentifier::cast(node.clone()).unwrap(), f)
                }
                JSX_SELF_CLOSING_ELEMENT => {
                    std::fmt::Debug::fmt(&JsxSelfClosingElement::cast(node.clone()).unwrap(), f)
                }
                JSX_SPREAD_ATTRIBUTE => {
                    std::fmt::Debug::fmt(&JsxSpreadAttribute::cast(node.clone()).unwrap(), f)
                }
                JSX_SPREAD_CHILD => {
                    std::fmt::Debug::fmt(&JsxSpreadChild::cast(node.clone()).unwrap(), f)
                }
                JSX_STRING => std::fmt::Debug::fmt(&JsxString::cast(node.clone()).unwrap(), f),
                JSX_TAG_EXPRESSION => {
                    std::fmt::Debug::fmt(&JsxTagExpression::cast(node.clone()).unwrap(), f)
                }
                JSX_TEXT => std::fmt::Debug::fmt(&JsxText::cast(node.clone()).unwrap(), f),
                NEW_TARGET => std::fmt::Debug::fmt(&NewTarget::cast(node.clone()).unwrap(), f),
                TS_ABSTRACT_MODIFIER => {
                    std::fmt::Debug::fmt(&TsAbstractModifier::cast(node.clone()).unwrap(), f)
                }
                TS_ACCESSIBILITY_MODIFIER => {
                    std::fmt::Debug::fmt(&TsAccessibilityModifier::cast(node.clone()).unwrap(), f)
                }
                TS_ANY_TYPE => std::fmt::Debug::fmt(&TsAnyType::cast(node.clone()).unwrap(), f),
                TS_ARRAY_TYPE => std::fmt::Debug::fmt(&TsArrayType::cast(node.clone()).unwrap(), f),
                TS_AS_ASSIGNMENT => {
                    std::fmt::Debug::fmt(&TsAsAssignment::cast(node.clone()).unwrap(), f)
                }
                TS_AS_EXPRESSION => {
                    std::fmt::Debug::fmt(&TsAsExpression::cast(node.clone()).unwrap(), f)
                }
                TS_ASSERTS_CONDITION => {
                    std::fmt::Debug::fmt(&TsAssertsCondition::cast(node.clone()).unwrap(), f)
                }
                TS_ASSERTS_RETURN_TYPE => {
                    std::fmt::Debug::fmt(&TsAssertsReturnType::cast(node.clone()).unwrap(), f)
                }
                TS_BIG_INT_LITERAL_TYPE => {
                    std::fmt::Debug::fmt(&TsBigIntLiteralType::cast(node.clone()).unwrap(), f)
                }
                TS_BIGINT_TYPE => {
                    std::fmt::Debug::fmt(&TsBigintType::cast(node.clone()).unwrap(), f)
                }
                TS_BOOLEAN_LITERAL_TYPE => {
                    std::fmt::Debug::fmt(&TsBooleanLiteralType::cast(node.clone()).unwrap(), f)
                }
                TS_BOOLEAN_TYPE => {
                    std::fmt::Debug::fmt(&TsBooleanType::cast(node.clone()).unwrap(), f)
                }
                TS_CALL_SIGNATURE_TYPE_MEMBER => {
                    std::fmt::Debug::fmt(&TsCallSignatureTypeMember::cast(node.clone()).unwrap(), f)
                }
                TS_CONDITIONAL_TYPE => {
                    std::fmt::Debug::fmt(&TsConditionalType::cast(node.clone()).unwrap(), f)
                }
                TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER => std::fmt::Debug::fmt(
                    &TsConstructSignatureTypeMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER => std::fmt::Debug::fmt(
                    &TsConstructorSignatureClassMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_CONSTRUCTOR_TYPE => {
                    std::fmt::Debug::fmt(&TsConstructorType::cast(node.clone()).unwrap(), f)
                }
                TS_DECLARE_FUNCTION_DECLARATION => std::fmt::Debug::fmt(
                    &TsDeclareFunctionDeclaration::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_DECLARE_MODIFIER => {
                    std::fmt::Debug::fmt(&TsDeclareModifier::cast(node.clone()).unwrap(), f)
                }
                TS_DECLARE_STATEMENT => {
                    std::fmt::Debug::fmt(&TsDeclareStatement::cast(node.clone()).unwrap(), f)
                }
                TS_DEFAULT_TYPE_CLAUSE => {
                    std::fmt::Debug::fmt(&TsDefaultTypeClause::cast(node.clone()).unwrap(), f)
                }
                TS_DEFINITE_PROPERTY_ANNOTATION => std::fmt::Debug::fmt(
                    &TsDefinitePropertyAnnotation::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_DEFINITE_VARIABLE_ANNOTATION => std::fmt::Debug::fmt(
                    &TsDefiniteVariableAnnotation::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY => std::fmt::Debug::fmt(
                    &TsEmptyExternalModuleDeclarationBody::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_ENUM_DECLARATION => {
                    std::fmt::Debug::fmt(&TsEnumDeclaration::cast(node.clone()).unwrap(), f)
                }
                TS_ENUM_MEMBER => {
                    std::fmt::Debug::fmt(&TsEnumMember::cast(node.clone()).unwrap(), f)
                }
                TS_ENUM_MEMBER_LIST => {
                    std::fmt::Debug::fmt(&TsEnumMemberList::cast(node.clone()).unwrap(), f)
                }
                TS_EXPORT_AS_NAMESPACE_CLAUSE => {
                    std::fmt::Debug::fmt(&TsExportAsNamespaceClause::cast(node.clone()).unwrap(), f)
                }
                TS_EXPORT_ASSIGNMENT_CLAUSE => {
                    std::fmt::Debug::fmt(&TsExportAssignmentClause::cast(node.clone()).unwrap(), f)
                }
                TS_EXPORT_DECLARE_CLAUSE => {
                    std::fmt::Debug::fmt(&TsExportDeclareClause::cast(node.clone()).unwrap(), f)
                }
                TS_EXTENDS_CLAUSE => {
                    std::fmt::Debug::fmt(&TsExtendsClause::cast(node.clone()).unwrap(), f)
                }
                TS_EXTERNAL_MODULE_DECLARATION => std::fmt::Debug::fmt(
                    &TsExternalModuleDeclaration::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_EXTERNAL_MODULE_REFERENCE => {
                    std::fmt::Debug::fmt(&TsExternalModuleReference::cast(node.clone()).unwrap(), f)
                }
                TS_FUNCTION_TYPE => {
                    std::fmt::Debug::fmt(&TsFunctionType::cast(node.clone()).unwrap(), f)
                }
                TS_GETTER_SIGNATURE_CLASS_MEMBER => std::fmt::Debug::fmt(
                    &TsGetterSignatureClassMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_GETTER_SIGNATURE_TYPE_MEMBER => std::fmt::Debug::fmt(
                    &TsGetterSignatureTypeMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_GLOBAL_DECLARATION => {
                    std::fmt::Debug::fmt(&TsGlobalDeclaration::cast(node.clone()).unwrap(), f)
                }
                TS_IDENTIFIER_BINDING => {
                    std::fmt::Debug::fmt(&TsIdentifierBinding::cast(node.clone()).unwrap(), f)
                }
                TS_IMPLEMENTS_CLAUSE => {
                    std::fmt::Debug::fmt(&TsImplementsClause::cast(node.clone()).unwrap(), f)
                }
                TS_IMPORT_EQUALS_DECLARATION => {
                    std::fmt::Debug::fmt(&TsImportEqualsDeclaration::cast(node.clone()).unwrap(), f)
                }
                TS_IMPORT_TYPE => {
                    std::fmt::Debug::fmt(&TsImportType::cast(node.clone()).unwrap(), f)
                }
                TS_IMPORT_TYPE_QUALIFIER => {
                    std::fmt::Debug::fmt(&TsImportTypeQualifier::cast(node.clone()).unwrap(), f)
                }
                TS_INDEX_SIGNATURE_CLASS_MEMBER => std::fmt::Debug::fmt(
                    &TsIndexSignatureClassMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_INDEX_SIGNATURE_MODIFIER_LIST => std::fmt::Debug::fmt(
                    &TsIndexSignatureModifierList::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_INDEX_SIGNATURE_PARAMETER => {
                    std::fmt::Debug::fmt(&TsIndexSignatureParameter::cast(node.clone()).unwrap(), f)
                }
                TS_INDEX_SIGNATURE_TYPE_MEMBER => std::fmt::Debug::fmt(
                    &TsIndexSignatureTypeMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_INDEXED_ACCESS_TYPE => {
                    std::fmt::Debug::fmt(&TsIndexedAccessType::cast(node.clone()).unwrap(), f)
                }
                TS_INFER_TYPE => std::fmt::Debug::fmt(&TsInferType::cast(node.clone()).unwrap(), f),
                TS_INTERFACE_DECLARATION => {
                    std::fmt::Debug::fmt(&TsInterfaceDeclaration::cast(node.clone()).unwrap(), f)
                }
                TS_INTERSECTION_TYPE => {
                    std::fmt::Debug::fmt(&TsIntersectionType::cast(node.clone()).unwrap(), f)
                }
                TS_INTERSECTION_TYPE_ELEMENT_LIST => std::fmt::Debug::fmt(
                    &TsIntersectionTypeElementList::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_MAPPED_TYPE => {
                    std::fmt::Debug::fmt(&TsMappedType::cast(node.clone()).unwrap(), f)
                }
                TS_MAPPED_TYPE_AS_CLAUSE => {
                    std::fmt::Debug::fmt(&TsMappedTypeAsClause::cast(node.clone()).unwrap(), f)
                }
                TS_MAPPED_TYPE_OPTIONAL_MODIFIER_CLAUSE => std::fmt::Debug::fmt(
                    &TsMappedTypeOptionalModifierClause::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_MAPPED_TYPE_READONLY_MODIFIER_CLAUSE => std::fmt::Debug::fmt(
                    &TsMappedTypeReadonlyModifierClause::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_METHOD_SIGNATURE_CLASS_MEMBER => std::fmt::Debug::fmt(
                    &TsMethodSignatureClassMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_METHOD_SIGNATURE_MODIFIER_LIST => std::fmt::Debug::fmt(
                    &TsMethodSignatureModifierList::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_METHOD_SIGNATURE_TYPE_MEMBER => std::fmt::Debug::fmt(
                    &TsMethodSignatureTypeMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_MODULE_BLOCK => {
                    std::fmt::Debug::fmt(&TsModuleBlock::cast(node.clone()).unwrap(), f)
                }
                TS_MODULE_DECLARATION => {
                    std::fmt::Debug::fmt(&TsModuleDeclaration::cast(node.clone()).unwrap(), f)
                }
                TS_NAME_WITH_TYPE_ARGUMENTS => {
                    std::fmt::Debug::fmt(&TsNameWithTypeArguments::cast(node.clone()).unwrap(), f)
                }
                TS_NAMED_TUPLE_TYPE_ELEMENT => {
                    std::fmt::Debug::fmt(&TsNamedTupleTypeElement::cast(node.clone()).unwrap(), f)
                }
                TS_NEVER_TYPE => std::fmt::Debug::fmt(&TsNeverType::cast(node.clone()).unwrap(), f),
                TS_NON_NULL_ASSERTION_ASSIGNMENT => std::fmt::Debug::fmt(
                    &TsNonNullAssertionAssignment::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_NON_NULL_ASSERTION_EXPRESSION => std::fmt::Debug::fmt(
                    &TsNonNullAssertionExpression::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_NON_PRIMITIVE_TYPE => {
                    std::fmt::Debug::fmt(&TsNonPrimitiveType::cast(node.clone()).unwrap(), f)
                }
                TS_NULL_LITERAL_TYPE => {
                    std::fmt::Debug::fmt(&TsNullLiteralType::cast(node.clone()).unwrap(), f)
                }
                TS_NUMBER_LITERAL_TYPE => {
                    std::fmt::Debug::fmt(&TsNumberLiteralType::cast(node.clone()).unwrap(), f)
                }
                TS_NUMBER_TYPE => {
                    std::fmt::Debug::fmt(&TsNumberType::cast(node.clone()).unwrap(), f)
                }
                TS_OBJECT_TYPE => {
                    std::fmt::Debug::fmt(&TsObjectType::cast(node.clone()).unwrap(), f)
                }
                TS_OPTIONAL_PROPERTY_ANNOTATION => std::fmt::Debug::fmt(
                    &TsOptionalPropertyAnnotation::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_OPTIONAL_TUPLE_TYPE_ELEMENT => std::fmt::Debug::fmt(
                    &TsOptionalTupleTypeElement::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_OVERRIDE_MODIFIER => {
                    std::fmt::Debug::fmt(&TsOverrideModifier::cast(node.clone()).unwrap(), f)
                }
                TS_PARENTHESIZED_TYPE => {
                    std::fmt::Debug::fmt(&TsParenthesizedType::cast(node.clone()).unwrap(), f)
                }
                TS_PREDICATE_RETURN_TYPE => {
                    std::fmt::Debug::fmt(&TsPredicateReturnType::cast(node.clone()).unwrap(), f)
                }
                TS_PROPERTY_PARAMETER => {
                    std::fmt::Debug::fmt(&TsPropertyParameter::cast(node.clone()).unwrap(), f)
                }
                TS_PROPERTY_PARAMETER_MODIFIER_LIST => std::fmt::Debug::fmt(
                    &TsPropertyParameterModifierList::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_PROPERTY_SIGNATURE_CLASS_MEMBER => std::fmt::Debug::fmt(
                    &TsPropertySignatureClassMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_PROPERTY_SIGNATURE_MODIFIER_LIST => std::fmt::Debug::fmt(
                    &TsPropertySignatureModifierList::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_PROPERTY_SIGNATURE_TYPE_MEMBER => std::fmt::Debug::fmt(
                    &TsPropertySignatureTypeMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_QUALIFIED_MODULE_NAME => {
                    std::fmt::Debug::fmt(&TsQualifiedModuleName::cast(node.clone()).unwrap(), f)
                }
                TS_QUALIFIED_NAME => {
                    std::fmt::Debug::fmt(&TsQualifiedName::cast(node.clone()).unwrap(), f)
                }
                TS_READONLY_MODIFIER => {
                    std::fmt::Debug::fmt(&TsReadonlyModifier::cast(node.clone()).unwrap(), f)
                }
                TS_REFERENCE_TYPE => {
                    std::fmt::Debug::fmt(&TsReferenceType::cast(node.clone()).unwrap(), f)
                }
                TS_REST_TUPLE_TYPE_ELEMENT => {
                    std::fmt::Debug::fmt(&TsRestTupleTypeElement::cast(node.clone()).unwrap(), f)
                }
                TS_RETURN_TYPE_ANNOTATION => {
                    std::fmt::Debug::fmt(&TsReturnTypeAnnotation::cast(node.clone()).unwrap(), f)
                }
                TS_SETTER_SIGNATURE_CLASS_MEMBER => std::fmt::Debug::fmt(
                    &TsSetterSignatureClassMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_SETTER_SIGNATURE_TYPE_MEMBER => std::fmt::Debug::fmt(
                    &TsSetterSignatureTypeMember::cast(node.clone()).unwrap(),
                    f,
                ),
                TS_STRING_LITERAL_TYPE => {
                    std::fmt::Debug::fmt(&TsStringLiteralType::cast(node.clone()).unwrap(), f)
                }
                TS_STRING_TYPE => {
                    std::fmt::Debug::fmt(&TsStringType::cast(node.clone()).unwrap(), f)
                }
                TS_SYMBOL_TYPE => {
                    std::fmt::Debug::fmt(&TsSymbolType::cast(node.clone()).unwrap(), f)
                }
                TS_TEMPLATE_CHUNK_ELEMENT => {
                    std::fmt::Debug::fmt(&TsTemplateChunkElement::cast(node.clone()).unwrap(), f)
                }
                TS_TEMPLATE_ELEMENT => {
                    std::fmt::Debug::fmt(&TsTemplateElement::cast(node.clone()).unwrap(), f)
                }
                TS_TEMPLATE_ELEMENT_LIST => {
                    std::fmt::Debug::fmt(&TsTemplateElementList::cast(node.clone()).unwrap(), f)
                }
                TS_TEMPLATE_LITERAL_TYPE => {
                    std::fmt::Debug::fmt(&TsTemplateLiteralType::cast(node.clone()).unwrap(), f)
                }
                TS_THIS_PARAMETER => {
                    std::fmt::Debug::fmt(&TsThisParameter::cast(node.clone()).unwrap(), f)
                }
                TS_THIS_TYPE => std::fmt::Debug::fmt(&TsThisType::cast(node.clone()).unwrap(), f),
                TS_TUPLE_TYPE => std::fmt::Debug::fmt(&TsTupleType::cast(node.clone()).unwrap(), f),
                TS_TUPLE_TYPE_ELEMENT_LIST => {
                    std::fmt::Debug::fmt(&TsTupleTypeElementList::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_ALIAS_DECLARATION => {
                    std::fmt::Debug::fmt(&TsTypeAliasDeclaration::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_ANNOTATION => {
                    std::fmt::Debug::fmt(&TsTypeAnnotation::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_ARGUMENT_LIST => {
                    std::fmt::Debug::fmt(&TsTypeArgumentList::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_ARGUMENTS => {
                    std::fmt::Debug::fmt(&TsTypeArguments::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_ASSERTION_ASSIGNMENT => {
                    std::fmt::Debug::fmt(&TsTypeAssertionAssignment::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_ASSERTION_EXPRESSION => {
                    std::fmt::Debug::fmt(&TsTypeAssertionExpression::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_CONSTRAINT_CLAUSE => {
                    std::fmt::Debug::fmt(&TsTypeConstraintClause::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_LIST => std::fmt::Debug::fmt(&TsTypeList::cast(node.clone()).unwrap(), f),
                TS_TYPE_MEMBER_LIST => {
                    std::fmt::Debug::fmt(&TsTypeMemberList::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_OPERATOR_TYPE => {
                    std::fmt::Debug::fmt(&TsTypeOperatorType::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_PARAMETER => {
                    std::fmt::Debug::fmt(&TsTypeParameter::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_PARAMETER_LIST => {
                    std::fmt::Debug::fmt(&TsTypeParameterList::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_PARAMETER_NAME => {
                    std::fmt::Debug::fmt(&TsTypeParameterName::cast(node.clone()).unwrap(), f)
                }
                TS_TYPE_PARAMETERS => {
                    std::fmt::Debug::fmt(&TsTypeParameters::cast(node.clone()).unwrap(), f)
                }
                TS_TYPEOF_TYPE => {
                    std::fmt::Debug::fmt(&TsTypeofType::cast(node.clone()).unwrap(), f)
                }
                TS_UNDEFINED_TYPE => {
                    std::fmt::Debug::fmt(&TsUndefinedType::cast(node.clone()).unwrap(), f)
                }
                TS_UNION_TYPE => std::fmt::Debug::fmt(&TsUnionType::cast(node.clone()).unwrap(), f),
                TS_UNION_TYPE_VARIANT_LIST => {
                    std::fmt::Debug::fmt(&TsUnionTypeVariantList::cast(node.clone()).unwrap(), f)
                }
                TS_UNKNOWN_TYPE => {
                    std::fmt::Debug::fmt(&TsUnknownType::cast(node.clone()).unwrap(), f)
                }
                TS_VOID_TYPE => std::fmt::Debug::fmt(&TsVoidType::cast(node.clone()).unwrap(), f),
                _ => std::fmt::Debug::fmt(node, f),
            },
            NodeOrToken::Token(token) => Debug::fmt(token, f),
        }
    }
}
