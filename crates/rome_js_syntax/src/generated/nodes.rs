//! Generated file, do not edit by hand, see `xtask/codegen`

#![allow(clippy::enum_variant_names)]
#![allow(clippy::match_like_matches_macro)]
use crate::{
    macros::map_syntax_node,
    JsLanguage as Language, JsSyntaxElement as SyntaxElement,
    JsSyntaxElementChildren as SyntaxElementChildren,
    JsSyntaxKind::{self as SyntaxKind, *},
    JsSyntaxList as SyntaxList, JsSyntaxNode as SyntaxNode, JsSyntaxToken as SyntaxToken,
};
use rome_rowan::{support, AstNode, SyntaxResult};
#[allow(unused)]
use rome_rowan::{
    AstNodeList, AstNodeListIterator, AstSeparatedList, AstSeparatedListNodesIterator,
};
#[cfg(feature = "serde")]
use serde_crate::ser::SerializeSeq;
#[cfg(feature = "serde")]
use serde_crate::{Serialize, Serializer};
use std::fmt::{Debug, Formatter};
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ImportMeta {
    pub(crate) syntax: SyntaxNode,
}
impl ImportMeta {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> ImportMetaFields {
        ImportMetaFields {
            import_token: self.import_token(),
            dot_token: self.dot_token(),
            meta_token: self.meta_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn meta_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for ImportMeta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct ImportMetaFields {
    pub import_token: SyntaxResult<SyntaxToken>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub meta_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayAssignmentPattern {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayAssignmentPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayAssignmentPatternFields {
        JsArrayAssignmentPatternFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayAssignmentPatternElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayAssignmentPattern {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsArrayAssignmentPatternFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub elements: JsArrayAssignmentPatternElementList,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayAssignmentPatternRestElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayAssignmentPatternRestElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayAssignmentPatternRestElementFields {
        JsArrayAssignmentPatternRestElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            pattern: self.pattern(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyAssignmentPattern> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayAssignmentPatternRestElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsArrayAssignmentPatternRestElementFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub pattern: SyntaxResult<JsAnyAssignmentPattern>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayBindingPattern {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayBindingPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayBindingPatternFields {
        JsArrayBindingPatternFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayBindingPatternElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayBindingPattern {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsArrayBindingPatternFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub elements: JsArrayBindingPatternElementList,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayBindingPatternRestElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayBindingPatternRestElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayBindingPatternRestElementFields {
        JsArrayBindingPatternRestElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            pattern: self.pattern(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayBindingPatternRestElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsArrayBindingPatternRestElementFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub pattern: SyntaxResult<JsAnyBindingPattern>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayExpressionFields {
        JsArrayExpressionFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayElementList { support::list(&self.syntax, 1usize) }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsArrayExpressionFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub elements: JsArrayElementList,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayHole {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayHole {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayHoleFields { JsArrayHoleFields {} }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayHole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsArrayHoleFields {}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrowFunctionExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrowFunctionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrowFunctionExpressionFields {
        JsArrowFunctionExpressionFields {
            async_token: self.async_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            fat_arrow_token: self.fat_arrow_token(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsAnyArrowFunctionParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrowFunctionExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsArrowFunctionExpressionFields {
    pub async_token: Option<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsAnyArrowFunctionParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub fat_arrow_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsAnyFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAssignmentExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsAssignmentExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsAssignmentExpressionFields {
        JsAssignmentExpressionFields {
            left: self.left(),
            operator_token: self.operator_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyAssignmentPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsAssignmentExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsAssignmentExpressionFields {
    pub left: SyntaxResult<JsAnyAssignmentPattern>,
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAssignmentWithDefault {
    pub(crate) syntax: SyntaxNode,
}
impl JsAssignmentWithDefault {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsAssignmentWithDefaultFields {
        JsAssignmentWithDefaultFields {
            pattern: self.pattern(),
            eq_token: self.eq_token(),
            default: self.default(),
        }
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyAssignmentPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn default(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsAssignmentWithDefault {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsAssignmentWithDefaultFields {
    pub pattern: SyntaxResult<JsAnyAssignmentPattern>,
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub default: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAwaitExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsAwaitExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsAwaitExpressionFields {
        JsAwaitExpressionFields {
            await_token: self.await_token(),
            argument: self.argument(),
        }
    }
    pub fn await_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsAwaitExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsAwaitExpressionFields {
    pub await_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBigIntLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsBigIntLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBigIntLiteralExpressionFields {
        JsBigIntLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBigIntLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsBigIntLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBinaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsBinaryExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBinaryExpressionFields {
        JsBinaryExpressionFields {
            left: self.left(),
            operator_token: self.operator_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBinaryExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsBinaryExpressionFields {
    pub left: SyntaxResult<JsAnyExpression>,
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBindingPatternWithDefault {
    pub(crate) syntax: SyntaxNode,
}
impl JsBindingPatternWithDefault {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBindingPatternWithDefaultFields {
        JsBindingPatternWithDefaultFields {
            pattern: self.pattern(),
            eq_token: self.eq_token(),
            default: self.default(),
        }
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn default(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBindingPatternWithDefault {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsBindingPatternWithDefaultFields {
    pub pattern: SyntaxResult<JsAnyBindingPattern>,
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub default: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBlockStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsBlockStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBlockStatementFields {
        JsBlockStatementFields {
            l_curly_token: self.l_curly_token(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn statements(&self) -> JsStatementList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBlockStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsBlockStatementFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBooleanLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsBooleanLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBooleanLiteralExpressionFields {
        JsBooleanLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBooleanLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsBooleanLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBreakStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsBreakStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBreakStatementFields {
        JsBreakStatementFields {
            break_token: self.break_token(),
            label_token: self.label_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn break_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn label_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsBreakStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsBreakStatementFields {
    pub break_token: SyntaxResult<SyntaxToken>,
    pub label_token: Option<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCallArguments {
    pub(crate) syntax: SyntaxNode,
}
impl JsCallArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCallArgumentsFields {
        JsCallArgumentsFields {
            l_paren_token: self.l_paren_token(),
            args: self.args(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn args(&self) -> JsCallArgumentList { support::list(&self.syntax, 1usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsCallArguments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsCallArgumentsFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub args: JsCallArgumentList,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCallExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsCallExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCallExpressionFields {
        JsCallExpressionFields {
            callee: self.callee(),
            optional_chain_token: self.optional_chain_token(),
            type_arguments: self.type_arguments(),
            arguments: self.arguments(),
        }
    }
    pub fn callee(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_chain_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
    pub fn arguments(&self) -> SyntaxResult<JsCallArguments> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsCallExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsCallExpressionFields {
    pub callee: SyntaxResult<JsAnyExpression>,
    pub optional_chain_token: Option<SyntaxToken>,
    pub type_arguments: Option<TsTypeArguments>,
    pub arguments: SyntaxResult<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCaseClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsCaseClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCaseClauseFields {
        JsCaseClauseFields {
            case_token: self.case_token(),
            test: self.test(),
            colon_token: self.colon_token(),
            consequent: self.consequent(),
        }
    }
    pub fn case_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn consequent(&self) -> JsStatementList { support::list(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsCaseClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsCaseClauseFields {
    pub case_token: SyntaxResult<SyntaxToken>,
    pub test: SyntaxResult<JsAnyExpression>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub consequent: JsStatementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCatchClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsCatchClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCatchClauseFields {
        JsCatchClauseFields {
            catch_token: self.catch_token(),
            declaration: self.declaration(),
            body: self.body(),
        }
    }
    pub fn catch_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> Option<JsCatchDeclaration> { support::node(&self.syntax, 1usize) }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsCatchClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsCatchClauseFields {
    pub catch_token: SyntaxResult<SyntaxToken>,
    pub declaration: Option<JsCatchDeclaration>,
    pub body: SyntaxResult<JsBlockStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCatchDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsCatchDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCatchDeclarationFields {
        JsCatchDeclarationFields {
            l_paren_token: self.l_paren_token(),
            binding: self.binding(),
            type_annotation: self.type_annotation(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsCatchDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsCatchDeclarationFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub binding: SyntaxResult<JsAnyBindingPattern>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsClassDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsClassDeclarationFields {
        JsClassDeclarationFields {
            abstract_token: self.abstract_token(),
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn abstract_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn class_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> { support::required_node(&self.syntax, 2usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> { support::node(&self.syntax, 4usize) }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 5usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
    pub fn members(&self) -> JsClassMemberList { support::list(&self.syntax, 7usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 8usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsClassDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsClassDeclarationFields {
    pub abstract_token: Option<SyntaxToken>,
    pub class_token: SyntaxResult<SyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassExportDefaultDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsClassExportDefaultDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsClassExportDefaultDeclarationFields {
        JsClassExportDefaultDeclarationFields {
            abstract_token: self.abstract_token(),
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn abstract_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn class_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> Option<JsAnyBinding> { support::node(&self.syntax, 2usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> { support::node(&self.syntax, 4usize) }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 5usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
    pub fn members(&self) -> JsClassMemberList { support::list(&self.syntax, 7usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 8usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsClassExportDefaultDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsClassExportDefaultDeclarationFields {
    pub abstract_token: Option<SyntaxToken>,
    pub class_token: SyntaxResult<SyntaxToken>,
    pub id: Option<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsClassExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsClassExpressionFields {
        JsClassExpressionFields {
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn class_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn id(&self) -> Option<JsAnyBinding> { support::node(&self.syntax, 1usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> { support::node(&self.syntax, 3usize) }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 4usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn members(&self) -> JsClassMemberList { support::list(&self.syntax, 6usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsClassExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsClassExpressionFields {
    pub class_token: SyntaxResult<SyntaxToken>,
    pub id: Option<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl JsComputedMemberAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsComputedMemberAssignmentFields {
        JsComputedMemberAssignmentFields {
            object: self.object(),
            l_brack_token: self.l_brack_token(),
            member: self.member(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsComputedMemberAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsComputedMemberAssignmentFields {
    pub object: SyntaxResult<JsAnyExpression>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<JsAnyExpression>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsComputedMemberExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsComputedMemberExpressionFields {
        JsComputedMemberExpressionFields {
            object: self.object(),
            optional_chain_token: self.optional_chain_token(),
            l_brack_token: self.l_brack_token(),
            member: self.member(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_chain_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn member(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsComputedMemberExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsComputedMemberExpressionFields {
    pub object: SyntaxResult<JsAnyExpression>,
    pub optional_chain_token: Option<SyntaxToken>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<JsAnyExpression>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberName {
    pub(crate) syntax: SyntaxNode,
}
impl JsComputedMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsComputedMemberNameFields {
        JsComputedMemberNameFields {
            l_brack_token: self.l_brack_token(),
            expression: self.expression(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsComputedMemberName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsComputedMemberNameFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConditionalExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsConditionalExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsConditionalExpressionFields {
        JsConditionalExpressionFields {
            test: self.test(),
            question_mark_token: self.question_mark_token(),
            consequent: self.consequent(),
            colon_token: self.colon_token(),
            alternate: self.alternate(),
        }
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn consequent(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn alternate(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsConditionalExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsConditionalExpressionFields {
    pub test: SyntaxResult<JsAnyExpression>,
    pub question_mark_token: SyntaxResult<SyntaxToken>,
    pub consequent: SyntaxResult<JsAnyExpression>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub alternate: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConstructorClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsConstructorClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsConstructorClassMemberFields {
        JsConstructorClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            parameters: self.parameters(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsConstructorModifierList { support::list(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsLiteralMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsConstructorParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsConstructorClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsConstructorClassMemberFields {
    pub modifiers: JsConstructorModifierList,
    pub name: SyntaxResult<JsLiteralMemberName>,
    pub parameters: SyntaxResult<JsConstructorParameters>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConstructorParameters {
    pub(crate) syntax: SyntaxNode,
}
impl JsConstructorParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsConstructorParametersFields {
        JsConstructorParametersFields {
            l_paren_token: self.l_paren_token(),
            parameters: self.parameters(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> JsConstructorParameterList { support::list(&self.syntax, 1usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsConstructorParameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsConstructorParametersFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameters: JsConstructorParameterList,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsContinueStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsContinueStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsContinueStatementFields {
        JsContinueStatementFields {
            continue_token: self.continue_token(),
            label_token: self.label_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn continue_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn label_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsContinueStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsContinueStatementFields {
    pub continue_token: SyntaxResult<SyntaxToken>,
    pub label_token: Option<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDebuggerStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsDebuggerStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDebuggerStatementFields {
        JsDebuggerStatementFields {
            debugger_token: self.debugger_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn debugger_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsDebuggerStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsDebuggerStatementFields {
    pub debugger_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDefaultClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsDefaultClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDefaultClauseFields {
        JsDefaultClauseFields {
            default_token: self.default_token(),
            colon_token: self.colon_token(),
            consequent: self.consequent(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn consequent(&self) -> JsStatementList { support::list(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsDefaultClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsDefaultClauseFields {
    pub default_token: SyntaxResult<SyntaxToken>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub consequent: JsStatementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDefaultImportSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsDefaultImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDefaultImportSpecifierFields {
        JsDefaultImportSpecifierFields {
            local_name: self.local_name(),
            trailing_comma_token: self.trailing_comma_token(),
        }
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn trailing_comma_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsDefaultImportSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsDefaultImportSpecifierFields {
    pub local_name: SyntaxResult<JsAnyBinding>,
    pub trailing_comma_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDirective {
    pub(crate) syntax: SyntaxNode,
}
impl JsDirective {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDirectiveFields {
        JsDirectiveFields {
            value_token: self.value_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsDirective {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsDirectiveFields {
    pub value_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDoWhileStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsDoWhileStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDoWhileStatementFields {
        JsDoWhileStatementFields {
            do_token: self.do_token(),
            body: self.body(),
            while_token: self.while_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn do_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn while_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsDoWhileStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsDoWhileStatementFields {
    pub do_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
    pub while_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub test: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsElseClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsElseClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsElseClauseFields {
        JsElseClauseFields {
            else_token: self.else_token(),
            alternate: self.alternate(),
        }
    }
    pub fn else_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn alternate(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsElseClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsElseClauseFields {
    pub else_token: SyntaxResult<SyntaxToken>,
    pub alternate: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsEmptyClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsEmptyClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsEmptyClassMemberFields {
        JsEmptyClassMemberFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsEmptyClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsEmptyClassMemberFields {
    pub semicolon_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsEmptyStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsEmptyStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsEmptyStatementFields {
        JsEmptyStatementFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsEmptyStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsEmptyStatementFields {
    pub semicolon_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExport {
    pub(crate) syntax: SyntaxNode,
}
impl JsExport {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportFields {
        JsExportFields {
            export_token: self.export_token(),
            export_clause: self.export_clause(),
        }
    }
    pub fn export_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn export_clause(&self) -> SyntaxResult<JsAnyExportClause> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportFields {
    pub export_token: SyntaxResult<SyntaxToken>,
    pub export_clause: SyntaxResult<JsAnyExportClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportAsClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportAsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportAsClauseFields {
        JsExportAsClauseFields {
            as_token: self.as_token(),
            exported_name: self.exported_name(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn exported_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportAsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportAsClauseFields {
    pub as_token: SyntaxResult<SyntaxToken>,
    pub exported_name: SyntaxResult<JsLiteralExportName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportDefaultDeclarationClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportDefaultDeclarationClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportDefaultDeclarationClauseFields {
        JsExportDefaultDeclarationClauseFields {
            default_token: self.default_token(),
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<JsAnyExportDefaultDeclaration> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportDefaultDeclarationClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportDefaultDeclarationClauseFields {
    pub default_token: SyntaxResult<SyntaxToken>,
    pub declaration: SyntaxResult<JsAnyExportDefaultDeclaration>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportDefaultExpressionClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportDefaultExpressionClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportDefaultExpressionClauseFields {
        JsExportDefaultExpressionClauseFields {
            default_token: self.default_token(),
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportDefaultExpressionClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportDefaultExpressionClauseFields {
    pub default_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportFromClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportFromClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportFromClauseFields {
        JsExportFromClauseFields {
            star_token: self.star_token(),
            export_as: self.export_as(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn export_as(&self) -> Option<JsExportAsClause> { support::node(&self.syntax, 1usize) }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> { support::node(&self.syntax, 4usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportFromClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportFromClauseFields {
    pub star_token: SyntaxResult<SyntaxToken>,
    pub export_as: Option<JsExportAsClause>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedClauseFields {
        JsExportNamedClauseFields {
            type_token: self.type_token(),
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn specifiers(&self) -> JsExportNamedSpecifierList { support::list(&self.syntax, 2usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportNamedClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub specifiers: JsExportNamedSpecifierList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedFromClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedFromClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedFromClauseFields {
        JsExportNamedFromClauseFields {
            type_token: self.type_token(),
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn specifiers(&self) -> JsExportNamedFromSpecifierList {
        support::list(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> { support::node(&self.syntax, 6usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 7usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedFromClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportNamedFromClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub specifiers: JsExportNamedFromSpecifierList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedFromSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedFromSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedFromSpecifierFields {
        JsExportNamedFromSpecifierFields {
            type_token: self.type_token(),
            source_name: self.source_name(),
            export_as: self.export_as(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn source_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn export_as(&self) -> Option<JsExportAsClause> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedFromSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportNamedFromSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub source_name: SyntaxResult<JsLiteralExportName>,
    pub export_as: Option<JsExportAsClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedShorthandSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedShorthandSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedShorthandSpecifierFields {
        JsExportNamedShorthandSpecifierFields {
            type_token: self.type_token(),
            name: self.name(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedShorthandSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportNamedShorthandSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedSpecifierFields {
        JsExportNamedSpecifierFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
            as_token: self.as_token(),
            exported_name: self.exported_name(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn local_name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn exported_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExportNamedSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub local_name: SyntaxResult<JsReferenceIdentifier>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub exported_name: SyntaxResult<JsLiteralExportName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExpressionSnipped {
    pub(crate) syntax: SyntaxNode,
}
impl JsExpressionSnipped {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExpressionSnippedFields {
        JsExpressionSnippedFields {
            expression: self.expression(),
            eof_token: self.eof_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExpressionSnipped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExpressionSnippedFields {
    pub expression: SyntaxResult<JsAnyExpression>,
    pub eof_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExpressionStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsExpressionStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExpressionStatementFields {
        JsExpressionStatementFields {
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExpressionStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExpressionStatementFields {
    pub expression: SyntaxResult<JsAnyExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExtendsClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExtendsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExtendsClauseFields {
        JsExtendsClauseFields {
            extends_token: self.extends_token(),
            super_class: self.super_class(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn super_class(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExtendsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsExtendsClauseFields {
    pub extends_token: SyntaxResult<SyntaxToken>,
    pub super_class: SyntaxResult<JsAnyExpression>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFinallyClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsFinallyClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFinallyClauseFields {
        JsFinallyClauseFields {
            finally_token: self.finally_token(),
            body: self.body(),
        }
    }
    pub fn finally_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFinallyClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsFinallyClauseFields {
    pub finally_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForInStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsForInStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsForInStatementFields {
        JsForInStatementFields {
            for_token: self.for_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            in_token: self.in_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> SyntaxResult<JsAnyForInOrOfInitializer> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn in_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsForInStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsForInStatementFields {
    pub for_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub initializer: SyntaxResult<JsAnyForInOrOfInitializer>,
    pub in_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForOfStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsForOfStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsForOfStatementFields {
        JsForOfStatementFields {
            for_token: self.for_token(),
            await_token: self.await_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            of_token: self.of_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn initializer(&self) -> SyntaxResult<JsAnyForInOrOfInitializer> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn of_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsForOfStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsForOfStatementFields {
    pub for_token: SyntaxResult<SyntaxToken>,
    pub await_token: Option<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub initializer: SyntaxResult<JsAnyForInOrOfInitializer>,
    pub of_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsForStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsForStatementFields {
        JsForStatementFields {
            for_token: self.for_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            first_semi_token: self.first_semi_token(),
            test: self.test(),
            second_semi_token: self.second_semi_token(),
            update: self.update(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> Option<JsAnyForInitializer> { support::node(&self.syntax, 2usize) }
    pub fn first_semi_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn test(&self) -> Option<JsAnyExpression> { support::node(&self.syntax, 4usize) }
    pub fn second_semi_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn update(&self) -> Option<JsAnyExpression> { support::node(&self.syntax, 6usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 8usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsForStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsForStatementFields {
    pub for_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub initializer: Option<JsAnyForInitializer>,
    pub first_semi_token: SyntaxResult<SyntaxToken>,
    pub test: Option<JsAnyExpression>,
    pub second_semi_token: SyntaxResult<SyntaxToken>,
    pub update: Option<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsForVariableDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsForVariableDeclarationFields {
        JsForVariableDeclarationFields {
            kind_token: self.kind_token(),
            declarator: self.declarator(),
        }
    }
    pub fn kind_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declarator(&self) -> SyntaxResult<JsVariableDeclarator> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsForVariableDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsForVariableDeclarationFields {
    pub kind_token: SyntaxResult<SyntaxToken>,
    pub declarator: SyntaxResult<JsVariableDeclarator>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFormalParameter {
    pub(crate) syntax: SyntaxNode,
}
impl JsFormalParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFormalParameterFields {
        JsFormalParameterFields {
            binding: self.binding(),
            question_mark_token: self.question_mark_token(),
            type_annotation: self.type_annotation(),
            initializer: self.initializer(),
        }
    }
    pub fn binding(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsFormalParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsFormalParameterFields {
    pub binding: SyntaxResult<JsAnyBindingPattern>,
    pub question_mark_token: Option<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionBody {
    pub(crate) syntax: SyntaxNode,
}
impl JsFunctionBody {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFunctionBodyFields {
        JsFunctionBodyFields {
            l_curly_token: self.l_curly_token(),
            directives: self.directives(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn directives(&self) -> JsDirectiveList { support::list(&self.syntax, 1usize) }
    pub fn statements(&self) -> JsStatementList { support::list(&self.syntax, 2usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFunctionBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsFunctionBodyFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub directives: JsDirectiveList,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsFunctionDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFunctionDeclarationFields {
        JsFunctionDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> { support::required_node(&self.syntax, 3usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFunctionDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsFunctionDeclarationFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionExportDefaultDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsFunctionExportDefaultDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFunctionExportDefaultDeclarationFields {
        JsFunctionExportDefaultDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn id(&self) -> Option<JsAnyBinding> { support::node(&self.syntax, 3usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFunctionExportDefaultDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsFunctionExportDefaultDeclarationFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub id: Option<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsFunctionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFunctionExpressionFields {
        JsFunctionExpressionFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn id(&self) -> Option<JsAnyBinding> { support::node(&self.syntax, 3usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFunctionExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsFunctionExpressionFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub id: Option<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsGetterClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsGetterClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsGetterClassMemberFields {
        JsGetterClassMemberFields {
            modifiers: self.modifiers(),
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList { support::list(&self.syntax, 0usize) }
    pub fn get_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> { support::node(&self.syntax, 5usize) }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsGetterClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsGetterClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub get_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsGetterObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsGetterObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsGetterObjectMemberFields {
        JsGetterObjectMemberFields {
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            body: self.body(),
        }
    }
    pub fn get_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> { support::node(&self.syntax, 4usize) }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsGetterObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsGetterObjectMemberFields {
    pub get_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl JsIdentifierAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsIdentifierAssignmentFields {
        JsIdentifierAssignmentFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsIdentifierAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsIdentifierAssignmentFields {
    pub name_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierBinding {
    pub(crate) syntax: SyntaxNode,
}
impl JsIdentifierBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsIdentifierBindingFields {
        JsIdentifierBindingFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsIdentifierBinding {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsIdentifierBindingFields {
    pub name_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsIdentifierExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsIdentifierExpressionFields {
        JsIdentifierExpressionFields { name: self.name() }
    }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsIdentifierExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsIdentifierExpressionFields {
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIfStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsIfStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsIfStatementFields {
        JsIfStatementFields {
            if_token: self.if_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            consequent: self.consequent(),
            else_clause: self.else_clause(),
        }
    }
    pub fn if_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn consequent(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn else_clause(&self) -> Option<JsElseClause> { support::node(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsIfStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsIfStatementFields {
    pub if_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub test: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub consequent: SyntaxResult<JsAnyStatement>,
    pub else_clause: Option<JsElseClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImport {
    pub(crate) syntax: SyntaxNode,
}
impl JsImport {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportFields {
        JsImportFields {
            import_token: self.import_token(),
            import_clause: self.import_clause(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn import_clause(&self) -> SyntaxResult<JsAnyImportClause> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsImportFields {
    pub import_token: SyntaxResult<SyntaxToken>,
    pub import_clause: SyntaxResult<JsAnyImportClause>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportAssertion {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportAssertion {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportAssertionFields {
        JsImportAssertionFields {
            assert_token: self.assert_token(),
            l_curly_token: self.l_curly_token(),
            assertions: self.assertions(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn assert_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn assertions(&self) -> JsImportAssertionEntryList { support::list(&self.syntax, 2usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportAssertion {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsImportAssertionFields {
    pub assert_token: SyntaxResult<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub assertions: JsImportAssertionEntryList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportAssertionEntry {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportAssertionEntry {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportAssertionEntryFields {
        JsImportAssertionEntryFields {
            key: self.key(),
            colon_token: self.colon_token(),
            value_token: self.value_token(),
        }
    }
    pub fn key(&self) -> SyntaxResult<SyntaxToken> { support::required_token(&self.syntax, 0usize) }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportAssertionEntry {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsImportAssertionEntryFields {
    pub key: SyntaxResult<SyntaxToken>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportBareClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportBareClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportBareClauseFields {
        JsImportBareClauseFields {
            source: self.source(),
            assertion: self.assertion(),
        }
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportBareClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsImportBareClauseFields {
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportCallExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportCallExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportCallExpressionFields {
        JsImportCallExpressionFields {
            import_token: self.import_token(),
            arguments: self.arguments(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn arguments(&self) -> SyntaxResult<JsCallArguments> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportCallExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsImportCallExpressionFields {
    pub import_token: SyntaxResult<SyntaxToken>,
    pub arguments: SyntaxResult<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportDefaultClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportDefaultClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportDefaultClauseFields {
        JsImportDefaultClauseFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> { support::node(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportDefaultClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsImportDefaultClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportNamedClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportNamedClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportNamedClauseFields {
        JsImportNamedClauseFields {
            type_token: self.type_token(),
            default_specifier: self.default_specifier(),
            named_import: self.named_import(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn default_specifier(&self) -> Option<JsDefaultImportSpecifier> {
        support::node(&self.syntax, 1usize)
    }
    pub fn named_import(&self) -> SyntaxResult<JsAnyNamedImport> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> { support::node(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportNamedClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsImportNamedClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub default_specifier: Option<JsDefaultImportSpecifier>,
    pub named_import: SyntaxResult<JsAnyNamedImport>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportNamespaceClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportNamespaceClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportNamespaceClauseFields {
        JsImportNamespaceClauseFields {
            type_token: self.type_token(),
            star_token: self.star_token(),
            as_token: self.as_token(),
            local_name: self.local_name(),
            from_token: self.from_token(),
            source: self.source(),
            assertion: self.assertion(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn assertion(&self) -> Option<JsImportAssertion> { support::node(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportNamespaceClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsImportNamespaceClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub star_token: SyntaxResult<SyntaxToken>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub assertion: Option<JsImportAssertion>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsInExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsInExpressionFields {
        JsInExpressionFields {
            property: self.property(),
            in_token: self.in_token(),
            object: self.object(),
        }
    }
    pub fn property(&self) -> SyntaxResult<JsAnyInProperty> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn in_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsInExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsInExpressionFields {
    pub property: SyntaxResult<JsAnyInProperty>,
    pub in_token: SyntaxResult<SyntaxToken>,
    pub object: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInitializerClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsInitializerClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsInitializerClauseFields {
        JsInitializerClauseFields {
            eq_token: self.eq_token(),
            expression: self.expression(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsInitializerClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsInitializerClauseFields {
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInstanceofExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsInstanceofExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsInstanceofExpressionFields {
        JsInstanceofExpressionFields {
            left: self.left(),
            instanceof_token: self.instanceof_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn instanceof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsInstanceofExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsInstanceofExpressionFields {
    pub left: SyntaxResult<JsAnyExpression>,
    pub instanceof_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLabeledStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsLabeledStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsLabeledStatementFields {
        JsLabeledStatementFields {
            label_token: self.label_token(),
            colon_token: self.colon_token(),
            body: self.body(),
        }
    }
    pub fn label_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsLabeledStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsLabeledStatementFields {
    pub label_token: SyntaxResult<SyntaxToken>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLiteralExportName {
    pub(crate) syntax: SyntaxNode,
}
impl JsLiteralExportName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsLiteralExportNameFields {
        JsLiteralExportNameFields {
            value: self.value(),
        }
    }
    pub fn value(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsLiteralExportName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsLiteralExportNameFields {
    pub value: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLiteralMemberName {
    pub(crate) syntax: SyntaxNode,
}
impl JsLiteralMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsLiteralMemberNameFields {
        JsLiteralMemberNameFields {
            value: self.value(),
        }
    }
    pub fn value(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsLiteralMemberName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsLiteralMemberNameFields {
    pub value: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLogicalExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsLogicalExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsLogicalExpressionFields {
        JsLogicalExpressionFields {
            left: self.left(),
            operator_token: self.operator_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsLogicalExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsLogicalExpressionFields {
    pub left: SyntaxResult<JsAnyExpression>,
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsMethodClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsMethodClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsMethodClassMemberFields {
        JsMethodClassMemberFields {
            modifiers: self.modifiers(),
            async_token: self.async_token(),
            star_token: self.star_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList { support::list(&self.syntax, 0usize) }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 4usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 5usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 6usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 7usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 8usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsMethodClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsMethodClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub async_token: Option<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub question_mark_token: Option<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsMethodObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsMethodObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsMethodObjectMemberFields {
        JsMethodObjectMemberFields {
            async_token: self.async_token(),
            star_token: self.star_token(),
            name: self.name(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsMethodObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsMethodObjectMemberFields {
    pub async_token: Option<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsModule {
    pub(crate) syntax: SyntaxNode,
}
impl JsModule {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsModuleFields {
        JsModuleFields {
            interpreter_token: self.interpreter_token(),
            directives: self.directives(),
            items: self.items(),
            eof_token: self.eof_token(),
        }
    }
    pub fn interpreter_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn directives(&self) -> JsDirectiveList { support::list(&self.syntax, 1usize) }
    pub fn items(&self) -> JsModuleItemList { support::list(&self.syntax, 2usize) }
    pub fn eof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsModule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsModuleFields {
    pub interpreter_token: Option<SyntaxToken>,
    pub directives: JsDirectiveList,
    pub items: JsModuleItemList,
    pub eof_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsModuleSource {
    pub(crate) syntax: SyntaxNode,
}
impl JsModuleSource {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsModuleSourceFields {
        JsModuleSourceFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsModuleSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsModuleSourceFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsName {
    pub(crate) syntax: SyntaxNode,
}
impl JsName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNameFields {
        JsNameFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsNameFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamedImportSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNamedImportSpecifierFields {
        JsNamedImportSpecifierFields {
            type_token: self.type_token(),
            name: self.name(),
            as_token: self.as_token(),
            local_name: self.local_name(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNamedImportSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsNamedImportSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsLiteralExportName>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamedImportSpecifiers {
    pub(crate) syntax: SyntaxNode,
}
impl JsNamedImportSpecifiers {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNamedImportSpecifiersFields {
        JsNamedImportSpecifiersFields {
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn specifiers(&self) -> JsNamedImportSpecifierList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNamedImportSpecifiers {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsNamedImportSpecifiersFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub specifiers: JsNamedImportSpecifierList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamespaceImportSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsNamespaceImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNamespaceImportSpecifierFields {
        JsNamespaceImportSpecifierFields {
            star_token: self.star_token(),
            as_token: self.as_token(),
            local_name: self.local_name(),
        }
    }
    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNamespaceImportSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsNamespaceImportSpecifierFields {
    pub star_token: SyntaxResult<SyntaxToken>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNewExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsNewExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNewExpressionFields {
        JsNewExpressionFields {
            new_token: self.new_token(),
            callee: self.callee(),
            type_arguments: self.type_arguments(),
            arguments: self.arguments(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn callee(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
    pub fn arguments(&self) -> Option<JsCallArguments> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsNewExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsNewExpressionFields {
    pub new_token: SyntaxResult<SyntaxToken>,
    pub callee: SyntaxResult<JsAnyExpression>,
    pub type_arguments: Option<TsTypeArguments>,
    pub arguments: Option<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNullLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsNullLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNullLiteralExpressionFields {
        JsNullLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNullLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsNullLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNumberLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsNumberLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNumberLiteralExpressionFields {
        JsNumberLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNumberLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsNumberLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPattern {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectAssignmentPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternFields {
        JsObjectAssignmentPatternFields {
            l_curly_token: self.l_curly_token(),
            properties: self.properties(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn properties(&self) -> JsObjectAssignmentPatternPropertyList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPattern {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectAssignmentPatternFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub properties: JsObjectAssignmentPatternPropertyList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternProperty {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectAssignmentPatternProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternPropertyFields {
        JsObjectAssignmentPatternPropertyFields {
            member: self.member(),
            colon_token: self.colon_token(),
            pattern: self.pattern(),
            init: self.init(),
        }
    }
    pub fn member(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyAssignmentPattern> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPatternProperty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectAssignmentPatternPropertyFields {
    pub member: SyntaxResult<JsAnyObjectMemberName>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub pattern: SyntaxResult<JsAnyAssignmentPattern>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternRest {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectAssignmentPatternRest {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternRestFields {
        JsObjectAssignmentPatternRestFields {
            dotdotdot_token: self.dotdotdot_token(),
            target: self.target(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn target(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPatternRest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectAssignmentPatternRestFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub target: SyntaxResult<JsAnyAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternShorthandProperty {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectAssignmentPatternShorthandProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternShorthandPropertyFields {
        JsObjectAssignmentPatternShorthandPropertyFields {
            identifier: self.identifier(),
            init: self.init(),
        }
    }
    pub fn identifier(&self) -> SyntaxResult<JsIdentifierAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPatternShorthandProperty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectAssignmentPatternShorthandPropertyFields {
    pub identifier: SyntaxResult<JsIdentifierAssignment>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPattern {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectBindingPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectBindingPatternFields {
        JsObjectBindingPatternFields {
            l_curly_token: self.l_curly_token(),
            properties: self.properties(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn properties(&self) -> JsObjectBindingPatternPropertyList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPattern {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectBindingPatternFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub properties: JsObjectBindingPatternPropertyList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternProperty {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectBindingPatternProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectBindingPatternPropertyFields {
        JsObjectBindingPatternPropertyFields {
            member: self.member(),
            colon_token: self.colon_token(),
            pattern: self.pattern(),
            init: self.init(),
        }
    }
    pub fn member(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn pattern(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPatternProperty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectBindingPatternPropertyFields {
    pub member: SyntaxResult<JsAnyObjectMemberName>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub pattern: SyntaxResult<JsAnyBindingPattern>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternRest {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectBindingPatternRest {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectBindingPatternRestFields {
        JsObjectBindingPatternRestFields {
            dotdotdot_token: self.dotdotdot_token(),
            binding: self.binding(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPatternRest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectBindingPatternRestFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub binding: SyntaxResult<JsAnyBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternShorthandProperty {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectBindingPatternShorthandProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectBindingPatternShorthandPropertyFields {
        JsObjectBindingPatternShorthandPropertyFields {
            identifier: self.identifier(),
            init: self.init(),
        }
    }
    pub fn identifier(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPatternShorthandProperty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectBindingPatternShorthandPropertyFields {
    pub identifier: SyntaxResult<JsAnyBinding>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectExpressionFields {
        JsObjectExpressionFields {
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn members(&self) -> JsObjectMemberList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsObjectExpressionFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: JsObjectMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParameters {
    pub(crate) syntax: SyntaxNode,
}
impl JsParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsParametersFields {
        JsParametersFields {
            l_paren_token: self.l_paren_token(),
            items: self.items(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> JsParameterList { support::list(&self.syntax, 1usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsParameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsParametersFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub items: JsParameterList,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParenthesizedAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl JsParenthesizedAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsParenthesizedAssignmentFields {
        JsParenthesizedAssignmentFields {
            l_paren_token: self.l_paren_token(),
            assignment: self.assignment(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn assignment(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsParenthesizedAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsParenthesizedAssignmentFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub assignment: SyntaxResult<JsAnyAssignment>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParenthesizedExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsParenthesizedExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsParenthesizedExpressionFields {
        JsParenthesizedExpressionFields {
            l_paren_token: self.l_paren_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsParenthesizedExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsParenthesizedExpressionFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPostUpdateExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsPostUpdateExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPostUpdateExpressionFields {
        JsPostUpdateExpressionFields {
            operand: self.operand(),
            operator_token: self.operator_token(),
        }
    }
    pub fn operand(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPostUpdateExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsPostUpdateExpressionFields {
    pub operand: SyntaxResult<JsAnyAssignment>,
    pub operator_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPreUpdateExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsPreUpdateExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPreUpdateExpressionFields {
        JsPreUpdateExpressionFields {
            operator_token: self.operator_token(),
            operand: self.operand(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn operand(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPreUpdateExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsPreUpdateExpressionFields {
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub operand: SyntaxResult<JsAnyAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPrivateClassMemberName {
    pub(crate) syntax: SyntaxNode,
}
impl JsPrivateClassMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPrivateClassMemberNameFields {
        JsPrivateClassMemberNameFields {
            hash_token: self.hash_token(),
            id_token: self.id_token(),
        }
    }
    pub fn hash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn id_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPrivateClassMemberName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsPrivateClassMemberNameFields {
    pub hash_token: SyntaxResult<SyntaxToken>,
    pub id_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPrivateName {
    pub(crate) syntax: SyntaxNode,
}
impl JsPrivateName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPrivateNameFields {
        JsPrivateNameFields {
            hash_token: self.hash_token(),
            value_token: self.value_token(),
        }
    }
    pub fn hash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPrivateName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsPrivateNameFields {
    pub hash_token: SyntaxResult<SyntaxToken>,
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPropertyClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsPropertyClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPropertyClassMemberFields {
        JsPropertyClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            property_annotation: self.property_annotation(),
            value: self.value(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> JsPropertyModifierList { support::list(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn property_annotation(&self) -> Option<TsAnyPropertyAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn value(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 3usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsPropertyClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsPropertyClassMemberFields {
    pub modifiers: JsPropertyModifierList,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub property_annotation: Option<TsAnyPropertyAnnotation>,
    pub value: Option<JsInitializerClause>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPropertyObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsPropertyObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPropertyObjectMemberFields {
        JsPropertyObjectMemberFields {
            name: self.name(),
            colon_token: self.colon_token(),
            value: self.value(),
        }
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn value(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPropertyObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsPropertyObjectMemberFields {
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub value: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsReferenceIdentifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsReferenceIdentifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsReferenceIdentifierFields {
        JsReferenceIdentifierFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsReferenceIdentifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsReferenceIdentifierFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsRegexLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsRegexLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsRegexLiteralExpressionFields {
        JsRegexLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsRegexLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsRegexLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsRestParameter {
    pub(crate) syntax: SyntaxNode,
}
impl JsRestParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsRestParameterFields {
        JsRestParameterFields {
            dotdotdot_token: self.dotdotdot_token(),
            binding: self.binding(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsRestParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsRestParameterFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub binding: SyntaxResult<JsAnyBindingPattern>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsReturnStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsReturnStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsReturnStatementFields {
        JsReturnStatementFields {
            return_token: self.return_token(),
            argument: self.argument(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn return_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> Option<JsAnyExpression> { support::node(&self.syntax, 1usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsReturnStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsReturnStatementFields {
    pub return_token: SyntaxResult<SyntaxToken>,
    pub argument: Option<JsAnyExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsScript {
    pub(crate) syntax: SyntaxNode,
}
impl JsScript {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsScriptFields {
        JsScriptFields {
            interpreter_token: self.interpreter_token(),
            directives: self.directives(),
            statements: self.statements(),
            eof_token: self.eof_token(),
        }
    }
    pub fn interpreter_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn directives(&self) -> JsDirectiveList { support::list(&self.syntax, 1usize) }
    pub fn statements(&self) -> JsStatementList { support::list(&self.syntax, 2usize) }
    pub fn eof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsScript {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsScriptFields {
    pub interpreter_token: Option<SyntaxToken>,
    pub directives: JsDirectiveList,
    pub statements: JsStatementList,
    pub eof_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSequenceExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsSequenceExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSequenceExpressionFields {
        JsSequenceExpressionFields {
            left: self.left(),
            comma_token: self.comma_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn comma_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSequenceExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsSequenceExpressionFields {
    pub left: SyntaxResult<JsAnyExpression>,
    pub comma_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSetterClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsSetterClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSetterClassMemberFields {
        JsSetterClassMemberFields {
            modifiers: self.modifiers(),
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList { support::list(&self.syntax, 0usize) }
    pub fn set_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSetterClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsSetterClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub set_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<JsAnyFormalParameter>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSetterObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsSetterObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSetterObjectMemberFields {
        JsSetterObjectMemberFields {
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn set_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSetterObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsSetterObjectMemberFields {
    pub set_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<JsAnyFormalParameter>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsShorthandNamedImportSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsShorthandNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsShorthandNamedImportSpecifierFields {
        JsShorthandNamedImportSpecifierFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn local_name(&self) -> SyntaxResult<JsAnyBinding> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsShorthandNamedImportSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsShorthandNamedImportSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub local_name: SyntaxResult<JsAnyBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsShorthandPropertyObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsShorthandPropertyObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsShorthandPropertyObjectMemberFields {
        JsShorthandPropertyObjectMemberFields { name: self.name() }
    }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsShorthandPropertyObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsShorthandPropertyObjectMemberFields {
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSpread {
    pub(crate) syntax: SyntaxNode,
}
impl JsSpread {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSpreadFields {
        JsSpreadFields {
            dotdotdot_token: self.dotdotdot_token(),
            argument: self.argument(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSpread {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsSpreadFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticInitializationBlockClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsStaticInitializationBlockClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStaticInitializationBlockClassMemberFields {
        JsStaticInitializationBlockClassMemberFields {
            static_token: self.static_token(),
            l_curly_token: self.l_curly_token(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn static_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn statements(&self) -> JsStatementList { support::list(&self.syntax, 2usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsStaticInitializationBlockClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsStaticInitializationBlockClassMemberFields {
    pub static_token: SyntaxResult<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticMemberAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl JsStaticMemberAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStaticMemberAssignmentFields {
        JsStaticMemberAssignmentFields {
            object: self.object(),
            dot_token: self.dot_token(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsAnyName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsStaticMemberAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsStaticMemberAssignmentFields {
    pub object: SyntaxResult<JsAnyExpression>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<JsAnyName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticMemberExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsStaticMemberExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStaticMemberExpressionFields {
        JsStaticMemberExpressionFields {
            object: self.object(),
            operator_token: self.operator_token(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsAnyName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsStaticMemberExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsStaticMemberExpressionFields {
    pub object: SyntaxResult<JsAnyExpression>,
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<JsAnyName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticModifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsStaticModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStaticModifierFields {
        JsStaticModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsStaticModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsStaticModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStringLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsStringLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStringLiteralExpressionFields {
        JsStringLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsStringLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsStringLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSuperExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsSuperExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSuperExpressionFields {
        JsSuperExpressionFields {
            super_token: self.super_token(),
        }
    }
    pub fn super_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSuperExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsSuperExpressionFields {
    pub super_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSwitchStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsSwitchStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSwitchStatementFields {
        JsSwitchStatementFields {
            switch_token: self.switch_token(),
            l_paren_token: self.l_paren_token(),
            discriminant: self.discriminant(),
            r_paren_token: self.r_paren_token(),
            l_curly_token: self.l_curly_token(),
            cases: self.cases(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn switch_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn discriminant(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn cases(&self) -> JsSwitchCaseList { support::list(&self.syntax, 5usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSwitchStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsSwitchStatementFields {
    pub switch_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub discriminant: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub cases: JsSwitchCaseList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplate {
    pub(crate) syntax: SyntaxNode,
}
impl JsTemplate {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTemplateFields {
        JsTemplateFields {
            tag: self.tag(),
            type_arguments: self.type_arguments(),
            l_tick_token: self.l_tick_token(),
            elements: self.elements(),
            r_tick_token: self.r_tick_token(),
        }
    }
    pub fn tag(&self) -> Option<JsAnyExpression> { support::node(&self.syntax, 0usize) }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 1usize) }
    pub fn l_tick_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn elements(&self) -> JsTemplateElementList { support::list(&self.syntax, 3usize) }
    pub fn r_tick_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsTemplateFields {
    pub tag: Option<JsAnyExpression>,
    pub type_arguments: Option<TsTypeArguments>,
    pub l_tick_token: SyntaxResult<SyntaxToken>,
    pub elements: JsTemplateElementList,
    pub r_tick_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplateChunkElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsTemplateChunkElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTemplateChunkElementFields {
        JsTemplateChunkElementFields {
            template_chunk_token: self.template_chunk_token(),
        }
    }
    pub fn template_chunk_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTemplateChunkElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsTemplateChunkElementFields {
    pub template_chunk_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplateElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsTemplateElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTemplateElementFields {
        JsTemplateElementFields {
            dollar_curly_token: self.dollar_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn dollar_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTemplateElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsTemplateElementFields {
    pub dollar_curly_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsThisExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsThisExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsThisExpressionFields {
        JsThisExpressionFields {
            this_token: self.this_token(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsThisExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsThisExpressionFields {
    pub this_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsThrowStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsThrowStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsThrowStatementFields {
        JsThrowStatementFields {
            throw_token: self.throw_token(),
            argument: self.argument(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn throw_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsThrowStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsThrowStatementFields {
    pub throw_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTryFinallyStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsTryFinallyStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTryFinallyStatementFields {
        JsTryFinallyStatementFields {
            try_token: self.try_token(),
            body: self.body(),
            catch_clause: self.catch_clause(),
            finally_clause: self.finally_clause(),
        }
    }
    pub fn try_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn catch_clause(&self) -> Option<JsCatchClause> { support::node(&self.syntax, 2usize) }
    pub fn finally_clause(&self) -> SyntaxResult<JsFinallyClause> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTryFinallyStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsTryFinallyStatementFields {
    pub try_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
    pub catch_clause: Option<JsCatchClause>,
    pub finally_clause: SyntaxResult<JsFinallyClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTryStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsTryStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTryStatementFields {
        JsTryStatementFields {
            try_token: self.try_token(),
            body: self.body(),
            catch_clause: self.catch_clause(),
        }
    }
    pub fn try_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn catch_clause(&self) -> SyntaxResult<JsCatchClause> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTryStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsTryStatementFields {
    pub try_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
    pub catch_clause: SyntaxResult<JsCatchClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsUnaryExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsUnaryExpressionFields {
        JsUnaryExpressionFields {
            operator_token: self.operator_token(),
            argument: self.argument(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsUnaryExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsUnaryExpressionFields {
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsVariableDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsVariableDeclarationFields {
        JsVariableDeclarationFields {
            kind: self.kind(),
            declarators: self.declarators(),
        }
    }
    pub fn kind(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declarators(&self) -> JsVariableDeclaratorList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsVariableDeclarationFields {
    pub kind: SyntaxResult<SyntaxToken>,
    pub declarators: JsVariableDeclaratorList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclarationClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsVariableDeclarationClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsVariableDeclarationClauseFields {
        JsVariableDeclarationClauseFields {
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn declaration(&self) -> SyntaxResult<JsVariableDeclaration> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableDeclarationClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsVariableDeclarationClauseFields {
    pub declaration: SyntaxResult<JsVariableDeclaration>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclarator {
    pub(crate) syntax: SyntaxNode,
}
impl JsVariableDeclarator {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsVariableDeclaratorFields {
        JsVariableDeclaratorFields {
            id: self.id(),
            variable_annotation: self.variable_annotation(),
            initializer: self.initializer(),
        }
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn variable_annotation(&self) -> Option<TsAnyVariableAnnotation> {
        support::node(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableDeclarator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsVariableDeclaratorFields {
    pub id: SyntaxResult<JsAnyBindingPattern>,
    pub variable_annotation: Option<TsAnyVariableAnnotation>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsVariableStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsVariableStatementFields {
        JsVariableStatementFields {
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn declaration(&self) -> SyntaxResult<JsVariableDeclaration> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsVariableStatementFields {
    pub declaration: SyntaxResult<JsVariableDeclaration>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsWhileStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsWhileStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsWhileStatementFields {
        JsWhileStatementFields {
            while_token: self.while_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn while_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn test(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsWhileStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsWhileStatementFields {
    pub while_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub test: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsWithStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsWithStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsWithStatementFields {
        JsWithStatementFields {
            with_token: self.with_token(),
            l_paren_token: self.l_paren_token(),
            object: self.object(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn with_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn object(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn body(&self) -> SyntaxResult<JsAnyStatement> {
        support::required_node(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsWithStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsWithStatementFields {
    pub with_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub object: SyntaxResult<JsAnyExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsAnyStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsYieldArgument {
    pub(crate) syntax: SyntaxNode,
}
impl JsYieldArgument {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsYieldArgumentFields {
        JsYieldArgumentFields {
            star_token: self.star_token(),
            expression: self.expression(),
        }
    }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsYieldArgument {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsYieldArgumentFields {
    pub star_token: Option<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsYieldExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsYieldExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsYieldExpressionFields {
        JsYieldExpressionFields {
            yield_token: self.yield_token(),
            argument: self.argument(),
        }
    }
    pub fn yield_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> Option<JsYieldArgument> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsYieldExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsYieldExpressionFields {
    pub yield_token: SyntaxResult<SyntaxToken>,
    pub argument: Option<JsYieldArgument>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl JsxAttribute {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxAttributeFields {
        JsxAttributeFields {
            name: self.name(),
            initializer: self.initializer(),
        }
    }
    pub fn name(&self) -> SyntaxResult<JsxAnyAttributeName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn initializer(&self) -> Option<JsxAttributeInitializerClause> {
        support::node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxAttribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxAttributeFields {
    pub name: SyntaxResult<JsxAnyAttributeName>,
    pub initializer: Option<JsxAttributeInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxAttributeInitializerClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsxAttributeInitializerClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxAttributeInitializerClauseFields {
        JsxAttributeInitializerClauseFields {
            eq_token: self.eq_token(),
            value: self.value(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn value(&self) -> SyntaxResult<JsxAnyAttributeValue> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxAttributeInitializerClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxAttributeInitializerClauseFields {
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub value: SyntaxResult<JsxAnyAttributeValue>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxClosingElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsxClosingElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxClosingElementFields {
        JsxClosingElementFields {
            l_angle_token: self.l_angle_token(),
            slash_token: self.slash_token(),
            name: self.name(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn slash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxAnyElementName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxClosingElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxClosingElementFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub slash_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsxAnyElementName>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxClosingFragment {
    pub(crate) syntax: SyntaxNode,
}
impl JsxClosingFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxClosingFragmentFields {
        JsxClosingFragmentFields {
            l_angle_token: self.l_angle_token(),
            slash_token: self.slash_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn slash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxClosingFragment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxClosingFragmentFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub slash_token: SyntaxResult<SyntaxToken>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsxElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxElementFields {
        JsxElementFields {
            opening_element: self.opening_element(),
            children: self.children(),
            closing_element: self.closing_element(),
        }
    }
    pub fn opening_element(&self) -> SyntaxResult<JsxOpeningElement> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn children(&self) -> JsxChildList { support::list(&self.syntax, 1usize) }
    pub fn closing_element(&self) -> SyntaxResult<JsxClosingElement> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxElementFields {
    pub opening_element: SyntaxResult<JsxOpeningElement>,
    pub children: JsxChildList,
    pub closing_element: SyntaxResult<JsxClosingElement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxExpressionAttributeValue {
    pub(crate) syntax: SyntaxNode,
}
impl JsxExpressionAttributeValue {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxExpressionAttributeValueFields {
        JsxExpressionAttributeValueFields {
            l_curly_token: self.l_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxExpressionAttributeValue {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxExpressionAttributeValueFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxExpressionChild {
    pub(crate) syntax: SyntaxNode,
}
impl JsxExpressionChild {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxExpressionChildFields {
        JsxExpressionChildFields {
            l_curly_token: self.l_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> Option<JsAnyExpression> { support::node(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxExpressionChild {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxExpressionChildFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub expression: Option<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxFragment {
    pub(crate) syntax: SyntaxNode,
}
impl JsxFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxFragmentFields {
        JsxFragmentFields {
            opening_fragment: self.opening_fragment(),
            children: self.children(),
            closing_fragment: self.closing_fragment(),
        }
    }
    pub fn opening_fragment(&self) -> SyntaxResult<JsxOpeningFragment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn children(&self) -> JsxChildList { support::list(&self.syntax, 1usize) }
    pub fn closing_fragment(&self) -> SyntaxResult<JsxClosingFragment> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxFragment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxFragmentFields {
    pub opening_fragment: SyntaxResult<JsxOpeningFragment>,
    pub children: JsxChildList,
    pub closing_fragment: SyntaxResult<JsxClosingFragment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxMemberName {
    pub(crate) syntax: SyntaxNode,
}
impl JsxMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxMemberNameFields {
        JsxMemberNameFields {
            object: self.object(),
            dot_token: self.dot_token(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<JsxAnyObjectName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsxMemberName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxMemberNameFields {
    pub object: SyntaxResult<JsxAnyObjectName>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxName {
    pub(crate) syntax: SyntaxNode,
}
impl JsxName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxNameFields {
        JsxNameFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxNameFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxNamespaceName {
    pub(crate) syntax: SyntaxNode,
}
impl JsxNamespaceName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxNamespaceNameFields {
        JsxNamespaceNameFields {
            namespace: self.namespace(),
            colon_token: self.colon_token(),
            name: self.name(),
        }
    }
    pub fn namespace(&self) -> SyntaxResult<JsxName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsxNamespaceName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxNamespaceNameFields {
    pub namespace: SyntaxResult<JsxName>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsxName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxOpeningElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsxOpeningElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxOpeningElementFields {
        JsxOpeningElementFields {
            l_angle_token: self.l_angle_token(),
            name: self.name(),
            type_arguments: self.type_arguments(),
            attributes: self.attributes(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxAnyElementName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
    pub fn attributes(&self) -> JsxAttributeList { support::list(&self.syntax, 3usize) }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxOpeningElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxOpeningElementFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsxAnyElementName>,
    pub type_arguments: Option<TsTypeArguments>,
    pub attributes: JsxAttributeList,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxOpeningFragment {
    pub(crate) syntax: SyntaxNode,
}
impl JsxOpeningFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxOpeningFragmentFields {
        JsxOpeningFragmentFields {
            l_angle_token: self.l_angle_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxOpeningFragment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxOpeningFragmentFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxReferenceIdentifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsxReferenceIdentifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxReferenceIdentifierFields {
        JsxReferenceIdentifierFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxReferenceIdentifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxReferenceIdentifierFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSelfClosingElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsxSelfClosingElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxSelfClosingElementFields {
        JsxSelfClosingElementFields {
            l_angle_token: self.l_angle_token(),
            name: self.name(),
            type_arguments: self.type_arguments(),
            attributes: self.attributes(),
            slash_token: self.slash_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxAnyElementName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
    pub fn attributes(&self) -> JsxAttributeList { support::list(&self.syntax, 3usize) }
    pub fn slash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxSelfClosingElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxSelfClosingElementFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsxAnyElementName>,
    pub type_arguments: Option<TsTypeArguments>,
    pub attributes: JsxAttributeList,
    pub slash_token: SyntaxResult<SyntaxToken>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSpreadAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl JsxSpreadAttribute {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxSpreadAttributeFields {
        JsxSpreadAttributeFields {
            l_curly_token: self.l_curly_token(),
            dotdotdot_token: self.dotdotdot_token(),
            argument: self.argument(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn argument(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxSpreadAttribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxSpreadAttributeFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSpreadChild {
    pub(crate) syntax: SyntaxNode,
}
impl JsxSpreadChild {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxSpreadChildFields {
        JsxSpreadChildFields {
            l_curly_token: self.l_curly_token(),
            dotdotdot_token: self.dotdotdot_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxSpreadChild {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxSpreadChildFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxString {
    pub(crate) syntax: SyntaxNode,
}
impl JsxString {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxStringFields {
        JsxStringFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxString {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxStringFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxTagExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsxTagExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxTagExpressionFields { JsxTagExpressionFields { tag: self.tag() } }
    pub fn tag(&self) -> SyntaxResult<JsxAnyTag> { support::required_node(&self.syntax, 0usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsxTagExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxTagExpressionFields {
    pub tag: SyntaxResult<JsxAnyTag>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxText {
    pub(crate) syntax: SyntaxNode,
}
impl JsxText {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxTextFields {
        JsxTextFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct JsxTextFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct NewTarget {
    pub(crate) syntax: SyntaxNode,
}
impl NewTarget {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> NewTargetFields {
        NewTargetFields {
            new_token: self.new_token(),
            dot_token: self.dot_token(),
            target_token: self.target_token(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn target_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for NewTarget {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct NewTargetFields {
    pub new_token: SyntaxResult<SyntaxToken>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub target_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAbstractModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsAbstractModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAbstractModifierFields {
        TsAbstractModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsAbstractModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsAbstractModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAccessibilityModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsAccessibilityModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAccessibilityModifierFields {
        TsAccessibilityModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsAccessibilityModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsAccessibilityModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAnyType {
    pub(crate) syntax: SyntaxNode,
}
impl TsAnyType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAnyTypeFields {
        TsAnyTypeFields {
            any_token: self.any_token(),
        }
    }
    pub fn any_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsAnyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsAnyTypeFields {
    pub any_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsArrayType {
    pub(crate) syntax: SyntaxNode,
}
impl TsArrayType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsArrayTypeFields {
        TsArrayTypeFields {
            element_type: self.element_type(),
            l_brack_token: self.l_brack_token(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn element_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsArrayType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsArrayTypeFields {
    pub element_type: SyntaxResult<TsType>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAsAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl TsAsAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAsAssignmentFields {
        TsAsAssignmentFields {
            assignment: self.assignment(),
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn assignment(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsAsAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsAsAssignmentFields {
    pub assignment: SyntaxResult<JsAnyAssignment>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAsExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TsAsExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAsExpressionFields {
        TsAsExpressionFields {
            expression: self.expression(),
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsAsExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsAsExpressionFields {
    pub expression: SyntaxResult<JsAnyExpression>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAssertsCondition {
    pub(crate) syntax: SyntaxNode,
}
impl TsAssertsCondition {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAssertsConditionFields {
        TsAssertsConditionFields {
            is_token: self.is_token(),
            ty: self.ty(),
        }
    }
    pub fn is_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsAssertsCondition {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsAssertsConditionFields {
    pub is_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAssertsReturnType {
    pub(crate) syntax: SyntaxNode,
}
impl TsAssertsReturnType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAssertsReturnTypeFields {
        TsAssertsReturnTypeFields {
            asserts_token: self.asserts_token(),
            parameter_name: self.parameter_name(),
            predicate: self.predicate(),
        }
    }
    pub fn asserts_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn parameter_name(&self) -> SyntaxResult<TsAnyTypePredicateParameterName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn predicate(&self) -> Option<TsAssertsCondition> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsAssertsReturnType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsAssertsReturnTypeFields {
    pub asserts_token: SyntaxResult<SyntaxToken>,
    pub parameter_name: SyntaxResult<TsAnyTypePredicateParameterName>,
    pub predicate: Option<TsAssertsCondition>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBigIntLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsBigIntLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsBigIntLiteralTypeFields {
        TsBigIntLiteralTypeFields {
            minus_token: self.minus_token(),
            literal_token: self.literal_token(),
        }
    }
    pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn literal_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsBigIntLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsBigIntLiteralTypeFields {
    pub minus_token: Option<SyntaxToken>,
    pub literal_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBigintType {
    pub(crate) syntax: SyntaxNode,
}
impl TsBigintType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsBigintTypeFields {
        TsBigintTypeFields {
            bigint_token: self.bigint_token(),
        }
    }
    pub fn bigint_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsBigintType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsBigintTypeFields {
    pub bigint_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBooleanLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsBooleanLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsBooleanLiteralTypeFields {
        TsBooleanLiteralTypeFields {
            literal: self.literal(),
        }
    }
    pub fn literal(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsBooleanLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsBooleanLiteralTypeFields {
    pub literal: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBooleanType {
    pub(crate) syntax: SyntaxNode,
}
impl TsBooleanType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsBooleanTypeFields {
        TsBooleanTypeFields {
            boolean_token: self.boolean_token(),
        }
    }
    pub fn boolean_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsBooleanType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsBooleanTypeFields {
    pub boolean_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsCallSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsCallSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsCallSignatureTypeMemberFields {
        TsCallSignatureTypeMemberFields {
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsCallSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsCallSignatureTypeMemberFields {
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConditionalType {
    pub(crate) syntax: SyntaxNode,
}
impl TsConditionalType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConditionalTypeFields {
        TsConditionalTypeFields {
            check_type: self.check_type(),
            extends_token: self.extends_token(),
            extends_type: self.extends_type(),
            question_mark_token: self.question_mark_token(),
            true_type: self.true_type(),
            colon_token: self.colon_token(),
            false_type: self.false_type(),
        }
    }
    pub fn check_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn extends_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn extends_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn true_type(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 4usize) }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn false_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsConditionalType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsConditionalTypeFields {
    pub check_type: SyntaxResult<TsType>,
    pub extends_token: SyntaxResult<SyntaxToken>,
    pub extends_type: SyntaxResult<TsType>,
    pub question_mark_token: SyntaxResult<SyntaxToken>,
    pub true_type: SyntaxResult<TsType>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub false_type: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsConstructSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConstructSignatureTypeMemberFields {
        TsConstructSignatureTypeMemberFields {
            new_token: self.new_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsConstructSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsConstructSignatureTypeMemberFields {
    pub new_token: SyntaxResult<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructorSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsConstructorSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConstructorSignatureClassMemberFields {
        TsConstructorSignatureClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            parameters: self.parameters(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> JsConstructorModifierList { support::list(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsLiteralMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsConstructorParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsConstructorSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsConstructorSignatureClassMemberFields {
    pub modifiers: JsConstructorModifierList,
    pub name: SyntaxResult<JsLiteralMemberName>,
    pub parameters: SyntaxResult<JsConstructorParameters>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructorType {
    pub(crate) syntax: SyntaxNode,
}
impl TsConstructorType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConstructorTypeFields {
        TsConstructorTypeFields {
            abstract_token: self.abstract_token(),
            new_token: self.new_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            fat_arrow_token: self.fat_arrow_token(),
            return_type: self.return_type(),
        }
    }
    pub fn abstract_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn new_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsConstructorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsConstructorTypeFields {
    pub abstract_token: Option<SyntaxToken>,
    pub new_token: SyntaxResult<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub fat_arrow_token: SyntaxResult<SyntaxToken>,
    pub return_type: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareFunctionDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsDeclareFunctionDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDeclareFunctionDeclarationFields {
        TsDeclareFunctionDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> { support::required_node(&self.syntax, 2usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsDeclareFunctionDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsDeclareFunctionDeclarationFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsDeclareModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDeclareModifierFields {
        TsDeclareModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsDeclareModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsDeclareModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareStatement {
    pub(crate) syntax: SyntaxNode,
}
impl TsDeclareStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDeclareStatementFields {
        TsDeclareStatementFields {
            declare_token: self.declare_token(),
            declaration: self.declaration(),
        }
    }
    pub fn declare_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<JsAnyDeclarationClause> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsDeclareStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsDeclareStatementFields {
    pub declare_token: SyntaxResult<SyntaxToken>,
    pub declaration: SyntaxResult<JsAnyDeclarationClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefaultTypeClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsDefaultTypeClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDefaultTypeClauseFields {
        TsDefaultTypeClauseFields {
            eq_token: self.eq_token(),
            ty: self.ty(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsDefaultTypeClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsDefaultTypeClauseFields {
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefinitePropertyAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsDefinitePropertyAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDefinitePropertyAnnotationFields {
        TsDefinitePropertyAnnotationFields {
            excl_token: self.excl_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn excl_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsDefinitePropertyAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsDefinitePropertyAnnotationFields {
    pub excl_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefiniteVariableAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsDefiniteVariableAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDefiniteVariableAnnotationFields {
        TsDefiniteVariableAnnotationFields {
            excl_token: self.excl_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn excl_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsDefiniteVariableAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsDefiniteVariableAnnotationFields {
    pub excl_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEmptyExternalModuleDeclarationBody {
    pub(crate) syntax: SyntaxNode,
}
impl TsEmptyExternalModuleDeclarationBody {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsEmptyExternalModuleDeclarationBodyFields {
        TsEmptyExternalModuleDeclarationBodyFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsEmptyExternalModuleDeclarationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsEmptyExternalModuleDeclarationBodyFields {
    pub semicolon_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEnumDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsEnumDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsEnumDeclarationFields {
        TsEnumDeclarationFields {
            const_token: self.const_token(),
            enum_token: self.enum_token(),
            id: self.id(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn enum_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> { support::required_node(&self.syntax, 2usize) }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn members(&self) -> TsEnumMemberList { support::list(&self.syntax, 4usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsEnumDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsEnumDeclarationFields {
    pub const_token: Option<SyntaxToken>,
    pub enum_token: SyntaxResult<SyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: TsEnumMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEnumMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsEnumMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsEnumMemberFields {
        TsEnumMemberFields {
            name: self.name(),
            initializer: self.initializer(),
        }
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsEnumMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsEnumMemberFields {
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportAsNamespaceClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsExportAsNamespaceClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExportAsNamespaceClauseFields {
        TsExportAsNamespaceClauseFields {
            as_token: self.as_token(),
            namespace_token: self.namespace_token(),
            name: self.name(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn namespace_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 2usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsExportAsNamespaceClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsExportAsNamespaceClauseFields {
    pub as_token: SyntaxResult<SyntaxToken>,
    pub namespace_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsName>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportAssignmentClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsExportAssignmentClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExportAssignmentClauseFields {
        TsExportAssignmentClauseFields {
            eq_token: self.eq_token(),
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsExportAssignmentClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsExportAssignmentClauseFields {
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportDeclareClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsExportDeclareClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExportDeclareClauseFields {
        TsExportDeclareClauseFields {
            declare_token: self.declare_token(),
            declaration: self.declaration(),
        }
    }
    pub fn declare_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<JsAnyDeclarationClause> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsExportDeclareClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsExportDeclareClauseFields {
    pub declare_token: SyntaxResult<SyntaxToken>,
    pub declaration: SyntaxResult<JsAnyDeclarationClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExtendsClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsExtendsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExtendsClauseFields {
        TsExtendsClauseFields {
            extends_token: self.extends_token(),
            types: self.types(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsTypeList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsExtendsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsExtendsClauseFields {
    pub extends_token: SyntaxResult<SyntaxToken>,
    pub types: TsTypeList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExternalModuleDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsExternalModuleDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExternalModuleDeclarationFields {
        TsExternalModuleDeclarationFields {
            module_token: self.module_token(),
            source: self.source(),
            body: self.body(),
        }
    }
    pub fn module_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn body(&self) -> Option<TsAnyExternalModuleDeclarationBody> {
        support::node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsExternalModuleDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsExternalModuleDeclarationFields {
    pub module_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub body: Option<TsAnyExternalModuleDeclarationBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExternalModuleReference {
    pub(crate) syntax: SyntaxNode,
}
impl TsExternalModuleReference {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExternalModuleReferenceFields {
        TsExternalModuleReferenceFields {
            require_token: self.require_token(),
            l_paren_token: self.l_paren_token(),
            source: self.source(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn require_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsExternalModuleReference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsExternalModuleReferenceFields {
    pub require_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsFunctionType {
    pub(crate) syntax: SyntaxNode,
}
impl TsFunctionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsFunctionTypeFields {
        TsFunctionTypeFields {
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            fat_arrow_token: self.fat_arrow_token(),
            return_type: self.return_type(),
        }
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn return_type(&self) -> SyntaxResult<TsAnyReturnType> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsFunctionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsFunctionTypeFields {
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub fat_arrow_token: SyntaxResult<SyntaxToken>,
    pub return_type: SyntaxResult<TsAnyReturnType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGetterSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsGetterSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsGetterSignatureClassMemberFields {
        TsGetterSignatureClassMemberFields {
            modifiers: self.modifiers(),
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList { support::list(&self.syntax, 0usize) }
    pub fn get_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> { support::node(&self.syntax, 5usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsGetterSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsGetterSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub get_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGetterSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsGetterSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsGetterSignatureTypeMemberFields {
        TsGetterSignatureTypeMemberFields {
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn get_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsGetterSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsGetterSignatureTypeMemberFields {
    pub get_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGlobalDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsGlobalDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsGlobalDeclarationFields {
        TsGlobalDeclarationFields {
            global_token: self.global_token(),
            body: self.body(),
        }
    }
    pub fn global_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<TsModuleBlock> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsGlobalDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsGlobalDeclarationFields {
    pub global_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<TsModuleBlock>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIdentifierBinding {
    pub(crate) syntax: SyntaxNode,
}
impl TsIdentifierBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIdentifierBindingFields {
        TsIdentifierBindingFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsIdentifierBinding {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsIdentifierBindingFields {
    pub name_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImplementsClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsImplementsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsImplementsClauseFields {
        TsImplementsClauseFields {
            implements_token: self.implements_token(),
            types: self.types(),
        }
    }
    pub fn implements_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsTypeList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsImplementsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsImplementsClauseFields {
    pub implements_token: SyntaxResult<SyntaxToken>,
    pub types: TsTypeList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportEqualsDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsImportEqualsDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsImportEqualsDeclarationFields {
        TsImportEqualsDeclarationFields {
            import_token: self.import_token(),
            type_token: self.type_token(),
            id: self.id(),
            eq_token: self.eq_token(),
            module_reference: self.module_reference(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn id(&self) -> SyntaxResult<JsAnyBinding> { support::required_node(&self.syntax, 2usize) }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn module_reference(&self) -> SyntaxResult<TsAnyModuleReference> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsImportEqualsDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsImportEqualsDeclarationFields {
    pub import_token: SyntaxResult<SyntaxToken>,
    pub type_token: Option<SyntaxToken>,
    pub id: SyntaxResult<JsAnyBinding>,
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub module_reference: SyntaxResult<TsAnyModuleReference>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportType {
    pub(crate) syntax: SyntaxNode,
}
impl TsImportType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsImportTypeFields {
        TsImportTypeFields {
            typeof_token: self.typeof_token(),
            import_token: self.import_token(),
            l_paren_token: self.l_paren_token(),
            argument_token: self.argument_token(),
            r_paren_token: self.r_paren_token(),
            qualifier_clause: self.qualifier_clause(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn typeof_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn argument_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn qualifier_clause(&self) -> Option<TsImportTypeQualifier> {
        support::node(&self.syntax, 5usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsImportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsImportTypeFields {
    pub typeof_token: Option<SyntaxToken>,
    pub import_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub argument_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub qualifier_clause: Option<TsImportTypeQualifier>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportTypeQualifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsImportTypeQualifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsImportTypeQualifierFields {
        TsImportTypeQualifierFields {
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn right(&self) -> SyntaxResult<TsAnyName> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsImportTypeQualifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsImportTypeQualifierFields {
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<TsAnyName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsIndexSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIndexSignatureClassMemberFields {
        TsIndexSignatureClassMemberFields {
            modifiers: self.modifiers(),
            l_brack_token: self.l_brack_token(),
            parameter: self.parameter(),
            r_brack_token: self.r_brack_token(),
            type_annotation: self.type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsIndexSignatureModifierList { support::list(&self.syntax, 0usize) }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn parameter(&self) -> SyntaxResult<TsIndexSignatureParameter> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsIndexSignatureClassMemberFields {
    pub modifiers: TsIndexSignatureModifierList,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<TsIndexSignatureParameter>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureParameter {
    pub(crate) syntax: SyntaxNode,
}
impl TsIndexSignatureParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIndexSignatureParameterFields {
        TsIndexSignatureParameterFields {
            binding: self.binding(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn binding(&self) -> SyntaxResult<JsIdentifierBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexSignatureParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsIndexSignatureParameterFields {
    pub binding: SyntaxResult<JsIdentifierBinding>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsIndexSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIndexSignatureTypeMemberFields {
        TsIndexSignatureTypeMemberFields {
            readonly_token: self.readonly_token(),
            l_brack_token: self.l_brack_token(),
            parameter: self.parameter(),
            r_brack_token: self.r_brack_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn readonly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn parameter(&self) -> SyntaxResult<TsIndexSignatureParameter> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsIndexSignatureTypeMemberFields {
    pub readonly_token: Option<SyntaxToken>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<TsIndexSignatureParameter>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexedAccessType {
    pub(crate) syntax: SyntaxNode,
}
impl TsIndexedAccessType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIndexedAccessTypeFields {
        TsIndexedAccessTypeFields {
            object_type: self.object_type(),
            l_brack_token: self.l_brack_token(),
            index_type: self.index_type(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn index_type(&self) -> SyntaxResult<TsType> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexedAccessType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsIndexedAccessTypeFields {
    pub object_type: SyntaxResult<TsType>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub index_type: SyntaxResult<TsType>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInferType {
    pub(crate) syntax: SyntaxNode,
}
impl TsInferType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsInferTypeFields {
        TsInferTypeFields {
            infer_token: self.infer_token(),
            type_parameter: self.type_parameter(),
        }
    }
    pub fn infer_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_parameter(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsInferType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsInferTypeFields {
    pub infer_token: SyntaxResult<SyntaxToken>,
    pub type_parameter: SyntaxResult<TsTypeParameterName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInterfaceDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsInterfaceDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsInterfaceDeclarationFields {
        TsInterfaceDeclarationFields {
            interface_token: self.interface_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn interface_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn id(&self) -> SyntaxResult<TsIdentifierBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn extends_clause(&self) -> Option<TsExtendsClause> { support::node(&self.syntax, 3usize) }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn members(&self) -> TsTypeMemberList { support::list(&self.syntax, 5usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsInterfaceDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsInterfaceDeclarationFields {
    pub interface_token: SyntaxResult<SyntaxToken>,
    pub id: SyntaxResult<TsIdentifierBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<TsExtendsClause>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: TsTypeMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIntersectionType {
    pub(crate) syntax: SyntaxNode,
}
impl TsIntersectionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIntersectionTypeFields {
        TsIntersectionTypeFields {
            leading_separator_token: self.leading_separator_token(),
            types: self.types(),
        }
    }
    pub fn leading_separator_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsIntersectionTypeElementList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsIntersectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsIntersectionTypeFields {
    pub leading_separator_token: Option<SyntaxToken>,
    pub types: TsIntersectionTypeElementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedType {
    pub(crate) syntax: SyntaxNode,
}
impl TsMappedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMappedTypeFields {
        TsMappedTypeFields {
            l_curly_token: self.l_curly_token(),
            readonly_modifier: self.readonly_modifier(),
            l_brack_token: self.l_brack_token(),
            property_name: self.property_name(),
            in_token: self.in_token(),
            keys_type: self.keys_type(),
            as_clause: self.as_clause(),
            r_brack_token: self.r_brack_token(),
            optional_modifier: self.optional_modifier(),
            mapped_type: self.mapped_type(),
            semicolon_token: self.semicolon_token(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn readonly_modifier(&self) -> Option<TsMappedTypeReadonlyModifierClause> {
        support::node(&self.syntax, 1usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn property_name(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn in_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn keys_type(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 5usize) }
    pub fn as_clause(&self) -> Option<TsMappedTypeAsClause> { support::node(&self.syntax, 6usize) }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
    pub fn optional_modifier(&self) -> Option<TsMappedTypeOptionalModifierClause> {
        support::node(&self.syntax, 8usize)
    }
    pub fn mapped_type(&self) -> Option<TsTypeAnnotation> { support::node(&self.syntax, 9usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 10usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 11usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsMappedType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsMappedTypeFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub readonly_modifier: Option<TsMappedTypeReadonlyModifierClause>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub property_name: SyntaxResult<TsTypeParameterName>,
    pub in_token: SyntaxResult<SyntaxToken>,
    pub keys_type: SyntaxResult<TsType>,
    pub as_clause: Option<TsMappedTypeAsClause>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
    pub optional_modifier: Option<TsMappedTypeOptionalModifierClause>,
    pub mapped_type: Option<TsTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeAsClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsMappedTypeAsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMappedTypeAsClauseFields {
        TsMappedTypeAsClauseFields {
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsMappedTypeAsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsMappedTypeAsClauseFields {
    pub as_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeOptionalModifierClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsMappedTypeOptionalModifierClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMappedTypeOptionalModifierClauseFields {
        TsMappedTypeOptionalModifierClauseFields {
            operator_token: self.operator_token(),
            question_mark_token: self.question_mark_token(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsMappedTypeOptionalModifierClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsMappedTypeOptionalModifierClauseFields {
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub question_mark_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeReadonlyModifierClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsMappedTypeReadonlyModifierClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMappedTypeReadonlyModifierClauseFields {
        TsMappedTypeReadonlyModifierClauseFields {
            operator_token: self.operator_token(),
            readonly_token: self.readonly_token(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn readonly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsMappedTypeReadonlyModifierClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsMappedTypeReadonlyModifierClauseFields {
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub readonly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMethodSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsMethodSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMethodSignatureClassMemberFields {
        TsMethodSignatureClassMemberFields {
            modifiers: self.modifiers(),
            async_token: self.async_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList { support::list(&self.syntax, 0usize) }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 3usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 7usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsMethodSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsMethodSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub async_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub question_mark_token: Option<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMethodSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsMethodSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMethodSignatureTypeMemberFields {
        TsMethodSignatureTypeMemberFields {
            name: self.name(),
            optional_token: self.optional_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsMethodSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsMethodSignatureTypeMemberFields {
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub optional_token: Option<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsModuleBlock {
    pub(crate) syntax: SyntaxNode,
}
impl TsModuleBlock {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsModuleBlockFields {
        TsModuleBlockFields {
            l_curly_token: self.l_curly_token(),
            items: self.items(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> JsModuleItemList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsModuleBlock {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsModuleBlockFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub items: JsModuleItemList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsModuleDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsModuleDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsModuleDeclarationFields {
        TsModuleDeclarationFields {
            module_or_namespace: self.module_or_namespace(),
            name: self.name(),
            body: self.body(),
        }
    }
    pub fn module_or_namespace(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<TsAnyModuleName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn body(&self) -> SyntaxResult<TsModuleBlock> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsModuleDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsModuleDeclarationFields {
    pub module_or_namespace: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<TsAnyModuleName>,
    pub body: SyntaxResult<TsModuleBlock>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNameWithTypeArguments {
    pub(crate) syntax: SyntaxNode,
}
impl TsNameWithTypeArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNameWithTypeArgumentsFields {
        TsNameWithTypeArgumentsFields {
            name: self.name(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn name(&self) -> SyntaxResult<TsAnyName> { support::required_node(&self.syntax, 0usize) }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsNameWithTypeArguments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNameWithTypeArgumentsFields {
    pub name: SyntaxResult<TsAnyName>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNamedTupleTypeElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsNamedTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNamedTupleTypeElementFields {
        TsNamedTupleTypeElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 1usize) }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsNamedTupleTypeElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNamedTupleTypeElementFields {
    pub dotdotdot_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsName>,
    pub question_mark_token: Option<SyntaxToken>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNeverType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNeverType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNeverTypeFields {
        TsNeverTypeFields {
            never_token: self.never_token(),
        }
    }
    pub fn never_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNeverType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNeverTypeFields {
    pub never_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonNullAssertionAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl TsNonNullAssertionAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNonNullAssertionAssignmentFields {
        TsNonNullAssertionAssignmentFields {
            assignment: self.assignment(),
            excl_token: self.excl_token(),
        }
    }
    pub fn assignment(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn excl_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNonNullAssertionAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNonNullAssertionAssignmentFields {
    pub assignment: SyntaxResult<JsAnyAssignment>,
    pub excl_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonNullAssertionExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TsNonNullAssertionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNonNullAssertionExpressionFields {
        TsNonNullAssertionExpressionFields {
            expression: self.expression(),
            excl_token: self.excl_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn excl_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNonNullAssertionExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNonNullAssertionExpressionFields {
    pub expression: SyntaxResult<JsAnyExpression>,
    pub excl_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonPrimitiveType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNonPrimitiveType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNonPrimitiveTypeFields {
        TsNonPrimitiveTypeFields {
            object_token: self.object_token(),
        }
    }
    pub fn object_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNonPrimitiveType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNonPrimitiveTypeFields {
    pub object_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNullLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNullLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNullLiteralTypeFields {
        TsNullLiteralTypeFields {
            literal_token: self.literal_token(),
        }
    }
    pub fn literal_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNullLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNullLiteralTypeFields {
    pub literal_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNumberLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNumberLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNumberLiteralTypeFields {
        TsNumberLiteralTypeFields {
            minus_token: self.minus_token(),
            literal_token: self.literal_token(),
        }
    }
    pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn literal_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNumberLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNumberLiteralTypeFields {
    pub minus_token: Option<SyntaxToken>,
    pub literal_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNumberType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNumberType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNumberTypeFields {
        TsNumberTypeFields {
            number_token: self.number_token(),
        }
    }
    pub fn number_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNumberType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsNumberTypeFields {
    pub number_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsObjectType {
    pub(crate) syntax: SyntaxNode,
}
impl TsObjectType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsObjectTypeFields {
        TsObjectTypeFields {
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn members(&self) -> TsTypeMemberList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsObjectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsObjectTypeFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: TsTypeMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOptionalPropertyAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsOptionalPropertyAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsOptionalPropertyAnnotationFields {
        TsOptionalPropertyAnnotationFields {
            question_mark_token: self.question_mark_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsOptionalPropertyAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsOptionalPropertyAnnotationFields {
    pub question_mark_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOptionalTupleTypeElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsOptionalTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsOptionalTupleTypeElementFields {
        TsOptionalTupleTypeElementFields {
            ty: self.ty(),
            question_mark_token: self.question_mark_token(),
        }
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 0usize) }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsOptionalTupleTypeElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsOptionalTupleTypeElementFields {
    pub ty: SyntaxResult<TsType>,
    pub question_mark_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOverrideModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsOverrideModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsOverrideModifierFields {
        TsOverrideModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsOverrideModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsOverrideModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsParenthesizedType {
    pub(crate) syntax: SyntaxNode,
}
impl TsParenthesizedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsParenthesizedTypeFields {
        TsParenthesizedTypeFields {
            l_paren_token: self.l_paren_token(),
            ty: self.ty(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsParenthesizedType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsParenthesizedTypeFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPredicateReturnType {
    pub(crate) syntax: SyntaxNode,
}
impl TsPredicateReturnType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsPredicateReturnTypeFields {
        TsPredicateReturnTypeFields {
            parameter_name: self.parameter_name(),
            is_token: self.is_token(),
            ty: self.ty(),
        }
    }
    pub fn parameter_name(&self) -> SyntaxResult<TsAnyTypePredicateParameterName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn is_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsPredicateReturnType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsPredicateReturnTypeFields {
    pub parameter_name: SyntaxResult<TsAnyTypePredicateParameterName>,
    pub is_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertyParameter {
    pub(crate) syntax: SyntaxNode,
}
impl TsPropertyParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsPropertyParameterFields {
        TsPropertyParameterFields {
            modifiers: self.modifiers(),
            formal_parameter: self.formal_parameter(),
        }
    }
    pub fn modifiers(&self) -> TsPropertyParameterModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn formal_parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertyParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsPropertyParameterFields {
    pub modifiers: TsPropertyParameterModifierList,
    pub formal_parameter: SyntaxResult<JsAnyFormalParameter>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertySignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsPropertySignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsPropertySignatureClassMemberFields {
        TsPropertySignatureClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            property_annotation: self.property_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsPropertySignatureModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn property_annotation(&self) -> Option<TsAnyPropertySignatureAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertySignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsPropertySignatureClassMemberFields {
    pub modifiers: TsPropertySignatureModifierList,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub property_annotation: Option<TsAnyPropertySignatureAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertySignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsPropertySignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsPropertySignatureTypeMemberFields {
        TsPropertySignatureTypeMemberFields {
            readonly_token: self.readonly_token(),
            name: self.name(),
            optional_token: self.optional_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn readonly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn optional_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertySignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsPropertySignatureTypeMemberFields {
    pub readonly_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub optional_token: Option<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsQualifiedModuleName {
    pub(crate) syntax: SyntaxNode,
}
impl TsQualifiedModuleName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsQualifiedModuleNameFields {
        TsQualifiedModuleNameFields {
            left: self.left(),
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<TsAnyModuleName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsQualifiedModuleName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsQualifiedModuleNameFields {
    pub left: SyntaxResult<TsAnyModuleName>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsQualifiedName {
    pub(crate) syntax: SyntaxNode,
}
impl TsQualifiedName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsQualifiedNameFields {
        TsQualifiedNameFields {
            left: self.left(),
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<TsAnyName> { support::required_node(&self.syntax, 0usize) }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsQualifiedName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsQualifiedNameFields {
    pub left: SyntaxResult<TsAnyName>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReadonlyModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsReadonlyModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsReadonlyModifierFields {
        TsReadonlyModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsReadonlyModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsReadonlyModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReferenceType {
    pub(crate) syntax: SyntaxNode,
}
impl TsReferenceType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsReferenceTypeFields {
        TsReferenceTypeFields {
            name: self.name(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn name(&self) -> SyntaxResult<TsAnyName> { support::required_node(&self.syntax, 0usize) }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsReferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsReferenceTypeFields {
    pub name: SyntaxResult<TsAnyName>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsRestTupleTypeElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsRestTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsRestTupleTypeElementFields {
        TsRestTupleTypeElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            ty: self.ty(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsRestTupleTypeElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsRestTupleTypeElementFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReturnTypeAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsReturnTypeAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsReturnTypeAnnotationFields {
        TsReturnTypeAnnotationFields {
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsAnyReturnType> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsReturnTypeAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsReturnTypeAnnotationFields {
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsAnyReturnType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSetterSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsSetterSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsSetterSignatureClassMemberFields {
        TsSetterSignatureClassMemberFields {
            modifiers: self.modifiers(),
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList { support::list(&self.syntax, 0usize) }
    pub fn set_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsSetterSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsSetterSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub set_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsAnyClassMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<JsAnyFormalParameter>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSetterSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsSetterSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsSetterSignatureTypeMemberFields {
        TsSetterSignatureTypeMemberFields {
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            separator_token: self.separator_token(),
        }
    }
    pub fn set_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<JsAnyObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn parameter(&self) -> SyntaxResult<JsAnyFormalParameter> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsSetterSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsSetterSignatureTypeMemberFields {
    pub set_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsAnyObjectMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<JsAnyFormalParameter>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsStringLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsStringLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsStringLiteralTypeFields {
        TsStringLiteralTypeFields {
            literal_token: self.literal_token(),
        }
    }
    pub fn literal_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsStringLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsStringLiteralTypeFields {
    pub literal_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsStringType {
    pub(crate) syntax: SyntaxNode,
}
impl TsStringType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsStringTypeFields {
        TsStringTypeFields {
            string_token: self.string_token(),
        }
    }
    pub fn string_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsStringType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsStringTypeFields {
    pub string_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSymbolType {
    pub(crate) syntax: SyntaxNode,
}
impl TsSymbolType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsSymbolTypeFields {
        TsSymbolTypeFields {
            symbol_token: self.symbol_token(),
        }
    }
    pub fn symbol_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsSymbolType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsSymbolTypeFields {
    pub symbol_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateChunkElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsTemplateChunkElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTemplateChunkElementFields {
        TsTemplateChunkElementFields {
            template_chunk_token: self.template_chunk_token(),
        }
    }
    pub fn template_chunk_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTemplateChunkElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTemplateChunkElementFields {
    pub template_chunk_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsTemplateElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTemplateElementFields {
        TsTemplateElementFields {
            dollar_curly_token: self.dollar_curly_token(),
            ty: self.ty(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn dollar_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTemplateElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTemplateElementFields {
    pub dollar_curly_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsTemplateLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTemplateLiteralTypeFields {
        TsTemplateLiteralTypeFields {
            l_tick_token: self.l_tick_token(),
            elements: self.elements(),
            r_tick_token: self.r_tick_token(),
        }
    }
    pub fn l_tick_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> TsTemplateElementList { support::list(&self.syntax, 1usize) }
    pub fn r_tick_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTemplateLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTemplateLiteralTypeFields {
    pub l_tick_token: SyntaxResult<SyntaxToken>,
    pub elements: TsTemplateElementList,
    pub r_tick_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsThisParameter {
    pub(crate) syntax: SyntaxNode,
}
impl TsThisParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsThisParameterFields {
        TsThisParameterFields {
            this_token: self.this_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsThisParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsThisParameterFields {
    pub this_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsThisType {
    pub(crate) syntax: SyntaxNode,
}
impl TsThisType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsThisTypeFields {
        TsThisTypeFields {
            this_token: self.this_token(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsThisType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsThisTypeFields {
    pub this_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTupleType {
    pub(crate) syntax: SyntaxNode,
}
impl TsTupleType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTupleTypeFields {
        TsTupleTypeFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> TsTupleTypeElementList { support::list(&self.syntax, 1usize) }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTupleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTupleTypeFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub elements: TsTupleTypeElementList,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAliasDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeAliasDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeAliasDeclarationFields {
        TsTypeAliasDeclarationFields {
            type_token: self.type_token(),
            binding_identifier: self.binding_identifier(),
            type_parameters: self.type_parameters(),
            eq_token: self.eq_token(),
            ty: self.ty(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding_identifier(&self) -> SyntaxResult<TsIdentifierBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 4usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeAliasDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeAliasDeclarationFields {
    pub type_token: SyntaxResult<SyntaxToken>,
    pub binding_identifier: SyntaxResult<TsIdentifierBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeAnnotationFields {
        TsTypeAnnotationFields {
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeAnnotationFields {
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeArguments {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeArgumentsFields {
        TsTypeArgumentsFields {
            l_angle_token: self.l_angle_token(),
            ts_type_argument_list: self.ts_type_argument_list(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ts_type_argument_list(&self) -> TsTypeArgumentList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeArguments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeArgumentsFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub ts_type_argument_list: TsTypeArgumentList,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAssertionAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeAssertionAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeAssertionAssignmentFields {
        TsTypeAssertionAssignmentFields {
            l_angle_token: self.l_angle_token(),
            ty: self.ty(),
            r_angle_token: self.r_angle_token(),
            assignment: self.assignment(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn assignment(&self) -> SyntaxResult<JsAnyAssignment> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeAssertionAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeAssertionAssignmentFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
    pub assignment: SyntaxResult<JsAnyAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAssertionExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeAssertionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeAssertionExpressionFields {
        TsTypeAssertionExpressionFields {
            l_angle_token: self.l_angle_token(),
            ty: self.ty(),
            r_angle_token: self.r_angle_token(),
            expression: self.expression(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn expression(&self) -> SyntaxResult<JsAnyExpression> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeAssertionExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeAssertionExpressionFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<JsAnyExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeConstraintClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeConstraintClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeConstraintClauseFields {
        TsTypeConstraintClauseFields {
            extends_token: self.extends_token(),
            ty: self.ty(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeConstraintClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeConstraintClauseFields {
    pub extends_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeOperatorType {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeOperatorType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeOperatorTypeFields {
        TsTypeOperatorTypeFields {
            operator_token: self.operator_token(),
            ty: self.ty(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<TsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeOperatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeOperatorTypeFields {
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<TsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameter {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeParameterFields {
        TsTypeParameterFields {
            name: self.name(),
            constraint: self.constraint(),
            default: self.default(),
        }
    }
    pub fn name(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn constraint(&self) -> Option<TsTypeConstraintClause> {
        support::node(&self.syntax, 1usize)
    }
    pub fn default(&self) -> Option<TsDefaultTypeClause> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeParameterFields {
    pub name: SyntaxResult<TsTypeParameterName>,
    pub constraint: Option<TsTypeConstraintClause>,
    pub default: Option<TsDefaultTypeClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameterName {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeParameterName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeParameterNameFields {
        TsTypeParameterNameFields {
            ident_token: self.ident_token(),
        }
    }
    pub fn ident_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameterName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeParameterNameFields {
    pub ident_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameters {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeParametersFields {
        TsTypeParametersFields {
            l_angle_token: self.l_angle_token(),
            items: self.items(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> TsTypeParameterList { support::list(&self.syntax, 1usize) }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeParametersFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub items: TsTypeParameterList,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeofType {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeofType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeofTypeFields {
        TsTypeofTypeFields {
            typeof_token: self.typeof_token(),
            expression_name: self.expression_name(),
        }
    }
    pub fn typeof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression_name(&self) -> SyntaxResult<TsAnyName> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeofType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsTypeofTypeFields {
    pub typeof_token: SyntaxResult<SyntaxToken>,
    pub expression_name: SyntaxResult<TsAnyName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUndefinedType {
    pub(crate) syntax: SyntaxNode,
}
impl TsUndefinedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsUndefinedTypeFields {
        TsUndefinedTypeFields {
            undefined_token: self.undefined_token(),
        }
    }
    pub fn undefined_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsUndefinedType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsUndefinedTypeFields {
    pub undefined_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUnionType {
    pub(crate) syntax: SyntaxNode,
}
impl TsUnionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsUnionTypeFields {
        TsUnionTypeFields {
            leading_separator_token: self.leading_separator_token(),
            types: self.types(),
        }
    }
    pub fn leading_separator_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsUnionTypeVariantList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsUnionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsUnionTypeFields {
    pub leading_separator_token: Option<SyntaxToken>,
    pub types: TsUnionTypeVariantList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUnknownType {
    pub(crate) syntax: SyntaxNode,
}
impl TsUnknownType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsUnknownTypeFields {
        TsUnknownTypeFields {
            unknown_token: self.unknown_token(),
        }
    }
    pub fn unknown_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsUnknownType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsUnknownTypeFields {
    pub unknown_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsVoidType {
    pub(crate) syntax: SyntaxNode,
}
impl TsVoidType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsVoidTypeFields {
        TsVoidTypeFields {
            void_token: self.void_token(),
        }
    }
    pub fn void_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsVoidType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize), serde(crate = "serde_crate"))]
pub struct TsVoidTypeFields {
    pub void_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyArrayAssignmentPatternElement {
    JsAnyAssignmentPattern(JsAnyAssignmentPattern),
    JsArrayAssignmentPatternRestElement(JsArrayAssignmentPatternRestElement),
    JsArrayHole(JsArrayHole),
    JsAssignmentWithDefault(JsAssignmentWithDefault),
}
impl JsAnyArrayAssignmentPatternElement {
    pub fn as_js_any_assignment_pattern(&self) -> Option<&JsAnyAssignmentPattern> {
        match &self {
            JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_assignment_pattern_rest_element(
        &self,
    ) -> Option<&JsArrayAssignmentPatternRestElement> {
        match &self {
            JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(item) => {
                Some(item)
            }
            _ => None,
        }
    }
    pub fn as_js_array_hole(&self) -> Option<&JsArrayHole> {
        match &self {
            JsAnyArrayAssignmentPatternElement::JsArrayHole(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_assignment_with_default(&self) -> Option<&JsAssignmentWithDefault> {
        match &self {
            JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyArrayBindingPatternElement {
    JsAnyBindingPattern(JsAnyBindingPattern),
    JsArrayBindingPatternRestElement(JsArrayBindingPatternRestElement),
    JsArrayHole(JsArrayHole),
    JsBindingPatternWithDefault(JsBindingPatternWithDefault),
}
impl JsAnyArrayBindingPatternElement {
    pub fn as_js_any_binding_pattern(&self) -> Option<&JsAnyBindingPattern> {
        match &self {
            JsAnyArrayBindingPatternElement::JsAnyBindingPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_binding_pattern_rest_element(
        &self,
    ) -> Option<&JsArrayBindingPatternRestElement> {
        match &self {
            JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_hole(&self) -> Option<&JsArrayHole> {
        match &self {
            JsAnyArrayBindingPatternElement::JsArrayHole(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_binding_pattern_with_default(&self) -> Option<&JsBindingPatternWithDefault> {
        match &self {
            JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyArrayElement {
    JsAnyExpression(JsAnyExpression),
    JsArrayHole(JsArrayHole),
    JsSpread(JsSpread),
}
impl JsAnyArrayElement {
    pub fn as_js_any_expression(&self) -> Option<&JsAnyExpression> {
        match &self {
            JsAnyArrayElement::JsAnyExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_hole(&self) -> Option<&JsArrayHole> {
        match &self {
            JsAnyArrayElement::JsArrayHole(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_spread(&self) -> Option<&JsSpread> {
        match &self {
            JsAnyArrayElement::JsSpread(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyArrowFunctionParameters {
    JsAnyBinding(JsAnyBinding),
    JsParameters(JsParameters),
}
impl JsAnyArrowFunctionParameters {
    pub fn as_js_any_binding(&self) -> Option<&JsAnyBinding> {
        match &self {
            JsAnyArrowFunctionParameters::JsAnyBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_parameters(&self) -> Option<&JsParameters> {
        match &self {
            JsAnyArrowFunctionParameters::JsParameters(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyAssignment {
    JsComputedMemberAssignment(JsComputedMemberAssignment),
    JsIdentifierAssignment(JsIdentifierAssignment),
    JsParenthesizedAssignment(JsParenthesizedAssignment),
    JsStaticMemberAssignment(JsStaticMemberAssignment),
    JsUnknownAssignment(JsUnknownAssignment),
    TsAsAssignment(TsAsAssignment),
    TsNonNullAssertionAssignment(TsNonNullAssertionAssignment),
    TsTypeAssertionAssignment(TsTypeAssertionAssignment),
}
impl JsAnyAssignment {
    pub fn as_js_computed_member_assignment(&self) -> Option<&JsComputedMemberAssignment> {
        match &self {
            JsAnyAssignment::JsComputedMemberAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_identifier_assignment(&self) -> Option<&JsIdentifierAssignment> {
        match &self {
            JsAnyAssignment::JsIdentifierAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_parenthesized_assignment(&self) -> Option<&JsParenthesizedAssignment> {
        match &self {
            JsAnyAssignment::JsParenthesizedAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_member_assignment(&self) -> Option<&JsStaticMemberAssignment> {
        match &self {
            JsAnyAssignment::JsStaticMemberAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_assignment(&self) -> Option<&JsUnknownAssignment> {
        match &self {
            JsAnyAssignment::JsUnknownAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_as_assignment(&self) -> Option<&TsAsAssignment> {
        match &self {
            JsAnyAssignment::TsAsAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_non_null_assertion_assignment(&self) -> Option<&TsNonNullAssertionAssignment> {
        match &self {
            JsAnyAssignment::TsNonNullAssertionAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_assertion_assignment(&self) -> Option<&TsTypeAssertionAssignment> {
        match &self {
            JsAnyAssignment::TsTypeAssertionAssignment(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyAssignmentPattern {
    JsAnyAssignment(JsAnyAssignment),
    JsArrayAssignmentPattern(JsArrayAssignmentPattern),
    JsObjectAssignmentPattern(JsObjectAssignmentPattern),
}
impl JsAnyAssignmentPattern {
    pub fn as_js_any_assignment(&self) -> Option<&JsAnyAssignment> {
        match &self {
            JsAnyAssignmentPattern::JsAnyAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_assignment_pattern(&self) -> Option<&JsArrayAssignmentPattern> {
        match &self {
            JsAnyAssignmentPattern::JsArrayAssignmentPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_assignment_pattern(&self) -> Option<&JsObjectAssignmentPattern> {
        match &self {
            JsAnyAssignmentPattern::JsObjectAssignmentPattern(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyBinding {
    JsIdentifierBinding(JsIdentifierBinding),
    JsUnknownBinding(JsUnknownBinding),
}
impl JsAnyBinding {
    pub fn as_js_identifier_binding(&self) -> Option<&JsIdentifierBinding> {
        match &self {
            JsAnyBinding::JsIdentifierBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_binding(&self) -> Option<&JsUnknownBinding> {
        match &self {
            JsAnyBinding::JsUnknownBinding(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyBindingPattern {
    JsAnyBinding(JsAnyBinding),
    JsArrayBindingPattern(JsArrayBindingPattern),
    JsObjectBindingPattern(JsObjectBindingPattern),
}
impl JsAnyBindingPattern {
    pub fn as_js_any_binding(&self) -> Option<&JsAnyBinding> {
        match &self {
            JsAnyBindingPattern::JsAnyBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_binding_pattern(&self) -> Option<&JsArrayBindingPattern> {
        match &self {
            JsAnyBindingPattern::JsArrayBindingPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_binding_pattern(&self) -> Option<&JsObjectBindingPattern> {
        match &self {
            JsAnyBindingPattern::JsObjectBindingPattern(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyCallArgument {
    JsAnyExpression(JsAnyExpression),
    JsSpread(JsSpread),
}
impl JsAnyCallArgument {
    pub fn as_js_any_expression(&self) -> Option<&JsAnyExpression> {
        match &self {
            JsAnyCallArgument::JsAnyExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_spread(&self) -> Option<&JsSpread> {
        match &self {
            JsAnyCallArgument::JsSpread(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyClass {
    JsClassDeclaration(JsClassDeclaration),
    JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration),
    JsClassExpression(JsClassExpression),
}
impl JsAnyClass {
    pub fn as_js_class_declaration(&self) -> Option<&JsClassDeclaration> {
        match &self {
            JsAnyClass::JsClassDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_class_export_default_declaration(
        &self,
    ) -> Option<&JsClassExportDefaultDeclaration> {
        match &self {
            JsAnyClass::JsClassExportDefaultDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_class_expression(&self) -> Option<&JsClassExpression> {
        match &self {
            JsAnyClass::JsClassExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyClassMember {
    JsConstructorClassMember(JsConstructorClassMember),
    JsEmptyClassMember(JsEmptyClassMember),
    JsGetterClassMember(JsGetterClassMember),
    JsMethodClassMember(JsMethodClassMember),
    JsPropertyClassMember(JsPropertyClassMember),
    JsSetterClassMember(JsSetterClassMember),
    JsStaticInitializationBlockClassMember(JsStaticInitializationBlockClassMember),
    JsUnknownMember(JsUnknownMember),
    TsConstructorSignatureClassMember(TsConstructorSignatureClassMember),
    TsGetterSignatureClassMember(TsGetterSignatureClassMember),
    TsIndexSignatureClassMember(TsIndexSignatureClassMember),
    TsMethodSignatureClassMember(TsMethodSignatureClassMember),
    TsPropertySignatureClassMember(TsPropertySignatureClassMember),
    TsSetterSignatureClassMember(TsSetterSignatureClassMember),
}
impl JsAnyClassMember {
    pub fn as_js_constructor_class_member(&self) -> Option<&JsConstructorClassMember> {
        match &self {
            JsAnyClassMember::JsConstructorClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_empty_class_member(&self) -> Option<&JsEmptyClassMember> {
        match &self {
            JsAnyClassMember::JsEmptyClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_getter_class_member(&self) -> Option<&JsGetterClassMember> {
        match &self {
            JsAnyClassMember::JsGetterClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_method_class_member(&self) -> Option<&JsMethodClassMember> {
        match &self {
            JsAnyClassMember::JsMethodClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_property_class_member(&self) -> Option<&JsPropertyClassMember> {
        match &self {
            JsAnyClassMember::JsPropertyClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_setter_class_member(&self) -> Option<&JsSetterClassMember> {
        match &self {
            JsAnyClassMember::JsSetterClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_initialization_block_class_member(
        &self,
    ) -> Option<&JsStaticInitializationBlockClassMember> {
        match &self {
            JsAnyClassMember::JsStaticInitializationBlockClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_member(&self) -> Option<&JsUnknownMember> {
        match &self {
            JsAnyClassMember::JsUnknownMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_constructor_signature_class_member(
        &self,
    ) -> Option<&TsConstructorSignatureClassMember> {
        match &self {
            JsAnyClassMember::TsConstructorSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_getter_signature_class_member(&self) -> Option<&TsGetterSignatureClassMember> {
        match &self {
            JsAnyClassMember::TsGetterSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_index_signature_class_member(&self) -> Option<&TsIndexSignatureClassMember> {
        match &self {
            JsAnyClassMember::TsIndexSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_method_signature_class_member(&self) -> Option<&TsMethodSignatureClassMember> {
        match &self {
            JsAnyClassMember::TsMethodSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_property_signature_class_member(&self) -> Option<&TsPropertySignatureClassMember> {
        match &self {
            JsAnyClassMember::TsPropertySignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_setter_signature_class_member(&self) -> Option<&TsSetterSignatureClassMember> {
        match &self {
            JsAnyClassMember::TsSetterSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyClassMemberName {
    JsComputedMemberName(JsComputedMemberName),
    JsLiteralMemberName(JsLiteralMemberName),
    JsPrivateClassMemberName(JsPrivateClassMemberName),
}
impl JsAnyClassMemberName {
    pub fn as_js_computed_member_name(&self) -> Option<&JsComputedMemberName> {
        match &self {
            JsAnyClassMemberName::JsComputedMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_literal_member_name(&self) -> Option<&JsLiteralMemberName> {
        match &self {
            JsAnyClassMemberName::JsLiteralMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_private_class_member_name(&self) -> Option<&JsPrivateClassMemberName> {
        match &self {
            JsAnyClassMemberName::JsPrivateClassMemberName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyConstructorParameter {
    JsAnyFormalParameter(JsAnyFormalParameter),
    JsRestParameter(JsRestParameter),
    TsPropertyParameter(TsPropertyParameter),
}
impl JsAnyConstructorParameter {
    pub fn as_js_any_formal_parameter(&self) -> Option<&JsAnyFormalParameter> {
        match &self {
            JsAnyConstructorParameter::JsAnyFormalParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_rest_parameter(&self) -> Option<&JsRestParameter> {
        match &self {
            JsAnyConstructorParameter::JsRestParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_property_parameter(&self) -> Option<&TsPropertyParameter> {
        match &self {
            JsAnyConstructorParameter::TsPropertyParameter(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyDeclaration {
    JsClassDeclaration(JsClassDeclaration),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsVariableDeclaration(JsVariableDeclaration),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
impl JsAnyDeclaration {
    pub fn as_js_class_declaration(&self) -> Option<&JsClassDeclaration> {
        match &self {
            JsAnyDeclaration::JsClassDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_declaration(&self) -> Option<&JsFunctionDeclaration> {
        match &self {
            JsAnyDeclaration::JsFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_variable_declaration(&self) -> Option<&JsVariableDeclaration> {
        match &self {
            JsAnyDeclaration::JsVariableDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_function_declaration(&self) -> Option<&TsDeclareFunctionDeclaration> {
        match &self {
            JsAnyDeclaration::TsDeclareFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_enum_declaration(&self) -> Option<&TsEnumDeclaration> {
        match &self {
            JsAnyDeclaration::TsEnumDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_external_module_declaration(&self) -> Option<&TsExternalModuleDeclaration> {
        match &self {
            JsAnyDeclaration::TsExternalModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_global_declaration(&self) -> Option<&TsGlobalDeclaration> {
        match &self {
            JsAnyDeclaration::TsGlobalDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_import_equals_declaration(&self) -> Option<&TsImportEqualsDeclaration> {
        match &self {
            JsAnyDeclaration::TsImportEqualsDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_interface_declaration(&self) -> Option<&TsInterfaceDeclaration> {
        match &self {
            JsAnyDeclaration::TsInterfaceDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_module_declaration(&self) -> Option<&TsModuleDeclaration> {
        match &self {
            JsAnyDeclaration::TsModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_alias_declaration(&self) -> Option<&TsTypeAliasDeclaration> {
        match &self {
            JsAnyDeclaration::TsTypeAliasDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyDeclarationClause {
    JsClassDeclaration(JsClassDeclaration),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsVariableDeclarationClause(JsVariableDeclarationClause),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
impl JsAnyDeclarationClause {
    pub fn as_js_class_declaration(&self) -> Option<&JsClassDeclaration> {
        match &self {
            JsAnyDeclarationClause::JsClassDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_declaration(&self) -> Option<&JsFunctionDeclaration> {
        match &self {
            JsAnyDeclarationClause::JsFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_variable_declaration_clause(&self) -> Option<&JsVariableDeclarationClause> {
        match &self {
            JsAnyDeclarationClause::JsVariableDeclarationClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_function_declaration(&self) -> Option<&TsDeclareFunctionDeclaration> {
        match &self {
            JsAnyDeclarationClause::TsDeclareFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_enum_declaration(&self) -> Option<&TsEnumDeclaration> {
        match &self {
            JsAnyDeclarationClause::TsEnumDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_external_module_declaration(&self) -> Option<&TsExternalModuleDeclaration> {
        match &self {
            JsAnyDeclarationClause::TsExternalModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_global_declaration(&self) -> Option<&TsGlobalDeclaration> {
        match &self {
            JsAnyDeclarationClause::TsGlobalDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_import_equals_declaration(&self) -> Option<&TsImportEqualsDeclaration> {
        match &self {
            JsAnyDeclarationClause::TsImportEqualsDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_interface_declaration(&self) -> Option<&TsInterfaceDeclaration> {
        match &self {
            JsAnyDeclarationClause::TsInterfaceDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_module_declaration(&self) -> Option<&TsModuleDeclaration> {
        match &self {
            JsAnyDeclarationClause::TsModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_alias_declaration(&self) -> Option<&TsTypeAliasDeclaration> {
        match &self {
            JsAnyDeclarationClause::TsTypeAliasDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyExportClause {
    JsAnyDeclarationClause(JsAnyDeclarationClause),
    JsExportDefaultDeclarationClause(JsExportDefaultDeclarationClause),
    JsExportDefaultExpressionClause(JsExportDefaultExpressionClause),
    JsExportFromClause(JsExportFromClause),
    JsExportNamedClause(JsExportNamedClause),
    JsExportNamedFromClause(JsExportNamedFromClause),
    TsExportAsNamespaceClause(TsExportAsNamespaceClause),
    TsExportAssignmentClause(TsExportAssignmentClause),
    TsExportDeclareClause(TsExportDeclareClause),
}
impl JsAnyExportClause {
    pub fn as_js_any_declaration_clause(&self) -> Option<&JsAnyDeclarationClause> {
        match &self {
            JsAnyExportClause::JsAnyDeclarationClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_default_declaration_clause(
        &self,
    ) -> Option<&JsExportDefaultDeclarationClause> {
        match &self {
            JsAnyExportClause::JsExportDefaultDeclarationClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_default_expression_clause(
        &self,
    ) -> Option<&JsExportDefaultExpressionClause> {
        match &self {
            JsAnyExportClause::JsExportDefaultExpressionClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_from_clause(&self) -> Option<&JsExportFromClause> {
        match &self {
            JsAnyExportClause::JsExportFromClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_named_clause(&self) -> Option<&JsExportNamedClause> {
        match &self {
            JsAnyExportClause::JsExportNamedClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_named_from_clause(&self) -> Option<&JsExportNamedFromClause> {
        match &self {
            JsAnyExportClause::JsExportNamedFromClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_export_as_namespace_clause(&self) -> Option<&TsExportAsNamespaceClause> {
        match &self {
            JsAnyExportClause::TsExportAsNamespaceClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_export_assignment_clause(&self) -> Option<&TsExportAssignmentClause> {
        match &self {
            JsAnyExportClause::TsExportAssignmentClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_export_declare_clause(&self) -> Option<&TsExportDeclareClause> {
        match &self {
            JsAnyExportClause::TsExportDeclareClause(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyExportDefaultDeclaration {
    JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration),
    JsFunctionExportDefaultDeclaration(JsFunctionExportDefaultDeclaration),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
}
impl JsAnyExportDefaultDeclaration {
    pub fn as_js_class_export_default_declaration(
        &self,
    ) -> Option<&JsClassExportDefaultDeclaration> {
        match &self {
            JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_export_default_declaration(
        &self,
    ) -> Option<&JsFunctionExportDefaultDeclaration> {
        match &self {
            JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_function_declaration(&self) -> Option<&TsDeclareFunctionDeclaration> {
        match &self {
            JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_interface_declaration(&self) -> Option<&TsInterfaceDeclaration> {
        match &self {
            JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyExportNamedSpecifier {
    JsExportNamedShorthandSpecifier(JsExportNamedShorthandSpecifier),
    JsExportNamedSpecifier(JsExportNamedSpecifier),
}
impl JsAnyExportNamedSpecifier {
    pub fn as_js_export_named_shorthand_specifier(
        &self,
    ) -> Option<&JsExportNamedShorthandSpecifier> {
        match &self {
            JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_named_specifier(&self) -> Option<&JsExportNamedSpecifier> {
        match &self {
            JsAnyExportNamedSpecifier::JsExportNamedSpecifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyExpression {
    ImportMeta(ImportMeta),
    JsAnyLiteralExpression(JsAnyLiteralExpression),
    JsArrayExpression(JsArrayExpression),
    JsArrowFunctionExpression(JsArrowFunctionExpression),
    JsAssignmentExpression(JsAssignmentExpression),
    JsAwaitExpression(JsAwaitExpression),
    JsBinaryExpression(JsBinaryExpression),
    JsCallExpression(JsCallExpression),
    JsClassExpression(JsClassExpression),
    JsComputedMemberExpression(JsComputedMemberExpression),
    JsConditionalExpression(JsConditionalExpression),
    JsFunctionExpression(JsFunctionExpression),
    JsIdentifierExpression(JsIdentifierExpression),
    JsImportCallExpression(JsImportCallExpression),
    JsInExpression(JsInExpression),
    JsInstanceofExpression(JsInstanceofExpression),
    JsLogicalExpression(JsLogicalExpression),
    JsNewExpression(JsNewExpression),
    JsObjectExpression(JsObjectExpression),
    JsParenthesizedExpression(JsParenthesizedExpression),
    JsPostUpdateExpression(JsPostUpdateExpression),
    JsPreUpdateExpression(JsPreUpdateExpression),
    JsSequenceExpression(JsSequenceExpression),
    JsStaticMemberExpression(JsStaticMemberExpression),
    JsSuperExpression(JsSuperExpression),
    JsTemplate(JsTemplate),
    JsThisExpression(JsThisExpression),
    JsUnaryExpression(JsUnaryExpression),
    JsUnknownExpression(JsUnknownExpression),
    JsYieldExpression(JsYieldExpression),
    JsxTagExpression(JsxTagExpression),
    NewTarget(NewTarget),
    TsAsExpression(TsAsExpression),
    TsNonNullAssertionExpression(TsNonNullAssertionExpression),
    TsTypeAssertionExpression(TsTypeAssertionExpression),
}
impl JsAnyExpression {
    pub fn as_import_meta(&self) -> Option<&ImportMeta> {
        match &self {
            JsAnyExpression::ImportMeta(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_any_literal_expression(&self) -> Option<&JsAnyLiteralExpression> {
        match &self {
            JsAnyExpression::JsAnyLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_expression(&self) -> Option<&JsArrayExpression> {
        match &self {
            JsAnyExpression::JsArrayExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_arrow_function_expression(&self) -> Option<&JsArrowFunctionExpression> {
        match &self {
            JsAnyExpression::JsArrowFunctionExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_assignment_expression(&self) -> Option<&JsAssignmentExpression> {
        match &self {
            JsAnyExpression::JsAssignmentExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_await_expression(&self) -> Option<&JsAwaitExpression> {
        match &self {
            JsAnyExpression::JsAwaitExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_binary_expression(&self) -> Option<&JsBinaryExpression> {
        match &self {
            JsAnyExpression::JsBinaryExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_call_expression(&self) -> Option<&JsCallExpression> {
        match &self {
            JsAnyExpression::JsCallExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_class_expression(&self) -> Option<&JsClassExpression> {
        match &self {
            JsAnyExpression::JsClassExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_computed_member_expression(&self) -> Option<&JsComputedMemberExpression> {
        match &self {
            JsAnyExpression::JsComputedMemberExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_conditional_expression(&self) -> Option<&JsConditionalExpression> {
        match &self {
            JsAnyExpression::JsConditionalExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_expression(&self) -> Option<&JsFunctionExpression> {
        match &self {
            JsAnyExpression::JsFunctionExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_identifier_expression(&self) -> Option<&JsIdentifierExpression> {
        match &self {
            JsAnyExpression::JsIdentifierExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_call_expression(&self) -> Option<&JsImportCallExpression> {
        match &self {
            JsAnyExpression::JsImportCallExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_in_expression(&self) -> Option<&JsInExpression> {
        match &self {
            JsAnyExpression::JsInExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_instanceof_expression(&self) -> Option<&JsInstanceofExpression> {
        match &self {
            JsAnyExpression::JsInstanceofExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_logical_expression(&self) -> Option<&JsLogicalExpression> {
        match &self {
            JsAnyExpression::JsLogicalExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_new_expression(&self) -> Option<&JsNewExpression> {
        match &self {
            JsAnyExpression::JsNewExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_expression(&self) -> Option<&JsObjectExpression> {
        match &self {
            JsAnyExpression::JsObjectExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_parenthesized_expression(&self) -> Option<&JsParenthesizedExpression> {
        match &self {
            JsAnyExpression::JsParenthesizedExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_post_update_expression(&self) -> Option<&JsPostUpdateExpression> {
        match &self {
            JsAnyExpression::JsPostUpdateExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_pre_update_expression(&self) -> Option<&JsPreUpdateExpression> {
        match &self {
            JsAnyExpression::JsPreUpdateExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_sequence_expression(&self) -> Option<&JsSequenceExpression> {
        match &self {
            JsAnyExpression::JsSequenceExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_member_expression(&self) -> Option<&JsStaticMemberExpression> {
        match &self {
            JsAnyExpression::JsStaticMemberExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_super_expression(&self) -> Option<&JsSuperExpression> {
        match &self {
            JsAnyExpression::JsSuperExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_template(&self) -> Option<&JsTemplate> {
        match &self {
            JsAnyExpression::JsTemplate(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_this_expression(&self) -> Option<&JsThisExpression> {
        match &self {
            JsAnyExpression::JsThisExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unary_expression(&self) -> Option<&JsUnaryExpression> {
        match &self {
            JsAnyExpression::JsUnaryExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_expression(&self) -> Option<&JsUnknownExpression> {
        match &self {
            JsAnyExpression::JsUnknownExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_yield_expression(&self) -> Option<&JsYieldExpression> {
        match &self {
            JsAnyExpression::JsYieldExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_tag_expression(&self) -> Option<&JsxTagExpression> {
        match &self {
            JsAnyExpression::JsxTagExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_new_target(&self) -> Option<&NewTarget> {
        match &self {
            JsAnyExpression::NewTarget(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_as_expression(&self) -> Option<&TsAsExpression> {
        match &self {
            JsAnyExpression::TsAsExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_non_null_assertion_expression(&self) -> Option<&TsNonNullAssertionExpression> {
        match &self {
            JsAnyExpression::TsNonNullAssertionExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_assertion_expression(&self) -> Option<&TsTypeAssertionExpression> {
        match &self {
            JsAnyExpression::TsTypeAssertionExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyForInOrOfInitializer {
    JsAnyAssignmentPattern(JsAnyAssignmentPattern),
    JsForVariableDeclaration(JsForVariableDeclaration),
}
impl JsAnyForInOrOfInitializer {
    pub fn as_js_any_assignment_pattern(&self) -> Option<&JsAnyAssignmentPattern> {
        match &self {
            JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_for_variable_declaration(&self) -> Option<&JsForVariableDeclaration> {
        match &self {
            JsAnyForInOrOfInitializer::JsForVariableDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyForInitializer {
    JsAnyExpression(JsAnyExpression),
    JsVariableDeclaration(JsVariableDeclaration),
}
impl JsAnyForInitializer {
    pub fn as_js_any_expression(&self) -> Option<&JsAnyExpression> {
        match &self {
            JsAnyForInitializer::JsAnyExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_variable_declaration(&self) -> Option<&JsVariableDeclaration> {
        match &self {
            JsAnyForInitializer::JsVariableDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyFormalParameter {
    JsFormalParameter(JsFormalParameter),
    JsUnknownParameter(JsUnknownParameter),
}
impl JsAnyFormalParameter {
    pub fn as_js_formal_parameter(&self) -> Option<&JsFormalParameter> {
        match &self {
            JsAnyFormalParameter::JsFormalParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_parameter(&self) -> Option<&JsUnknownParameter> {
        match &self {
            JsAnyFormalParameter::JsUnknownParameter(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyFunction {
    JsArrowFunctionExpression(JsArrowFunctionExpression),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsFunctionExportDefaultDeclaration(JsFunctionExportDefaultDeclaration),
    JsFunctionExpression(JsFunctionExpression),
}
impl JsAnyFunction {
    pub fn as_js_arrow_function_expression(&self) -> Option<&JsArrowFunctionExpression> {
        match &self {
            JsAnyFunction::JsArrowFunctionExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_declaration(&self) -> Option<&JsFunctionDeclaration> {
        match &self {
            JsAnyFunction::JsFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_export_default_declaration(
        &self,
    ) -> Option<&JsFunctionExportDefaultDeclaration> {
        match &self {
            JsAnyFunction::JsFunctionExportDefaultDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_expression(&self) -> Option<&JsFunctionExpression> {
        match &self {
            JsAnyFunction::JsFunctionExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyFunctionBody {
    JsAnyExpression(JsAnyExpression),
    JsFunctionBody(JsFunctionBody),
}
impl JsAnyFunctionBody {
    pub fn as_js_any_expression(&self) -> Option<&JsAnyExpression> {
        match &self {
            JsAnyFunctionBody::JsAnyExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_body(&self) -> Option<&JsFunctionBody> {
        match &self {
            JsAnyFunctionBody::JsFunctionBody(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyImportAssertionEntry {
    JsImportAssertionEntry(JsImportAssertionEntry),
    JsUnknownImportAssertionEntry(JsUnknownImportAssertionEntry),
}
impl JsAnyImportAssertionEntry {
    pub fn as_js_import_assertion_entry(&self) -> Option<&JsImportAssertionEntry> {
        match &self {
            JsAnyImportAssertionEntry::JsImportAssertionEntry(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_import_assertion_entry(&self) -> Option<&JsUnknownImportAssertionEntry> {
        match &self {
            JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyImportClause {
    JsImportBareClause(JsImportBareClause),
    JsImportDefaultClause(JsImportDefaultClause),
    JsImportNamedClause(JsImportNamedClause),
    JsImportNamespaceClause(JsImportNamespaceClause),
}
impl JsAnyImportClause {
    pub fn as_js_import_bare_clause(&self) -> Option<&JsImportBareClause> {
        match &self {
            JsAnyImportClause::JsImportBareClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_default_clause(&self) -> Option<&JsImportDefaultClause> {
        match &self {
            JsAnyImportClause::JsImportDefaultClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_named_clause(&self) -> Option<&JsImportNamedClause> {
        match &self {
            JsAnyImportClause::JsImportNamedClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_namespace_clause(&self) -> Option<&JsImportNamespaceClause> {
        match &self {
            JsAnyImportClause::JsImportNamespaceClause(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyInProperty {
    JsAnyExpression(JsAnyExpression),
    JsPrivateName(JsPrivateName),
}
impl JsAnyInProperty {
    pub fn as_js_any_expression(&self) -> Option<&JsAnyExpression> {
        match &self {
            JsAnyInProperty::JsAnyExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_private_name(&self) -> Option<&JsPrivateName> {
        match &self {
            JsAnyInProperty::JsPrivateName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyLiteralExpression {
    JsBigIntLiteralExpression(JsBigIntLiteralExpression),
    JsBooleanLiteralExpression(JsBooleanLiteralExpression),
    JsNullLiteralExpression(JsNullLiteralExpression),
    JsNumberLiteralExpression(JsNumberLiteralExpression),
    JsRegexLiteralExpression(JsRegexLiteralExpression),
    JsStringLiteralExpression(JsStringLiteralExpression),
}
impl JsAnyLiteralExpression {
    pub fn as_js_big_int_literal_expression(&self) -> Option<&JsBigIntLiteralExpression> {
        match &self {
            JsAnyLiteralExpression::JsBigIntLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_boolean_literal_expression(&self) -> Option<&JsBooleanLiteralExpression> {
        match &self {
            JsAnyLiteralExpression::JsBooleanLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_null_literal_expression(&self) -> Option<&JsNullLiteralExpression> {
        match &self {
            JsAnyLiteralExpression::JsNullLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_number_literal_expression(&self) -> Option<&JsNumberLiteralExpression> {
        match &self {
            JsAnyLiteralExpression::JsNumberLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_regex_literal_expression(&self) -> Option<&JsRegexLiteralExpression> {
        match &self {
            JsAnyLiteralExpression::JsRegexLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_string_literal_expression(&self) -> Option<&JsStringLiteralExpression> {
        match &self {
            JsAnyLiteralExpression::JsStringLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyMethodModifier {
    JsStaticModifier(JsStaticModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
}
impl JsAnyMethodModifier {
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            JsAnyMethodModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            JsAnyMethodModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            JsAnyMethodModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyModuleItem {
    JsAnyStatement(JsAnyStatement),
    JsExport(JsExport),
    JsImport(JsImport),
}
impl JsAnyModuleItem {
    pub fn as_js_any_statement(&self) -> Option<&JsAnyStatement> {
        match &self {
            JsAnyModuleItem::JsAnyStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export(&self) -> Option<&JsExport> {
        match &self {
            JsAnyModuleItem::JsExport(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import(&self) -> Option<&JsImport> {
        match &self {
            JsAnyModuleItem::JsImport(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyName {
    JsName(JsName),
    JsPrivateName(JsPrivateName),
}
impl JsAnyName {
    pub fn as_js_name(&self) -> Option<&JsName> {
        match &self {
            JsAnyName::JsName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_private_name(&self) -> Option<&JsPrivateName> {
        match &self {
            JsAnyName::JsPrivateName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyNamedImport {
    JsNamedImportSpecifiers(JsNamedImportSpecifiers),
    JsNamespaceImportSpecifier(JsNamespaceImportSpecifier),
}
impl JsAnyNamedImport {
    pub fn as_js_named_import_specifiers(&self) -> Option<&JsNamedImportSpecifiers> {
        match &self {
            JsAnyNamedImport::JsNamedImportSpecifiers(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_namespace_import_specifier(&self) -> Option<&JsNamespaceImportSpecifier> {
        match &self {
            JsAnyNamedImport::JsNamespaceImportSpecifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyNamedImportSpecifier {
    JsNamedImportSpecifier(JsNamedImportSpecifier),
    JsShorthandNamedImportSpecifier(JsShorthandNamedImportSpecifier),
    JsUnknownNamedImportSpecifier(JsUnknownNamedImportSpecifier),
}
impl JsAnyNamedImportSpecifier {
    pub fn as_js_named_import_specifier(&self) -> Option<&JsNamedImportSpecifier> {
        match &self {
            JsAnyNamedImportSpecifier::JsNamedImportSpecifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_shorthand_named_import_specifier(
        &self,
    ) -> Option<&JsShorthandNamedImportSpecifier> {
        match &self {
            JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_named_import_specifier(&self) -> Option<&JsUnknownNamedImportSpecifier> {
        match &self {
            JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyObjectAssignmentPatternMember {
    JsObjectAssignmentPatternProperty(JsObjectAssignmentPatternProperty),
    JsObjectAssignmentPatternRest(JsObjectAssignmentPatternRest),
    JsObjectAssignmentPatternShorthandProperty(JsObjectAssignmentPatternShorthandProperty),
    JsUnknownAssignment(JsUnknownAssignment),
}
impl JsAnyObjectAssignmentPatternMember {
    pub fn as_js_object_assignment_pattern_property(
        &self,
    ) -> Option<&JsObjectAssignmentPatternProperty> {
        match &self {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(item) => {
                Some(item)
            }
            _ => None,
        }
    }
    pub fn as_js_object_assignment_pattern_rest(&self) -> Option<&JsObjectAssignmentPatternRest> {
        match &self {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_assignment_pattern_shorthand_property(
        &self,
    ) -> Option<&JsObjectAssignmentPatternShorthandProperty> {
        match &self {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(
                item,
            ) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_assignment(&self) -> Option<&JsUnknownAssignment> {
        match &self {
            JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyObjectBindingPatternMember {
    JsIdentifierBinding(JsIdentifierBinding),
    JsObjectBindingPatternProperty(JsObjectBindingPatternProperty),
    JsObjectBindingPatternRest(JsObjectBindingPatternRest),
    JsObjectBindingPatternShorthandProperty(JsObjectBindingPatternShorthandProperty),
    JsUnknownBinding(JsUnknownBinding),
}
impl JsAnyObjectBindingPatternMember {
    pub fn as_js_identifier_binding(&self) -> Option<&JsIdentifierBinding> {
        match &self {
            JsAnyObjectBindingPatternMember::JsIdentifierBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_binding_pattern_property(&self) -> Option<&JsObjectBindingPatternProperty> {
        match &self {
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_binding_pattern_rest(&self) -> Option<&JsObjectBindingPatternRest> {
        match &self {
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_binding_pattern_shorthand_property(
        &self,
    ) -> Option<&JsObjectBindingPatternShorthandProperty> {
        match &self {
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(item) => {
                Some(item)
            }
            _ => None,
        }
    }
    pub fn as_js_unknown_binding(&self) -> Option<&JsUnknownBinding> {
        match &self {
            JsAnyObjectBindingPatternMember::JsUnknownBinding(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyObjectMember {
    JsGetterObjectMember(JsGetterObjectMember),
    JsMethodObjectMember(JsMethodObjectMember),
    JsPropertyObjectMember(JsPropertyObjectMember),
    JsSetterObjectMember(JsSetterObjectMember),
    JsShorthandPropertyObjectMember(JsShorthandPropertyObjectMember),
    JsSpread(JsSpread),
    JsUnknownMember(JsUnknownMember),
}
impl JsAnyObjectMember {
    pub fn as_js_getter_object_member(&self) -> Option<&JsGetterObjectMember> {
        match &self {
            JsAnyObjectMember::JsGetterObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_method_object_member(&self) -> Option<&JsMethodObjectMember> {
        match &self {
            JsAnyObjectMember::JsMethodObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_property_object_member(&self) -> Option<&JsPropertyObjectMember> {
        match &self {
            JsAnyObjectMember::JsPropertyObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_setter_object_member(&self) -> Option<&JsSetterObjectMember> {
        match &self {
            JsAnyObjectMember::JsSetterObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_shorthand_property_object_member(
        &self,
    ) -> Option<&JsShorthandPropertyObjectMember> {
        match &self {
            JsAnyObjectMember::JsShorthandPropertyObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_spread(&self) -> Option<&JsSpread> {
        match &self {
            JsAnyObjectMember::JsSpread(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_member(&self) -> Option<&JsUnknownMember> {
        match &self {
            JsAnyObjectMember::JsUnknownMember(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyObjectMemberName {
    JsComputedMemberName(JsComputedMemberName),
    JsLiteralMemberName(JsLiteralMemberName),
}
impl JsAnyObjectMemberName {
    pub fn as_js_computed_member_name(&self) -> Option<&JsComputedMemberName> {
        match &self {
            JsAnyObjectMemberName::JsComputedMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_literal_member_name(&self) -> Option<&JsLiteralMemberName> {
        match &self {
            JsAnyObjectMemberName::JsLiteralMemberName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyParameter {
    JsAnyFormalParameter(JsAnyFormalParameter),
    JsRestParameter(JsRestParameter),
    TsThisParameter(TsThisParameter),
}
impl JsAnyParameter {
    pub fn as_js_any_formal_parameter(&self) -> Option<&JsAnyFormalParameter> {
        match &self {
            JsAnyParameter::JsAnyFormalParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_rest_parameter(&self) -> Option<&JsRestParameter> {
        match &self {
            JsAnyParameter::JsRestParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_this_parameter(&self) -> Option<&TsThisParameter> {
        match &self {
            JsAnyParameter::TsThisParameter(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyPropertyModifier {
    JsStaticModifier(JsStaticModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
impl JsAnyPropertyModifier {
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            JsAnyPropertyModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            JsAnyPropertyModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            JsAnyPropertyModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_readonly_modifier(&self) -> Option<&TsReadonlyModifier> {
        match &self {
            JsAnyPropertyModifier::TsReadonlyModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyRoot {
    JsExpressionSnipped(JsExpressionSnipped),
    JsModule(JsModule),
    JsScript(JsScript),
}
impl JsAnyRoot {
    pub fn as_js_expression_snipped(&self) -> Option<&JsExpressionSnipped> {
        match &self {
            JsAnyRoot::JsExpressionSnipped(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_module(&self) -> Option<&JsModule> {
        match &self {
            JsAnyRoot::JsModule(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_script(&self) -> Option<&JsScript> {
        match &self {
            JsAnyRoot::JsScript(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyStatement {
    JsBlockStatement(JsBlockStatement),
    JsBreakStatement(JsBreakStatement),
    JsClassDeclaration(JsClassDeclaration),
    JsContinueStatement(JsContinueStatement),
    JsDebuggerStatement(JsDebuggerStatement),
    JsDoWhileStatement(JsDoWhileStatement),
    JsEmptyStatement(JsEmptyStatement),
    JsExpressionStatement(JsExpressionStatement),
    JsForInStatement(JsForInStatement),
    JsForOfStatement(JsForOfStatement),
    JsForStatement(JsForStatement),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsIfStatement(JsIfStatement),
    JsLabeledStatement(JsLabeledStatement),
    JsReturnStatement(JsReturnStatement),
    JsSwitchStatement(JsSwitchStatement),
    JsThrowStatement(JsThrowStatement),
    JsTryFinallyStatement(JsTryFinallyStatement),
    JsTryStatement(JsTryStatement),
    JsUnknownStatement(JsUnknownStatement),
    JsVariableStatement(JsVariableStatement),
    JsWhileStatement(JsWhileStatement),
    JsWithStatement(JsWithStatement),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsDeclareStatement(TsDeclareStatement),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
impl JsAnyStatement {
    pub fn as_js_block_statement(&self) -> Option<&JsBlockStatement> {
        match &self {
            JsAnyStatement::JsBlockStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_break_statement(&self) -> Option<&JsBreakStatement> {
        match &self {
            JsAnyStatement::JsBreakStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_class_declaration(&self) -> Option<&JsClassDeclaration> {
        match &self {
            JsAnyStatement::JsClassDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_continue_statement(&self) -> Option<&JsContinueStatement> {
        match &self {
            JsAnyStatement::JsContinueStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_debugger_statement(&self) -> Option<&JsDebuggerStatement> {
        match &self {
            JsAnyStatement::JsDebuggerStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_do_while_statement(&self) -> Option<&JsDoWhileStatement> {
        match &self {
            JsAnyStatement::JsDoWhileStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_empty_statement(&self) -> Option<&JsEmptyStatement> {
        match &self {
            JsAnyStatement::JsEmptyStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_expression_statement(&self) -> Option<&JsExpressionStatement> {
        match &self {
            JsAnyStatement::JsExpressionStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_for_in_statement(&self) -> Option<&JsForInStatement> {
        match &self {
            JsAnyStatement::JsForInStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_for_of_statement(&self) -> Option<&JsForOfStatement> {
        match &self {
            JsAnyStatement::JsForOfStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_for_statement(&self) -> Option<&JsForStatement> {
        match &self {
            JsAnyStatement::JsForStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_declaration(&self) -> Option<&JsFunctionDeclaration> {
        match &self {
            JsAnyStatement::JsFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_if_statement(&self) -> Option<&JsIfStatement> {
        match &self {
            JsAnyStatement::JsIfStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_labeled_statement(&self) -> Option<&JsLabeledStatement> {
        match &self {
            JsAnyStatement::JsLabeledStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_return_statement(&self) -> Option<&JsReturnStatement> {
        match &self {
            JsAnyStatement::JsReturnStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_switch_statement(&self) -> Option<&JsSwitchStatement> {
        match &self {
            JsAnyStatement::JsSwitchStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_throw_statement(&self) -> Option<&JsThrowStatement> {
        match &self {
            JsAnyStatement::JsThrowStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_try_finally_statement(&self) -> Option<&JsTryFinallyStatement> {
        match &self {
            JsAnyStatement::JsTryFinallyStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_try_statement(&self) -> Option<&JsTryStatement> {
        match &self {
            JsAnyStatement::JsTryStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unknown_statement(&self) -> Option<&JsUnknownStatement> {
        match &self {
            JsAnyStatement::JsUnknownStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_variable_statement(&self) -> Option<&JsVariableStatement> {
        match &self {
            JsAnyStatement::JsVariableStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_while_statement(&self) -> Option<&JsWhileStatement> {
        match &self {
            JsAnyStatement::JsWhileStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_with_statement(&self) -> Option<&JsWithStatement> {
        match &self {
            JsAnyStatement::JsWithStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_function_declaration(&self) -> Option<&TsDeclareFunctionDeclaration> {
        match &self {
            JsAnyStatement::TsDeclareFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_statement(&self) -> Option<&TsDeclareStatement> {
        match &self {
            JsAnyStatement::TsDeclareStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_enum_declaration(&self) -> Option<&TsEnumDeclaration> {
        match &self {
            JsAnyStatement::TsEnumDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_external_module_declaration(&self) -> Option<&TsExternalModuleDeclaration> {
        match &self {
            JsAnyStatement::TsExternalModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_global_declaration(&self) -> Option<&TsGlobalDeclaration> {
        match &self {
            JsAnyStatement::TsGlobalDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_import_equals_declaration(&self) -> Option<&TsImportEqualsDeclaration> {
        match &self {
            JsAnyStatement::TsImportEqualsDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_interface_declaration(&self) -> Option<&TsInterfaceDeclaration> {
        match &self {
            JsAnyStatement::TsInterfaceDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_module_declaration(&self) -> Option<&TsModuleDeclaration> {
        match &self {
            JsAnyStatement::TsModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_alias_declaration(&self) -> Option<&TsTypeAliasDeclaration> {
        match &self {
            JsAnyStatement::TsTypeAliasDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnySwitchClause {
    JsCaseClause(JsCaseClause),
    JsDefaultClause(JsDefaultClause),
}
impl JsAnySwitchClause {
    pub fn as_js_case_clause(&self) -> Option<&JsCaseClause> {
        match &self {
            JsAnySwitchClause::JsCaseClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_default_clause(&self) -> Option<&JsDefaultClause> {
        match &self {
            JsAnySwitchClause::JsDefaultClause(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsAnyTemplateElement {
    JsTemplateChunkElement(JsTemplateChunkElement),
    JsTemplateElement(JsTemplateElement),
}
impl JsAnyTemplateElement {
    pub fn as_js_template_chunk_element(&self) -> Option<&JsTemplateChunkElement> {
        match &self {
            JsAnyTemplateElement::JsTemplateChunkElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_template_element(&self) -> Option<&JsTemplateElement> {
        match &self {
            JsAnyTemplateElement::JsTemplateElement(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsxAnyAttribute {
    JsxAttribute(JsxAttribute),
    JsxSpreadAttribute(JsxSpreadAttribute),
}
impl JsxAnyAttribute {
    pub fn as_jsx_attribute(&self) -> Option<&JsxAttribute> {
        match &self {
            JsxAnyAttribute::JsxAttribute(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_spread_attribute(&self) -> Option<&JsxSpreadAttribute> {
        match &self {
            JsxAnyAttribute::JsxSpreadAttribute(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsxAnyAttributeName {
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
}
impl JsxAnyAttributeName {
    pub fn as_jsx_name(&self) -> Option<&JsxName> {
        match &self {
            JsxAnyAttributeName::JsxName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_namespace_name(&self) -> Option<&JsxNamespaceName> {
        match &self {
            JsxAnyAttributeName::JsxNamespaceName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsxAnyAttributeValue {
    JsxAnyTag(JsxAnyTag),
    JsxExpressionAttributeValue(JsxExpressionAttributeValue),
    JsxString(JsxString),
}
impl JsxAnyAttributeValue {
    pub fn as_jsx_any_tag(&self) -> Option<&JsxAnyTag> {
        match &self {
            JsxAnyAttributeValue::JsxAnyTag(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_expression_attribute_value(&self) -> Option<&JsxExpressionAttributeValue> {
        match &self {
            JsxAnyAttributeValue::JsxExpressionAttributeValue(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_string(&self) -> Option<&JsxString> {
        match &self {
            JsxAnyAttributeValue::JsxString(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsxAnyChild {
    JsxElement(JsxElement),
    JsxExpressionChild(JsxExpressionChild),
    JsxFragment(JsxFragment),
    JsxSelfClosingElement(JsxSelfClosingElement),
    JsxSpreadChild(JsxSpreadChild),
    JsxText(JsxText),
}
impl JsxAnyChild {
    pub fn as_jsx_element(&self) -> Option<&JsxElement> {
        match &self {
            JsxAnyChild::JsxElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_expression_child(&self) -> Option<&JsxExpressionChild> {
        match &self {
            JsxAnyChild::JsxExpressionChild(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_fragment(&self) -> Option<&JsxFragment> {
        match &self {
            JsxAnyChild::JsxFragment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_self_closing_element(&self) -> Option<&JsxSelfClosingElement> {
        match &self {
            JsxAnyChild::JsxSelfClosingElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_spread_child(&self) -> Option<&JsxSpreadChild> {
        match &self {
            JsxAnyChild::JsxSpreadChild(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_text(&self) -> Option<&JsxText> {
        match &self {
            JsxAnyChild::JsxText(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsxAnyElementName {
    JsxMemberName(JsxMemberName),
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
    JsxReferenceIdentifier(JsxReferenceIdentifier),
}
impl JsxAnyElementName {
    pub fn as_jsx_member_name(&self) -> Option<&JsxMemberName> {
        match &self {
            JsxAnyElementName::JsxMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_name(&self) -> Option<&JsxName> {
        match &self {
            JsxAnyElementName::JsxName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_namespace_name(&self) -> Option<&JsxNamespaceName> {
        match &self {
            JsxAnyElementName::JsxNamespaceName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_reference_identifier(&self) -> Option<&JsxReferenceIdentifier> {
        match &self {
            JsxAnyElementName::JsxReferenceIdentifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsxAnyName {
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
}
impl JsxAnyName {
    pub fn as_jsx_name(&self) -> Option<&JsxName> {
        match &self {
            JsxAnyName::JsxName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_namespace_name(&self) -> Option<&JsxNamespaceName> {
        match &self {
            JsxAnyName::JsxNamespaceName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsxAnyObjectName {
    JsxMemberName(JsxMemberName),
    JsxNamespaceName(JsxNamespaceName),
    JsxReferenceIdentifier(JsxReferenceIdentifier),
}
impl JsxAnyObjectName {
    pub fn as_jsx_member_name(&self) -> Option<&JsxMemberName> {
        match &self {
            JsxAnyObjectName::JsxMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_namespace_name(&self) -> Option<&JsxNamespaceName> {
        match &self {
            JsxAnyObjectName::JsxNamespaceName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_reference_identifier(&self) -> Option<&JsxReferenceIdentifier> {
        match &self {
            JsxAnyObjectName::JsxReferenceIdentifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum JsxAnyTag {
    JsxElement(JsxElement),
    JsxFragment(JsxFragment),
    JsxSelfClosingElement(JsxSelfClosingElement),
}
impl JsxAnyTag {
    pub fn as_jsx_element(&self) -> Option<&JsxElement> {
        match &self {
            JsxAnyTag::JsxElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_fragment(&self) -> Option<&JsxFragment> {
        match &self {
            JsxAnyTag::JsxFragment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_self_closing_element(&self) -> Option<&JsxSelfClosingElement> {
        match &self {
            JsxAnyTag::JsxSelfClosingElement(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyExternalModuleDeclarationBody {
    TsEmptyExternalModuleDeclarationBody(TsEmptyExternalModuleDeclarationBody),
    TsModuleBlock(TsModuleBlock),
}
impl TsAnyExternalModuleDeclarationBody {
    pub fn as_ts_empty_external_module_declaration_body(
        &self,
    ) -> Option<&TsEmptyExternalModuleDeclarationBody> {
        match &self {
            TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(item) => {
                Some(item)
            }
            _ => None,
        }
    }
    pub fn as_ts_module_block(&self) -> Option<&TsModuleBlock> {
        match &self {
            TsAnyExternalModuleDeclarationBody::TsModuleBlock(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyIndexSignatureModifier {
    JsStaticModifier(JsStaticModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
impl TsAnyIndexSignatureModifier {
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            TsAnyIndexSignatureModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_readonly_modifier(&self) -> Option<&TsReadonlyModifier> {
        match &self {
            TsAnyIndexSignatureModifier::TsReadonlyModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyMethodSignatureModifier {
    JsStaticModifier(JsStaticModifier),
    TsAbstractModifier(TsAbstractModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
}
impl TsAnyMethodSignatureModifier {
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            TsAnyMethodSignatureModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_abstract_modifier(&self) -> Option<&TsAbstractModifier> {
        match &self {
            TsAnyMethodSignatureModifier::TsAbstractModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            TsAnyMethodSignatureModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            TsAnyMethodSignatureModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyModuleName {
    TsIdentifierBinding(TsIdentifierBinding),
    TsQualifiedModuleName(TsQualifiedModuleName),
}
impl TsAnyModuleName {
    pub fn as_ts_identifier_binding(&self) -> Option<&TsIdentifierBinding> {
        match &self {
            TsAnyModuleName::TsIdentifierBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_qualified_module_name(&self) -> Option<&TsQualifiedModuleName> {
        match &self {
            TsAnyModuleName::TsQualifiedModuleName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyModuleReference {
    TsAnyName(TsAnyName),
    TsExternalModuleReference(TsExternalModuleReference),
}
impl TsAnyModuleReference {
    pub fn as_ts_any_name(&self) -> Option<&TsAnyName> {
        match &self {
            TsAnyModuleReference::TsAnyName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_external_module_reference(&self) -> Option<&TsExternalModuleReference> {
        match &self {
            TsAnyModuleReference::TsExternalModuleReference(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyName {
    JsReferenceIdentifier(JsReferenceIdentifier),
    TsQualifiedName(TsQualifiedName),
}
impl TsAnyName {
    pub fn as_js_reference_identifier(&self) -> Option<&JsReferenceIdentifier> {
        match &self {
            TsAnyName::JsReferenceIdentifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_qualified_name(&self) -> Option<&TsQualifiedName> {
        match &self {
            TsAnyName::TsQualifiedName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyPropertyAnnotation {
    TsDefinitePropertyAnnotation(TsDefinitePropertyAnnotation),
    TsOptionalPropertyAnnotation(TsOptionalPropertyAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
impl TsAnyPropertyAnnotation {
    pub fn as_ts_definite_property_annotation(&self) -> Option<&TsDefinitePropertyAnnotation> {
        match &self {
            TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_optional_property_annotation(&self) -> Option<&TsOptionalPropertyAnnotation> {
        match &self {
            TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_annotation(&self) -> Option<&TsTypeAnnotation> {
        match &self {
            TsAnyPropertyAnnotation::TsTypeAnnotation(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyPropertyParameterModifier {
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
impl TsAnyPropertyParameterModifier {
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            TsAnyPropertyParameterModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            TsAnyPropertyParameterModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_readonly_modifier(&self) -> Option<&TsReadonlyModifier> {
        match &self {
            TsAnyPropertyParameterModifier::TsReadonlyModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyPropertySignatureAnnotation {
    TsOptionalPropertyAnnotation(TsOptionalPropertyAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
impl TsAnyPropertySignatureAnnotation {
    pub fn as_ts_optional_property_annotation(&self) -> Option<&TsOptionalPropertyAnnotation> {
        match &self {
            TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_annotation(&self) -> Option<&TsTypeAnnotation> {
        match &self {
            TsAnyPropertySignatureAnnotation::TsTypeAnnotation(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyPropertySignatureModifier {
    JsStaticModifier(JsStaticModifier),
    TsAbstractModifier(TsAbstractModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsDeclareModifier(TsDeclareModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
impl TsAnyPropertySignatureModifier {
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            TsAnyPropertySignatureModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_abstract_modifier(&self) -> Option<&TsAbstractModifier> {
        match &self {
            TsAnyPropertySignatureModifier::TsAbstractModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            TsAnyPropertySignatureModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_modifier(&self) -> Option<&TsDeclareModifier> {
        match &self {
            TsAnyPropertySignatureModifier::TsDeclareModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            TsAnyPropertySignatureModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_readonly_modifier(&self) -> Option<&TsReadonlyModifier> {
        match &self {
            TsAnyPropertySignatureModifier::TsReadonlyModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyReturnType {
    TsAssertsReturnType(TsAssertsReturnType),
    TsPredicateReturnType(TsPredicateReturnType),
    TsType(TsType),
}
impl TsAnyReturnType {
    pub fn as_ts_asserts_return_type(&self) -> Option<&TsAssertsReturnType> {
        match &self {
            TsAnyReturnType::TsAssertsReturnType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_predicate_return_type(&self) -> Option<&TsPredicateReturnType> {
        match &self {
            TsAnyReturnType::TsPredicateReturnType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type(&self) -> Option<&TsType> {
        match &self {
            TsAnyReturnType::TsType(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyTemplateElement {
    TsTemplateChunkElement(TsTemplateChunkElement),
    TsTemplateElement(TsTemplateElement),
}
impl TsAnyTemplateElement {
    pub fn as_ts_template_chunk_element(&self) -> Option<&TsTemplateChunkElement> {
        match &self {
            TsAnyTemplateElement::TsTemplateChunkElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_template_element(&self) -> Option<&TsTemplateElement> {
        match &self {
            TsAnyTemplateElement::TsTemplateElement(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyTupleTypeElement {
    TsNamedTupleTypeElement(TsNamedTupleTypeElement),
    TsOptionalTupleTypeElement(TsOptionalTupleTypeElement),
    TsRestTupleTypeElement(TsRestTupleTypeElement),
    TsType(TsType),
}
impl TsAnyTupleTypeElement {
    pub fn as_ts_named_tuple_type_element(&self) -> Option<&TsNamedTupleTypeElement> {
        match &self {
            TsAnyTupleTypeElement::TsNamedTupleTypeElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_optional_tuple_type_element(&self) -> Option<&TsOptionalTupleTypeElement> {
        match &self {
            TsAnyTupleTypeElement::TsOptionalTupleTypeElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_rest_tuple_type_element(&self) -> Option<&TsRestTupleTypeElement> {
        match &self {
            TsAnyTupleTypeElement::TsRestTupleTypeElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type(&self) -> Option<&TsType> {
        match &self {
            TsAnyTupleTypeElement::TsType(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyTypeMember {
    JsUnknownMember(JsUnknownMember),
    TsCallSignatureTypeMember(TsCallSignatureTypeMember),
    TsConstructSignatureTypeMember(TsConstructSignatureTypeMember),
    TsGetterSignatureTypeMember(TsGetterSignatureTypeMember),
    TsIndexSignatureTypeMember(TsIndexSignatureTypeMember),
    TsMethodSignatureTypeMember(TsMethodSignatureTypeMember),
    TsPropertySignatureTypeMember(TsPropertySignatureTypeMember),
    TsSetterSignatureTypeMember(TsSetterSignatureTypeMember),
}
impl TsAnyTypeMember {
    pub fn as_js_unknown_member(&self) -> Option<&JsUnknownMember> {
        match &self {
            TsAnyTypeMember::JsUnknownMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_call_signature_type_member(&self) -> Option<&TsCallSignatureTypeMember> {
        match &self {
            TsAnyTypeMember::TsCallSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_construct_signature_type_member(&self) -> Option<&TsConstructSignatureTypeMember> {
        match &self {
            TsAnyTypeMember::TsConstructSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_getter_signature_type_member(&self) -> Option<&TsGetterSignatureTypeMember> {
        match &self {
            TsAnyTypeMember::TsGetterSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_index_signature_type_member(&self) -> Option<&TsIndexSignatureTypeMember> {
        match &self {
            TsAnyTypeMember::TsIndexSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_method_signature_type_member(&self) -> Option<&TsMethodSignatureTypeMember> {
        match &self {
            TsAnyTypeMember::TsMethodSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_property_signature_type_member(&self) -> Option<&TsPropertySignatureTypeMember> {
        match &self {
            TsAnyTypeMember::TsPropertySignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_setter_signature_type_member(&self) -> Option<&TsSetterSignatureTypeMember> {
        match &self {
            TsAnyTypeMember::TsSetterSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyTypePredicateParameterName {
    JsReferenceIdentifier(JsReferenceIdentifier),
    TsThisType(TsThisType),
}
impl TsAnyTypePredicateParameterName {
    pub fn as_js_reference_identifier(&self) -> Option<&JsReferenceIdentifier> {
        match &self {
            TsAnyTypePredicateParameterName::JsReferenceIdentifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_this_type(&self) -> Option<&TsThisType> {
        match &self {
            TsAnyTypePredicateParameterName::TsThisType(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsAnyVariableAnnotation {
    TsDefiniteVariableAnnotation(TsDefiniteVariableAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
impl TsAnyVariableAnnotation {
    pub fn as_ts_definite_variable_annotation(&self) -> Option<&TsDefiniteVariableAnnotation> {
        match &self {
            TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_annotation(&self) -> Option<&TsTypeAnnotation> {
        match &self {
            TsAnyVariableAnnotation::TsTypeAnnotation(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub enum TsType {
    TsAnyType(TsAnyType),
    TsArrayType(TsArrayType),
    TsBigIntLiteralType(TsBigIntLiteralType),
    TsBigintType(TsBigintType),
    TsBooleanLiteralType(TsBooleanLiteralType),
    TsBooleanType(TsBooleanType),
    TsConditionalType(TsConditionalType),
    TsConstructorType(TsConstructorType),
    TsFunctionType(TsFunctionType),
    TsImportType(TsImportType),
    TsIndexedAccessType(TsIndexedAccessType),
    TsInferType(TsInferType),
    TsIntersectionType(TsIntersectionType),
    TsMappedType(TsMappedType),
    TsNeverType(TsNeverType),
    TsNonPrimitiveType(TsNonPrimitiveType),
    TsNullLiteralType(TsNullLiteralType),
    TsNumberLiteralType(TsNumberLiteralType),
    TsNumberType(TsNumberType),
    TsObjectType(TsObjectType),
    TsParenthesizedType(TsParenthesizedType),
    TsReferenceType(TsReferenceType),
    TsStringLiteralType(TsStringLiteralType),
    TsStringType(TsStringType),
    TsSymbolType(TsSymbolType),
    TsTemplateLiteralType(TsTemplateLiteralType),
    TsThisType(TsThisType),
    TsTupleType(TsTupleType),
    TsTypeOperatorType(TsTypeOperatorType),
    TsTypeofType(TsTypeofType),
    TsUndefinedType(TsUndefinedType),
    TsUnionType(TsUnionType),
    TsUnknownType(TsUnknownType),
    TsVoidType(TsVoidType),
}
impl TsType {
    pub fn as_ts_any_type(&self) -> Option<&TsAnyType> {
        match &self {
            TsType::TsAnyType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_array_type(&self) -> Option<&TsArrayType> {
        match &self {
            TsType::TsArrayType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_big_int_literal_type(&self) -> Option<&TsBigIntLiteralType> {
        match &self {
            TsType::TsBigIntLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_bigint_type(&self) -> Option<&TsBigintType> {
        match &self {
            TsType::TsBigintType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_boolean_literal_type(&self) -> Option<&TsBooleanLiteralType> {
        match &self {
            TsType::TsBooleanLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_boolean_type(&self) -> Option<&TsBooleanType> {
        match &self {
            TsType::TsBooleanType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_conditional_type(&self) -> Option<&TsConditionalType> {
        match &self {
            TsType::TsConditionalType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_constructor_type(&self) -> Option<&TsConstructorType> {
        match &self {
            TsType::TsConstructorType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_function_type(&self) -> Option<&TsFunctionType> {
        match &self {
            TsType::TsFunctionType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_import_type(&self) -> Option<&TsImportType> {
        match &self {
            TsType::TsImportType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_indexed_access_type(&self) -> Option<&TsIndexedAccessType> {
        match &self {
            TsType::TsIndexedAccessType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_infer_type(&self) -> Option<&TsInferType> {
        match &self {
            TsType::TsInferType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_intersection_type(&self) -> Option<&TsIntersectionType> {
        match &self {
            TsType::TsIntersectionType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_mapped_type(&self) -> Option<&TsMappedType> {
        match &self {
            TsType::TsMappedType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_never_type(&self) -> Option<&TsNeverType> {
        match &self {
            TsType::TsNeverType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_non_primitive_type(&self) -> Option<&TsNonPrimitiveType> {
        match &self {
            TsType::TsNonPrimitiveType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_null_literal_type(&self) -> Option<&TsNullLiteralType> {
        match &self {
            TsType::TsNullLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_number_literal_type(&self) -> Option<&TsNumberLiteralType> {
        match &self {
            TsType::TsNumberLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_number_type(&self) -> Option<&TsNumberType> {
        match &self {
            TsType::TsNumberType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_object_type(&self) -> Option<&TsObjectType> {
        match &self {
            TsType::TsObjectType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_parenthesized_type(&self) -> Option<&TsParenthesizedType> {
        match &self {
            TsType::TsParenthesizedType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_reference_type(&self) -> Option<&TsReferenceType> {
        match &self {
            TsType::TsReferenceType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_string_literal_type(&self) -> Option<&TsStringLiteralType> {
        match &self {
            TsType::TsStringLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_string_type(&self) -> Option<&TsStringType> {
        match &self {
            TsType::TsStringType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_symbol_type(&self) -> Option<&TsSymbolType> {
        match &self {
            TsType::TsSymbolType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_template_literal_type(&self) -> Option<&TsTemplateLiteralType> {
        match &self {
            TsType::TsTemplateLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_this_type(&self) -> Option<&TsThisType> {
        match &self {
            TsType::TsThisType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_tuple_type(&self) -> Option<&TsTupleType> {
        match &self {
            TsType::TsTupleType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_operator_type(&self) -> Option<&TsTypeOperatorType> {
        match &self {
            TsType::TsTypeOperatorType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_typeof_type(&self) -> Option<&TsTypeofType> {
        match &self {
            TsType::TsTypeofType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_undefined_type(&self) -> Option<&TsUndefinedType> {
        match &self {
            TsType::TsUndefinedType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_union_type(&self) -> Option<&TsUnionType> {
        match &self {
            TsType::TsUnionType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_unknown_type(&self) -> Option<&TsUnknownType> {
        match &self {
            TsType::TsUnknownType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_void_type(&self) -> Option<&TsVoidType> {
        match &self {
            TsType::TsVoidType(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for ImportMeta {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPORT_META }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for ImportMeta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ImportMeta")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("meta_token", &support::DebugSyntaxResult(self.meta_token()))
            .finish()
    }
}
impl From<ImportMeta> for SyntaxNode {
    fn from(n: ImportMeta) -> SyntaxNode { n.syntax }
}
impl From<ImportMeta> for SyntaxElement {
    fn from(n: ImportMeta) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayAssignmentPattern {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_ASSIGNMENT_PATTERN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayAssignmentPattern")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayAssignmentPattern> for SyntaxNode {
    fn from(n: JsArrayAssignmentPattern) -> SyntaxNode { n.syntax }
}
impl From<JsArrayAssignmentPattern> for SyntaxElement {
    fn from(n: JsArrayAssignmentPattern) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayAssignmentPatternRestElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayAssignmentPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayAssignmentPatternRestElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .finish()
    }
}
impl From<JsArrayAssignmentPatternRestElement> for SyntaxNode {
    fn from(n: JsArrayAssignmentPatternRestElement) -> SyntaxNode { n.syntax }
}
impl From<JsArrayAssignmentPatternRestElement> for SyntaxElement {
    fn from(n: JsArrayAssignmentPatternRestElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayBindingPattern {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_BINDING_PATTERN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayBindingPattern")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayBindingPattern> for SyntaxNode {
    fn from(n: JsArrayBindingPattern) -> SyntaxNode { n.syntax }
}
impl From<JsArrayBindingPattern> for SyntaxElement {
    fn from(n: JsArrayBindingPattern) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayBindingPatternRestElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_BINDING_PATTERN_REST_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayBindingPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayBindingPatternRestElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .finish()
    }
}
impl From<JsArrayBindingPatternRestElement> for SyntaxNode {
    fn from(n: JsArrayBindingPatternRestElement) -> SyntaxNode { n.syntax }
}
impl From<JsArrayBindingPatternRestElement> for SyntaxElement {
    fn from(n: JsArrayBindingPatternRestElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayExpression")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayExpression> for SyntaxNode {
    fn from(n: JsArrayExpression) -> SyntaxNode { n.syntax }
}
impl From<JsArrayExpression> for SyntaxElement {
    fn from(n: JsArrayExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayHole {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_HOLE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayHole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayHole").finish()
    }
}
impl From<JsArrayHole> for SyntaxNode {
    fn from(n: JsArrayHole) -> SyntaxNode { n.syntax }
}
impl From<JsArrayHole> for SyntaxElement {
    fn from(n: JsArrayHole) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrowFunctionExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARROW_FUNCTION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrowFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrowFunctionExpression")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsArrowFunctionExpression> for SyntaxNode {
    fn from(n: JsArrowFunctionExpression) -> SyntaxNode { n.syntax }
}
impl From<JsArrowFunctionExpression> for SyntaxElement {
    fn from(n: JsArrowFunctionExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsAssignmentExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ASSIGNMENT_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsAssignmentExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAssignmentExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsAssignmentExpression> for SyntaxNode {
    fn from(n: JsAssignmentExpression) -> SyntaxNode { n.syntax }
}
impl From<JsAssignmentExpression> for SyntaxElement {
    fn from(n: JsAssignmentExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsAssignmentWithDefault {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ASSIGNMENT_WITH_DEFAULT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsAssignmentWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAssignmentWithDefault")
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("default", &support::DebugSyntaxResult(self.default()))
            .finish()
    }
}
impl From<JsAssignmentWithDefault> for SyntaxNode {
    fn from(n: JsAssignmentWithDefault) -> SyntaxNode { n.syntax }
}
impl From<JsAssignmentWithDefault> for SyntaxElement {
    fn from(n: JsAssignmentWithDefault) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsAwaitExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_AWAIT_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsAwaitExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAwaitExpression")
            .field(
                "await_token",
                &support::DebugSyntaxResult(self.await_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsAwaitExpression> for SyntaxNode {
    fn from(n: JsAwaitExpression) -> SyntaxNode { n.syntax }
}
impl From<JsAwaitExpression> for SyntaxElement {
    fn from(n: JsAwaitExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBigIntLiteralExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BIG_INT_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBigIntLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBigIntLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsBigIntLiteralExpression> for SyntaxNode {
    fn from(n: JsBigIntLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsBigIntLiteralExpression> for SyntaxElement {
    fn from(n: JsBigIntLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBinaryExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BINARY_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBinaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBinaryExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsBinaryExpression> for SyntaxNode {
    fn from(n: JsBinaryExpression) -> SyntaxNode { n.syntax }
}
impl From<JsBinaryExpression> for SyntaxElement {
    fn from(n: JsBinaryExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBindingPatternWithDefault {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BINDING_PATTERN_WITH_DEFAULT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBindingPatternWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBindingPatternWithDefault")
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("default", &support::DebugSyntaxResult(self.default()))
            .finish()
    }
}
impl From<JsBindingPatternWithDefault> for SyntaxNode {
    fn from(n: JsBindingPatternWithDefault) -> SyntaxNode { n.syntax }
}
impl From<JsBindingPatternWithDefault> for SyntaxElement {
    fn from(n: JsBindingPatternWithDefault) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBlockStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BLOCK_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBlockStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBlockStatement")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsBlockStatement> for SyntaxNode {
    fn from(n: JsBlockStatement) -> SyntaxNode { n.syntax }
}
impl From<JsBlockStatement> for SyntaxElement {
    fn from(n: JsBlockStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBooleanLiteralExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOOLEAN_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBooleanLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBooleanLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsBooleanLiteralExpression> for SyntaxNode {
    fn from(n: JsBooleanLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsBooleanLiteralExpression> for SyntaxElement {
    fn from(n: JsBooleanLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBreakStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BREAK_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBreakStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBreakStatement")
            .field(
                "break_token",
                &support::DebugSyntaxResult(self.break_token()),
            )
            .field(
                "label_token",
                &support::DebugOptionalElement(self.label_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsBreakStatement> for SyntaxNode {
    fn from(n: JsBreakStatement) -> SyntaxNode { n.syntax }
}
impl From<JsBreakStatement> for SyntaxElement {
    fn from(n: JsBreakStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCallArguments {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CALL_ARGUMENTS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCallArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCallArguments")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("args", &self.args())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsCallArguments> for SyntaxNode {
    fn from(n: JsCallArguments) -> SyntaxNode { n.syntax }
}
impl From<JsCallArguments> for SyntaxElement {
    fn from(n: JsCallArguments) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCallExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CALL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCallExpression")
            .field("callee", &support::DebugSyntaxResult(self.callee()))
            .field(
                "optional_chain_token",
                &support::DebugOptionalElement(self.optional_chain_token()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("arguments", &support::DebugSyntaxResult(self.arguments()))
            .finish()
    }
}
impl From<JsCallExpression> for SyntaxNode {
    fn from(n: JsCallExpression) -> SyntaxNode { n.syntax }
}
impl From<JsCallExpression> for SyntaxElement {
    fn from(n: JsCallExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCaseClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CASE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCaseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCaseClause")
            .field("case_token", &support::DebugSyntaxResult(self.case_token()))
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("consequent", &self.consequent())
            .finish()
    }
}
impl From<JsCaseClause> for SyntaxNode {
    fn from(n: JsCaseClause) -> SyntaxNode { n.syntax }
}
impl From<JsCaseClause> for SyntaxElement {
    fn from(n: JsCaseClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCatchClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CATCH_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCatchClause")
            .field(
                "catch_token",
                &support::DebugSyntaxResult(self.catch_token()),
            )
            .field(
                "declaration",
                &support::DebugOptionalElement(self.declaration()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsCatchClause> for SyntaxNode {
    fn from(n: JsCatchClause) -> SyntaxNode { n.syntax }
}
impl From<JsCatchClause> for SyntaxElement {
    fn from(n: JsCatchClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCatchDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CATCH_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCatchDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCatchDeclaration")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsCatchDeclaration> for SyntaxNode {
    fn from(n: JsCatchDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsCatchDeclaration> for SyntaxElement {
    fn from(n: JsCatchDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsClassDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CLASS_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsClassDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassDeclaration")
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassDeclaration> for SyntaxNode {
    fn from(n: JsClassDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsClassDeclaration> for SyntaxElement {
    fn from(n: JsClassDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsClassExportDefaultDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CLASS_EXPORT_DEFAULT_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsClassExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassExportDefaultDeclaration")
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassExportDefaultDeclaration> for SyntaxNode {
    fn from(n: JsClassExportDefaultDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsClassExportDefaultDeclaration> for SyntaxElement {
    fn from(n: JsClassExportDefaultDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsClassExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CLASS_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsClassExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassExpression")
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassExpression> for SyntaxNode {
    fn from(n: JsClassExpression) -> SyntaxNode { n.syntax }
}
impl From<JsClassExpression> for SyntaxElement {
    fn from(n: JsClassExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsComputedMemberAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_COMPUTED_MEMBER_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsComputedMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberAssignment")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberAssignment> for SyntaxNode {
    fn from(n: JsComputedMemberAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsComputedMemberAssignment> for SyntaxElement {
    fn from(n: JsComputedMemberAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsComputedMemberExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_COMPUTED_MEMBER_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsComputedMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberExpression")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "optional_chain_token",
                &support::DebugOptionalElement(self.optional_chain_token()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberExpression> for SyntaxNode {
    fn from(n: JsComputedMemberExpression) -> SyntaxNode { n.syntax }
}
impl From<JsComputedMemberExpression> for SyntaxElement {
    fn from(n: JsComputedMemberExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsComputedMemberName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_COMPUTED_MEMBER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsComputedMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberName")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberName> for SyntaxNode {
    fn from(n: JsComputedMemberName) -> SyntaxNode { n.syntax }
}
impl From<JsComputedMemberName> for SyntaxElement {
    fn from(n: JsComputedMemberName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsConditionalExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONDITIONAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsConditionalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConditionalExpression")
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field("consequent", &support::DebugSyntaxResult(self.consequent()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("alternate", &support::DebugSyntaxResult(self.alternate()))
            .finish()
    }
}
impl From<JsConditionalExpression> for SyntaxNode {
    fn from(n: JsConditionalExpression) -> SyntaxNode { n.syntax }
}
impl From<JsConditionalExpression> for SyntaxElement {
    fn from(n: JsConditionalExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsConstructorClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONSTRUCTOR_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsConstructorClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConstructorClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsConstructorClassMember> for SyntaxNode {
    fn from(n: JsConstructorClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsConstructorClassMember> for SyntaxElement {
    fn from(n: JsConstructorClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsConstructorParameters {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONSTRUCTOR_PARAMETERS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsConstructorParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConstructorParameters")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameters", &self.parameters())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsConstructorParameters> for SyntaxNode {
    fn from(n: JsConstructorParameters) -> SyntaxNode { n.syntax }
}
impl From<JsConstructorParameters> for SyntaxElement {
    fn from(n: JsConstructorParameters) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsContinueStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONTINUE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsContinueStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsContinueStatement")
            .field(
                "continue_token",
                &support::DebugSyntaxResult(self.continue_token()),
            )
            .field(
                "label_token",
                &support::DebugOptionalElement(self.label_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsContinueStatement> for SyntaxNode {
    fn from(n: JsContinueStatement) -> SyntaxNode { n.syntax }
}
impl From<JsContinueStatement> for SyntaxElement {
    fn from(n: JsContinueStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDebuggerStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DEBUGGER_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDebuggerStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDebuggerStatement")
            .field(
                "debugger_token",
                &support::DebugSyntaxResult(self.debugger_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDebuggerStatement> for SyntaxNode {
    fn from(n: JsDebuggerStatement) -> SyntaxNode { n.syntax }
}
impl From<JsDebuggerStatement> for SyntaxElement {
    fn from(n: JsDebuggerStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDefaultClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DEFAULT_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDefaultClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("consequent", &self.consequent())
            .finish()
    }
}
impl From<JsDefaultClause> for SyntaxNode {
    fn from(n: JsDefaultClause) -> SyntaxNode { n.syntax }
}
impl From<JsDefaultClause> for SyntaxElement {
    fn from(n: JsDefaultClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDefaultImportSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DEFAULT_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDefaultImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDefaultImportSpecifier")
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field(
                "trailing_comma_token",
                &support::DebugSyntaxResult(self.trailing_comma_token()),
            )
            .finish()
    }
}
impl From<JsDefaultImportSpecifier> for SyntaxNode {
    fn from(n: JsDefaultImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsDefaultImportSpecifier> for SyntaxElement {
    fn from(n: JsDefaultImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDirective {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DIRECTIVE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDirective")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDirective> for SyntaxNode {
    fn from(n: JsDirective) -> SyntaxNode { n.syntax }
}
impl From<JsDirective> for SyntaxElement {
    fn from(n: JsDirective) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDoWhileStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DO_WHILE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDoWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDoWhileStatement")
            .field("do_token", &support::DebugSyntaxResult(self.do_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "while_token",
                &support::DebugSyntaxResult(self.while_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDoWhileStatement> for SyntaxNode {
    fn from(n: JsDoWhileStatement) -> SyntaxNode { n.syntax }
}
impl From<JsDoWhileStatement> for SyntaxElement {
    fn from(n: JsDoWhileStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsElseClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ELSE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsElseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsElseClause")
            .field("else_token", &support::DebugSyntaxResult(self.else_token()))
            .field("alternate", &support::DebugSyntaxResult(self.alternate()))
            .finish()
    }
}
impl From<JsElseClause> for SyntaxNode {
    fn from(n: JsElseClause) -> SyntaxNode { n.syntax }
}
impl From<JsElseClause> for SyntaxElement {
    fn from(n: JsElseClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsEmptyClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EMPTY_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsEmptyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsEmptyClassMember")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsEmptyClassMember> for SyntaxNode {
    fn from(n: JsEmptyClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsEmptyClassMember> for SyntaxElement {
    fn from(n: JsEmptyClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsEmptyStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EMPTY_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsEmptyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsEmptyStatement")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsEmptyStatement> for SyntaxNode {
    fn from(n: JsEmptyStatement) -> SyntaxNode { n.syntax }
}
impl From<JsEmptyStatement> for SyntaxElement {
    fn from(n: JsEmptyStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExport {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExport")
            .field(
                "export_token",
                &support::DebugSyntaxResult(self.export_token()),
            )
            .field(
                "export_clause",
                &support::DebugSyntaxResult(self.export_clause()),
            )
            .finish()
    }
}
impl From<JsExport> for SyntaxNode {
    fn from(n: JsExport) -> SyntaxNode { n.syntax }
}
impl From<JsExport> for SyntaxElement {
    fn from(n: JsExport) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportAsClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_AS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportAsClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "exported_name",
                &support::DebugSyntaxResult(self.exported_name()),
            )
            .finish()
    }
}
impl From<JsExportAsClause> for SyntaxNode {
    fn from(n: JsExportAsClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportAsClause> for SyntaxElement {
    fn from(n: JsExportAsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportDefaultDeclarationClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_DEFAULT_DECLARATION_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportDefaultDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportDefaultDeclarationClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportDefaultDeclarationClause> for SyntaxNode {
    fn from(n: JsExportDefaultDeclarationClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportDefaultDeclarationClause> for SyntaxElement {
    fn from(n: JsExportDefaultDeclarationClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportDefaultExpressionClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportDefaultExpressionClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportDefaultExpressionClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportDefaultExpressionClause> for SyntaxNode {
    fn from(n: JsExportDefaultExpressionClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportDefaultExpressionClause> for SyntaxElement {
    fn from(n: JsExportDefaultExpressionClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportFromClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_FROM_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportFromClause")
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field(
                "export_as",
                &support::DebugOptionalElement(self.export_as()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportFromClause> for SyntaxNode {
    fn from(n: JsExportFromClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportFromClause> for SyntaxElement {
    fn from(n: JsExportFromClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportNamedClause> for SyntaxNode {
    fn from(n: JsExportNamedClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedClause> for SyntaxElement {
    fn from(n: JsExportNamedClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedFromClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_FROM_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedFromClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportNamedFromClause> for SyntaxNode {
    fn from(n: JsExportNamedFromClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedFromClause> for SyntaxElement {
    fn from(n: JsExportNamedFromClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedFromSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_FROM_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedFromSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedFromSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "source_name",
                &support::DebugSyntaxResult(self.source_name()),
            )
            .field(
                "export_as",
                &support::DebugOptionalElement(self.export_as()),
            )
            .finish()
    }
}
impl From<JsExportNamedFromSpecifier> for SyntaxNode {
    fn from(n: JsExportNamedFromSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedFromSpecifier> for SyntaxElement {
    fn from(n: JsExportNamedFromSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedShorthandSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_SHORTHAND_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedShorthandSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedShorthandSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsExportNamedShorthandSpecifier> for SyntaxNode {
    fn from(n: JsExportNamedShorthandSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedShorthandSpecifier> for SyntaxElement {
    fn from(n: JsExportNamedShorthandSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "exported_name",
                &support::DebugSyntaxResult(self.exported_name()),
            )
            .finish()
    }
}
impl From<JsExportNamedSpecifier> for SyntaxNode {
    fn from(n: JsExportNamedSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedSpecifier> for SyntaxElement {
    fn from(n: JsExportNamedSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExpressionSnipped {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPRESSION_SNIPPED }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExpressionSnipped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExpressionSnipped")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsExpressionSnipped> for SyntaxNode {
    fn from(n: JsExpressionSnipped) -> SyntaxNode { n.syntax }
}
impl From<JsExpressionSnipped> for SyntaxElement {
    fn from(n: JsExpressionSnipped) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExpressionStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPRESSION_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExpressionStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExpressionStatement")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExpressionStatement> for SyntaxNode {
    fn from(n: JsExpressionStatement) -> SyntaxNode { n.syntax }
}
impl From<JsExpressionStatement> for SyntaxElement {
    fn from(n: JsExpressionStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExtendsClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXTENDS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExtendsClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field(
                "super_class",
                &support::DebugSyntaxResult(self.super_class()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<JsExtendsClause> for SyntaxNode {
    fn from(n: JsExtendsClause) -> SyntaxNode { n.syntax }
}
impl From<JsExtendsClause> for SyntaxElement {
    fn from(n: JsExtendsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFinallyClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FINALLY_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFinallyClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFinallyClause")
            .field(
                "finally_token",
                &support::DebugSyntaxResult(self.finally_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFinallyClause> for SyntaxNode {
    fn from(n: JsFinallyClause) -> SyntaxNode { n.syntax }
}
impl From<JsFinallyClause> for SyntaxElement {
    fn from(n: JsFinallyClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsForInStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FOR_IN_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsForInStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForInStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugSyntaxResult(self.initializer()),
            )
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForInStatement> for SyntaxNode {
    fn from(n: JsForInStatement) -> SyntaxNode { n.syntax }
}
impl From<JsForInStatement> for SyntaxElement {
    fn from(n: JsForInStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsForOfStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FOR_OF_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsForOfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForOfStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "await_token",
                &support::DebugOptionalElement(self.await_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugSyntaxResult(self.initializer()),
            )
            .field("of_token", &support::DebugSyntaxResult(self.of_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForOfStatement> for SyntaxNode {
    fn from(n: JsForOfStatement) -> SyntaxNode { n.syntax }
}
impl From<JsForOfStatement> for SyntaxElement {
    fn from(n: JsForOfStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsForStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FOR_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsForStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .field(
                "first_semi_token",
                &support::DebugSyntaxResult(self.first_semi_token()),
            )
            .field("test", &support::DebugOptionalElement(self.test()))
            .field(
                "second_semi_token",
                &support::DebugSyntaxResult(self.second_semi_token()),
            )
            .field("update", &support::DebugOptionalElement(self.update()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForStatement> for SyntaxNode {
    fn from(n: JsForStatement) -> SyntaxNode { n.syntax }
}
impl From<JsForStatement> for SyntaxElement {
    fn from(n: JsForStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsForVariableDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FOR_VARIABLE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsForVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForVariableDeclaration")
            .field("kind_token", &support::DebugSyntaxResult(self.kind_token()))
            .field("declarator", &support::DebugSyntaxResult(self.declarator()))
            .finish()
    }
}
impl From<JsForVariableDeclaration> for SyntaxNode {
    fn from(n: JsForVariableDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsForVariableDeclaration> for SyntaxElement {
    fn from(n: JsForVariableDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFormalParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FORMAL_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFormalParameter")
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsFormalParameter> for SyntaxNode {
    fn from(n: JsFormalParameter) -> SyntaxNode { n.syntax }
}
impl From<JsFormalParameter> for SyntaxElement {
    fn from(n: JsFormalParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFunctionBody {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FUNCTION_BODY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionBody")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("directives", &self.directives())
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsFunctionBody> for SyntaxNode {
    fn from(n: JsFunctionBody) -> SyntaxNode { n.syntax }
}
impl From<JsFunctionBody> for SyntaxElement {
    fn from(n: JsFunctionBody) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFunctionDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FUNCTION_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionDeclaration> for SyntaxNode {
    fn from(n: JsFunctionDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsFunctionDeclaration> for SyntaxElement {
    fn from(n: JsFunctionDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFunctionExportDefaultDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FUNCTION_EXPORT_DEFAULT_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFunctionExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionExportDefaultDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionExportDefaultDeclaration> for SyntaxNode {
    fn from(n: JsFunctionExportDefaultDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsFunctionExportDefaultDeclaration> for SyntaxElement {
    fn from(n: JsFunctionExportDefaultDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFunctionExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FUNCTION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionExpression")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionExpression> for SyntaxNode {
    fn from(n: JsFunctionExpression) -> SyntaxNode { n.syntax }
}
impl From<JsFunctionExpression> for SyntaxElement {
    fn from(n: JsFunctionExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsGetterClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_GETTER_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsGetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsGetterClassMember")
            .field("modifiers", &self.modifiers())
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsGetterClassMember> for SyntaxNode {
    fn from(n: JsGetterClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsGetterClassMember> for SyntaxElement {
    fn from(n: JsGetterClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsGetterObjectMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_GETTER_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsGetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsGetterObjectMember")
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsGetterObjectMember> for SyntaxNode {
    fn from(n: JsGetterObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsGetterObjectMember> for SyntaxElement {
    fn from(n: JsGetterObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsIdentifierAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IDENTIFIER_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsIdentifierAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierAssignment")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<JsIdentifierAssignment> for SyntaxNode {
    fn from(n: JsIdentifierAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsIdentifierAssignment> for SyntaxElement {
    fn from(n: JsIdentifierAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsIdentifierBinding {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IDENTIFIER_BINDING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierBinding")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<JsIdentifierBinding> for SyntaxNode {
    fn from(n: JsIdentifierBinding) -> SyntaxNode { n.syntax }
}
impl From<JsIdentifierBinding> for SyntaxElement {
    fn from(n: JsIdentifierBinding) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsIdentifierExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IDENTIFIER_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsIdentifierExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierExpression")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsIdentifierExpression> for SyntaxNode {
    fn from(n: JsIdentifierExpression) -> SyntaxNode { n.syntax }
}
impl From<JsIdentifierExpression> for SyntaxElement {
    fn from(n: JsIdentifierExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsIfStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IF_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsIfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIfStatement")
            .field("if_token", &support::DebugSyntaxResult(self.if_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("consequent", &support::DebugSyntaxResult(self.consequent()))
            .field(
                "else_clause",
                &support::DebugOptionalElement(self.else_clause()),
            )
            .finish()
    }
}
impl From<JsIfStatement> for SyntaxNode {
    fn from(n: JsIfStatement) -> SyntaxNode { n.syntax }
}
impl From<JsIfStatement> for SyntaxElement {
    fn from(n: JsIfStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImport {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImport")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "import_clause",
                &support::DebugSyntaxResult(self.import_clause()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsImport> for SyntaxNode {
    fn from(n: JsImport) -> SyntaxNode { n.syntax }
}
impl From<JsImport> for SyntaxElement {
    fn from(n: JsImport) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportAssertion {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_ASSERTION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportAssertion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportAssertion")
            .field(
                "assert_token",
                &support::DebugSyntaxResult(self.assert_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("assertions", &self.assertions())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsImportAssertion> for SyntaxNode {
    fn from(n: JsImportAssertion) -> SyntaxNode { n.syntax }
}
impl From<JsImportAssertion> for SyntaxElement {
    fn from(n: JsImportAssertion) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportAssertionEntry {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_ASSERTION_ENTRY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportAssertionEntry")
            .field("key", &support::DebugSyntaxResult(self.key()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsImportAssertionEntry> for SyntaxNode {
    fn from(n: JsImportAssertionEntry) -> SyntaxNode { n.syntax }
}
impl From<JsImportAssertionEntry> for SyntaxElement {
    fn from(n: JsImportAssertionEntry) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportBareClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_BARE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportBareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportBareClause")
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .finish()
    }
}
impl From<JsImportBareClause> for SyntaxNode {
    fn from(n: JsImportBareClause) -> SyntaxNode { n.syntax }
}
impl From<JsImportBareClause> for SyntaxElement {
    fn from(n: JsImportBareClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportCallExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_CALL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportCallExpression")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field("arguments", &support::DebugSyntaxResult(self.arguments()))
            .finish()
    }
}
impl From<JsImportCallExpression> for SyntaxNode {
    fn from(n: JsImportCallExpression) -> SyntaxNode { n.syntax }
}
impl From<JsImportCallExpression> for SyntaxElement {
    fn from(n: JsImportCallExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportDefaultClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_DEFAULT_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportDefaultClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .finish()
    }
}
impl From<JsImportDefaultClause> for SyntaxNode {
    fn from(n: JsImportDefaultClause) -> SyntaxNode { n.syntax }
}
impl From<JsImportDefaultClause> for SyntaxElement {
    fn from(n: JsImportDefaultClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportNamedClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_NAMED_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportNamedClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "default_specifier",
                &support::DebugOptionalElement(self.default_specifier()),
            )
            .field(
                "named_import",
                &support::DebugSyntaxResult(self.named_import()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .finish()
    }
}
impl From<JsImportNamedClause> for SyntaxNode {
    fn from(n: JsImportNamedClause) -> SyntaxNode { n.syntax }
}
impl From<JsImportNamedClause> for SyntaxElement {
    fn from(n: JsImportNamedClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportNamespaceClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_NAMESPACE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportNamespaceClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "assertion",
                &support::DebugOptionalElement(self.assertion()),
            )
            .finish()
    }
}
impl From<JsImportNamespaceClause> for SyntaxNode {
    fn from(n: JsImportNamespaceClause) -> SyntaxNode { n.syntax }
}
impl From<JsImportNamespaceClause> for SyntaxElement {
    fn from(n: JsImportNamespaceClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsInExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IN_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsInExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInExpression")
            .field("property", &support::DebugSyntaxResult(self.property()))
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("object", &support::DebugSyntaxResult(self.object()))
            .finish()
    }
}
impl From<JsInExpression> for SyntaxNode {
    fn from(n: JsInExpression) -> SyntaxNode { n.syntax }
}
impl From<JsInExpression> for SyntaxElement {
    fn from(n: JsInExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsInitializerClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_INITIALIZER_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInitializerClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<JsInitializerClause> for SyntaxNode {
    fn from(n: JsInitializerClause) -> SyntaxNode { n.syntax }
}
impl From<JsInitializerClause> for SyntaxElement {
    fn from(n: JsInitializerClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsInstanceofExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_INSTANCEOF_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsInstanceofExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInstanceofExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "instanceof_token",
                &support::DebugSyntaxResult(self.instanceof_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsInstanceofExpression> for SyntaxNode {
    fn from(n: JsInstanceofExpression) -> SyntaxNode { n.syntax }
}
impl From<JsInstanceofExpression> for SyntaxElement {
    fn from(n: JsInstanceofExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsLabeledStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_LABELED_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsLabeledStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLabeledStatement")
            .field(
                "label_token",
                &support::DebugSyntaxResult(self.label_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsLabeledStatement> for SyntaxNode {
    fn from(n: JsLabeledStatement) -> SyntaxNode { n.syntax }
}
impl From<JsLabeledStatement> for SyntaxElement {
    fn from(n: JsLabeledStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsLiteralExportName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_LITERAL_EXPORT_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsLiteralExportName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLiteralExportName")
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsLiteralExportName> for SyntaxNode {
    fn from(n: JsLiteralExportName) -> SyntaxNode { n.syntax }
}
impl From<JsLiteralExportName> for SyntaxElement {
    fn from(n: JsLiteralExportName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsLiteralMemberName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_LITERAL_MEMBER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsLiteralMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLiteralMemberName")
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsLiteralMemberName> for SyntaxNode {
    fn from(n: JsLiteralMemberName) -> SyntaxNode { n.syntax }
}
impl From<JsLiteralMemberName> for SyntaxElement {
    fn from(n: JsLiteralMemberName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsLogicalExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_LOGICAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsLogicalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLogicalExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsLogicalExpression> for SyntaxNode {
    fn from(n: JsLogicalExpression) -> SyntaxNode { n.syntax }
}
impl From<JsLogicalExpression> for SyntaxElement {
    fn from(n: JsLogicalExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsMethodClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_METHOD_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsMethodClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsMethodClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsMethodClassMember> for SyntaxNode {
    fn from(n: JsMethodClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsMethodClassMember> for SyntaxElement {
    fn from(n: JsMethodClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsMethodObjectMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_METHOD_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsMethodObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsMethodObjectMember")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsMethodObjectMember> for SyntaxNode {
    fn from(n: JsMethodObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsMethodObjectMember> for SyntaxElement {
    fn from(n: JsMethodObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsModule {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_MODULE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsModule")
            .field(
                "interpreter_token",
                &support::DebugOptionalElement(self.interpreter_token()),
            )
            .field("directives", &self.directives())
            .field("items", &self.items())
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsModule> for SyntaxNode {
    fn from(n: JsModule) -> SyntaxNode { n.syntax }
}
impl From<JsModule> for SyntaxElement {
    fn from(n: JsModule) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsModuleSource {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_MODULE_SOURCE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsModuleSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsModuleSource")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsModuleSource> for SyntaxNode {
    fn from(n: JsModuleSource) -> SyntaxNode { n.syntax }
}
impl From<JsModuleSource> for SyntaxElement {
    fn from(n: JsModuleSource) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsName")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsName> for SyntaxNode {
    fn from(n: JsName) -> SyntaxNode { n.syntax }
}
impl From<JsName> for SyntaxElement {
    fn from(n: JsName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNamedImportSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAMED_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamedImportSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsNamedImportSpecifier> for SyntaxNode {
    fn from(n: JsNamedImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsNamedImportSpecifier> for SyntaxElement {
    fn from(n: JsNamedImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNamedImportSpecifiers {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAMED_IMPORT_SPECIFIERS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNamedImportSpecifiers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamedImportSpecifiers")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsNamedImportSpecifiers> for SyntaxNode {
    fn from(n: JsNamedImportSpecifiers) -> SyntaxNode { n.syntax }
}
impl From<JsNamedImportSpecifiers> for SyntaxElement {
    fn from(n: JsNamedImportSpecifiers) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNamespaceImportSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAMESPACE_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNamespaceImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamespaceImportSpecifier")
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsNamespaceImportSpecifier> for SyntaxNode {
    fn from(n: JsNamespaceImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsNamespaceImportSpecifier> for SyntaxElement {
    fn from(n: JsNamespaceImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNewExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NEW_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNewExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNewExpression")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field("callee", &support::DebugSyntaxResult(self.callee()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field(
                "arguments",
                &support::DebugOptionalElement(self.arguments()),
            )
            .finish()
    }
}
impl From<JsNewExpression> for SyntaxNode {
    fn from(n: JsNewExpression) -> SyntaxNode { n.syntax }
}
impl From<JsNewExpression> for SyntaxElement {
    fn from(n: JsNewExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNullLiteralExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NULL_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNullLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNullLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsNullLiteralExpression> for SyntaxNode {
    fn from(n: JsNullLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsNullLiteralExpression> for SyntaxElement {
    fn from(n: JsNullLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNumberLiteralExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NUMBER_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNumberLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNumberLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsNumberLiteralExpression> for SyntaxNode {
    fn from(n: JsNumberLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsNumberLiteralExpression> for SyntaxElement {
    fn from(n: JsNumberLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectAssignmentPattern {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_ASSIGNMENT_PATTERN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPattern")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("properties", &self.properties())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectAssignmentPattern> for SyntaxNode {
    fn from(n: JsObjectAssignmentPattern) -> SyntaxNode { n.syntax }
}
impl From<JsObjectAssignmentPattern> for SyntaxElement {
    fn from(n: JsObjectAssignmentPattern) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectAssignmentPatternProperty {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectAssignmentPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternProperty")
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternProperty> for SyntaxNode {
    fn from(n: JsObjectAssignmentPatternProperty) -> SyntaxNode { n.syntax }
}
impl From<JsObjectAssignmentPatternProperty> for SyntaxElement {
    fn from(n: JsObjectAssignmentPatternProperty) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectAssignmentPatternRest {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_ASSIGNMENT_PATTERN_REST }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectAssignmentPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternRest")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("target", &support::DebugSyntaxResult(self.target()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternRest> for SyntaxNode {
    fn from(n: JsObjectAssignmentPatternRest) -> SyntaxNode { n.syntax }
}
impl From<JsObjectAssignmentPatternRest> for SyntaxElement {
    fn from(n: JsObjectAssignmentPatternRest) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectAssignmentPatternShorthandProperty {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectAssignmentPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternShorthandProperty")
            .field("identifier", &support::DebugSyntaxResult(self.identifier()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for SyntaxNode {
    fn from(n: JsObjectAssignmentPatternShorthandProperty) -> SyntaxNode { n.syntax }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for SyntaxElement {
    fn from(n: JsObjectAssignmentPatternShorthandProperty) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectBindingPattern {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPattern")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("properties", &self.properties())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectBindingPattern> for SyntaxNode {
    fn from(n: JsObjectBindingPattern) -> SyntaxNode { n.syntax }
}
impl From<JsObjectBindingPattern> for SyntaxElement {
    fn from(n: JsObjectBindingPattern) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectBindingPatternProperty {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN_PROPERTY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectBindingPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternProperty")
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectBindingPatternProperty> for SyntaxNode {
    fn from(n: JsObjectBindingPatternProperty) -> SyntaxNode { n.syntax }
}
impl From<JsObjectBindingPatternProperty> for SyntaxElement {
    fn from(n: JsObjectBindingPatternProperty) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectBindingPatternRest {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN_REST }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectBindingPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternRest")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .finish()
    }
}
impl From<JsObjectBindingPatternRest> for SyntaxNode {
    fn from(n: JsObjectBindingPatternRest) -> SyntaxNode { n.syntax }
}
impl From<JsObjectBindingPatternRest> for SyntaxElement {
    fn from(n: JsObjectBindingPatternRest) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectBindingPatternShorthandProperty {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectBindingPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternShorthandProperty")
            .field("identifier", &support::DebugSyntaxResult(self.identifier()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectBindingPatternShorthandProperty> for SyntaxNode {
    fn from(n: JsObjectBindingPatternShorthandProperty) -> SyntaxNode { n.syntax }
}
impl From<JsObjectBindingPatternShorthandProperty> for SyntaxElement {
    fn from(n: JsObjectBindingPatternShorthandProperty) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectExpression")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectExpression> for SyntaxNode {
    fn from(n: JsObjectExpression) -> SyntaxNode { n.syntax }
}
impl From<JsObjectExpression> for SyntaxElement {
    fn from(n: JsObjectExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsParameters {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PARAMETERS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParameters")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("items", &self.items())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParameters> for SyntaxNode {
    fn from(n: JsParameters) -> SyntaxNode { n.syntax }
}
impl From<JsParameters> for SyntaxElement {
    fn from(n: JsParameters) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsParenthesizedAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PARENTHESIZED_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsParenthesizedAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParenthesizedAssignment")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParenthesizedAssignment> for SyntaxNode {
    fn from(n: JsParenthesizedAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsParenthesizedAssignment> for SyntaxElement {
    fn from(n: JsParenthesizedAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsParenthesizedExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PARENTHESIZED_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsParenthesizedExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParenthesizedExpression")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParenthesizedExpression> for SyntaxNode {
    fn from(n: JsParenthesizedExpression) -> SyntaxNode { n.syntax }
}
impl From<JsParenthesizedExpression> for SyntaxElement {
    fn from(n: JsParenthesizedExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPostUpdateExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_POST_UPDATE_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPostUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPostUpdateExpression")
            .field("operand", &support::DebugSyntaxResult(self.operand()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .finish()
    }
}
impl From<JsPostUpdateExpression> for SyntaxNode {
    fn from(n: JsPostUpdateExpression) -> SyntaxNode { n.syntax }
}
impl From<JsPostUpdateExpression> for SyntaxElement {
    fn from(n: JsPostUpdateExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPreUpdateExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PRE_UPDATE_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPreUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPreUpdateExpression")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("operand", &support::DebugSyntaxResult(self.operand()))
            .finish()
    }
}
impl From<JsPreUpdateExpression> for SyntaxNode {
    fn from(n: JsPreUpdateExpression) -> SyntaxNode { n.syntax }
}
impl From<JsPreUpdateExpression> for SyntaxElement {
    fn from(n: JsPreUpdateExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPrivateClassMemberName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PRIVATE_CLASS_MEMBER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPrivateClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPrivateClassMemberName")
            .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
            .field("id_token", &support::DebugSyntaxResult(self.id_token()))
            .finish()
    }
}
impl From<JsPrivateClassMemberName> for SyntaxNode {
    fn from(n: JsPrivateClassMemberName) -> SyntaxNode { n.syntax }
}
impl From<JsPrivateClassMemberName> for SyntaxElement {
    fn from(n: JsPrivateClassMemberName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPrivateName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PRIVATE_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPrivateName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPrivateName")
            .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsPrivateName> for SyntaxNode {
    fn from(n: JsPrivateName) -> SyntaxNode { n.syntax }
}
impl From<JsPrivateName> for SyntaxElement {
    fn from(n: JsPrivateName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPropertyClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PROPERTY_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPropertyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPropertyClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "property_annotation",
                &support::DebugOptionalElement(self.property_annotation()),
            )
            .field("value", &support::DebugOptionalElement(self.value()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsPropertyClassMember> for SyntaxNode {
    fn from(n: JsPropertyClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsPropertyClassMember> for SyntaxElement {
    fn from(n: JsPropertyClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPropertyObjectMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PROPERTY_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPropertyObjectMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsPropertyObjectMember> for SyntaxNode {
    fn from(n: JsPropertyObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsPropertyObjectMember> for SyntaxElement {
    fn from(n: JsPropertyObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsReferenceIdentifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_REFERENCE_IDENTIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsReferenceIdentifier")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsReferenceIdentifier> for SyntaxNode {
    fn from(n: JsReferenceIdentifier) -> SyntaxNode { n.syntax }
}
impl From<JsReferenceIdentifier> for SyntaxElement {
    fn from(n: JsReferenceIdentifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsRegexLiteralExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_REGEX_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsRegexLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsRegexLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsRegexLiteralExpression> for SyntaxNode {
    fn from(n: JsRegexLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsRegexLiteralExpression> for SyntaxElement {
    fn from(n: JsRegexLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsRestParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_REST_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsRestParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsRestParameter")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<JsRestParameter> for SyntaxNode {
    fn from(n: JsRestParameter) -> SyntaxNode { n.syntax }
}
impl From<JsRestParameter> for SyntaxElement {
    fn from(n: JsRestParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsReturnStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_RETURN_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsReturnStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsReturnStatement")
            .field(
                "return_token",
                &support::DebugSyntaxResult(self.return_token()),
            )
            .field("argument", &support::DebugOptionalElement(self.argument()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsReturnStatement> for SyntaxNode {
    fn from(n: JsReturnStatement) -> SyntaxNode { n.syntax }
}
impl From<JsReturnStatement> for SyntaxElement {
    fn from(n: JsReturnStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsScript {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SCRIPT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsScript")
            .field(
                "interpreter_token",
                &support::DebugOptionalElement(self.interpreter_token()),
            )
            .field("directives", &self.directives())
            .field("statements", &self.statements())
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsScript> for SyntaxNode {
    fn from(n: JsScript) -> SyntaxNode { n.syntax }
}
impl From<JsScript> for SyntaxElement {
    fn from(n: JsScript) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSequenceExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SEQUENCE_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSequenceExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSequenceExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "comma_token",
                &support::DebugSyntaxResult(self.comma_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsSequenceExpression> for SyntaxNode {
    fn from(n: JsSequenceExpression) -> SyntaxNode { n.syntax }
}
impl From<JsSequenceExpression> for SyntaxElement {
    fn from(n: JsSequenceExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSetterClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SETTER_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSetterClassMember")
            .field("modifiers", &self.modifiers())
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsSetterClassMember> for SyntaxNode {
    fn from(n: JsSetterClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsSetterClassMember> for SyntaxElement {
    fn from(n: JsSetterClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSetterObjectMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SETTER_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSetterObjectMember")
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsSetterObjectMember> for SyntaxNode {
    fn from(n: JsSetterObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsSetterObjectMember> for SyntaxElement {
    fn from(n: JsSetterObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsShorthandNamedImportSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SHORTHAND_NAMED_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsShorthandNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsShorthandNamedImportSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsShorthandNamedImportSpecifier> for SyntaxNode {
    fn from(n: JsShorthandNamedImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsShorthandNamedImportSpecifier> for SyntaxElement {
    fn from(n: JsShorthandNamedImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsShorthandPropertyObjectMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SHORTHAND_PROPERTY_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsShorthandPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsShorthandPropertyObjectMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsShorthandPropertyObjectMember> for SyntaxNode {
    fn from(n: JsShorthandPropertyObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsShorthandPropertyObjectMember> for SyntaxElement {
    fn from(n: JsShorthandPropertyObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSpread {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SPREAD }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSpread {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSpread")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsSpread> for SyntaxNode {
    fn from(n: JsSpread) -> SyntaxNode { n.syntax }
}
impl From<JsSpread> for SyntaxElement {
    fn from(n: JsSpread) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStaticInitializationBlockClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStaticInitializationBlockClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticInitializationBlockClassMember")
            .field(
                "static_token",
                &support::DebugSyntaxResult(self.static_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsStaticInitializationBlockClassMember> for SyntaxNode {
    fn from(n: JsStaticInitializationBlockClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsStaticInitializationBlockClassMember> for SyntaxElement {
    fn from(n: JsStaticInitializationBlockClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStaticMemberAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATIC_MEMBER_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStaticMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticMemberAssignment")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsStaticMemberAssignment> for SyntaxNode {
    fn from(n: JsStaticMemberAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsStaticMemberAssignment> for SyntaxElement {
    fn from(n: JsStaticMemberAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStaticMemberExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATIC_MEMBER_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStaticMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticMemberExpression")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsStaticMemberExpression> for SyntaxNode {
    fn from(n: JsStaticMemberExpression) -> SyntaxNode { n.syntax }
}
impl From<JsStaticMemberExpression> for SyntaxElement {
    fn from(n: JsStaticMemberExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStaticModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATIC_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStaticModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<JsStaticModifier> for SyntaxNode {
    fn from(n: JsStaticModifier) -> SyntaxNode { n.syntax }
}
impl From<JsStaticModifier> for SyntaxElement {
    fn from(n: JsStaticModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStringLiteralExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STRING_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStringLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStringLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsStringLiteralExpression> for SyntaxNode {
    fn from(n: JsStringLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsStringLiteralExpression> for SyntaxElement {
    fn from(n: JsStringLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSuperExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SUPER_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSuperExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSuperExpression")
            .field(
                "super_token",
                &support::DebugSyntaxResult(self.super_token()),
            )
            .finish()
    }
}
impl From<JsSuperExpression> for SyntaxNode {
    fn from(n: JsSuperExpression) -> SyntaxNode { n.syntax }
}
impl From<JsSuperExpression> for SyntaxElement {
    fn from(n: JsSuperExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSwitchStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SWITCH_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSwitchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSwitchStatement")
            .field(
                "switch_token",
                &support::DebugSyntaxResult(self.switch_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "discriminant",
                &support::DebugSyntaxResult(self.discriminant()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("cases", &self.cases())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsSwitchStatement> for SyntaxNode {
    fn from(n: JsSwitchStatement) -> SyntaxNode { n.syntax }
}
impl From<JsSwitchStatement> for SyntaxElement {
    fn from(n: JsSwitchStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTemplate {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TEMPLATE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplate")
            .field("tag", &support::DebugOptionalElement(self.tag()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field(
                "l_tick_token",
                &support::DebugSyntaxResult(self.l_tick_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_tick_token",
                &support::DebugSyntaxResult(self.r_tick_token()),
            )
            .finish()
    }
}
impl From<JsTemplate> for SyntaxNode {
    fn from(n: JsTemplate) -> SyntaxNode { n.syntax }
}
impl From<JsTemplate> for SyntaxElement {
    fn from(n: JsTemplate) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTemplateChunkElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TEMPLATE_CHUNK_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplateChunkElement")
            .field(
                "template_chunk_token",
                &support::DebugSyntaxResult(self.template_chunk_token()),
            )
            .finish()
    }
}
impl From<JsTemplateChunkElement> for SyntaxNode {
    fn from(n: JsTemplateChunkElement) -> SyntaxNode { n.syntax }
}
impl From<JsTemplateChunkElement> for SyntaxElement {
    fn from(n: JsTemplateChunkElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTemplateElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TEMPLATE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplateElement")
            .field(
                "dollar_curly_token",
                &support::DebugSyntaxResult(self.dollar_curly_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsTemplateElement> for SyntaxNode {
    fn from(n: JsTemplateElement) -> SyntaxNode { n.syntax }
}
impl From<JsTemplateElement> for SyntaxElement {
    fn from(n: JsTemplateElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsThisExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_THIS_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsThisExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsThisExpression")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .finish()
    }
}
impl From<JsThisExpression> for SyntaxNode {
    fn from(n: JsThisExpression) -> SyntaxNode { n.syntax }
}
impl From<JsThisExpression> for SyntaxElement {
    fn from(n: JsThisExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsThrowStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_THROW_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsThrowStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsThrowStatement")
            .field(
                "throw_token",
                &support::DebugSyntaxResult(self.throw_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsThrowStatement> for SyntaxNode {
    fn from(n: JsThrowStatement) -> SyntaxNode { n.syntax }
}
impl From<JsThrowStatement> for SyntaxElement {
    fn from(n: JsThrowStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTryFinallyStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TRY_FINALLY_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTryFinallyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTryFinallyStatement")
            .field("try_token", &support::DebugSyntaxResult(self.try_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "catch_clause",
                &support::DebugOptionalElement(self.catch_clause()),
            )
            .field(
                "finally_clause",
                &support::DebugSyntaxResult(self.finally_clause()),
            )
            .finish()
    }
}
impl From<JsTryFinallyStatement> for SyntaxNode {
    fn from(n: JsTryFinallyStatement) -> SyntaxNode { n.syntax }
}
impl From<JsTryFinallyStatement> for SyntaxElement {
    fn from(n: JsTryFinallyStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTryStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TRY_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTryStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTryStatement")
            .field("try_token", &support::DebugSyntaxResult(self.try_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "catch_clause",
                &support::DebugSyntaxResult(self.catch_clause()),
            )
            .finish()
    }
}
impl From<JsTryStatement> for SyntaxNode {
    fn from(n: JsTryStatement) -> SyntaxNode { n.syntax }
}
impl From<JsTryStatement> for SyntaxElement {
    fn from(n: JsTryStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsUnaryExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNARY_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnaryExpression")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsUnaryExpression> for SyntaxNode {
    fn from(n: JsUnaryExpression) -> SyntaxNode { n.syntax }
}
impl From<JsUnaryExpression> for SyntaxElement {
    fn from(n: JsUnaryExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsVariableDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclaration")
            .field("kind", &support::DebugSyntaxResult(self.kind()))
            .field("declarators", &self.declarators())
            .finish()
    }
}
impl From<JsVariableDeclaration> for SyntaxNode {
    fn from(n: JsVariableDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsVariableDeclaration> for SyntaxElement {
    fn from(n: JsVariableDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsVariableDeclarationClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_DECLARATION_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsVariableDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclarationClause")
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsVariableDeclarationClause> for SyntaxNode {
    fn from(n: JsVariableDeclarationClause) -> SyntaxNode { n.syntax }
}
impl From<JsVariableDeclarationClause> for SyntaxElement {
    fn from(n: JsVariableDeclarationClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsVariableDeclarator {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_DECLARATOR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsVariableDeclarator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclarator")
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "variable_annotation",
                &support::DebugOptionalElement(self.variable_annotation()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsVariableDeclarator> for SyntaxNode {
    fn from(n: JsVariableDeclarator) -> SyntaxNode { n.syntax }
}
impl From<JsVariableDeclarator> for SyntaxElement {
    fn from(n: JsVariableDeclarator) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsVariableStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsVariableStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableStatement")
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsVariableStatement> for SyntaxNode {
    fn from(n: JsVariableStatement) -> SyntaxNode { n.syntax }
}
impl From<JsVariableStatement> for SyntaxElement {
    fn from(n: JsVariableStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsWhileStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_WHILE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsWhileStatement")
            .field(
                "while_token",
                &support::DebugSyntaxResult(self.while_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsWhileStatement> for SyntaxNode {
    fn from(n: JsWhileStatement) -> SyntaxNode { n.syntax }
}
impl From<JsWhileStatement> for SyntaxElement {
    fn from(n: JsWhileStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsWithStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_WITH_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsWithStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsWithStatement")
            .field("with_token", &support::DebugSyntaxResult(self.with_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsWithStatement> for SyntaxNode {
    fn from(n: JsWithStatement) -> SyntaxNode { n.syntax }
}
impl From<JsWithStatement> for SyntaxElement {
    fn from(n: JsWithStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsYieldArgument {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_YIELD_ARGUMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsYieldArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsYieldArgument")
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<JsYieldArgument> for SyntaxNode {
    fn from(n: JsYieldArgument) -> SyntaxNode { n.syntax }
}
impl From<JsYieldArgument> for SyntaxElement {
    fn from(n: JsYieldArgument) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsYieldExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_YIELD_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsYieldExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsYieldExpression")
            .field(
                "yield_token",
                &support::DebugSyntaxResult(self.yield_token()),
            )
            .field("argument", &support::DebugOptionalElement(self.argument()))
            .finish()
    }
}
impl From<JsYieldExpression> for SyntaxNode {
    fn from(n: JsYieldExpression) -> SyntaxNode { n.syntax }
}
impl From<JsYieldExpression> for SyntaxElement {
    fn from(n: JsYieldExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxAttribute {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_ATTRIBUTE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxAttribute")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsxAttribute> for SyntaxNode {
    fn from(n: JsxAttribute) -> SyntaxNode { n.syntax }
}
impl From<JsxAttribute> for SyntaxElement {
    fn from(n: JsxAttribute) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxAttributeInitializerClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_ATTRIBUTE_INITIALIZER_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxAttributeInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxAttributeInitializerClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsxAttributeInitializerClause> for SyntaxNode {
    fn from(n: JsxAttributeInitializerClause) -> SyntaxNode { n.syntax }
}
impl From<JsxAttributeInitializerClause> for SyntaxElement {
    fn from(n: JsxAttributeInitializerClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxClosingElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_CLOSING_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxClosingElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxClosingElement> for SyntaxNode {
    fn from(n: JsxClosingElement) -> SyntaxNode { n.syntax }
}
impl From<JsxClosingElement> for SyntaxElement {
    fn from(n: JsxClosingElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxClosingFragment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_CLOSING_FRAGMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxClosingFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxClosingFragment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxClosingFragment> for SyntaxNode {
    fn from(n: JsxClosingFragment) -> SyntaxNode { n.syntax }
}
impl From<JsxClosingFragment> for SyntaxElement {
    fn from(n: JsxClosingFragment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxElement")
            .field(
                "opening_element",
                &support::DebugSyntaxResult(self.opening_element()),
            )
            .field("children", &self.children())
            .field(
                "closing_element",
                &support::DebugSyntaxResult(self.closing_element()),
            )
            .finish()
    }
}
impl From<JsxElement> for SyntaxNode {
    fn from(n: JsxElement) -> SyntaxNode { n.syntax }
}
impl From<JsxElement> for SyntaxElement {
    fn from(n: JsxElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxExpressionAttributeValue {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_EXPRESSION_ATTRIBUTE_VALUE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxExpressionAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxExpressionAttributeValue")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxExpressionAttributeValue> for SyntaxNode {
    fn from(n: JsxExpressionAttributeValue) -> SyntaxNode { n.syntax }
}
impl From<JsxExpressionAttributeValue> for SyntaxElement {
    fn from(n: JsxExpressionAttributeValue) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxExpressionChild {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_EXPRESSION_CHILD }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxExpressionChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxExpressionChild")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "expression",
                &support::DebugOptionalElement(self.expression()),
            )
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxExpressionChild> for SyntaxNode {
    fn from(n: JsxExpressionChild) -> SyntaxNode { n.syntax }
}
impl From<JsxExpressionChild> for SyntaxElement {
    fn from(n: JsxExpressionChild) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxFragment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_FRAGMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxFragment")
            .field(
                "opening_fragment",
                &support::DebugSyntaxResult(self.opening_fragment()),
            )
            .field("children", &self.children())
            .field(
                "closing_fragment",
                &support::DebugSyntaxResult(self.closing_fragment()),
            )
            .finish()
    }
}
impl From<JsxFragment> for SyntaxNode {
    fn from(n: JsxFragment) -> SyntaxNode { n.syntax }
}
impl From<JsxFragment> for SyntaxElement {
    fn from(n: JsxFragment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxMemberName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_MEMBER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxMemberName")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsxMemberName> for SyntaxNode {
    fn from(n: JsxMemberName) -> SyntaxNode { n.syntax }
}
impl From<JsxMemberName> for SyntaxElement {
    fn from(n: JsxMemberName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxName")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxName> for SyntaxNode {
    fn from(n: JsxName) -> SyntaxNode { n.syntax }
}
impl From<JsxName> for SyntaxElement {
    fn from(n: JsxName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxNamespaceName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_NAMESPACE_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxNamespaceName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxNamespaceName")
            .field("namespace", &support::DebugSyntaxResult(self.namespace()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsxNamespaceName> for SyntaxNode {
    fn from(n: JsxNamespaceName) -> SyntaxNode { n.syntax }
}
impl From<JsxNamespaceName> for SyntaxElement {
    fn from(n: JsxNamespaceName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxOpeningElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_OPENING_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxOpeningElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxOpeningElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("attributes", &self.attributes())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxOpeningElement> for SyntaxNode {
    fn from(n: JsxOpeningElement) -> SyntaxNode { n.syntax }
}
impl From<JsxOpeningElement> for SyntaxElement {
    fn from(n: JsxOpeningElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxOpeningFragment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_OPENING_FRAGMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxOpeningFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxOpeningFragment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxOpeningFragment> for SyntaxNode {
    fn from(n: JsxOpeningFragment) -> SyntaxNode { n.syntax }
}
impl From<JsxOpeningFragment> for SyntaxElement {
    fn from(n: JsxOpeningFragment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxReferenceIdentifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_REFERENCE_IDENTIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxReferenceIdentifier")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxReferenceIdentifier> for SyntaxNode {
    fn from(n: JsxReferenceIdentifier) -> SyntaxNode { n.syntax }
}
impl From<JsxReferenceIdentifier> for SyntaxElement {
    fn from(n: JsxReferenceIdentifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxSelfClosingElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_SELF_CLOSING_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxSelfClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSelfClosingElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("attributes", &self.attributes())
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxSelfClosingElement> for SyntaxNode {
    fn from(n: JsxSelfClosingElement) -> SyntaxNode { n.syntax }
}
impl From<JsxSelfClosingElement> for SyntaxElement {
    fn from(n: JsxSelfClosingElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxSpreadAttribute {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_SPREAD_ATTRIBUTE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxSpreadAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSpreadAttribute")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxSpreadAttribute> for SyntaxNode {
    fn from(n: JsxSpreadAttribute) -> SyntaxNode { n.syntax }
}
impl From<JsxSpreadAttribute> for SyntaxElement {
    fn from(n: JsxSpreadAttribute) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxSpreadChild {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_SPREAD_CHILD }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxSpreadChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSpreadChild")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxSpreadChild> for SyntaxNode {
    fn from(n: JsxSpreadChild) -> SyntaxNode { n.syntax }
}
impl From<JsxSpreadChild> for SyntaxElement {
    fn from(n: JsxSpreadChild) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxString {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_STRING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxString")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxString> for SyntaxNode {
    fn from(n: JsxString) -> SyntaxNode { n.syntax }
}
impl From<JsxString> for SyntaxElement {
    fn from(n: JsxString) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxTagExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_TAG_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxTagExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxTagExpression")
            .field("tag", &support::DebugSyntaxResult(self.tag()))
            .finish()
    }
}
impl From<JsxTagExpression> for SyntaxNode {
    fn from(n: JsxTagExpression) -> SyntaxNode { n.syntax }
}
impl From<JsxTagExpression> for SyntaxElement {
    fn from(n: JsxTagExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxText {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_TEXT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxText")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxText> for SyntaxNode {
    fn from(n: JsxText) -> SyntaxNode { n.syntax }
}
impl From<JsxText> for SyntaxElement {
    fn from(n: JsxText) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for NewTarget {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == NEW_TARGET }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for NewTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NewTarget")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field(
                "target_token",
                &support::DebugSyntaxResult(self.target_token()),
            )
            .finish()
    }
}
impl From<NewTarget> for SyntaxNode {
    fn from(n: NewTarget) -> SyntaxNode { n.syntax }
}
impl From<NewTarget> for SyntaxElement {
    fn from(n: NewTarget) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAbstractModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ABSTRACT_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAbstractModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAbstractModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsAbstractModifier> for SyntaxNode {
    fn from(n: TsAbstractModifier) -> SyntaxNode { n.syntax }
}
impl From<TsAbstractModifier> for SyntaxElement {
    fn from(n: TsAbstractModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAccessibilityModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ACCESSIBILITY_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAccessibilityModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAccessibilityModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsAccessibilityModifier> for SyntaxNode {
    fn from(n: TsAccessibilityModifier) -> SyntaxNode { n.syntax }
}
impl From<TsAccessibilityModifier> for SyntaxElement {
    fn from(n: TsAccessibilityModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAnyType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ANY_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAnyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAnyType")
            .field("any_token", &support::DebugSyntaxResult(self.any_token()))
            .finish()
    }
}
impl From<TsAnyType> for SyntaxNode {
    fn from(n: TsAnyType) -> SyntaxNode { n.syntax }
}
impl From<TsAnyType> for SyntaxElement {
    fn from(n: TsAnyType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsArrayType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ARRAY_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsArrayType")
            .field(
                "element_type",
                &support::DebugSyntaxResult(self.element_type()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsArrayType> for SyntaxNode {
    fn from(n: TsArrayType) -> SyntaxNode { n.syntax }
}
impl From<TsArrayType> for SyntaxElement {
    fn from(n: TsArrayType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAsAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_AS_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAsAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAsAssignment")
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAsAssignment> for SyntaxNode {
    fn from(n: TsAsAssignment) -> SyntaxNode { n.syntax }
}
impl From<TsAsAssignment> for SyntaxElement {
    fn from(n: TsAsAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAsExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_AS_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAsExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAsExpression")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAsExpression> for SyntaxNode {
    fn from(n: TsAsExpression) -> SyntaxNode { n.syntax }
}
impl From<TsAsExpression> for SyntaxElement {
    fn from(n: TsAsExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAssertsCondition {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ASSERTS_CONDITION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAssertsCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAssertsCondition")
            .field("is_token", &support::DebugSyntaxResult(self.is_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAssertsCondition> for SyntaxNode {
    fn from(n: TsAssertsCondition) -> SyntaxNode { n.syntax }
}
impl From<TsAssertsCondition> for SyntaxElement {
    fn from(n: TsAssertsCondition) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAssertsReturnType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ASSERTS_RETURN_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAssertsReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAssertsReturnType")
            .field(
                "asserts_token",
                &support::DebugSyntaxResult(self.asserts_token()),
            )
            .field(
                "parameter_name",
                &support::DebugSyntaxResult(self.parameter_name()),
            )
            .field(
                "predicate",
                &support::DebugOptionalElement(self.predicate()),
            )
            .finish()
    }
}
impl From<TsAssertsReturnType> for SyntaxNode {
    fn from(n: TsAssertsReturnType) -> SyntaxNode { n.syntax }
}
impl From<TsAssertsReturnType> for SyntaxElement {
    fn from(n: TsAssertsReturnType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsBigIntLiteralType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BIG_INT_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBigIntLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBigIntLiteralType")
            .field(
                "minus_token",
                &support::DebugOptionalElement(self.minus_token()),
            )
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsBigIntLiteralType> for SyntaxNode {
    fn from(n: TsBigIntLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsBigIntLiteralType> for SyntaxElement {
    fn from(n: TsBigIntLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsBigintType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BIGINT_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBigintType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBigintType")
            .field(
                "bigint_token",
                &support::DebugSyntaxResult(self.bigint_token()),
            )
            .finish()
    }
}
impl From<TsBigintType> for SyntaxNode {
    fn from(n: TsBigintType) -> SyntaxNode { n.syntax }
}
impl From<TsBigintType> for SyntaxElement {
    fn from(n: TsBigintType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsBooleanLiteralType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BOOLEAN_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBooleanLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBooleanLiteralType")
            .field("literal", &support::DebugSyntaxResult(self.literal()))
            .finish()
    }
}
impl From<TsBooleanLiteralType> for SyntaxNode {
    fn from(n: TsBooleanLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsBooleanLiteralType> for SyntaxElement {
    fn from(n: TsBooleanLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsBooleanType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BOOLEAN_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBooleanType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBooleanType")
            .field(
                "boolean_token",
                &support::DebugSyntaxResult(self.boolean_token()),
            )
            .finish()
    }
}
impl From<TsBooleanType> for SyntaxNode {
    fn from(n: TsBooleanType) -> SyntaxNode { n.syntax }
}
impl From<TsBooleanType> for SyntaxElement {
    fn from(n: TsBooleanType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsCallSignatureTypeMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CALL_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsCallSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsCallSignatureTypeMember")
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsCallSignatureTypeMember> for SyntaxNode {
    fn from(n: TsCallSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsCallSignatureTypeMember> for SyntaxElement {
    fn from(n: TsCallSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConditionalType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONDITIONAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConditionalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConditionalType")
            .field("check_type", &support::DebugSyntaxResult(self.check_type()))
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field(
                "extends_type",
                &support::DebugSyntaxResult(self.extends_type()),
            )
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field("true_type", &support::DebugSyntaxResult(self.true_type()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("false_type", &support::DebugSyntaxResult(self.false_type()))
            .finish()
    }
}
impl From<TsConditionalType> for SyntaxNode {
    fn from(n: TsConditionalType) -> SyntaxNode { n.syntax }
}
impl From<TsConditionalType> for SyntaxElement {
    fn from(n: TsConditionalType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConstructSignatureTypeMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConstructSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructSignatureTypeMember")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsConstructSignatureTypeMember> for SyntaxNode {
    fn from(n: TsConstructSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsConstructSignatureTypeMember> for SyntaxElement {
    fn from(n: TsConstructSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConstructorSignatureClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConstructorSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructorSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsConstructorSignatureClassMember> for SyntaxNode {
    fn from(n: TsConstructorSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsConstructorSignatureClassMember> for SyntaxElement {
    fn from(n: TsConstructorSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConstructorType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONSTRUCTOR_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConstructorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructorType")
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field(
                "return_type",
                &support::DebugSyntaxResult(self.return_type()),
            )
            .finish()
    }
}
impl From<TsConstructorType> for SyntaxNode {
    fn from(n: TsConstructorType) -> SyntaxNode { n.syntax }
}
impl From<TsConstructorType> for SyntaxElement {
    fn from(n: TsConstructorType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDeclareFunctionDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DECLARE_FUNCTION_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDeclareFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareFunctionDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsDeclareFunctionDeclaration> for SyntaxNode {
    fn from(n: TsDeclareFunctionDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsDeclareFunctionDeclaration> for SyntaxElement {
    fn from(n: TsDeclareFunctionDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDeclareModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DECLARE_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDeclareModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsDeclareModifier> for SyntaxNode {
    fn from(n: TsDeclareModifier) -> SyntaxNode { n.syntax }
}
impl From<TsDeclareModifier> for SyntaxElement {
    fn from(n: TsDeclareModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDeclareStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DECLARE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDeclareStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareStatement")
            .field(
                "declare_token",
                &support::DebugSyntaxResult(self.declare_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .finish()
    }
}
impl From<TsDeclareStatement> for SyntaxNode {
    fn from(n: TsDeclareStatement) -> SyntaxNode { n.syntax }
}
impl From<TsDeclareStatement> for SyntaxElement {
    fn from(n: TsDeclareStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDefaultTypeClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DEFAULT_TYPE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDefaultTypeClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefaultTypeClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsDefaultTypeClause> for SyntaxNode {
    fn from(n: TsDefaultTypeClause) -> SyntaxNode { n.syntax }
}
impl From<TsDefaultTypeClause> for SyntaxElement {
    fn from(n: TsDefaultTypeClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDefinitePropertyAnnotation {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DEFINITE_PROPERTY_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDefinitePropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefinitePropertyAnnotation")
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsDefinitePropertyAnnotation> for SyntaxNode {
    fn from(n: TsDefinitePropertyAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsDefinitePropertyAnnotation> for SyntaxElement {
    fn from(n: TsDefinitePropertyAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDefiniteVariableAnnotation {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DEFINITE_VARIABLE_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDefiniteVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefiniteVariableAnnotation")
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsDefiniteVariableAnnotation> for SyntaxNode {
    fn from(n: TsDefiniteVariableAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsDefiniteVariableAnnotation> for SyntaxElement {
    fn from(n: TsDefiniteVariableAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsEmptyExternalModuleDeclarationBody {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsEmptyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEmptyExternalModuleDeclarationBody")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsEmptyExternalModuleDeclarationBody> for SyntaxNode {
    fn from(n: TsEmptyExternalModuleDeclarationBody) -> SyntaxNode { n.syntax }
}
impl From<TsEmptyExternalModuleDeclarationBody> for SyntaxElement {
    fn from(n: TsEmptyExternalModuleDeclarationBody) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsEnumDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ENUM_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsEnumDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEnumDeclaration")
            .field(
                "const_token",
                &support::DebugOptionalElement(self.const_token()),
            )
            .field("enum_token", &support::DebugSyntaxResult(self.enum_token()))
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsEnumDeclaration> for SyntaxNode {
    fn from(n: TsEnumDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsEnumDeclaration> for SyntaxElement {
    fn from(n: TsEnumDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsEnumMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ENUM_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsEnumMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEnumMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<TsEnumMember> for SyntaxNode {
    fn from(n: TsEnumMember) -> SyntaxNode { n.syntax }
}
impl From<TsEnumMember> for SyntaxElement {
    fn from(n: TsEnumMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExportAsNamespaceClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXPORT_AS_NAMESPACE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExportAsNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportAsNamespaceClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "namespace_token",
                &support::DebugSyntaxResult(self.namespace_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsExportAsNamespaceClause> for SyntaxNode {
    fn from(n: TsExportAsNamespaceClause) -> SyntaxNode { n.syntax }
}
impl From<TsExportAsNamespaceClause> for SyntaxElement {
    fn from(n: TsExportAsNamespaceClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExportAssignmentClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXPORT_ASSIGNMENT_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExportAssignmentClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportAssignmentClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsExportAssignmentClause> for SyntaxNode {
    fn from(n: TsExportAssignmentClause) -> SyntaxNode { n.syntax }
}
impl From<TsExportAssignmentClause> for SyntaxElement {
    fn from(n: TsExportAssignmentClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExportDeclareClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXPORT_DECLARE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExportDeclareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportDeclareClause")
            .field(
                "declare_token",
                &support::DebugSyntaxResult(self.declare_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .finish()
    }
}
impl From<TsExportDeclareClause> for SyntaxNode {
    fn from(n: TsExportDeclareClause) -> SyntaxNode { n.syntax }
}
impl From<TsExportDeclareClause> for SyntaxElement {
    fn from(n: TsExportDeclareClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExtendsClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXTENDS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExtendsClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsExtendsClause> for SyntaxNode {
    fn from(n: TsExtendsClause) -> SyntaxNode { n.syntax }
}
impl From<TsExtendsClause> for SyntaxElement {
    fn from(n: TsExtendsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExternalModuleDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXTERNAL_MODULE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExternalModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExternalModuleDeclaration")
            .field(
                "module_token",
                &support::DebugSyntaxResult(self.module_token()),
            )
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field("body", &support::DebugOptionalElement(self.body()))
            .finish()
    }
}
impl From<TsExternalModuleDeclaration> for SyntaxNode {
    fn from(n: TsExternalModuleDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsExternalModuleDeclaration> for SyntaxElement {
    fn from(n: TsExternalModuleDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExternalModuleReference {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXTERNAL_MODULE_REFERENCE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExternalModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExternalModuleReference")
            .field(
                "require_token",
                &support::DebugSyntaxResult(self.require_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<TsExternalModuleReference> for SyntaxNode {
    fn from(n: TsExternalModuleReference) -> SyntaxNode { n.syntax }
}
impl From<TsExternalModuleReference> for SyntaxElement {
    fn from(n: TsExternalModuleReference) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsFunctionType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_FUNCTION_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsFunctionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsFunctionType")
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field(
                "return_type",
                &support::DebugSyntaxResult(self.return_type()),
            )
            .finish()
    }
}
impl From<TsFunctionType> for SyntaxNode {
    fn from(n: TsFunctionType) -> SyntaxNode { n.syntax }
}
impl From<TsFunctionType> for SyntaxElement {
    fn from(n: TsFunctionType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsGetterSignatureClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_GETTER_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsGetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGetterSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsGetterSignatureClassMember> for SyntaxNode {
    fn from(n: TsGetterSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsGetterSignatureClassMember> for SyntaxElement {
    fn from(n: TsGetterSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsGetterSignatureTypeMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_GETTER_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsGetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGetterSignatureTypeMember")
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsGetterSignatureTypeMember> for SyntaxNode {
    fn from(n: TsGetterSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsGetterSignatureTypeMember> for SyntaxElement {
    fn from(n: TsGetterSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsGlobalDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_GLOBAL_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsGlobalDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGlobalDeclaration")
            .field(
                "global_token",
                &support::DebugSyntaxResult(self.global_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<TsGlobalDeclaration> for SyntaxNode {
    fn from(n: TsGlobalDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsGlobalDeclaration> for SyntaxElement {
    fn from(n: TsGlobalDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIdentifierBinding {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IDENTIFIER_BINDING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIdentifierBinding")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<TsIdentifierBinding> for SyntaxNode {
    fn from(n: TsIdentifierBinding) -> SyntaxNode { n.syntax }
}
impl From<TsIdentifierBinding> for SyntaxElement {
    fn from(n: TsIdentifierBinding) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsImplementsClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IMPLEMENTS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsImplementsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImplementsClause")
            .field(
                "implements_token",
                &support::DebugSyntaxResult(self.implements_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsImplementsClause> for SyntaxNode {
    fn from(n: TsImplementsClause) -> SyntaxNode { n.syntax }
}
impl From<TsImplementsClause> for SyntaxElement {
    fn from(n: TsImplementsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsImportEqualsDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IMPORT_EQUALS_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsImportEqualsDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportEqualsDeclaration")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field(
                "module_reference",
                &support::DebugSyntaxResult(self.module_reference()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsImportEqualsDeclaration> for SyntaxNode {
    fn from(n: TsImportEqualsDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsImportEqualsDeclaration> for SyntaxElement {
    fn from(n: TsImportEqualsDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsImportType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IMPORT_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsImportType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportType")
            .field(
                "typeof_token",
                &support::DebugOptionalElement(self.typeof_token()),
            )
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "argument_token",
                &support::DebugSyntaxResult(self.argument_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "qualifier_clause",
                &support::DebugOptionalElement(self.qualifier_clause()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsImportType> for SyntaxNode {
    fn from(n: TsImportType) -> SyntaxNode { n.syntax }
}
impl From<TsImportType> for SyntaxElement {
    fn from(n: TsImportType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsImportTypeQualifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IMPORT_TYPE_QUALIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsImportTypeQualifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportTypeQualifier")
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsImportTypeQualifier> for SyntaxNode {
    fn from(n: TsImportTypeQualifier) -> SyntaxNode { n.syntax }
}
impl From<TsImportTypeQualifier> for SyntaxElement {
    fn from(n: TsImportTypeQualifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIndexSignatureClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEX_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIndexSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureClassMember> for SyntaxNode {
    fn from(n: TsIndexSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsIndexSignatureClassMember> for SyntaxElement {
    fn from(n: TsIndexSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIndexSignatureParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEX_SIGNATURE_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIndexSignatureParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureParameter")
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureParameter> for SyntaxNode {
    fn from(n: TsIndexSignatureParameter) -> SyntaxNode { n.syntax }
}
impl From<TsIndexSignatureParameter> for SyntaxElement {
    fn from(n: TsIndexSignatureParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIndexSignatureTypeMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEX_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIndexSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureTypeMember")
            .field(
                "readonly_token",
                &support::DebugOptionalElement(self.readonly_token()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureTypeMember> for SyntaxNode {
    fn from(n: TsIndexSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsIndexSignatureTypeMember> for SyntaxElement {
    fn from(n: TsIndexSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIndexedAccessType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEXED_ACCESS_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIndexedAccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexedAccessType")
            .field(
                "object_type",
                &support::DebugSyntaxResult(self.object_type()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("index_type", &support::DebugSyntaxResult(self.index_type()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsIndexedAccessType> for SyntaxNode {
    fn from(n: TsIndexedAccessType) -> SyntaxNode { n.syntax }
}
impl From<TsIndexedAccessType> for SyntaxElement {
    fn from(n: TsIndexedAccessType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsInferType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INFER_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsInferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInferType")
            .field(
                "infer_token",
                &support::DebugSyntaxResult(self.infer_token()),
            )
            .field(
                "type_parameter",
                &support::DebugSyntaxResult(self.type_parameter()),
            )
            .finish()
    }
}
impl From<TsInferType> for SyntaxNode {
    fn from(n: TsInferType) -> SyntaxNode { n.syntax }
}
impl From<TsInferType> for SyntaxElement {
    fn from(n: TsInferType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsInterfaceDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INTERFACE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsInterfaceDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInterfaceDeclaration")
            .field(
                "interface_token",
                &support::DebugSyntaxResult(self.interface_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsInterfaceDeclaration> for SyntaxNode {
    fn from(n: TsInterfaceDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsInterfaceDeclaration> for SyntaxElement {
    fn from(n: TsInterfaceDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIntersectionType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INTERSECTION_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIntersectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIntersectionType")
            .field(
                "leading_separator_token",
                &support::DebugOptionalElement(self.leading_separator_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsIntersectionType> for SyntaxNode {
    fn from(n: TsIntersectionType) -> SyntaxNode { n.syntax }
}
impl From<TsIntersectionType> for SyntaxElement {
    fn from(n: TsIntersectionType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMappedType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MAPPED_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMappedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedType")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "readonly_modifier",
                &support::DebugOptionalElement(self.readonly_modifier()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field(
                "property_name",
                &support::DebugSyntaxResult(self.property_name()),
            )
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("keys_type", &support::DebugSyntaxResult(self.keys_type()))
            .field(
                "as_clause",
                &support::DebugOptionalElement(self.as_clause()),
            )
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "optional_modifier",
                &support::DebugOptionalElement(self.optional_modifier()),
            )
            .field(
                "mapped_type",
                &support::DebugOptionalElement(self.mapped_type()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsMappedType> for SyntaxNode {
    fn from(n: TsMappedType) -> SyntaxNode { n.syntax }
}
impl From<TsMappedType> for SyntaxElement {
    fn from(n: TsMappedType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMappedTypeAsClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MAPPED_TYPE_AS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMappedTypeAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeAsClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsMappedTypeAsClause> for SyntaxNode {
    fn from(n: TsMappedTypeAsClause) -> SyntaxNode { n.syntax }
}
impl From<TsMappedTypeAsClause> for SyntaxElement {
    fn from(n: TsMappedTypeAsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMappedTypeOptionalModifierClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MAPPED_TYPE_OPTIONAL_MODIFIER_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMappedTypeOptionalModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeOptionalModifierClause")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .finish()
    }
}
impl From<TsMappedTypeOptionalModifierClause> for SyntaxNode {
    fn from(n: TsMappedTypeOptionalModifierClause) -> SyntaxNode { n.syntax }
}
impl From<TsMappedTypeOptionalModifierClause> for SyntaxElement {
    fn from(n: TsMappedTypeOptionalModifierClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMappedTypeReadonlyModifierClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MAPPED_TYPE_READONLY_MODIFIER_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMappedTypeReadonlyModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeReadonlyModifierClause")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field(
                "readonly_token",
                &support::DebugSyntaxResult(self.readonly_token()),
            )
            .finish()
    }
}
impl From<TsMappedTypeReadonlyModifierClause> for SyntaxNode {
    fn from(n: TsMappedTypeReadonlyModifierClause) -> SyntaxNode { n.syntax }
}
impl From<TsMappedTypeReadonlyModifierClause> for SyntaxElement {
    fn from(n: TsMappedTypeReadonlyModifierClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMethodSignatureClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_METHOD_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMethodSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMethodSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsMethodSignatureClassMember> for SyntaxNode {
    fn from(n: TsMethodSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsMethodSignatureClassMember> for SyntaxElement {
    fn from(n: TsMethodSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMethodSignatureTypeMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_METHOD_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMethodSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMethodSignatureTypeMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "optional_token",
                &support::DebugOptionalElement(self.optional_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsMethodSignatureTypeMember> for SyntaxNode {
    fn from(n: TsMethodSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsMethodSignatureTypeMember> for SyntaxElement {
    fn from(n: TsMethodSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsModuleBlock {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MODULE_BLOCK }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsModuleBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsModuleBlock")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("items", &self.items())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsModuleBlock> for SyntaxNode {
    fn from(n: TsModuleBlock) -> SyntaxNode { n.syntax }
}
impl From<TsModuleBlock> for SyntaxElement {
    fn from(n: TsModuleBlock) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsModuleDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MODULE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsModuleDeclaration")
            .field(
                "module_or_namespace",
                &support::DebugSyntaxResult(self.module_or_namespace()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<TsModuleDeclaration> for SyntaxNode {
    fn from(n: TsModuleDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsModuleDeclaration> for SyntaxElement {
    fn from(n: TsModuleDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNameWithTypeArguments {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NAME_WITH_TYPE_ARGUMENTS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNameWithTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNameWithTypeArguments")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsNameWithTypeArguments> for SyntaxNode {
    fn from(n: TsNameWithTypeArguments) -> SyntaxNode { n.syntax }
}
impl From<TsNameWithTypeArguments> for SyntaxElement {
    fn from(n: TsNameWithTypeArguments) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNamedTupleTypeElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NAMED_TUPLE_TYPE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNamedTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNamedTupleTypeElement")
            .field(
                "dotdotdot_token",
                &support::DebugOptionalElement(self.dotdotdot_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsNamedTupleTypeElement> for SyntaxNode {
    fn from(n: TsNamedTupleTypeElement) -> SyntaxNode { n.syntax }
}
impl From<TsNamedTupleTypeElement> for SyntaxElement {
    fn from(n: TsNamedTupleTypeElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNeverType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NEVER_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNeverType")
            .field(
                "never_token",
                &support::DebugSyntaxResult(self.never_token()),
            )
            .finish()
    }
}
impl From<TsNeverType> for SyntaxNode {
    fn from(n: TsNeverType) -> SyntaxNode { n.syntax }
}
impl From<TsNeverType> for SyntaxElement {
    fn from(n: TsNeverType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNonNullAssertionAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NON_NULL_ASSERTION_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNonNullAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonNullAssertionAssignment")
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .finish()
    }
}
impl From<TsNonNullAssertionAssignment> for SyntaxNode {
    fn from(n: TsNonNullAssertionAssignment) -> SyntaxNode { n.syntax }
}
impl From<TsNonNullAssertionAssignment> for SyntaxElement {
    fn from(n: TsNonNullAssertionAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNonNullAssertionExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NON_NULL_ASSERTION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNonNullAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonNullAssertionExpression")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .finish()
    }
}
impl From<TsNonNullAssertionExpression> for SyntaxNode {
    fn from(n: TsNonNullAssertionExpression) -> SyntaxNode { n.syntax }
}
impl From<TsNonNullAssertionExpression> for SyntaxElement {
    fn from(n: TsNonNullAssertionExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNonPrimitiveType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NON_PRIMITIVE_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNonPrimitiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonPrimitiveType")
            .field(
                "object_token",
                &support::DebugSyntaxResult(self.object_token()),
            )
            .finish()
    }
}
impl From<TsNonPrimitiveType> for SyntaxNode {
    fn from(n: TsNonPrimitiveType) -> SyntaxNode { n.syntax }
}
impl From<TsNonPrimitiveType> for SyntaxElement {
    fn from(n: TsNonPrimitiveType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNullLiteralType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NULL_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNullLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNullLiteralType")
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsNullLiteralType> for SyntaxNode {
    fn from(n: TsNullLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsNullLiteralType> for SyntaxElement {
    fn from(n: TsNullLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNumberLiteralType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NUMBER_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNumberLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNumberLiteralType")
            .field(
                "minus_token",
                &support::DebugOptionalElement(self.minus_token()),
            )
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsNumberLiteralType> for SyntaxNode {
    fn from(n: TsNumberLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsNumberLiteralType> for SyntaxElement {
    fn from(n: TsNumberLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNumberType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NUMBER_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNumberType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNumberType")
            .field(
                "number_token",
                &support::DebugSyntaxResult(self.number_token()),
            )
            .finish()
    }
}
impl From<TsNumberType> for SyntaxNode {
    fn from(n: TsNumberType) -> SyntaxNode { n.syntax }
}
impl From<TsNumberType> for SyntaxElement {
    fn from(n: TsNumberType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsObjectType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OBJECT_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsObjectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsObjectType")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsObjectType> for SyntaxNode {
    fn from(n: TsObjectType) -> SyntaxNode { n.syntax }
}
impl From<TsObjectType> for SyntaxElement {
    fn from(n: TsObjectType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsOptionalPropertyAnnotation {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OPTIONAL_PROPERTY_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsOptionalPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOptionalPropertyAnnotation")
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsOptionalPropertyAnnotation> for SyntaxNode {
    fn from(n: TsOptionalPropertyAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsOptionalPropertyAnnotation> for SyntaxElement {
    fn from(n: TsOptionalPropertyAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsOptionalTupleTypeElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OPTIONAL_TUPLE_TYPE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsOptionalTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOptionalTupleTypeElement")
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .finish()
    }
}
impl From<TsOptionalTupleTypeElement> for SyntaxNode {
    fn from(n: TsOptionalTupleTypeElement) -> SyntaxNode { n.syntax }
}
impl From<TsOptionalTupleTypeElement> for SyntaxElement {
    fn from(n: TsOptionalTupleTypeElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsOverrideModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OVERRIDE_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsOverrideModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOverrideModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsOverrideModifier> for SyntaxNode {
    fn from(n: TsOverrideModifier) -> SyntaxNode { n.syntax }
}
impl From<TsOverrideModifier> for SyntaxElement {
    fn from(n: TsOverrideModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsParenthesizedType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PARENTHESIZED_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsParenthesizedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsParenthesizedType")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<TsParenthesizedType> for SyntaxNode {
    fn from(n: TsParenthesizedType) -> SyntaxNode { n.syntax }
}
impl From<TsParenthesizedType> for SyntaxElement {
    fn from(n: TsParenthesizedType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsPredicateReturnType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PREDICATE_RETURN_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsPredicateReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPredicateReturnType")
            .field(
                "parameter_name",
                &support::DebugSyntaxResult(self.parameter_name()),
            )
            .field("is_token", &support::DebugSyntaxResult(self.is_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsPredicateReturnType> for SyntaxNode {
    fn from(n: TsPredicateReturnType) -> SyntaxNode { n.syntax }
}
impl From<TsPredicateReturnType> for SyntaxElement {
    fn from(n: TsPredicateReturnType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsPropertyParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsPropertyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertyParameter")
            .field("modifiers", &self.modifiers())
            .field(
                "formal_parameter",
                &support::DebugSyntaxResult(self.formal_parameter()),
            )
            .finish()
    }
}
impl From<TsPropertyParameter> for SyntaxNode {
    fn from(n: TsPropertyParameter) -> SyntaxNode { n.syntax }
}
impl From<TsPropertyParameter> for SyntaxElement {
    fn from(n: TsPropertyParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsPropertySignatureClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsPropertySignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertySignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "property_annotation",
                &support::DebugOptionalElement(self.property_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsPropertySignatureClassMember> for SyntaxNode {
    fn from(n: TsPropertySignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsPropertySignatureClassMember> for SyntaxElement {
    fn from(n: TsPropertySignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsPropertySignatureTypeMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsPropertySignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertySignatureTypeMember")
            .field(
                "readonly_token",
                &support::DebugOptionalElement(self.readonly_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "optional_token",
                &support::DebugOptionalElement(self.optional_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsPropertySignatureTypeMember> for SyntaxNode {
    fn from(n: TsPropertySignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsPropertySignatureTypeMember> for SyntaxElement {
    fn from(n: TsPropertySignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsQualifiedModuleName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_QUALIFIED_MODULE_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsQualifiedModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsQualifiedModuleName")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsQualifiedModuleName> for SyntaxNode {
    fn from(n: TsQualifiedModuleName) -> SyntaxNode { n.syntax }
}
impl From<TsQualifiedModuleName> for SyntaxElement {
    fn from(n: TsQualifiedModuleName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsQualifiedName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_QUALIFIED_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsQualifiedName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsQualifiedName")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsQualifiedName> for SyntaxNode {
    fn from(n: TsQualifiedName) -> SyntaxNode { n.syntax }
}
impl From<TsQualifiedName> for SyntaxElement {
    fn from(n: TsQualifiedName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsReadonlyModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_READONLY_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsReadonlyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReadonlyModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsReadonlyModifier> for SyntaxNode {
    fn from(n: TsReadonlyModifier) -> SyntaxNode { n.syntax }
}
impl From<TsReadonlyModifier> for SyntaxElement {
    fn from(n: TsReadonlyModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsReferenceType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_REFERENCE_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsReferenceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReferenceType")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsReferenceType> for SyntaxNode {
    fn from(n: TsReferenceType) -> SyntaxNode { n.syntax }
}
impl From<TsReferenceType> for SyntaxElement {
    fn from(n: TsReferenceType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsRestTupleTypeElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_REST_TUPLE_TYPE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsRestTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsRestTupleTypeElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsRestTupleTypeElement> for SyntaxNode {
    fn from(n: TsRestTupleTypeElement) -> SyntaxNode { n.syntax }
}
impl From<TsRestTupleTypeElement> for SyntaxElement {
    fn from(n: TsRestTupleTypeElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsReturnTypeAnnotation {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_RETURN_TYPE_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsReturnTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReturnTypeAnnotation")
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsReturnTypeAnnotation> for SyntaxNode {
    fn from(n: TsReturnTypeAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsReturnTypeAnnotation> for SyntaxElement {
    fn from(n: TsReturnTypeAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsSetterSignatureClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_SETTER_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsSetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSetterSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsSetterSignatureClassMember> for SyntaxNode {
    fn from(n: TsSetterSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsSetterSignatureClassMember> for SyntaxElement {
    fn from(n: TsSetterSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsSetterSignatureTypeMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_SETTER_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsSetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSetterSignatureTypeMember")
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsSetterSignatureTypeMember> for SyntaxNode {
    fn from(n: TsSetterSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsSetterSignatureTypeMember> for SyntaxElement {
    fn from(n: TsSetterSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsStringLiteralType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_STRING_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsStringLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsStringLiteralType")
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsStringLiteralType> for SyntaxNode {
    fn from(n: TsStringLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsStringLiteralType> for SyntaxElement {
    fn from(n: TsStringLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsStringType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_STRING_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsStringType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsStringType")
            .field(
                "string_token",
                &support::DebugSyntaxResult(self.string_token()),
            )
            .finish()
    }
}
impl From<TsStringType> for SyntaxNode {
    fn from(n: TsStringType) -> SyntaxNode { n.syntax }
}
impl From<TsStringType> for SyntaxElement {
    fn from(n: TsStringType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsSymbolType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_SYMBOL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsSymbolType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSymbolType")
            .field(
                "symbol_token",
                &support::DebugSyntaxResult(self.symbol_token()),
            )
            .finish()
    }
}
impl From<TsSymbolType> for SyntaxNode {
    fn from(n: TsSymbolType) -> SyntaxNode { n.syntax }
}
impl From<TsSymbolType> for SyntaxElement {
    fn from(n: TsSymbolType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTemplateChunkElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TEMPLATE_CHUNK_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateChunkElement")
            .field(
                "template_chunk_token",
                &support::DebugSyntaxResult(self.template_chunk_token()),
            )
            .finish()
    }
}
impl From<TsTemplateChunkElement> for SyntaxNode {
    fn from(n: TsTemplateChunkElement) -> SyntaxNode { n.syntax }
}
impl From<TsTemplateChunkElement> for SyntaxElement {
    fn from(n: TsTemplateChunkElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTemplateElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TEMPLATE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateElement")
            .field(
                "dollar_curly_token",
                &support::DebugSyntaxResult(self.dollar_curly_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsTemplateElement> for SyntaxNode {
    fn from(n: TsTemplateElement) -> SyntaxNode { n.syntax }
}
impl From<TsTemplateElement> for SyntaxElement {
    fn from(n: TsTemplateElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTemplateLiteralType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TEMPLATE_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTemplateLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateLiteralType")
            .field(
                "l_tick_token",
                &support::DebugSyntaxResult(self.l_tick_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_tick_token",
                &support::DebugSyntaxResult(self.r_tick_token()),
            )
            .finish()
    }
}
impl From<TsTemplateLiteralType> for SyntaxNode {
    fn from(n: TsTemplateLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsTemplateLiteralType> for SyntaxElement {
    fn from(n: TsTemplateLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsThisParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_THIS_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsThisParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsThisParameter")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsThisParameter> for SyntaxNode {
    fn from(n: TsThisParameter) -> SyntaxNode { n.syntax }
}
impl From<TsThisParameter> for SyntaxElement {
    fn from(n: TsThisParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsThisType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_THIS_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsThisType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsThisType")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .finish()
    }
}
impl From<TsThisType> for SyntaxNode {
    fn from(n: TsThisType) -> SyntaxNode { n.syntax }
}
impl From<TsThisType> for SyntaxElement {
    fn from(n: TsThisType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTupleType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TUPLE_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTupleType")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsTupleType> for SyntaxNode {
    fn from(n: TsTupleType) -> SyntaxNode { n.syntax }
}
impl From<TsTupleType> for SyntaxElement {
    fn from(n: TsTupleType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeAliasDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ALIAS_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeAliasDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAliasDeclaration")
            .field("type_token", &support::DebugSyntaxResult(self.type_token()))
            .field(
                "binding_identifier",
                &support::DebugSyntaxResult(self.binding_identifier()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsTypeAliasDeclaration> for SyntaxNode {
    fn from(n: TsTypeAliasDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsTypeAliasDeclaration> for SyntaxElement {
    fn from(n: TsTypeAliasDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeAnnotation {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAnnotation")
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeAnnotation> for SyntaxNode {
    fn from(n: TsTypeAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsTypeAnnotation> for SyntaxElement {
    fn from(n: TsTypeAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeArguments {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ARGUMENTS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeArguments")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ts_type_argument_list", &self.ts_type_argument_list())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<TsTypeArguments> for SyntaxNode {
    fn from(n: TsTypeArguments) -> SyntaxNode { n.syntax }
}
impl From<TsTypeArguments> for SyntaxElement {
    fn from(n: TsTypeArguments) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeAssertionAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ASSERTION_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAssertionAssignment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .finish()
    }
}
impl From<TsTypeAssertionAssignment> for SyntaxNode {
    fn from(n: TsTypeAssertionAssignment) -> SyntaxNode { n.syntax }
}
impl From<TsTypeAssertionAssignment> for SyntaxElement {
    fn from(n: TsTypeAssertionAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeAssertionExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ASSERTION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAssertionExpression")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<TsTypeAssertionExpression> for SyntaxNode {
    fn from(n: TsTypeAssertionExpression) -> SyntaxNode { n.syntax }
}
impl From<TsTypeAssertionExpression> for SyntaxElement {
    fn from(n: TsTypeAssertionExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeConstraintClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_CONSTRAINT_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeConstraintClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeConstraintClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeConstraintClause> for SyntaxNode {
    fn from(n: TsTypeConstraintClause) -> SyntaxNode { n.syntax }
}
impl From<TsTypeConstraintClause> for SyntaxElement {
    fn from(n: TsTypeConstraintClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeOperatorType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_OPERATOR_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeOperatorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeOperatorType")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeOperatorType> for SyntaxNode {
    fn from(n: TsTypeOperatorType) -> SyntaxNode { n.syntax }
}
impl From<TsTypeOperatorType> for SyntaxElement {
    fn from(n: TsTypeOperatorType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameter")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "constraint",
                &support::DebugOptionalElement(self.constraint()),
            )
            .field("default", &support::DebugOptionalElement(self.default()))
            .finish()
    }
}
impl From<TsTypeParameter> for SyntaxNode {
    fn from(n: TsTypeParameter) -> SyntaxNode { n.syntax }
}
impl From<TsTypeParameter> for SyntaxElement {
    fn from(n: TsTypeParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeParameterName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameterName")
            .field(
                "ident_token",
                &support::DebugSyntaxResult(self.ident_token()),
            )
            .finish()
    }
}
impl From<TsTypeParameterName> for SyntaxNode {
    fn from(n: TsTypeParameterName) -> SyntaxNode { n.syntax }
}
impl From<TsTypeParameterName> for SyntaxElement {
    fn from(n: TsTypeParameterName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeParameters {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETERS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameters")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("items", &self.items())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<TsTypeParameters> for SyntaxNode {
    fn from(n: TsTypeParameters) -> SyntaxNode { n.syntax }
}
impl From<TsTypeParameters> for SyntaxElement {
    fn from(n: TsTypeParameters) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeofType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPEOF_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeofType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeofType")
            .field(
                "typeof_token",
                &support::DebugSyntaxResult(self.typeof_token()),
            )
            .field(
                "expression_name",
                &support::DebugSyntaxResult(self.expression_name()),
            )
            .finish()
    }
}
impl From<TsTypeofType> for SyntaxNode {
    fn from(n: TsTypeofType) -> SyntaxNode { n.syntax }
}
impl From<TsTypeofType> for SyntaxElement {
    fn from(n: TsTypeofType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsUndefinedType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_UNDEFINED_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsUndefinedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUndefinedType")
            .field(
                "undefined_token",
                &support::DebugSyntaxResult(self.undefined_token()),
            )
            .finish()
    }
}
impl From<TsUndefinedType> for SyntaxNode {
    fn from(n: TsUndefinedType) -> SyntaxNode { n.syntax }
}
impl From<TsUndefinedType> for SyntaxElement {
    fn from(n: TsUndefinedType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsUnionType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_UNION_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsUnionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUnionType")
            .field(
                "leading_separator_token",
                &support::DebugOptionalElement(self.leading_separator_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsUnionType> for SyntaxNode {
    fn from(n: TsUnionType) -> SyntaxNode { n.syntax }
}
impl From<TsUnionType> for SyntaxElement {
    fn from(n: TsUnionType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsUnknownType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_UNKNOWN_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsUnknownType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUnknownType")
            .field(
                "unknown_token",
                &support::DebugSyntaxResult(self.unknown_token()),
            )
            .finish()
    }
}
impl From<TsUnknownType> for SyntaxNode {
    fn from(n: TsUnknownType) -> SyntaxNode { n.syntax }
}
impl From<TsUnknownType> for SyntaxElement {
    fn from(n: TsUnknownType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsVoidType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_VOID_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsVoidType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsVoidType")
            .field("void_token", &support::DebugSyntaxResult(self.void_token()))
            .finish()
    }
}
impl From<TsVoidType> for SyntaxNode {
    fn from(n: TsVoidType) -> SyntaxNode { n.syntax }
}
impl From<TsVoidType> for SyntaxElement {
    fn from(n: TsVoidType) -> SyntaxElement { n.syntax.into() }
}
impl From<JsArrayAssignmentPatternRestElement> for JsAnyArrayAssignmentPatternElement {
    fn from(node: JsArrayAssignmentPatternRestElement) -> JsAnyArrayAssignmentPatternElement {
        JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(node)
    }
}
impl From<JsArrayHole> for JsAnyArrayAssignmentPatternElement {
    fn from(node: JsArrayHole) -> JsAnyArrayAssignmentPatternElement {
        JsAnyArrayAssignmentPatternElement::JsArrayHole(node)
    }
}
impl From<JsAssignmentWithDefault> for JsAnyArrayAssignmentPatternElement {
    fn from(node: JsAssignmentWithDefault) -> JsAnyArrayAssignmentPatternElement {
        JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(node)
    }
}
impl AstNode for JsAnyArrayAssignmentPatternElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT
            | JS_ARRAY_HOLE
            | JS_ASSIGNMENT_WITH_DEFAULT => true,
            k if JsAnyAssignmentPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT => {
                JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(
                    JsArrayAssignmentPatternRestElement { syntax },
                )
            }
            JS_ARRAY_HOLE => {
                JsAnyArrayAssignmentPatternElement::JsArrayHole(JsArrayHole { syntax })
            }
            JS_ASSIGNMENT_WITH_DEFAULT => {
                JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(
                    JsAssignmentWithDefault { syntax },
                )
            }
            _ => {
                if let Some(js_any_assignment_pattern) = JsAnyAssignmentPattern::cast(syntax) {
                    return Some(JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(
                        js_any_assignment_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                &it.syntax
            }
            JsAnyArrayAssignmentPatternElement::JsArrayHole(it) => &it.syntax,
            JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => &it.syntax,
            JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                it.syntax
            }
            JsAnyArrayAssignmentPatternElement::JsArrayHole(it) => it.syntax,
            JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => it.syntax,
            JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyArrayAssignmentPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyArrayAssignmentPatternElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyArrayAssignmentPatternElement> for SyntaxNode {
    fn from(n: JsAnyArrayAssignmentPatternElement) -> SyntaxNode {
        match n {
            JsAnyArrayAssignmentPatternElement::JsAnyAssignmentPattern(it) => it.into(),
            JsAnyArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                it.into()
            }
            JsAnyArrayAssignmentPatternElement::JsArrayHole(it) => it.into(),
            JsAnyArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => it.into(),
        }
    }
}
impl From<JsAnyArrayAssignmentPatternElement> for SyntaxElement {
    fn from(n: JsAnyArrayAssignmentPatternElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayBindingPatternRestElement> for JsAnyArrayBindingPatternElement {
    fn from(node: JsArrayBindingPatternRestElement) -> JsAnyArrayBindingPatternElement {
        JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(node)
    }
}
impl From<JsArrayHole> for JsAnyArrayBindingPatternElement {
    fn from(node: JsArrayHole) -> JsAnyArrayBindingPatternElement {
        JsAnyArrayBindingPatternElement::JsArrayHole(node)
    }
}
impl From<JsBindingPatternWithDefault> for JsAnyArrayBindingPatternElement {
    fn from(node: JsBindingPatternWithDefault) -> JsAnyArrayBindingPatternElement {
        JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(node)
    }
}
impl AstNode for JsAnyArrayBindingPatternElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_BINDING_PATTERN_REST_ELEMENT
            | JS_ARRAY_HOLE
            | JS_BINDING_PATTERN_WITH_DEFAULT => true,
            k if JsAnyBindingPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_BINDING_PATTERN_REST_ELEMENT => {
                JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(
                    JsArrayBindingPatternRestElement { syntax },
                )
            }
            JS_ARRAY_HOLE => JsAnyArrayBindingPatternElement::JsArrayHole(JsArrayHole { syntax }),
            JS_BINDING_PATTERN_WITH_DEFAULT => {
                JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(
                    JsBindingPatternWithDefault { syntax },
                )
            }
            _ => {
                if let Some(js_any_binding_pattern) = JsAnyBindingPattern::cast(syntax) {
                    return Some(JsAnyArrayBindingPatternElement::JsAnyBindingPattern(
                        js_any_binding_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => &it.syntax,
            JsAnyArrayBindingPatternElement::JsArrayHole(it) => &it.syntax,
            JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(it) => &it.syntax,
            JsAnyArrayBindingPatternElement::JsAnyBindingPattern(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => it.syntax,
            JsAnyArrayBindingPatternElement::JsArrayHole(it) => it.syntax,
            JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(it) => it.syntax,
            JsAnyArrayBindingPatternElement::JsAnyBindingPattern(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyArrayBindingPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyArrayBindingPatternElement::JsAnyBindingPattern(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyArrayBindingPatternElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyArrayBindingPatternElement> for SyntaxNode {
    fn from(n: JsAnyArrayBindingPatternElement) -> SyntaxNode {
        match n {
            JsAnyArrayBindingPatternElement::JsAnyBindingPattern(it) => it.into(),
            JsAnyArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => it.into(),
            JsAnyArrayBindingPatternElement::JsArrayHole(it) => it.into(),
            JsAnyArrayBindingPatternElement::JsBindingPatternWithDefault(it) => it.into(),
        }
    }
}
impl From<JsAnyArrayBindingPatternElement> for SyntaxElement {
    fn from(n: JsAnyArrayBindingPatternElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayHole> for JsAnyArrayElement {
    fn from(node: JsArrayHole) -> JsAnyArrayElement { JsAnyArrayElement::JsArrayHole(node) }
}
impl From<JsSpread> for JsAnyArrayElement {
    fn from(node: JsSpread) -> JsAnyArrayElement { JsAnyArrayElement::JsSpread(node) }
}
impl AstNode for JsAnyArrayElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_HOLE | JS_SPREAD => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_HOLE => JsAnyArrayElement::JsArrayHole(JsArrayHole { syntax }),
            JS_SPREAD => JsAnyArrayElement::JsSpread(JsSpread { syntax }),
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyArrayElement::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyArrayElement::JsArrayHole(it) => &it.syntax,
            JsAnyArrayElement::JsSpread(it) => &it.syntax,
            JsAnyArrayElement::JsAnyExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyArrayElement::JsArrayHole(it) => it.syntax,
            JsAnyArrayElement::JsSpread(it) => it.syntax,
            JsAnyArrayElement::JsAnyExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyArrayElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyArrayElement::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrayElement::JsSpread(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyArrayElement> for SyntaxNode {
    fn from(n: JsAnyArrayElement) -> SyntaxNode {
        match n {
            JsAnyArrayElement::JsAnyExpression(it) => it.into(),
            JsAnyArrayElement::JsArrayHole(it) => it.into(),
            JsAnyArrayElement::JsSpread(it) => it.into(),
        }
    }
}
impl From<JsAnyArrayElement> for SyntaxElement {
    fn from(n: JsAnyArrayElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsParameters> for JsAnyArrowFunctionParameters {
    fn from(node: JsParameters) -> JsAnyArrowFunctionParameters {
        JsAnyArrowFunctionParameters::JsParameters(node)
    }
}
impl AstNode for JsAnyArrowFunctionParameters {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_PARAMETERS => true,
            k if JsAnyBinding::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_PARAMETERS => JsAnyArrowFunctionParameters::JsParameters(JsParameters { syntax }),
            _ => {
                if let Some(js_any_binding) = JsAnyBinding::cast(syntax) {
                    return Some(JsAnyArrowFunctionParameters::JsAnyBinding(js_any_binding));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyArrowFunctionParameters::JsParameters(it) => &it.syntax,
            JsAnyArrowFunctionParameters::JsAnyBinding(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyArrowFunctionParameters::JsParameters(it) => it.syntax,
            JsAnyArrowFunctionParameters::JsAnyBinding(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyArrowFunctionParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyArrowFunctionParameters::JsAnyBinding(it) => std::fmt::Debug::fmt(it, f),
            JsAnyArrowFunctionParameters::JsParameters(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyArrowFunctionParameters> for SyntaxNode {
    fn from(n: JsAnyArrowFunctionParameters) -> SyntaxNode {
        match n {
            JsAnyArrowFunctionParameters::JsAnyBinding(it) => it.into(),
            JsAnyArrowFunctionParameters::JsParameters(it) => it.into(),
        }
    }
}
impl From<JsAnyArrowFunctionParameters> for SyntaxElement {
    fn from(n: JsAnyArrowFunctionParameters) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsComputedMemberAssignment> for JsAnyAssignment {
    fn from(node: JsComputedMemberAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsComputedMemberAssignment(node)
    }
}
impl From<JsIdentifierAssignment> for JsAnyAssignment {
    fn from(node: JsIdentifierAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsIdentifierAssignment(node)
    }
}
impl From<JsParenthesizedAssignment> for JsAnyAssignment {
    fn from(node: JsParenthesizedAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsParenthesizedAssignment(node)
    }
}
impl From<JsStaticMemberAssignment> for JsAnyAssignment {
    fn from(node: JsStaticMemberAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsStaticMemberAssignment(node)
    }
}
impl From<JsUnknownAssignment> for JsAnyAssignment {
    fn from(node: JsUnknownAssignment) -> JsAnyAssignment {
        JsAnyAssignment::JsUnknownAssignment(node)
    }
}
impl From<TsAsAssignment> for JsAnyAssignment {
    fn from(node: TsAsAssignment) -> JsAnyAssignment { JsAnyAssignment::TsAsAssignment(node) }
}
impl From<TsNonNullAssertionAssignment> for JsAnyAssignment {
    fn from(node: TsNonNullAssertionAssignment) -> JsAnyAssignment {
        JsAnyAssignment::TsNonNullAssertionAssignment(node)
    }
}
impl From<TsTypeAssertionAssignment> for JsAnyAssignment {
    fn from(node: TsTypeAssertionAssignment) -> JsAnyAssignment {
        JsAnyAssignment::TsTypeAssertionAssignment(node)
    }
}
impl AstNode for JsAnyAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_COMPUTED_MEMBER_ASSIGNMENT
                | JS_IDENTIFIER_ASSIGNMENT
                | JS_PARENTHESIZED_ASSIGNMENT
                | JS_STATIC_MEMBER_ASSIGNMENT
                | JS_UNKNOWN_ASSIGNMENT
                | TS_AS_ASSIGNMENT
                | TS_NON_NULL_ASSERTION_ASSIGNMENT
                | TS_TYPE_ASSERTION_ASSIGNMENT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_COMPUTED_MEMBER_ASSIGNMENT => {
                JsAnyAssignment::JsComputedMemberAssignment(JsComputedMemberAssignment { syntax })
            }
            JS_IDENTIFIER_ASSIGNMENT => {
                JsAnyAssignment::JsIdentifierAssignment(JsIdentifierAssignment { syntax })
            }
            JS_PARENTHESIZED_ASSIGNMENT => {
                JsAnyAssignment::JsParenthesizedAssignment(JsParenthesizedAssignment { syntax })
            }
            JS_STATIC_MEMBER_ASSIGNMENT => {
                JsAnyAssignment::JsStaticMemberAssignment(JsStaticMemberAssignment { syntax })
            }
            JS_UNKNOWN_ASSIGNMENT => {
                JsAnyAssignment::JsUnknownAssignment(JsUnknownAssignment { syntax })
            }
            TS_AS_ASSIGNMENT => JsAnyAssignment::TsAsAssignment(TsAsAssignment { syntax }),
            TS_NON_NULL_ASSERTION_ASSIGNMENT => {
                JsAnyAssignment::TsNonNullAssertionAssignment(TsNonNullAssertionAssignment {
                    syntax,
                })
            }
            TS_TYPE_ASSERTION_ASSIGNMENT => {
                JsAnyAssignment::TsTypeAssertionAssignment(TsTypeAssertionAssignment { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyAssignment::JsComputedMemberAssignment(it) => &it.syntax,
            JsAnyAssignment::JsIdentifierAssignment(it) => &it.syntax,
            JsAnyAssignment::JsParenthesizedAssignment(it) => &it.syntax,
            JsAnyAssignment::JsStaticMemberAssignment(it) => &it.syntax,
            JsAnyAssignment::JsUnknownAssignment(it) => &it.syntax,
            JsAnyAssignment::TsAsAssignment(it) => &it.syntax,
            JsAnyAssignment::TsNonNullAssertionAssignment(it) => &it.syntax,
            JsAnyAssignment::TsTypeAssertionAssignment(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyAssignment::JsComputedMemberAssignment(it) => it.syntax,
            JsAnyAssignment::JsIdentifierAssignment(it) => it.syntax,
            JsAnyAssignment::JsParenthesizedAssignment(it) => it.syntax,
            JsAnyAssignment::JsStaticMemberAssignment(it) => it.syntax,
            JsAnyAssignment::JsUnknownAssignment(it) => it.syntax,
            JsAnyAssignment::TsAsAssignment(it) => it.syntax,
            JsAnyAssignment::TsNonNullAssertionAssignment(it) => it.syntax,
            JsAnyAssignment::TsTypeAssertionAssignment(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyAssignment::JsComputedMemberAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::JsIdentifierAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::JsParenthesizedAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::JsStaticMemberAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::JsUnknownAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::TsAsAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::TsNonNullAssertionAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignment::TsTypeAssertionAssignment(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyAssignment> for SyntaxNode {
    fn from(n: JsAnyAssignment) -> SyntaxNode {
        match n {
            JsAnyAssignment::JsComputedMemberAssignment(it) => it.into(),
            JsAnyAssignment::JsIdentifierAssignment(it) => it.into(),
            JsAnyAssignment::JsParenthesizedAssignment(it) => it.into(),
            JsAnyAssignment::JsStaticMemberAssignment(it) => it.into(),
            JsAnyAssignment::JsUnknownAssignment(it) => it.into(),
            JsAnyAssignment::TsAsAssignment(it) => it.into(),
            JsAnyAssignment::TsNonNullAssertionAssignment(it) => it.into(),
            JsAnyAssignment::TsTypeAssertionAssignment(it) => it.into(),
        }
    }
}
impl From<JsAnyAssignment> for SyntaxElement {
    fn from(n: JsAnyAssignment) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayAssignmentPattern> for JsAnyAssignmentPattern {
    fn from(node: JsArrayAssignmentPattern) -> JsAnyAssignmentPattern {
        JsAnyAssignmentPattern::JsArrayAssignmentPattern(node)
    }
}
impl From<JsObjectAssignmentPattern> for JsAnyAssignmentPattern {
    fn from(node: JsObjectAssignmentPattern) -> JsAnyAssignmentPattern {
        JsAnyAssignmentPattern::JsObjectAssignmentPattern(node)
    }
}
impl AstNode for JsAnyAssignmentPattern {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_ASSIGNMENT_PATTERN | JS_OBJECT_ASSIGNMENT_PATTERN => true,
            k if JsAnyAssignment::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_ASSIGNMENT_PATTERN => {
                JsAnyAssignmentPattern::JsArrayAssignmentPattern(JsArrayAssignmentPattern {
                    syntax,
                })
            }
            JS_OBJECT_ASSIGNMENT_PATTERN => {
                JsAnyAssignmentPattern::JsObjectAssignmentPattern(JsObjectAssignmentPattern {
                    syntax,
                })
            }
            _ => {
                if let Some(js_any_assignment) = JsAnyAssignment::cast(syntax) {
                    return Some(JsAnyAssignmentPattern::JsAnyAssignment(js_any_assignment));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyAssignmentPattern::JsArrayAssignmentPattern(it) => &it.syntax,
            JsAnyAssignmentPattern::JsObjectAssignmentPattern(it) => &it.syntax,
            JsAnyAssignmentPattern::JsAnyAssignment(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyAssignmentPattern::JsArrayAssignmentPattern(it) => it.syntax,
            JsAnyAssignmentPattern::JsObjectAssignmentPattern(it) => it.syntax,
            JsAnyAssignmentPattern::JsAnyAssignment(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyAssignmentPattern::JsAnyAssignment(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignmentPattern::JsArrayAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
            JsAnyAssignmentPattern::JsObjectAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyAssignmentPattern> for SyntaxNode {
    fn from(n: JsAnyAssignmentPattern) -> SyntaxNode {
        match n {
            JsAnyAssignmentPattern::JsAnyAssignment(it) => it.into(),
            JsAnyAssignmentPattern::JsArrayAssignmentPattern(it) => it.into(),
            JsAnyAssignmentPattern::JsObjectAssignmentPattern(it) => it.into(),
        }
    }
}
impl From<JsAnyAssignmentPattern> for SyntaxElement {
    fn from(n: JsAnyAssignmentPattern) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsIdentifierBinding> for JsAnyBinding {
    fn from(node: JsIdentifierBinding) -> JsAnyBinding { JsAnyBinding::JsIdentifierBinding(node) }
}
impl From<JsUnknownBinding> for JsAnyBinding {
    fn from(node: JsUnknownBinding) -> JsAnyBinding { JsAnyBinding::JsUnknownBinding(node) }
}
impl AstNode for JsAnyBinding {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_IDENTIFIER_BINDING | JS_UNKNOWN_BINDING)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IDENTIFIER_BINDING => {
                JsAnyBinding::JsIdentifierBinding(JsIdentifierBinding { syntax })
            }
            JS_UNKNOWN_BINDING => JsAnyBinding::JsUnknownBinding(JsUnknownBinding { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyBinding::JsIdentifierBinding(it) => &it.syntax,
            JsAnyBinding::JsUnknownBinding(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyBinding::JsIdentifierBinding(it) => it.syntax,
            JsAnyBinding::JsUnknownBinding(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyBinding::JsIdentifierBinding(it) => std::fmt::Debug::fmt(it, f),
            JsAnyBinding::JsUnknownBinding(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyBinding> for SyntaxNode {
    fn from(n: JsAnyBinding) -> SyntaxNode {
        match n {
            JsAnyBinding::JsIdentifierBinding(it) => it.into(),
            JsAnyBinding::JsUnknownBinding(it) => it.into(),
        }
    }
}
impl From<JsAnyBinding> for SyntaxElement {
    fn from(n: JsAnyBinding) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayBindingPattern> for JsAnyBindingPattern {
    fn from(node: JsArrayBindingPattern) -> JsAnyBindingPattern {
        JsAnyBindingPattern::JsArrayBindingPattern(node)
    }
}
impl From<JsObjectBindingPattern> for JsAnyBindingPattern {
    fn from(node: JsObjectBindingPattern) -> JsAnyBindingPattern {
        JsAnyBindingPattern::JsObjectBindingPattern(node)
    }
}
impl AstNode for JsAnyBindingPattern {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_BINDING_PATTERN | JS_OBJECT_BINDING_PATTERN => true,
            k if JsAnyBinding::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_BINDING_PATTERN => {
                JsAnyBindingPattern::JsArrayBindingPattern(JsArrayBindingPattern { syntax })
            }
            JS_OBJECT_BINDING_PATTERN => {
                JsAnyBindingPattern::JsObjectBindingPattern(JsObjectBindingPattern { syntax })
            }
            _ => {
                if let Some(js_any_binding) = JsAnyBinding::cast(syntax) {
                    return Some(JsAnyBindingPattern::JsAnyBinding(js_any_binding));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyBindingPattern::JsArrayBindingPattern(it) => &it.syntax,
            JsAnyBindingPattern::JsObjectBindingPattern(it) => &it.syntax,
            JsAnyBindingPattern::JsAnyBinding(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyBindingPattern::JsArrayBindingPattern(it) => it.syntax,
            JsAnyBindingPattern::JsObjectBindingPattern(it) => it.syntax,
            JsAnyBindingPattern::JsAnyBinding(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyBindingPattern::JsAnyBinding(it) => std::fmt::Debug::fmt(it, f),
            JsAnyBindingPattern::JsArrayBindingPattern(it) => std::fmt::Debug::fmt(it, f),
            JsAnyBindingPattern::JsObjectBindingPattern(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyBindingPattern> for SyntaxNode {
    fn from(n: JsAnyBindingPattern) -> SyntaxNode {
        match n {
            JsAnyBindingPattern::JsAnyBinding(it) => it.into(),
            JsAnyBindingPattern::JsArrayBindingPattern(it) => it.into(),
            JsAnyBindingPattern::JsObjectBindingPattern(it) => it.into(),
        }
    }
}
impl From<JsAnyBindingPattern> for SyntaxElement {
    fn from(n: JsAnyBindingPattern) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsSpread> for JsAnyCallArgument {
    fn from(node: JsSpread) -> JsAnyCallArgument { JsAnyCallArgument::JsSpread(node) }
}
impl AstNode for JsAnyCallArgument {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_SPREAD => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_SPREAD => JsAnyCallArgument::JsSpread(JsSpread { syntax }),
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyCallArgument::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyCallArgument::JsSpread(it) => &it.syntax,
            JsAnyCallArgument::JsAnyExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyCallArgument::JsSpread(it) => it.syntax,
            JsAnyCallArgument::JsAnyExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyCallArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyCallArgument::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyCallArgument::JsSpread(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyCallArgument> for SyntaxNode {
    fn from(n: JsAnyCallArgument) -> SyntaxNode {
        match n {
            JsAnyCallArgument::JsAnyExpression(it) => it.into(),
            JsAnyCallArgument::JsSpread(it) => it.into(),
        }
    }
}
impl From<JsAnyCallArgument> for SyntaxElement {
    fn from(n: JsAnyCallArgument) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for JsAnyClass {
    fn from(node: JsClassDeclaration) -> JsAnyClass { JsAnyClass::JsClassDeclaration(node) }
}
impl From<JsClassExportDefaultDeclaration> for JsAnyClass {
    fn from(node: JsClassExportDefaultDeclaration) -> JsAnyClass {
        JsAnyClass::JsClassExportDefaultDeclaration(node)
    }
}
impl From<JsClassExpression> for JsAnyClass {
    fn from(node: JsClassExpression) -> JsAnyClass { JsAnyClass::JsClassExpression(node) }
}
impl AstNode for JsAnyClass {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION | JS_CLASS_EXPORT_DEFAULT_DECLARATION | JS_CLASS_EXPRESSION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => JsAnyClass::JsClassDeclaration(JsClassDeclaration { syntax }),
            JS_CLASS_EXPORT_DEFAULT_DECLARATION => {
                JsAnyClass::JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration {
                    syntax,
                })
            }
            JS_CLASS_EXPRESSION => JsAnyClass::JsClassExpression(JsClassExpression { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyClass::JsClassDeclaration(it) => &it.syntax,
            JsAnyClass::JsClassExportDefaultDeclaration(it) => &it.syntax,
            JsAnyClass::JsClassExpression(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyClass::JsClassDeclaration(it) => it.syntax,
            JsAnyClass::JsClassExportDefaultDeclaration(it) => it.syntax,
            JsAnyClass::JsClassExpression(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyClass::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClass::JsClassExportDefaultDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClass::JsClassExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyClass> for SyntaxNode {
    fn from(n: JsAnyClass) -> SyntaxNode {
        match n {
            JsAnyClass::JsClassDeclaration(it) => it.into(),
            JsAnyClass::JsClassExportDefaultDeclaration(it) => it.into(),
            JsAnyClass::JsClassExpression(it) => it.into(),
        }
    }
}
impl From<JsAnyClass> for SyntaxElement {
    fn from(n: JsAnyClass) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsConstructorClassMember> for JsAnyClassMember {
    fn from(node: JsConstructorClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsConstructorClassMember(node)
    }
}
impl From<JsEmptyClassMember> for JsAnyClassMember {
    fn from(node: JsEmptyClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsEmptyClassMember(node)
    }
}
impl From<JsGetterClassMember> for JsAnyClassMember {
    fn from(node: JsGetterClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsGetterClassMember(node)
    }
}
impl From<JsMethodClassMember> for JsAnyClassMember {
    fn from(node: JsMethodClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsMethodClassMember(node)
    }
}
impl From<JsPropertyClassMember> for JsAnyClassMember {
    fn from(node: JsPropertyClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsPropertyClassMember(node)
    }
}
impl From<JsSetterClassMember> for JsAnyClassMember {
    fn from(node: JsSetterClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsSetterClassMember(node)
    }
}
impl From<JsStaticInitializationBlockClassMember> for JsAnyClassMember {
    fn from(node: JsStaticInitializationBlockClassMember) -> JsAnyClassMember {
        JsAnyClassMember::JsStaticInitializationBlockClassMember(node)
    }
}
impl From<JsUnknownMember> for JsAnyClassMember {
    fn from(node: JsUnknownMember) -> JsAnyClassMember { JsAnyClassMember::JsUnknownMember(node) }
}
impl From<TsConstructorSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsConstructorSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsConstructorSignatureClassMember(node)
    }
}
impl From<TsGetterSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsGetterSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsGetterSignatureClassMember(node)
    }
}
impl From<TsIndexSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsIndexSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsIndexSignatureClassMember(node)
    }
}
impl From<TsMethodSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsMethodSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsMethodSignatureClassMember(node)
    }
}
impl From<TsPropertySignatureClassMember> for JsAnyClassMember {
    fn from(node: TsPropertySignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsPropertySignatureClassMember(node)
    }
}
impl From<TsSetterSignatureClassMember> for JsAnyClassMember {
    fn from(node: TsSetterSignatureClassMember) -> JsAnyClassMember {
        JsAnyClassMember::TsSetterSignatureClassMember(node)
    }
}
impl AstNode for JsAnyClassMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CONSTRUCTOR_CLASS_MEMBER
                | JS_EMPTY_CLASS_MEMBER
                | JS_GETTER_CLASS_MEMBER
                | JS_METHOD_CLASS_MEMBER
                | JS_PROPERTY_CLASS_MEMBER
                | JS_SETTER_CLASS_MEMBER
                | JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER
                | JS_UNKNOWN_MEMBER
                | TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER
                | TS_GETTER_SIGNATURE_CLASS_MEMBER
                | TS_INDEX_SIGNATURE_CLASS_MEMBER
                | TS_METHOD_SIGNATURE_CLASS_MEMBER
                | TS_PROPERTY_SIGNATURE_CLASS_MEMBER
                | TS_SETTER_SIGNATURE_CLASS_MEMBER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CONSTRUCTOR_CLASS_MEMBER => {
                JsAnyClassMember::JsConstructorClassMember(JsConstructorClassMember { syntax })
            }
            JS_EMPTY_CLASS_MEMBER => {
                JsAnyClassMember::JsEmptyClassMember(JsEmptyClassMember { syntax })
            }
            JS_GETTER_CLASS_MEMBER => {
                JsAnyClassMember::JsGetterClassMember(JsGetterClassMember { syntax })
            }
            JS_METHOD_CLASS_MEMBER => {
                JsAnyClassMember::JsMethodClassMember(JsMethodClassMember { syntax })
            }
            JS_PROPERTY_CLASS_MEMBER => {
                JsAnyClassMember::JsPropertyClassMember(JsPropertyClassMember { syntax })
            }
            JS_SETTER_CLASS_MEMBER => {
                JsAnyClassMember::JsSetterClassMember(JsSetterClassMember { syntax })
            }
            JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER => {
                JsAnyClassMember::JsStaticInitializationBlockClassMember(
                    JsStaticInitializationBlockClassMember { syntax },
                )
            }
            JS_UNKNOWN_MEMBER => JsAnyClassMember::JsUnknownMember(JsUnknownMember { syntax }),
            TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsConstructorSignatureClassMember(
                    TsConstructorSignatureClassMember { syntax },
                )
            }
            TS_GETTER_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsGetterSignatureClassMember(TsGetterSignatureClassMember {
                    syntax,
                })
            }
            TS_INDEX_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsIndexSignatureClassMember(TsIndexSignatureClassMember {
                    syntax,
                })
            }
            TS_METHOD_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsMethodSignatureClassMember(TsMethodSignatureClassMember {
                    syntax,
                })
            }
            TS_PROPERTY_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsPropertySignatureClassMember(TsPropertySignatureClassMember {
                    syntax,
                })
            }
            TS_SETTER_SIGNATURE_CLASS_MEMBER => {
                JsAnyClassMember::TsSetterSignatureClassMember(TsSetterSignatureClassMember {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyClassMember::JsConstructorClassMember(it) => &it.syntax,
            JsAnyClassMember::JsEmptyClassMember(it) => &it.syntax,
            JsAnyClassMember::JsGetterClassMember(it) => &it.syntax,
            JsAnyClassMember::JsMethodClassMember(it) => &it.syntax,
            JsAnyClassMember::JsPropertyClassMember(it) => &it.syntax,
            JsAnyClassMember::JsSetterClassMember(it) => &it.syntax,
            JsAnyClassMember::JsStaticInitializationBlockClassMember(it) => &it.syntax,
            JsAnyClassMember::JsUnknownMember(it) => &it.syntax,
            JsAnyClassMember::TsConstructorSignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsGetterSignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsIndexSignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsMethodSignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsPropertySignatureClassMember(it) => &it.syntax,
            JsAnyClassMember::TsSetterSignatureClassMember(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyClassMember::JsConstructorClassMember(it) => it.syntax,
            JsAnyClassMember::JsEmptyClassMember(it) => it.syntax,
            JsAnyClassMember::JsGetterClassMember(it) => it.syntax,
            JsAnyClassMember::JsMethodClassMember(it) => it.syntax,
            JsAnyClassMember::JsPropertyClassMember(it) => it.syntax,
            JsAnyClassMember::JsSetterClassMember(it) => it.syntax,
            JsAnyClassMember::JsStaticInitializationBlockClassMember(it) => it.syntax,
            JsAnyClassMember::JsUnknownMember(it) => it.syntax,
            JsAnyClassMember::TsConstructorSignatureClassMember(it) => it.syntax,
            JsAnyClassMember::TsGetterSignatureClassMember(it) => it.syntax,
            JsAnyClassMember::TsIndexSignatureClassMember(it) => it.syntax,
            JsAnyClassMember::TsMethodSignatureClassMember(it) => it.syntax,
            JsAnyClassMember::TsPropertySignatureClassMember(it) => it.syntax,
            JsAnyClassMember::TsSetterSignatureClassMember(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyClassMember::JsConstructorClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsEmptyClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsGetterClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsMethodClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsPropertyClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsSetterClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::JsStaticInitializationBlockClassMember(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyClassMember::JsUnknownMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsConstructorSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsGetterSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsIndexSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsMethodSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsPropertySignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMember::TsSetterSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyClassMember> for SyntaxNode {
    fn from(n: JsAnyClassMember) -> SyntaxNode {
        match n {
            JsAnyClassMember::JsConstructorClassMember(it) => it.into(),
            JsAnyClassMember::JsEmptyClassMember(it) => it.into(),
            JsAnyClassMember::JsGetterClassMember(it) => it.into(),
            JsAnyClassMember::JsMethodClassMember(it) => it.into(),
            JsAnyClassMember::JsPropertyClassMember(it) => it.into(),
            JsAnyClassMember::JsSetterClassMember(it) => it.into(),
            JsAnyClassMember::JsStaticInitializationBlockClassMember(it) => it.into(),
            JsAnyClassMember::JsUnknownMember(it) => it.into(),
            JsAnyClassMember::TsConstructorSignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsGetterSignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsIndexSignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsMethodSignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsPropertySignatureClassMember(it) => it.into(),
            JsAnyClassMember::TsSetterSignatureClassMember(it) => it.into(),
        }
    }
}
impl From<JsAnyClassMember> for SyntaxElement {
    fn from(n: JsAnyClassMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsComputedMemberName> for JsAnyClassMemberName {
    fn from(node: JsComputedMemberName) -> JsAnyClassMemberName {
        JsAnyClassMemberName::JsComputedMemberName(node)
    }
}
impl From<JsLiteralMemberName> for JsAnyClassMemberName {
    fn from(node: JsLiteralMemberName) -> JsAnyClassMemberName {
        JsAnyClassMemberName::JsLiteralMemberName(node)
    }
}
impl From<JsPrivateClassMemberName> for JsAnyClassMemberName {
    fn from(node: JsPrivateClassMemberName) -> JsAnyClassMemberName {
        JsAnyClassMemberName::JsPrivateClassMemberName(node)
    }
}
impl AstNode for JsAnyClassMemberName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_COMPUTED_MEMBER_NAME | JS_LITERAL_MEMBER_NAME | JS_PRIVATE_CLASS_MEMBER_NAME
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_COMPUTED_MEMBER_NAME => {
                JsAnyClassMemberName::JsComputedMemberName(JsComputedMemberName { syntax })
            }
            JS_LITERAL_MEMBER_NAME => {
                JsAnyClassMemberName::JsLiteralMemberName(JsLiteralMemberName { syntax })
            }
            JS_PRIVATE_CLASS_MEMBER_NAME => {
                JsAnyClassMemberName::JsPrivateClassMemberName(JsPrivateClassMemberName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyClassMemberName::JsComputedMemberName(it) => &it.syntax,
            JsAnyClassMemberName::JsLiteralMemberName(it) => &it.syntax,
            JsAnyClassMemberName::JsPrivateClassMemberName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyClassMemberName::JsComputedMemberName(it) => it.syntax,
            JsAnyClassMemberName::JsLiteralMemberName(it) => it.syntax,
            JsAnyClassMemberName::JsPrivateClassMemberName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyClassMemberName::JsComputedMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMemberName::JsLiteralMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsAnyClassMemberName::JsPrivateClassMemberName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyClassMemberName> for SyntaxNode {
    fn from(n: JsAnyClassMemberName) -> SyntaxNode {
        match n {
            JsAnyClassMemberName::JsComputedMemberName(it) => it.into(),
            JsAnyClassMemberName::JsLiteralMemberName(it) => it.into(),
            JsAnyClassMemberName::JsPrivateClassMemberName(it) => it.into(),
        }
    }
}
impl From<JsAnyClassMemberName> for SyntaxElement {
    fn from(n: JsAnyClassMemberName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsRestParameter> for JsAnyConstructorParameter {
    fn from(node: JsRestParameter) -> JsAnyConstructorParameter {
        JsAnyConstructorParameter::JsRestParameter(node)
    }
}
impl From<TsPropertyParameter> for JsAnyConstructorParameter {
    fn from(node: TsPropertyParameter) -> JsAnyConstructorParameter {
        JsAnyConstructorParameter::TsPropertyParameter(node)
    }
}
impl AstNode for JsAnyConstructorParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_REST_PARAMETER | TS_PROPERTY_PARAMETER => true,
            k if JsAnyFormalParameter::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REST_PARAMETER => {
                JsAnyConstructorParameter::JsRestParameter(JsRestParameter { syntax })
            }
            TS_PROPERTY_PARAMETER => {
                JsAnyConstructorParameter::TsPropertyParameter(TsPropertyParameter { syntax })
            }
            _ => {
                if let Some(js_any_formal_parameter) = JsAnyFormalParameter::cast(syntax) {
                    return Some(JsAnyConstructorParameter::JsAnyFormalParameter(
                        js_any_formal_parameter,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyConstructorParameter::JsRestParameter(it) => &it.syntax,
            JsAnyConstructorParameter::TsPropertyParameter(it) => &it.syntax,
            JsAnyConstructorParameter::JsAnyFormalParameter(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyConstructorParameter::JsRestParameter(it) => it.syntax,
            JsAnyConstructorParameter::TsPropertyParameter(it) => it.syntax,
            JsAnyConstructorParameter::JsAnyFormalParameter(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyConstructorParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyConstructorParameter::JsAnyFormalParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyConstructorParameter::JsRestParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyConstructorParameter::TsPropertyParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyConstructorParameter> for SyntaxNode {
    fn from(n: JsAnyConstructorParameter) -> SyntaxNode {
        match n {
            JsAnyConstructorParameter::JsAnyFormalParameter(it) => it.into(),
            JsAnyConstructorParameter::JsRestParameter(it) => it.into(),
            JsAnyConstructorParameter::TsPropertyParameter(it) => it.into(),
        }
    }
}
impl From<JsAnyConstructorParameter> for SyntaxElement {
    fn from(n: JsAnyConstructorParameter) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for JsAnyDeclaration {
    fn from(node: JsClassDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::JsClassDeclaration(node)
    }
}
impl From<JsFunctionDeclaration> for JsAnyDeclaration {
    fn from(node: JsFunctionDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::JsFunctionDeclaration(node)
    }
}
impl From<JsVariableDeclaration> for JsAnyDeclaration {
    fn from(node: JsVariableDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::JsVariableDeclaration(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for JsAnyDeclaration {
    fn from(node: TsDeclareFunctionDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsEnumDeclaration> for JsAnyDeclaration {
    fn from(node: TsEnumDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsEnumDeclaration(node)
    }
}
impl From<TsExternalModuleDeclaration> for JsAnyDeclaration {
    fn from(node: TsExternalModuleDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for JsAnyDeclaration {
    fn from(node: TsGlobalDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for JsAnyDeclaration {
    fn from(node: TsImportEqualsDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for JsAnyDeclaration {
    fn from(node: TsInterfaceDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for JsAnyDeclaration {
    fn from(node: TsModuleDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for JsAnyDeclaration {
    fn from(node: TsTypeAliasDeclaration) -> JsAnyDeclaration {
        JsAnyDeclaration::TsTypeAliasDeclaration(node)
    }
}
impl AstNode for JsAnyDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION
                | JS_FUNCTION_DECLARATION
                | JS_VARIABLE_DECLARATION
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => {
                JsAnyDeclaration::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                JsAnyDeclaration::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_VARIABLE_DECLARATION => {
                JsAnyDeclaration::JsVariableDeclaration(JsVariableDeclaration { syntax })
            }
            TS_DECLARE_FUNCTION_DECLARATION => {
                JsAnyDeclaration::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_ENUM_DECLARATION => {
                JsAnyDeclaration::TsEnumDeclaration(TsEnumDeclaration { syntax })
            }
            TS_EXTERNAL_MODULE_DECLARATION => {
                JsAnyDeclaration::TsExternalModuleDeclaration(TsExternalModuleDeclaration {
                    syntax,
                })
            }
            TS_GLOBAL_DECLARATION => {
                JsAnyDeclaration::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                JsAnyDeclaration::TsImportEqualsDeclaration(TsImportEqualsDeclaration { syntax })
            }
            TS_INTERFACE_DECLARATION => {
                JsAnyDeclaration::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                JsAnyDeclaration::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                JsAnyDeclaration::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyDeclaration::JsClassDeclaration(it) => &it.syntax,
            JsAnyDeclaration::JsFunctionDeclaration(it) => &it.syntax,
            JsAnyDeclaration::JsVariableDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsDeclareFunctionDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsEnumDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsExternalModuleDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsGlobalDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsImportEqualsDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsInterfaceDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsModuleDeclaration(it) => &it.syntax,
            JsAnyDeclaration::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyDeclaration::JsClassDeclaration(it) => it.syntax,
            JsAnyDeclaration::JsFunctionDeclaration(it) => it.syntax,
            JsAnyDeclaration::JsVariableDeclaration(it) => it.syntax,
            JsAnyDeclaration::TsDeclareFunctionDeclaration(it) => it.syntax,
            JsAnyDeclaration::TsEnumDeclaration(it) => it.syntax,
            JsAnyDeclaration::TsExternalModuleDeclaration(it) => it.syntax,
            JsAnyDeclaration::TsGlobalDeclaration(it) => it.syntax,
            JsAnyDeclaration::TsImportEqualsDeclaration(it) => it.syntax,
            JsAnyDeclaration::TsInterfaceDeclaration(it) => it.syntax,
            JsAnyDeclaration::TsModuleDeclaration(it) => it.syntax,
            JsAnyDeclaration::TsTypeAliasDeclaration(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyDeclaration::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::JsVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclaration::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyDeclaration> for SyntaxNode {
    fn from(n: JsAnyDeclaration) -> SyntaxNode {
        match n {
            JsAnyDeclaration::JsClassDeclaration(it) => it.into(),
            JsAnyDeclaration::JsFunctionDeclaration(it) => it.into(),
            JsAnyDeclaration::JsVariableDeclaration(it) => it.into(),
            JsAnyDeclaration::TsDeclareFunctionDeclaration(it) => it.into(),
            JsAnyDeclaration::TsEnumDeclaration(it) => it.into(),
            JsAnyDeclaration::TsExternalModuleDeclaration(it) => it.into(),
            JsAnyDeclaration::TsGlobalDeclaration(it) => it.into(),
            JsAnyDeclaration::TsImportEqualsDeclaration(it) => it.into(),
            JsAnyDeclaration::TsInterfaceDeclaration(it) => it.into(),
            JsAnyDeclaration::TsModuleDeclaration(it) => it.into(),
            JsAnyDeclaration::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyDeclaration> for SyntaxElement {
    fn from(n: JsAnyDeclaration) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for JsAnyDeclarationClause {
    fn from(node: JsClassDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::JsClassDeclaration(node)
    }
}
impl From<JsFunctionDeclaration> for JsAnyDeclarationClause {
    fn from(node: JsFunctionDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::JsFunctionDeclaration(node)
    }
}
impl From<JsVariableDeclarationClause> for JsAnyDeclarationClause {
    fn from(node: JsVariableDeclarationClause) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::JsVariableDeclarationClause(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsDeclareFunctionDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsEnumDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsEnumDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsEnumDeclaration(node)
    }
}
impl From<TsExternalModuleDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsExternalModuleDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsGlobalDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsImportEqualsDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsInterfaceDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsModuleDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for JsAnyDeclarationClause {
    fn from(node: TsTypeAliasDeclaration) -> JsAnyDeclarationClause {
        JsAnyDeclarationClause::TsTypeAliasDeclaration(node)
    }
}
impl AstNode for JsAnyDeclarationClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION
                | JS_FUNCTION_DECLARATION
                | JS_VARIABLE_DECLARATION_CLAUSE
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => {
                JsAnyDeclarationClause::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                JsAnyDeclarationClause::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_VARIABLE_DECLARATION_CLAUSE => {
                JsAnyDeclarationClause::JsVariableDeclarationClause(JsVariableDeclarationClause {
                    syntax,
                })
            }
            TS_DECLARE_FUNCTION_DECLARATION => {
                JsAnyDeclarationClause::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_ENUM_DECLARATION => {
                JsAnyDeclarationClause::TsEnumDeclaration(TsEnumDeclaration { syntax })
            }
            TS_EXTERNAL_MODULE_DECLARATION => {
                JsAnyDeclarationClause::TsExternalModuleDeclaration(TsExternalModuleDeclaration {
                    syntax,
                })
            }
            TS_GLOBAL_DECLARATION => {
                JsAnyDeclarationClause::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                JsAnyDeclarationClause::TsImportEqualsDeclaration(TsImportEqualsDeclaration {
                    syntax,
                })
            }
            TS_INTERFACE_DECLARATION => {
                JsAnyDeclarationClause::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                JsAnyDeclarationClause::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                JsAnyDeclarationClause::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyDeclarationClause::JsClassDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::JsFunctionDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::JsVariableDeclarationClause(it) => &it.syntax,
            JsAnyDeclarationClause::TsDeclareFunctionDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsEnumDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsExternalModuleDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsGlobalDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsImportEqualsDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsInterfaceDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsModuleDeclaration(it) => &it.syntax,
            JsAnyDeclarationClause::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyDeclarationClause::JsClassDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::JsFunctionDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::JsVariableDeclarationClause(it) => it.syntax,
            JsAnyDeclarationClause::TsDeclareFunctionDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::TsEnumDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::TsExternalModuleDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::TsGlobalDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::TsImportEqualsDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::TsInterfaceDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::TsModuleDeclaration(it) => it.syntax,
            JsAnyDeclarationClause::TsTypeAliasDeclaration(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyDeclarationClause::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::JsVariableDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyDeclarationClause::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyDeclarationClause> for SyntaxNode {
    fn from(n: JsAnyDeclarationClause) -> SyntaxNode {
        match n {
            JsAnyDeclarationClause::JsClassDeclaration(it) => it.into(),
            JsAnyDeclarationClause::JsFunctionDeclaration(it) => it.into(),
            JsAnyDeclarationClause::JsVariableDeclarationClause(it) => it.into(),
            JsAnyDeclarationClause::TsDeclareFunctionDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsEnumDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsExternalModuleDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsGlobalDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsImportEqualsDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsInterfaceDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsModuleDeclaration(it) => it.into(),
            JsAnyDeclarationClause::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyDeclarationClause> for SyntaxElement {
    fn from(n: JsAnyDeclarationClause) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExportDefaultDeclarationClause> for JsAnyExportClause {
    fn from(node: JsExportDefaultDeclarationClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportDefaultDeclarationClause(node)
    }
}
impl From<JsExportDefaultExpressionClause> for JsAnyExportClause {
    fn from(node: JsExportDefaultExpressionClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportDefaultExpressionClause(node)
    }
}
impl From<JsExportFromClause> for JsAnyExportClause {
    fn from(node: JsExportFromClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportFromClause(node)
    }
}
impl From<JsExportNamedClause> for JsAnyExportClause {
    fn from(node: JsExportNamedClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportNamedClause(node)
    }
}
impl From<JsExportNamedFromClause> for JsAnyExportClause {
    fn from(node: JsExportNamedFromClause) -> JsAnyExportClause {
        JsAnyExportClause::JsExportNamedFromClause(node)
    }
}
impl From<TsExportAsNamespaceClause> for JsAnyExportClause {
    fn from(node: TsExportAsNamespaceClause) -> JsAnyExportClause {
        JsAnyExportClause::TsExportAsNamespaceClause(node)
    }
}
impl From<TsExportAssignmentClause> for JsAnyExportClause {
    fn from(node: TsExportAssignmentClause) -> JsAnyExportClause {
        JsAnyExportClause::TsExportAssignmentClause(node)
    }
}
impl From<TsExportDeclareClause> for JsAnyExportClause {
    fn from(node: TsExportDeclareClause) -> JsAnyExportClause {
        JsAnyExportClause::TsExportDeclareClause(node)
    }
}
impl AstNode for JsAnyExportClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_EXPORT_DEFAULT_DECLARATION_CLAUSE
            | JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE
            | JS_EXPORT_FROM_CLAUSE
            | JS_EXPORT_NAMED_CLAUSE
            | JS_EXPORT_NAMED_FROM_CLAUSE
            | TS_EXPORT_AS_NAMESPACE_CLAUSE
            | TS_EXPORT_ASSIGNMENT_CLAUSE
            | TS_EXPORT_DECLARE_CLAUSE => true,
            k if JsAnyDeclarationClause::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT_DEFAULT_DECLARATION_CLAUSE => {
                JsAnyExportClause::JsExportDefaultDeclarationClause(
                    JsExportDefaultDeclarationClause { syntax },
                )
            }
            JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE => {
                JsAnyExportClause::JsExportDefaultExpressionClause(
                    JsExportDefaultExpressionClause { syntax },
                )
            }
            JS_EXPORT_FROM_CLAUSE => {
                JsAnyExportClause::JsExportFromClause(JsExportFromClause { syntax })
            }
            JS_EXPORT_NAMED_CLAUSE => {
                JsAnyExportClause::JsExportNamedClause(JsExportNamedClause { syntax })
            }
            JS_EXPORT_NAMED_FROM_CLAUSE => {
                JsAnyExportClause::JsExportNamedFromClause(JsExportNamedFromClause { syntax })
            }
            TS_EXPORT_AS_NAMESPACE_CLAUSE => {
                JsAnyExportClause::TsExportAsNamespaceClause(TsExportAsNamespaceClause { syntax })
            }
            TS_EXPORT_ASSIGNMENT_CLAUSE => {
                JsAnyExportClause::TsExportAssignmentClause(TsExportAssignmentClause { syntax })
            }
            TS_EXPORT_DECLARE_CLAUSE => {
                JsAnyExportClause::TsExportDeclareClause(TsExportDeclareClause { syntax })
            }
            _ => {
                if let Some(js_any_declaration_clause) = JsAnyDeclarationClause::cast(syntax) {
                    return Some(JsAnyExportClause::JsAnyDeclarationClause(
                        js_any_declaration_clause,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyExportClause::JsExportDefaultDeclarationClause(it) => &it.syntax,
            JsAnyExportClause::JsExportDefaultExpressionClause(it) => &it.syntax,
            JsAnyExportClause::JsExportFromClause(it) => &it.syntax,
            JsAnyExportClause::JsExportNamedClause(it) => &it.syntax,
            JsAnyExportClause::JsExportNamedFromClause(it) => &it.syntax,
            JsAnyExportClause::TsExportAsNamespaceClause(it) => &it.syntax,
            JsAnyExportClause::TsExportAssignmentClause(it) => &it.syntax,
            JsAnyExportClause::TsExportDeclareClause(it) => &it.syntax,
            JsAnyExportClause::JsAnyDeclarationClause(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyExportClause::JsExportDefaultDeclarationClause(it) => it.syntax,
            JsAnyExportClause::JsExportDefaultExpressionClause(it) => it.syntax,
            JsAnyExportClause::JsExportFromClause(it) => it.syntax,
            JsAnyExportClause::JsExportNamedClause(it) => it.syntax,
            JsAnyExportClause::JsExportNamedFromClause(it) => it.syntax,
            JsAnyExportClause::TsExportAsNamespaceClause(it) => it.syntax,
            JsAnyExportClause::TsExportAssignmentClause(it) => it.syntax,
            JsAnyExportClause::TsExportDeclareClause(it) => it.syntax,
            JsAnyExportClause::JsAnyDeclarationClause(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyExportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyExportClause::JsAnyDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportDefaultDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportDefaultExpressionClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportFromClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportNamedClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::JsExportNamedFromClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::TsExportAsNamespaceClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::TsExportAssignmentClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExportClause::TsExportDeclareClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyExportClause> for SyntaxNode {
    fn from(n: JsAnyExportClause) -> SyntaxNode {
        match n {
            JsAnyExportClause::JsAnyDeclarationClause(it) => it.into(),
            JsAnyExportClause::JsExportDefaultDeclarationClause(it) => it.into(),
            JsAnyExportClause::JsExportDefaultExpressionClause(it) => it.into(),
            JsAnyExportClause::JsExportFromClause(it) => it.into(),
            JsAnyExportClause::JsExportNamedClause(it) => it.into(),
            JsAnyExportClause::JsExportNamedFromClause(it) => it.into(),
            JsAnyExportClause::TsExportAsNamespaceClause(it) => it.into(),
            JsAnyExportClause::TsExportAssignmentClause(it) => it.into(),
            JsAnyExportClause::TsExportDeclareClause(it) => it.into(),
        }
    }
}
impl From<JsAnyExportClause> for SyntaxElement {
    fn from(n: JsAnyExportClause) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassExportDefaultDeclaration> for JsAnyExportDefaultDeclaration {
    fn from(node: JsClassExportDefaultDeclaration) -> JsAnyExportDefaultDeclaration {
        JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(node)
    }
}
impl From<JsFunctionExportDefaultDeclaration> for JsAnyExportDefaultDeclaration {
    fn from(node: JsFunctionExportDefaultDeclaration) -> JsAnyExportDefaultDeclaration {
        JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for JsAnyExportDefaultDeclaration {
    fn from(node: TsDeclareFunctionDeclaration) -> JsAnyExportDefaultDeclaration {
        JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for JsAnyExportDefaultDeclaration {
    fn from(node: TsInterfaceDeclaration) -> JsAnyExportDefaultDeclaration {
        JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(node)
    }
}
impl AstNode for JsAnyExportDefaultDeclaration {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_EXPORT_DEFAULT_DECLARATION
                | JS_FUNCTION_EXPORT_DEFAULT_DECLARATION
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_INTERFACE_DECLARATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_EXPORT_DEFAULT_DECLARATION => {
                JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(
                    JsClassExportDefaultDeclaration { syntax },
                )
            }
            JS_FUNCTION_EXPORT_DEFAULT_DECLARATION => {
                JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(
                    JsFunctionExportDefaultDeclaration { syntax },
                )
            }
            TS_DECLARE_FUNCTION_DECLARATION => {
                JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(
                    TsDeclareFunctionDeclaration { syntax },
                )
            }
            TS_INTERFACE_DECLARATION => {
                JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(TsInterfaceDeclaration {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => &it.syntax,
            JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => &it.syntax,
            JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(it) => &it.syntax,
            JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => it.syntax,
            JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => it.syntax,
            JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(it) => it.syntax,
            JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyExportDefaultDeclaration> for SyntaxNode {
    fn from(n: JsAnyExportDefaultDeclaration) -> SyntaxNode {
        match n {
            JsAnyExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => it.into(),
            JsAnyExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => it.into(),
            JsAnyExportDefaultDeclaration::TsDeclareFunctionDeclaration(it) => it.into(),
            JsAnyExportDefaultDeclaration::TsInterfaceDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyExportDefaultDeclaration> for SyntaxElement {
    fn from(n: JsAnyExportDefaultDeclaration) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExportNamedShorthandSpecifier> for JsAnyExportNamedSpecifier {
    fn from(node: JsExportNamedShorthandSpecifier) -> JsAnyExportNamedSpecifier {
        JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(node)
    }
}
impl From<JsExportNamedSpecifier> for JsAnyExportNamedSpecifier {
    fn from(node: JsExportNamedSpecifier) -> JsAnyExportNamedSpecifier {
        JsAnyExportNamedSpecifier::JsExportNamedSpecifier(node)
    }
}
impl AstNode for JsAnyExportNamedSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_EXPORT_NAMED_SHORTHAND_SPECIFIER | JS_EXPORT_NAMED_SPECIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT_NAMED_SHORTHAND_SPECIFIER => {
                JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(
                    JsExportNamedShorthandSpecifier { syntax },
                )
            }
            JS_EXPORT_NAMED_SPECIFIER => {
                JsAnyExportNamedSpecifier::JsExportNamedSpecifier(JsExportNamedSpecifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => &it.syntax,
            JsAnyExportNamedSpecifier::JsExportNamedSpecifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => it.syntax,
            JsAnyExportNamedSpecifier::JsExportNamedSpecifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyExportNamedSpecifier::JsExportNamedSpecifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyExportNamedSpecifier> for SyntaxNode {
    fn from(n: JsAnyExportNamedSpecifier) -> SyntaxNode {
        match n {
            JsAnyExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => it.into(),
            JsAnyExportNamedSpecifier::JsExportNamedSpecifier(it) => it.into(),
        }
    }
}
impl From<JsAnyExportNamedSpecifier> for SyntaxElement {
    fn from(n: JsAnyExportNamedSpecifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<ImportMeta> for JsAnyExpression {
    fn from(node: ImportMeta) -> JsAnyExpression { JsAnyExpression::ImportMeta(node) }
}
impl From<JsArrayExpression> for JsAnyExpression {
    fn from(node: JsArrayExpression) -> JsAnyExpression { JsAnyExpression::JsArrayExpression(node) }
}
impl From<JsArrowFunctionExpression> for JsAnyExpression {
    fn from(node: JsArrowFunctionExpression) -> JsAnyExpression {
        JsAnyExpression::JsArrowFunctionExpression(node)
    }
}
impl From<JsAssignmentExpression> for JsAnyExpression {
    fn from(node: JsAssignmentExpression) -> JsAnyExpression {
        JsAnyExpression::JsAssignmentExpression(node)
    }
}
impl From<JsAwaitExpression> for JsAnyExpression {
    fn from(node: JsAwaitExpression) -> JsAnyExpression { JsAnyExpression::JsAwaitExpression(node) }
}
impl From<JsBinaryExpression> for JsAnyExpression {
    fn from(node: JsBinaryExpression) -> JsAnyExpression {
        JsAnyExpression::JsBinaryExpression(node)
    }
}
impl From<JsCallExpression> for JsAnyExpression {
    fn from(node: JsCallExpression) -> JsAnyExpression { JsAnyExpression::JsCallExpression(node) }
}
impl From<JsClassExpression> for JsAnyExpression {
    fn from(node: JsClassExpression) -> JsAnyExpression { JsAnyExpression::JsClassExpression(node) }
}
impl From<JsComputedMemberExpression> for JsAnyExpression {
    fn from(node: JsComputedMemberExpression) -> JsAnyExpression {
        JsAnyExpression::JsComputedMemberExpression(node)
    }
}
impl From<JsConditionalExpression> for JsAnyExpression {
    fn from(node: JsConditionalExpression) -> JsAnyExpression {
        JsAnyExpression::JsConditionalExpression(node)
    }
}
impl From<JsFunctionExpression> for JsAnyExpression {
    fn from(node: JsFunctionExpression) -> JsAnyExpression {
        JsAnyExpression::JsFunctionExpression(node)
    }
}
impl From<JsIdentifierExpression> for JsAnyExpression {
    fn from(node: JsIdentifierExpression) -> JsAnyExpression {
        JsAnyExpression::JsIdentifierExpression(node)
    }
}
impl From<JsImportCallExpression> for JsAnyExpression {
    fn from(node: JsImportCallExpression) -> JsAnyExpression {
        JsAnyExpression::JsImportCallExpression(node)
    }
}
impl From<JsInExpression> for JsAnyExpression {
    fn from(node: JsInExpression) -> JsAnyExpression { JsAnyExpression::JsInExpression(node) }
}
impl From<JsInstanceofExpression> for JsAnyExpression {
    fn from(node: JsInstanceofExpression) -> JsAnyExpression {
        JsAnyExpression::JsInstanceofExpression(node)
    }
}
impl From<JsLogicalExpression> for JsAnyExpression {
    fn from(node: JsLogicalExpression) -> JsAnyExpression {
        JsAnyExpression::JsLogicalExpression(node)
    }
}
impl From<JsNewExpression> for JsAnyExpression {
    fn from(node: JsNewExpression) -> JsAnyExpression { JsAnyExpression::JsNewExpression(node) }
}
impl From<JsObjectExpression> for JsAnyExpression {
    fn from(node: JsObjectExpression) -> JsAnyExpression {
        JsAnyExpression::JsObjectExpression(node)
    }
}
impl From<JsParenthesizedExpression> for JsAnyExpression {
    fn from(node: JsParenthesizedExpression) -> JsAnyExpression {
        JsAnyExpression::JsParenthesizedExpression(node)
    }
}
impl From<JsPostUpdateExpression> for JsAnyExpression {
    fn from(node: JsPostUpdateExpression) -> JsAnyExpression {
        JsAnyExpression::JsPostUpdateExpression(node)
    }
}
impl From<JsPreUpdateExpression> for JsAnyExpression {
    fn from(node: JsPreUpdateExpression) -> JsAnyExpression {
        JsAnyExpression::JsPreUpdateExpression(node)
    }
}
impl From<JsSequenceExpression> for JsAnyExpression {
    fn from(node: JsSequenceExpression) -> JsAnyExpression {
        JsAnyExpression::JsSequenceExpression(node)
    }
}
impl From<JsStaticMemberExpression> for JsAnyExpression {
    fn from(node: JsStaticMemberExpression) -> JsAnyExpression {
        JsAnyExpression::JsStaticMemberExpression(node)
    }
}
impl From<JsSuperExpression> for JsAnyExpression {
    fn from(node: JsSuperExpression) -> JsAnyExpression { JsAnyExpression::JsSuperExpression(node) }
}
impl From<JsTemplate> for JsAnyExpression {
    fn from(node: JsTemplate) -> JsAnyExpression { JsAnyExpression::JsTemplate(node) }
}
impl From<JsThisExpression> for JsAnyExpression {
    fn from(node: JsThisExpression) -> JsAnyExpression { JsAnyExpression::JsThisExpression(node) }
}
impl From<JsUnaryExpression> for JsAnyExpression {
    fn from(node: JsUnaryExpression) -> JsAnyExpression { JsAnyExpression::JsUnaryExpression(node) }
}
impl From<JsUnknownExpression> for JsAnyExpression {
    fn from(node: JsUnknownExpression) -> JsAnyExpression {
        JsAnyExpression::JsUnknownExpression(node)
    }
}
impl From<JsYieldExpression> for JsAnyExpression {
    fn from(node: JsYieldExpression) -> JsAnyExpression { JsAnyExpression::JsYieldExpression(node) }
}
impl From<JsxTagExpression> for JsAnyExpression {
    fn from(node: JsxTagExpression) -> JsAnyExpression { JsAnyExpression::JsxTagExpression(node) }
}
impl From<NewTarget> for JsAnyExpression {
    fn from(node: NewTarget) -> JsAnyExpression { JsAnyExpression::NewTarget(node) }
}
impl From<TsAsExpression> for JsAnyExpression {
    fn from(node: TsAsExpression) -> JsAnyExpression { JsAnyExpression::TsAsExpression(node) }
}
impl From<TsNonNullAssertionExpression> for JsAnyExpression {
    fn from(node: TsNonNullAssertionExpression) -> JsAnyExpression {
        JsAnyExpression::TsNonNullAssertionExpression(node)
    }
}
impl From<TsTypeAssertionExpression> for JsAnyExpression {
    fn from(node: TsTypeAssertionExpression) -> JsAnyExpression {
        JsAnyExpression::TsTypeAssertionExpression(node)
    }
}
impl AstNode for JsAnyExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IMPORT_META
            | JS_ARRAY_EXPRESSION
            | JS_ARROW_FUNCTION_EXPRESSION
            | JS_ASSIGNMENT_EXPRESSION
            | JS_AWAIT_EXPRESSION
            | JS_BINARY_EXPRESSION
            | JS_CALL_EXPRESSION
            | JS_CLASS_EXPRESSION
            | JS_COMPUTED_MEMBER_EXPRESSION
            | JS_CONDITIONAL_EXPRESSION
            | JS_FUNCTION_EXPRESSION
            | JS_IDENTIFIER_EXPRESSION
            | JS_IMPORT_CALL_EXPRESSION
            | JS_IN_EXPRESSION
            | JS_INSTANCEOF_EXPRESSION
            | JS_LOGICAL_EXPRESSION
            | JS_NEW_EXPRESSION
            | JS_OBJECT_EXPRESSION
            | JS_PARENTHESIZED_EXPRESSION
            | JS_POST_UPDATE_EXPRESSION
            | JS_PRE_UPDATE_EXPRESSION
            | JS_SEQUENCE_EXPRESSION
            | JS_STATIC_MEMBER_EXPRESSION
            | JS_SUPER_EXPRESSION
            | JS_TEMPLATE
            | JS_THIS_EXPRESSION
            | JS_UNARY_EXPRESSION
            | JS_UNKNOWN_EXPRESSION
            | JS_YIELD_EXPRESSION
            | JSX_TAG_EXPRESSION
            | NEW_TARGET
            | TS_AS_EXPRESSION
            | TS_NON_NULL_ASSERTION_EXPRESSION
            | TS_TYPE_ASSERTION_EXPRESSION => true,
            k if JsAnyLiteralExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IMPORT_META => JsAnyExpression::ImportMeta(ImportMeta { syntax }),
            JS_ARRAY_EXPRESSION => JsAnyExpression::JsArrayExpression(JsArrayExpression { syntax }),
            JS_ARROW_FUNCTION_EXPRESSION => {
                JsAnyExpression::JsArrowFunctionExpression(JsArrowFunctionExpression { syntax })
            }
            JS_ASSIGNMENT_EXPRESSION => {
                JsAnyExpression::JsAssignmentExpression(JsAssignmentExpression { syntax })
            }
            JS_AWAIT_EXPRESSION => JsAnyExpression::JsAwaitExpression(JsAwaitExpression { syntax }),
            JS_BINARY_EXPRESSION => {
                JsAnyExpression::JsBinaryExpression(JsBinaryExpression { syntax })
            }
            JS_CALL_EXPRESSION => JsAnyExpression::JsCallExpression(JsCallExpression { syntax }),
            JS_CLASS_EXPRESSION => JsAnyExpression::JsClassExpression(JsClassExpression { syntax }),
            JS_COMPUTED_MEMBER_EXPRESSION => {
                JsAnyExpression::JsComputedMemberExpression(JsComputedMemberExpression { syntax })
            }
            JS_CONDITIONAL_EXPRESSION => {
                JsAnyExpression::JsConditionalExpression(JsConditionalExpression { syntax })
            }
            JS_FUNCTION_EXPRESSION => {
                JsAnyExpression::JsFunctionExpression(JsFunctionExpression { syntax })
            }
            JS_IDENTIFIER_EXPRESSION => {
                JsAnyExpression::JsIdentifierExpression(JsIdentifierExpression { syntax })
            }
            JS_IMPORT_CALL_EXPRESSION => {
                JsAnyExpression::JsImportCallExpression(JsImportCallExpression { syntax })
            }
            JS_IN_EXPRESSION => JsAnyExpression::JsInExpression(JsInExpression { syntax }),
            JS_INSTANCEOF_EXPRESSION => {
                JsAnyExpression::JsInstanceofExpression(JsInstanceofExpression { syntax })
            }
            JS_LOGICAL_EXPRESSION => {
                JsAnyExpression::JsLogicalExpression(JsLogicalExpression { syntax })
            }
            JS_NEW_EXPRESSION => JsAnyExpression::JsNewExpression(JsNewExpression { syntax }),
            JS_OBJECT_EXPRESSION => {
                JsAnyExpression::JsObjectExpression(JsObjectExpression { syntax })
            }
            JS_PARENTHESIZED_EXPRESSION => {
                JsAnyExpression::JsParenthesizedExpression(JsParenthesizedExpression { syntax })
            }
            JS_POST_UPDATE_EXPRESSION => {
                JsAnyExpression::JsPostUpdateExpression(JsPostUpdateExpression { syntax })
            }
            JS_PRE_UPDATE_EXPRESSION => {
                JsAnyExpression::JsPreUpdateExpression(JsPreUpdateExpression { syntax })
            }
            JS_SEQUENCE_EXPRESSION => {
                JsAnyExpression::JsSequenceExpression(JsSequenceExpression { syntax })
            }
            JS_STATIC_MEMBER_EXPRESSION => {
                JsAnyExpression::JsStaticMemberExpression(JsStaticMemberExpression { syntax })
            }
            JS_SUPER_EXPRESSION => JsAnyExpression::JsSuperExpression(JsSuperExpression { syntax }),
            JS_TEMPLATE => JsAnyExpression::JsTemplate(JsTemplate { syntax }),
            JS_THIS_EXPRESSION => JsAnyExpression::JsThisExpression(JsThisExpression { syntax }),
            JS_UNARY_EXPRESSION => JsAnyExpression::JsUnaryExpression(JsUnaryExpression { syntax }),
            JS_UNKNOWN_EXPRESSION => {
                JsAnyExpression::JsUnknownExpression(JsUnknownExpression { syntax })
            }
            JS_YIELD_EXPRESSION => JsAnyExpression::JsYieldExpression(JsYieldExpression { syntax }),
            JSX_TAG_EXPRESSION => JsAnyExpression::JsxTagExpression(JsxTagExpression { syntax }),
            NEW_TARGET => JsAnyExpression::NewTarget(NewTarget { syntax }),
            TS_AS_EXPRESSION => JsAnyExpression::TsAsExpression(TsAsExpression { syntax }),
            TS_NON_NULL_ASSERTION_EXPRESSION => {
                JsAnyExpression::TsNonNullAssertionExpression(TsNonNullAssertionExpression {
                    syntax,
                })
            }
            TS_TYPE_ASSERTION_EXPRESSION => {
                JsAnyExpression::TsTypeAssertionExpression(TsTypeAssertionExpression { syntax })
            }
            _ => {
                if let Some(js_any_literal_expression) = JsAnyLiteralExpression::cast(syntax) {
                    return Some(JsAnyExpression::JsAnyLiteralExpression(
                        js_any_literal_expression,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyExpression::ImportMeta(it) => &it.syntax,
            JsAnyExpression::JsArrayExpression(it) => &it.syntax,
            JsAnyExpression::JsArrowFunctionExpression(it) => &it.syntax,
            JsAnyExpression::JsAssignmentExpression(it) => &it.syntax,
            JsAnyExpression::JsAwaitExpression(it) => &it.syntax,
            JsAnyExpression::JsBinaryExpression(it) => &it.syntax,
            JsAnyExpression::JsCallExpression(it) => &it.syntax,
            JsAnyExpression::JsClassExpression(it) => &it.syntax,
            JsAnyExpression::JsComputedMemberExpression(it) => &it.syntax,
            JsAnyExpression::JsConditionalExpression(it) => &it.syntax,
            JsAnyExpression::JsFunctionExpression(it) => &it.syntax,
            JsAnyExpression::JsIdentifierExpression(it) => &it.syntax,
            JsAnyExpression::JsImportCallExpression(it) => &it.syntax,
            JsAnyExpression::JsInExpression(it) => &it.syntax,
            JsAnyExpression::JsInstanceofExpression(it) => &it.syntax,
            JsAnyExpression::JsLogicalExpression(it) => &it.syntax,
            JsAnyExpression::JsNewExpression(it) => &it.syntax,
            JsAnyExpression::JsObjectExpression(it) => &it.syntax,
            JsAnyExpression::JsParenthesizedExpression(it) => &it.syntax,
            JsAnyExpression::JsPostUpdateExpression(it) => &it.syntax,
            JsAnyExpression::JsPreUpdateExpression(it) => &it.syntax,
            JsAnyExpression::JsSequenceExpression(it) => &it.syntax,
            JsAnyExpression::JsStaticMemberExpression(it) => &it.syntax,
            JsAnyExpression::JsSuperExpression(it) => &it.syntax,
            JsAnyExpression::JsTemplate(it) => &it.syntax,
            JsAnyExpression::JsThisExpression(it) => &it.syntax,
            JsAnyExpression::JsUnaryExpression(it) => &it.syntax,
            JsAnyExpression::JsUnknownExpression(it) => &it.syntax,
            JsAnyExpression::JsYieldExpression(it) => &it.syntax,
            JsAnyExpression::JsxTagExpression(it) => &it.syntax,
            JsAnyExpression::NewTarget(it) => &it.syntax,
            JsAnyExpression::TsAsExpression(it) => &it.syntax,
            JsAnyExpression::TsNonNullAssertionExpression(it) => &it.syntax,
            JsAnyExpression::TsTypeAssertionExpression(it) => &it.syntax,
            JsAnyExpression::JsAnyLiteralExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyExpression::ImportMeta(it) => it.syntax,
            JsAnyExpression::JsArrayExpression(it) => it.syntax,
            JsAnyExpression::JsArrowFunctionExpression(it) => it.syntax,
            JsAnyExpression::JsAssignmentExpression(it) => it.syntax,
            JsAnyExpression::JsAwaitExpression(it) => it.syntax,
            JsAnyExpression::JsBinaryExpression(it) => it.syntax,
            JsAnyExpression::JsCallExpression(it) => it.syntax,
            JsAnyExpression::JsClassExpression(it) => it.syntax,
            JsAnyExpression::JsComputedMemberExpression(it) => it.syntax,
            JsAnyExpression::JsConditionalExpression(it) => it.syntax,
            JsAnyExpression::JsFunctionExpression(it) => it.syntax,
            JsAnyExpression::JsIdentifierExpression(it) => it.syntax,
            JsAnyExpression::JsImportCallExpression(it) => it.syntax,
            JsAnyExpression::JsInExpression(it) => it.syntax,
            JsAnyExpression::JsInstanceofExpression(it) => it.syntax,
            JsAnyExpression::JsLogicalExpression(it) => it.syntax,
            JsAnyExpression::JsNewExpression(it) => it.syntax,
            JsAnyExpression::JsObjectExpression(it) => it.syntax,
            JsAnyExpression::JsParenthesizedExpression(it) => it.syntax,
            JsAnyExpression::JsPostUpdateExpression(it) => it.syntax,
            JsAnyExpression::JsPreUpdateExpression(it) => it.syntax,
            JsAnyExpression::JsSequenceExpression(it) => it.syntax,
            JsAnyExpression::JsStaticMemberExpression(it) => it.syntax,
            JsAnyExpression::JsSuperExpression(it) => it.syntax,
            JsAnyExpression::JsTemplate(it) => it.syntax,
            JsAnyExpression::JsThisExpression(it) => it.syntax,
            JsAnyExpression::JsUnaryExpression(it) => it.syntax,
            JsAnyExpression::JsUnknownExpression(it) => it.syntax,
            JsAnyExpression::JsYieldExpression(it) => it.syntax,
            JsAnyExpression::JsxTagExpression(it) => it.syntax,
            JsAnyExpression::NewTarget(it) => it.syntax,
            JsAnyExpression::TsAsExpression(it) => it.syntax,
            JsAnyExpression::TsNonNullAssertionExpression(it) => it.syntax,
            JsAnyExpression::TsTypeAssertionExpression(it) => it.syntax,
            JsAnyExpression::JsAnyLiteralExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyExpression::ImportMeta(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsAnyLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsArrayExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsArrowFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsAssignmentExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsAwaitExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsBinaryExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsCallExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsClassExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsComputedMemberExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsConditionalExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsIdentifierExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsImportCallExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsInExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsInstanceofExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsLogicalExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsNewExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsObjectExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsParenthesizedExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsPostUpdateExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsPreUpdateExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsSequenceExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsStaticMemberExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsSuperExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsTemplate(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsThisExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsUnaryExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsUnknownExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsYieldExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::JsxTagExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::NewTarget(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::TsAsExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::TsNonNullAssertionExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyExpression::TsTypeAssertionExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyExpression> for SyntaxNode {
    fn from(n: JsAnyExpression) -> SyntaxNode {
        match n {
            JsAnyExpression::ImportMeta(it) => it.into(),
            JsAnyExpression::JsAnyLiteralExpression(it) => it.into(),
            JsAnyExpression::JsArrayExpression(it) => it.into(),
            JsAnyExpression::JsArrowFunctionExpression(it) => it.into(),
            JsAnyExpression::JsAssignmentExpression(it) => it.into(),
            JsAnyExpression::JsAwaitExpression(it) => it.into(),
            JsAnyExpression::JsBinaryExpression(it) => it.into(),
            JsAnyExpression::JsCallExpression(it) => it.into(),
            JsAnyExpression::JsClassExpression(it) => it.into(),
            JsAnyExpression::JsComputedMemberExpression(it) => it.into(),
            JsAnyExpression::JsConditionalExpression(it) => it.into(),
            JsAnyExpression::JsFunctionExpression(it) => it.into(),
            JsAnyExpression::JsIdentifierExpression(it) => it.into(),
            JsAnyExpression::JsImportCallExpression(it) => it.into(),
            JsAnyExpression::JsInExpression(it) => it.into(),
            JsAnyExpression::JsInstanceofExpression(it) => it.into(),
            JsAnyExpression::JsLogicalExpression(it) => it.into(),
            JsAnyExpression::JsNewExpression(it) => it.into(),
            JsAnyExpression::JsObjectExpression(it) => it.into(),
            JsAnyExpression::JsParenthesizedExpression(it) => it.into(),
            JsAnyExpression::JsPostUpdateExpression(it) => it.into(),
            JsAnyExpression::JsPreUpdateExpression(it) => it.into(),
            JsAnyExpression::JsSequenceExpression(it) => it.into(),
            JsAnyExpression::JsStaticMemberExpression(it) => it.into(),
            JsAnyExpression::JsSuperExpression(it) => it.into(),
            JsAnyExpression::JsTemplate(it) => it.into(),
            JsAnyExpression::JsThisExpression(it) => it.into(),
            JsAnyExpression::JsUnaryExpression(it) => it.into(),
            JsAnyExpression::JsUnknownExpression(it) => it.into(),
            JsAnyExpression::JsYieldExpression(it) => it.into(),
            JsAnyExpression::JsxTagExpression(it) => it.into(),
            JsAnyExpression::NewTarget(it) => it.into(),
            JsAnyExpression::TsAsExpression(it) => it.into(),
            JsAnyExpression::TsNonNullAssertionExpression(it) => it.into(),
            JsAnyExpression::TsTypeAssertionExpression(it) => it.into(),
        }
    }
}
impl From<JsAnyExpression> for SyntaxElement {
    fn from(n: JsAnyExpression) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsForVariableDeclaration> for JsAnyForInOrOfInitializer {
    fn from(node: JsForVariableDeclaration) -> JsAnyForInOrOfInitializer {
        JsAnyForInOrOfInitializer::JsForVariableDeclaration(node)
    }
}
impl AstNode for JsAnyForInOrOfInitializer {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_FOR_VARIABLE_DECLARATION => true,
            k if JsAnyAssignmentPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_FOR_VARIABLE_DECLARATION => {
                JsAnyForInOrOfInitializer::JsForVariableDeclaration(JsForVariableDeclaration {
                    syntax,
                })
            }
            _ => {
                if let Some(js_any_assignment_pattern) = JsAnyAssignmentPattern::cast(syntax) {
                    return Some(JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(
                        js_any_assignment_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyForInOrOfInitializer::JsForVariableDeclaration(it) => &it.syntax,
            JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyForInOrOfInitializer::JsForVariableDeclaration(it) => it.syntax,
            JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyForInOrOfInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
            JsAnyForInOrOfInitializer::JsForVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyForInOrOfInitializer> for SyntaxNode {
    fn from(n: JsAnyForInOrOfInitializer) -> SyntaxNode {
        match n {
            JsAnyForInOrOfInitializer::JsAnyAssignmentPattern(it) => it.into(),
            JsAnyForInOrOfInitializer::JsForVariableDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyForInOrOfInitializer> for SyntaxElement {
    fn from(n: JsAnyForInOrOfInitializer) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsVariableDeclaration> for JsAnyForInitializer {
    fn from(node: JsVariableDeclaration) -> JsAnyForInitializer {
        JsAnyForInitializer::JsVariableDeclaration(node)
    }
}
impl AstNode for JsAnyForInitializer {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_VARIABLE_DECLARATION => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_VARIABLE_DECLARATION => {
                JsAnyForInitializer::JsVariableDeclaration(JsVariableDeclaration { syntax })
            }
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyForInitializer::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyForInitializer::JsVariableDeclaration(it) => &it.syntax,
            JsAnyForInitializer::JsAnyExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyForInitializer::JsVariableDeclaration(it) => it.syntax,
            JsAnyForInitializer::JsAnyExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyForInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyForInitializer::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyForInitializer::JsVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyForInitializer> for SyntaxNode {
    fn from(n: JsAnyForInitializer) -> SyntaxNode {
        match n {
            JsAnyForInitializer::JsAnyExpression(it) => it.into(),
            JsAnyForInitializer::JsVariableDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyForInitializer> for SyntaxElement {
    fn from(n: JsAnyForInitializer) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsFormalParameter> for JsAnyFormalParameter {
    fn from(node: JsFormalParameter) -> JsAnyFormalParameter {
        JsAnyFormalParameter::JsFormalParameter(node)
    }
}
impl From<JsUnknownParameter> for JsAnyFormalParameter {
    fn from(node: JsUnknownParameter) -> JsAnyFormalParameter {
        JsAnyFormalParameter::JsUnknownParameter(node)
    }
}
impl AstNode for JsAnyFormalParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_FORMAL_PARAMETER | JS_UNKNOWN_PARAMETER)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_FORMAL_PARAMETER => {
                JsAnyFormalParameter::JsFormalParameter(JsFormalParameter { syntax })
            }
            JS_UNKNOWN_PARAMETER => {
                JsAnyFormalParameter::JsUnknownParameter(JsUnknownParameter { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyFormalParameter::JsFormalParameter(it) => &it.syntax,
            JsAnyFormalParameter::JsUnknownParameter(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyFormalParameter::JsFormalParameter(it) => it.syntax,
            JsAnyFormalParameter::JsUnknownParameter(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyFormalParameter::JsFormalParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFormalParameter::JsUnknownParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyFormalParameter> for SyntaxNode {
    fn from(n: JsAnyFormalParameter) -> SyntaxNode {
        match n {
            JsAnyFormalParameter::JsFormalParameter(it) => it.into(),
            JsAnyFormalParameter::JsUnknownParameter(it) => it.into(),
        }
    }
}
impl From<JsAnyFormalParameter> for SyntaxElement {
    fn from(n: JsAnyFormalParameter) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrowFunctionExpression> for JsAnyFunction {
    fn from(node: JsArrowFunctionExpression) -> JsAnyFunction {
        JsAnyFunction::JsArrowFunctionExpression(node)
    }
}
impl From<JsFunctionDeclaration> for JsAnyFunction {
    fn from(node: JsFunctionDeclaration) -> JsAnyFunction {
        JsAnyFunction::JsFunctionDeclaration(node)
    }
}
impl From<JsFunctionExportDefaultDeclaration> for JsAnyFunction {
    fn from(node: JsFunctionExportDefaultDeclaration) -> JsAnyFunction {
        JsAnyFunction::JsFunctionExportDefaultDeclaration(node)
    }
}
impl From<JsFunctionExpression> for JsAnyFunction {
    fn from(node: JsFunctionExpression) -> JsAnyFunction {
        JsAnyFunction::JsFunctionExpression(node)
    }
}
impl AstNode for JsAnyFunction {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_ARROW_FUNCTION_EXPRESSION
                | JS_FUNCTION_DECLARATION
                | JS_FUNCTION_EXPORT_DEFAULT_DECLARATION
                | JS_FUNCTION_EXPRESSION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARROW_FUNCTION_EXPRESSION => {
                JsAnyFunction::JsArrowFunctionExpression(JsArrowFunctionExpression { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                JsAnyFunction::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_FUNCTION_EXPORT_DEFAULT_DECLARATION => {
                JsAnyFunction::JsFunctionExportDefaultDeclaration(
                    JsFunctionExportDefaultDeclaration { syntax },
                )
            }
            JS_FUNCTION_EXPRESSION => {
                JsAnyFunction::JsFunctionExpression(JsFunctionExpression { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyFunction::JsArrowFunctionExpression(it) => &it.syntax,
            JsAnyFunction::JsFunctionDeclaration(it) => &it.syntax,
            JsAnyFunction::JsFunctionExportDefaultDeclaration(it) => &it.syntax,
            JsAnyFunction::JsFunctionExpression(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyFunction::JsArrowFunctionExpression(it) => it.syntax,
            JsAnyFunction::JsFunctionDeclaration(it) => it.syntax,
            JsAnyFunction::JsFunctionExportDefaultDeclaration(it) => it.syntax,
            JsAnyFunction::JsFunctionExpression(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyFunction::JsArrowFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFunction::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFunction::JsFunctionExportDefaultDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFunction::JsFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyFunction> for SyntaxNode {
    fn from(n: JsAnyFunction) -> SyntaxNode {
        match n {
            JsAnyFunction::JsArrowFunctionExpression(it) => it.into(),
            JsAnyFunction::JsFunctionDeclaration(it) => it.into(),
            JsAnyFunction::JsFunctionExportDefaultDeclaration(it) => it.into(),
            JsAnyFunction::JsFunctionExpression(it) => it.into(),
        }
    }
}
impl From<JsAnyFunction> for SyntaxElement {
    fn from(n: JsAnyFunction) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsFunctionBody> for JsAnyFunctionBody {
    fn from(node: JsFunctionBody) -> JsAnyFunctionBody { JsAnyFunctionBody::JsFunctionBody(node) }
}
impl AstNode for JsAnyFunctionBody {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_FUNCTION_BODY => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_FUNCTION_BODY => JsAnyFunctionBody::JsFunctionBody(JsFunctionBody { syntax }),
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyFunctionBody::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyFunctionBody::JsFunctionBody(it) => &it.syntax,
            JsAnyFunctionBody::JsAnyExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyFunctionBody::JsFunctionBody(it) => it.syntax,
            JsAnyFunctionBody::JsAnyExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyFunctionBody::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyFunctionBody::JsFunctionBody(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyFunctionBody> for SyntaxNode {
    fn from(n: JsAnyFunctionBody) -> SyntaxNode {
        match n {
            JsAnyFunctionBody::JsAnyExpression(it) => it.into(),
            JsAnyFunctionBody::JsFunctionBody(it) => it.into(),
        }
    }
}
impl From<JsAnyFunctionBody> for SyntaxElement {
    fn from(n: JsAnyFunctionBody) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsImportAssertionEntry> for JsAnyImportAssertionEntry {
    fn from(node: JsImportAssertionEntry) -> JsAnyImportAssertionEntry {
        JsAnyImportAssertionEntry::JsImportAssertionEntry(node)
    }
}
impl From<JsUnknownImportAssertionEntry> for JsAnyImportAssertionEntry {
    fn from(node: JsUnknownImportAssertionEntry) -> JsAnyImportAssertionEntry {
        JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(node)
    }
}
impl AstNode for JsAnyImportAssertionEntry {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_IMPORT_ASSERTION_ENTRY | JS_UNKNOWN_IMPORT_ASSERTION_ENTRY
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IMPORT_ASSERTION_ENTRY => {
                JsAnyImportAssertionEntry::JsImportAssertionEntry(JsImportAssertionEntry { syntax })
            }
            JS_UNKNOWN_IMPORT_ASSERTION_ENTRY => {
                JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(
                    JsUnknownImportAssertionEntry { syntax },
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyImportAssertionEntry::JsImportAssertionEntry(it) => &it.syntax,
            JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyImportAssertionEntry::JsImportAssertionEntry(it) => it.syntax,
            JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyImportAssertionEntry::JsImportAssertionEntry(it) => std::fmt::Debug::fmt(it, f),
            JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyImportAssertionEntry> for SyntaxNode {
    fn from(n: JsAnyImportAssertionEntry) -> SyntaxNode {
        match n {
            JsAnyImportAssertionEntry::JsImportAssertionEntry(it) => it.into(),
            JsAnyImportAssertionEntry::JsUnknownImportAssertionEntry(it) => it.into(),
        }
    }
}
impl From<JsAnyImportAssertionEntry> for SyntaxElement {
    fn from(n: JsAnyImportAssertionEntry) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsImportBareClause> for JsAnyImportClause {
    fn from(node: JsImportBareClause) -> JsAnyImportClause {
        JsAnyImportClause::JsImportBareClause(node)
    }
}
impl From<JsImportDefaultClause> for JsAnyImportClause {
    fn from(node: JsImportDefaultClause) -> JsAnyImportClause {
        JsAnyImportClause::JsImportDefaultClause(node)
    }
}
impl From<JsImportNamedClause> for JsAnyImportClause {
    fn from(node: JsImportNamedClause) -> JsAnyImportClause {
        JsAnyImportClause::JsImportNamedClause(node)
    }
}
impl From<JsImportNamespaceClause> for JsAnyImportClause {
    fn from(node: JsImportNamespaceClause) -> JsAnyImportClause {
        JsAnyImportClause::JsImportNamespaceClause(node)
    }
}
impl AstNode for JsAnyImportClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_IMPORT_BARE_CLAUSE
                | JS_IMPORT_DEFAULT_CLAUSE
                | JS_IMPORT_NAMED_CLAUSE
                | JS_IMPORT_NAMESPACE_CLAUSE
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IMPORT_BARE_CLAUSE => {
                JsAnyImportClause::JsImportBareClause(JsImportBareClause { syntax })
            }
            JS_IMPORT_DEFAULT_CLAUSE => {
                JsAnyImportClause::JsImportDefaultClause(JsImportDefaultClause { syntax })
            }
            JS_IMPORT_NAMED_CLAUSE => {
                JsAnyImportClause::JsImportNamedClause(JsImportNamedClause { syntax })
            }
            JS_IMPORT_NAMESPACE_CLAUSE => {
                JsAnyImportClause::JsImportNamespaceClause(JsImportNamespaceClause { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyImportClause::JsImportBareClause(it) => &it.syntax,
            JsAnyImportClause::JsImportDefaultClause(it) => &it.syntax,
            JsAnyImportClause::JsImportNamedClause(it) => &it.syntax,
            JsAnyImportClause::JsImportNamespaceClause(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyImportClause::JsImportBareClause(it) => it.syntax,
            JsAnyImportClause::JsImportDefaultClause(it) => it.syntax,
            JsAnyImportClause::JsImportNamedClause(it) => it.syntax,
            JsAnyImportClause::JsImportNamespaceClause(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyImportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyImportClause::JsImportBareClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyImportClause::JsImportDefaultClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyImportClause::JsImportNamedClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnyImportClause::JsImportNamespaceClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyImportClause> for SyntaxNode {
    fn from(n: JsAnyImportClause) -> SyntaxNode {
        match n {
            JsAnyImportClause::JsImportBareClause(it) => it.into(),
            JsAnyImportClause::JsImportDefaultClause(it) => it.into(),
            JsAnyImportClause::JsImportNamedClause(it) => it.into(),
            JsAnyImportClause::JsImportNamespaceClause(it) => it.into(),
        }
    }
}
impl From<JsAnyImportClause> for SyntaxElement {
    fn from(n: JsAnyImportClause) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsPrivateName> for JsAnyInProperty {
    fn from(node: JsPrivateName) -> JsAnyInProperty { JsAnyInProperty::JsPrivateName(node) }
}
impl AstNode for JsAnyInProperty {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_PRIVATE_NAME => true,
            k if JsAnyExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_PRIVATE_NAME => JsAnyInProperty::JsPrivateName(JsPrivateName { syntax }),
            _ => {
                if let Some(js_any_expression) = JsAnyExpression::cast(syntax) {
                    return Some(JsAnyInProperty::JsAnyExpression(js_any_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyInProperty::JsPrivateName(it) => &it.syntax,
            JsAnyInProperty::JsAnyExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyInProperty::JsPrivateName(it) => it.syntax,
            JsAnyInProperty::JsAnyExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyInProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyInProperty::JsAnyExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyInProperty::JsPrivateName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyInProperty> for SyntaxNode {
    fn from(n: JsAnyInProperty) -> SyntaxNode {
        match n {
            JsAnyInProperty::JsAnyExpression(it) => it.into(),
            JsAnyInProperty::JsPrivateName(it) => it.into(),
        }
    }
}
impl From<JsAnyInProperty> for SyntaxElement {
    fn from(n: JsAnyInProperty) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBigIntLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsBigIntLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsBigIntLiteralExpression(node)
    }
}
impl From<JsBooleanLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsBooleanLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsBooleanLiteralExpression(node)
    }
}
impl From<JsNullLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsNullLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsNullLiteralExpression(node)
    }
}
impl From<JsNumberLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsNumberLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsNumberLiteralExpression(node)
    }
}
impl From<JsRegexLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsRegexLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsRegexLiteralExpression(node)
    }
}
impl From<JsStringLiteralExpression> for JsAnyLiteralExpression {
    fn from(node: JsStringLiteralExpression) -> JsAnyLiteralExpression {
        JsAnyLiteralExpression::JsStringLiteralExpression(node)
    }
}
impl AstNode for JsAnyLiteralExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BIG_INT_LITERAL_EXPRESSION
                | JS_BOOLEAN_LITERAL_EXPRESSION
                | JS_NULL_LITERAL_EXPRESSION
                | JS_NUMBER_LITERAL_EXPRESSION
                | JS_REGEX_LITERAL_EXPRESSION
                | JS_STRING_LITERAL_EXPRESSION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BIG_INT_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsBigIntLiteralExpression(JsBigIntLiteralExpression {
                    syntax,
                })
            }
            JS_BOOLEAN_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsBooleanLiteralExpression(JsBooleanLiteralExpression {
                    syntax,
                })
            }
            JS_NULL_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsNullLiteralExpression(JsNullLiteralExpression { syntax })
            }
            JS_NUMBER_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsNumberLiteralExpression(JsNumberLiteralExpression {
                    syntax,
                })
            }
            JS_REGEX_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsRegexLiteralExpression(JsRegexLiteralExpression {
                    syntax,
                })
            }
            JS_STRING_LITERAL_EXPRESSION => {
                JsAnyLiteralExpression::JsStringLiteralExpression(JsStringLiteralExpression {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyLiteralExpression::JsBigIntLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsBooleanLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsNullLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsNumberLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsRegexLiteralExpression(it) => &it.syntax,
            JsAnyLiteralExpression::JsStringLiteralExpression(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyLiteralExpression::JsBigIntLiteralExpression(it) => it.syntax,
            JsAnyLiteralExpression::JsBooleanLiteralExpression(it) => it.syntax,
            JsAnyLiteralExpression::JsNullLiteralExpression(it) => it.syntax,
            JsAnyLiteralExpression::JsNumberLiteralExpression(it) => it.syntax,
            JsAnyLiteralExpression::JsRegexLiteralExpression(it) => it.syntax,
            JsAnyLiteralExpression::JsStringLiteralExpression(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyLiteralExpression::JsBigIntLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsBooleanLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsNullLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsNumberLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsRegexLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            JsAnyLiteralExpression::JsStringLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyLiteralExpression> for SyntaxNode {
    fn from(n: JsAnyLiteralExpression) -> SyntaxNode {
        match n {
            JsAnyLiteralExpression::JsBigIntLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsBooleanLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsNullLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsNumberLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsRegexLiteralExpression(it) => it.into(),
            JsAnyLiteralExpression::JsStringLiteralExpression(it) => it.into(),
        }
    }
}
impl From<JsAnyLiteralExpression> for SyntaxElement {
    fn from(n: JsAnyLiteralExpression) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for JsAnyMethodModifier {
    fn from(node: JsStaticModifier) -> JsAnyMethodModifier {
        JsAnyMethodModifier::JsStaticModifier(node)
    }
}
impl From<TsAccessibilityModifier> for JsAnyMethodModifier {
    fn from(node: TsAccessibilityModifier) -> JsAnyMethodModifier {
        JsAnyMethodModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for JsAnyMethodModifier {
    fn from(node: TsOverrideModifier) -> JsAnyMethodModifier {
        JsAnyMethodModifier::TsOverrideModifier(node)
    }
}
impl AstNode for JsAnyMethodModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER | TS_ACCESSIBILITY_MODIFIER | TS_OVERRIDE_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                JsAnyMethodModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                JsAnyMethodModifier::TsAccessibilityModifier(TsAccessibilityModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                JsAnyMethodModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyMethodModifier::JsStaticModifier(it) => &it.syntax,
            JsAnyMethodModifier::TsAccessibilityModifier(it) => &it.syntax,
            JsAnyMethodModifier::TsOverrideModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyMethodModifier::JsStaticModifier(it) => it.syntax,
            JsAnyMethodModifier::TsAccessibilityModifier(it) => it.syntax,
            JsAnyMethodModifier::TsOverrideModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyMethodModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyMethodModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyMethodModifier::TsAccessibilityModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyMethodModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyMethodModifier> for SyntaxNode {
    fn from(n: JsAnyMethodModifier) -> SyntaxNode {
        match n {
            JsAnyMethodModifier::JsStaticModifier(it) => it.into(),
            JsAnyMethodModifier::TsAccessibilityModifier(it) => it.into(),
            JsAnyMethodModifier::TsOverrideModifier(it) => it.into(),
        }
    }
}
impl From<JsAnyMethodModifier> for SyntaxElement {
    fn from(n: JsAnyMethodModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExport> for JsAnyModuleItem {
    fn from(node: JsExport) -> JsAnyModuleItem { JsAnyModuleItem::JsExport(node) }
}
impl From<JsImport> for JsAnyModuleItem {
    fn from(node: JsImport) -> JsAnyModuleItem { JsAnyModuleItem::JsImport(node) }
}
impl AstNode for JsAnyModuleItem {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_EXPORT | JS_IMPORT => true,
            k if JsAnyStatement::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT => JsAnyModuleItem::JsExport(JsExport { syntax }),
            JS_IMPORT => JsAnyModuleItem::JsImport(JsImport { syntax }),
            _ => {
                if let Some(js_any_statement) = JsAnyStatement::cast(syntax) {
                    return Some(JsAnyModuleItem::JsAnyStatement(js_any_statement));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyModuleItem::JsExport(it) => &it.syntax,
            JsAnyModuleItem::JsImport(it) => &it.syntax,
            JsAnyModuleItem::JsAnyStatement(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyModuleItem::JsExport(it) => it.syntax,
            JsAnyModuleItem::JsImport(it) => it.syntax,
            JsAnyModuleItem::JsAnyStatement(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyModuleItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyModuleItem::JsAnyStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyModuleItem::JsExport(it) => std::fmt::Debug::fmt(it, f),
            JsAnyModuleItem::JsImport(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyModuleItem> for SyntaxNode {
    fn from(n: JsAnyModuleItem) -> SyntaxNode {
        match n {
            JsAnyModuleItem::JsAnyStatement(it) => it.into(),
            JsAnyModuleItem::JsExport(it) => it.into(),
            JsAnyModuleItem::JsImport(it) => it.into(),
        }
    }
}
impl From<JsAnyModuleItem> for SyntaxElement {
    fn from(n: JsAnyModuleItem) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsName> for JsAnyName {
    fn from(node: JsName) -> JsAnyName { JsAnyName::JsName(node) }
}
impl From<JsPrivateName> for JsAnyName {
    fn from(node: JsPrivateName) -> JsAnyName { JsAnyName::JsPrivateName(node) }
}
impl AstNode for JsAnyName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JS_NAME | JS_PRIVATE_NAME) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_NAME => JsAnyName::JsName(JsName { syntax }),
            JS_PRIVATE_NAME => JsAnyName::JsPrivateName(JsPrivateName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyName::JsName(it) => &it.syntax,
            JsAnyName::JsPrivateName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyName::JsName(it) => it.syntax,
            JsAnyName::JsPrivateName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyName::JsName(it) => std::fmt::Debug::fmt(it, f),
            JsAnyName::JsPrivateName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyName> for SyntaxNode {
    fn from(n: JsAnyName) -> SyntaxNode {
        match n {
            JsAnyName::JsName(it) => it.into(),
            JsAnyName::JsPrivateName(it) => it.into(),
        }
    }
}
impl From<JsAnyName> for SyntaxElement {
    fn from(n: JsAnyName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsNamedImportSpecifiers> for JsAnyNamedImport {
    fn from(node: JsNamedImportSpecifiers) -> JsAnyNamedImport {
        JsAnyNamedImport::JsNamedImportSpecifiers(node)
    }
}
impl From<JsNamespaceImportSpecifier> for JsAnyNamedImport {
    fn from(node: JsNamespaceImportSpecifier) -> JsAnyNamedImport {
        JsAnyNamedImport::JsNamespaceImportSpecifier(node)
    }
}
impl AstNode for JsAnyNamedImport {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_NAMED_IMPORT_SPECIFIERS | JS_NAMESPACE_IMPORT_SPECIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_NAMED_IMPORT_SPECIFIERS => {
                JsAnyNamedImport::JsNamedImportSpecifiers(JsNamedImportSpecifiers { syntax })
            }
            JS_NAMESPACE_IMPORT_SPECIFIER => {
                JsAnyNamedImport::JsNamespaceImportSpecifier(JsNamespaceImportSpecifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyNamedImport::JsNamedImportSpecifiers(it) => &it.syntax,
            JsAnyNamedImport::JsNamespaceImportSpecifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyNamedImport::JsNamedImportSpecifiers(it) => it.syntax,
            JsAnyNamedImport::JsNamespaceImportSpecifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyNamedImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyNamedImport::JsNamedImportSpecifiers(it) => std::fmt::Debug::fmt(it, f),
            JsAnyNamedImport::JsNamespaceImportSpecifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyNamedImport> for SyntaxNode {
    fn from(n: JsAnyNamedImport) -> SyntaxNode {
        match n {
            JsAnyNamedImport::JsNamedImportSpecifiers(it) => it.into(),
            JsAnyNamedImport::JsNamespaceImportSpecifier(it) => it.into(),
        }
    }
}
impl From<JsAnyNamedImport> for SyntaxElement {
    fn from(n: JsAnyNamedImport) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsNamedImportSpecifier> for JsAnyNamedImportSpecifier {
    fn from(node: JsNamedImportSpecifier) -> JsAnyNamedImportSpecifier {
        JsAnyNamedImportSpecifier::JsNamedImportSpecifier(node)
    }
}
impl From<JsShorthandNamedImportSpecifier> for JsAnyNamedImportSpecifier {
    fn from(node: JsShorthandNamedImportSpecifier) -> JsAnyNamedImportSpecifier {
        JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(node)
    }
}
impl From<JsUnknownNamedImportSpecifier> for JsAnyNamedImportSpecifier {
    fn from(node: JsUnknownNamedImportSpecifier) -> JsAnyNamedImportSpecifier {
        JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(node)
    }
}
impl AstNode for JsAnyNamedImportSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_NAMED_IMPORT_SPECIFIER
                | JS_SHORTHAND_NAMED_IMPORT_SPECIFIER
                | JS_UNKNOWN_NAMED_IMPORT_SPECIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_NAMED_IMPORT_SPECIFIER => {
                JsAnyNamedImportSpecifier::JsNamedImportSpecifier(JsNamedImportSpecifier { syntax })
            }
            JS_SHORTHAND_NAMED_IMPORT_SPECIFIER => {
                JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(
                    JsShorthandNamedImportSpecifier { syntax },
                )
            }
            JS_UNKNOWN_NAMED_IMPORT_SPECIFIER => {
                JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(
                    JsUnknownNamedImportSpecifier { syntax },
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyNamedImportSpecifier::JsNamedImportSpecifier(it) => &it.syntax,
            JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => &it.syntax,
            JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyNamedImportSpecifier::JsNamedImportSpecifier(it) => it.syntax,
            JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => it.syntax,
            JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyNamedImportSpecifier::JsNamedImportSpecifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyNamedImportSpecifier> for SyntaxNode {
    fn from(n: JsAnyNamedImportSpecifier) -> SyntaxNode {
        match n {
            JsAnyNamedImportSpecifier::JsNamedImportSpecifier(it) => it.into(),
            JsAnyNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => it.into(),
            JsAnyNamedImportSpecifier::JsUnknownNamedImportSpecifier(it) => it.into(),
        }
    }
}
impl From<JsAnyNamedImportSpecifier> for SyntaxElement {
    fn from(n: JsAnyNamedImportSpecifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsObjectAssignmentPatternProperty> for JsAnyObjectAssignmentPatternMember {
    fn from(node: JsObjectAssignmentPatternProperty) -> JsAnyObjectAssignmentPatternMember {
        JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(node)
    }
}
impl From<JsObjectAssignmentPatternRest> for JsAnyObjectAssignmentPatternMember {
    fn from(node: JsObjectAssignmentPatternRest) -> JsAnyObjectAssignmentPatternMember {
        JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(node)
    }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for JsAnyObjectAssignmentPatternMember {
    fn from(
        node: JsObjectAssignmentPatternShorthandProperty,
    ) -> JsAnyObjectAssignmentPatternMember {
        JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(node)
    }
}
impl From<JsUnknownAssignment> for JsAnyObjectAssignmentPatternMember {
    fn from(node: JsUnknownAssignment) -> JsAnyObjectAssignmentPatternMember {
        JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(node)
    }
}
impl AstNode for JsAnyObjectAssignmentPatternMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY
                | JS_OBJECT_ASSIGNMENT_PATTERN_REST
                | JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY
                | JS_UNKNOWN_ASSIGNMENT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY => {
                JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(
                    JsObjectAssignmentPatternProperty { syntax },
                )
            }
            JS_OBJECT_ASSIGNMENT_PATTERN_REST => {
                JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(
                    JsObjectAssignmentPatternRest { syntax },
                )
            }
            JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY => {
                JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(
                    JsObjectAssignmentPatternShorthandProperty { syntax },
                )
            }
            JS_UNKNOWN_ASSIGNMENT => {
                JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(JsUnknownAssignment {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => &it.syntax,
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => &it.syntax,
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                &it.syntax
            }
            JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => it.syntax,
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => it.syntax,
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                it.syntax
            }
            JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyObjectAssignmentPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<JsAnyObjectAssignmentPatternMember> for SyntaxNode {
    fn from(n: JsAnyObjectAssignmentPatternMember) -> SyntaxNode {
        match n {
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => it.into(),
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => it.into(),
            JsAnyObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                it.into()
            }
            JsAnyObjectAssignmentPatternMember::JsUnknownAssignment(it) => it.into(),
        }
    }
}
impl From<JsAnyObjectAssignmentPatternMember> for SyntaxElement {
    fn from(n: JsAnyObjectAssignmentPatternMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsIdentifierBinding> for JsAnyObjectBindingPatternMember {
    fn from(node: JsIdentifierBinding) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsIdentifierBinding(node)
    }
}
impl From<JsObjectBindingPatternProperty> for JsAnyObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternProperty) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(node)
    }
}
impl From<JsObjectBindingPatternRest> for JsAnyObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternRest) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(node)
    }
}
impl From<JsObjectBindingPatternShorthandProperty> for JsAnyObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternShorthandProperty) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(node)
    }
}
impl From<JsUnknownBinding> for JsAnyObjectBindingPatternMember {
    fn from(node: JsUnknownBinding) -> JsAnyObjectBindingPatternMember {
        JsAnyObjectBindingPatternMember::JsUnknownBinding(node)
    }
}
impl AstNode for JsAnyObjectBindingPatternMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_IDENTIFIER_BINDING
                | JS_OBJECT_BINDING_PATTERN_PROPERTY
                | JS_OBJECT_BINDING_PATTERN_REST
                | JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY
                | JS_UNKNOWN_BINDING
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IDENTIFIER_BINDING => {
                JsAnyObjectBindingPatternMember::JsIdentifierBinding(JsIdentifierBinding { syntax })
            }
            JS_OBJECT_BINDING_PATTERN_PROPERTY => {
                JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(
                    JsObjectBindingPatternProperty { syntax },
                )
            }
            JS_OBJECT_BINDING_PATTERN_REST => {
                JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(
                    JsObjectBindingPatternRest { syntax },
                )
            }
            JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY => {
                JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(
                    JsObjectBindingPatternShorthandProperty { syntax },
                )
            }
            JS_UNKNOWN_BINDING => {
                JsAnyObjectBindingPatternMember::JsUnknownBinding(JsUnknownBinding { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyObjectBindingPatternMember::JsIdentifierBinding(it) => &it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => &it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(it) => &it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                &it.syntax
            }
            JsAnyObjectBindingPatternMember::JsUnknownBinding(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyObjectBindingPatternMember::JsIdentifierBinding(it) => it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(it) => it.syntax,
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                it.syntax
            }
            JsAnyObjectBindingPatternMember::JsUnknownBinding(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyObjectBindingPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyObjectBindingPatternMember::JsIdentifierBinding(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            JsAnyObjectBindingPatternMember::JsUnknownBinding(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyObjectBindingPatternMember> for SyntaxNode {
    fn from(n: JsAnyObjectBindingPatternMember) -> SyntaxNode {
        match n {
            JsAnyObjectBindingPatternMember::JsIdentifierBinding(it) => it.into(),
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => it.into(),
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternRest(it) => it.into(),
            JsAnyObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                it.into()
            }
            JsAnyObjectBindingPatternMember::JsUnknownBinding(it) => it.into(),
        }
    }
}
impl From<JsAnyObjectBindingPatternMember> for SyntaxElement {
    fn from(n: JsAnyObjectBindingPatternMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsGetterObjectMember> for JsAnyObjectMember {
    fn from(node: JsGetterObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsGetterObjectMember(node)
    }
}
impl From<JsMethodObjectMember> for JsAnyObjectMember {
    fn from(node: JsMethodObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsMethodObjectMember(node)
    }
}
impl From<JsPropertyObjectMember> for JsAnyObjectMember {
    fn from(node: JsPropertyObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsPropertyObjectMember(node)
    }
}
impl From<JsSetterObjectMember> for JsAnyObjectMember {
    fn from(node: JsSetterObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsSetterObjectMember(node)
    }
}
impl From<JsShorthandPropertyObjectMember> for JsAnyObjectMember {
    fn from(node: JsShorthandPropertyObjectMember) -> JsAnyObjectMember {
        JsAnyObjectMember::JsShorthandPropertyObjectMember(node)
    }
}
impl From<JsSpread> for JsAnyObjectMember {
    fn from(node: JsSpread) -> JsAnyObjectMember { JsAnyObjectMember::JsSpread(node) }
}
impl From<JsUnknownMember> for JsAnyObjectMember {
    fn from(node: JsUnknownMember) -> JsAnyObjectMember { JsAnyObjectMember::JsUnknownMember(node) }
}
impl AstNode for JsAnyObjectMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_GETTER_OBJECT_MEMBER
                | JS_METHOD_OBJECT_MEMBER
                | JS_PROPERTY_OBJECT_MEMBER
                | JS_SETTER_OBJECT_MEMBER
                | JS_SHORTHAND_PROPERTY_OBJECT_MEMBER
                | JS_SPREAD
                | JS_UNKNOWN_MEMBER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_GETTER_OBJECT_MEMBER => {
                JsAnyObjectMember::JsGetterObjectMember(JsGetterObjectMember { syntax })
            }
            JS_METHOD_OBJECT_MEMBER => {
                JsAnyObjectMember::JsMethodObjectMember(JsMethodObjectMember { syntax })
            }
            JS_PROPERTY_OBJECT_MEMBER => {
                JsAnyObjectMember::JsPropertyObjectMember(JsPropertyObjectMember { syntax })
            }
            JS_SETTER_OBJECT_MEMBER => {
                JsAnyObjectMember::JsSetterObjectMember(JsSetterObjectMember { syntax })
            }
            JS_SHORTHAND_PROPERTY_OBJECT_MEMBER => {
                JsAnyObjectMember::JsShorthandPropertyObjectMember(
                    JsShorthandPropertyObjectMember { syntax },
                )
            }
            JS_SPREAD => JsAnyObjectMember::JsSpread(JsSpread { syntax }),
            JS_UNKNOWN_MEMBER => JsAnyObjectMember::JsUnknownMember(JsUnknownMember { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyObjectMember::JsGetterObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsMethodObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsPropertyObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsSetterObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsShorthandPropertyObjectMember(it) => &it.syntax,
            JsAnyObjectMember::JsSpread(it) => &it.syntax,
            JsAnyObjectMember::JsUnknownMember(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyObjectMember::JsGetterObjectMember(it) => it.syntax,
            JsAnyObjectMember::JsMethodObjectMember(it) => it.syntax,
            JsAnyObjectMember::JsPropertyObjectMember(it) => it.syntax,
            JsAnyObjectMember::JsSetterObjectMember(it) => it.syntax,
            JsAnyObjectMember::JsShorthandPropertyObjectMember(it) => it.syntax,
            JsAnyObjectMember::JsSpread(it) => it.syntax,
            JsAnyObjectMember::JsUnknownMember(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyObjectMember::JsGetterObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsMethodObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsPropertyObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsSetterObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsShorthandPropertyObjectMember(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsSpread(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMember::JsUnknownMember(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyObjectMember> for SyntaxNode {
    fn from(n: JsAnyObjectMember) -> SyntaxNode {
        match n {
            JsAnyObjectMember::JsGetterObjectMember(it) => it.into(),
            JsAnyObjectMember::JsMethodObjectMember(it) => it.into(),
            JsAnyObjectMember::JsPropertyObjectMember(it) => it.into(),
            JsAnyObjectMember::JsSetterObjectMember(it) => it.into(),
            JsAnyObjectMember::JsShorthandPropertyObjectMember(it) => it.into(),
            JsAnyObjectMember::JsSpread(it) => it.into(),
            JsAnyObjectMember::JsUnknownMember(it) => it.into(),
        }
    }
}
impl From<JsAnyObjectMember> for SyntaxElement {
    fn from(n: JsAnyObjectMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsComputedMemberName> for JsAnyObjectMemberName {
    fn from(node: JsComputedMemberName) -> JsAnyObjectMemberName {
        JsAnyObjectMemberName::JsComputedMemberName(node)
    }
}
impl From<JsLiteralMemberName> for JsAnyObjectMemberName {
    fn from(node: JsLiteralMemberName) -> JsAnyObjectMemberName {
        JsAnyObjectMemberName::JsLiteralMemberName(node)
    }
}
impl AstNode for JsAnyObjectMemberName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_COMPUTED_MEMBER_NAME | JS_LITERAL_MEMBER_NAME)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_COMPUTED_MEMBER_NAME => {
                JsAnyObjectMemberName::JsComputedMemberName(JsComputedMemberName { syntax })
            }
            JS_LITERAL_MEMBER_NAME => {
                JsAnyObjectMemberName::JsLiteralMemberName(JsLiteralMemberName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyObjectMemberName::JsComputedMemberName(it) => &it.syntax,
            JsAnyObjectMemberName::JsLiteralMemberName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyObjectMemberName::JsComputedMemberName(it) => it.syntax,
            JsAnyObjectMemberName::JsLiteralMemberName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyObjectMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyObjectMemberName::JsComputedMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsAnyObjectMemberName::JsLiteralMemberName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyObjectMemberName> for SyntaxNode {
    fn from(n: JsAnyObjectMemberName) -> SyntaxNode {
        match n {
            JsAnyObjectMemberName::JsComputedMemberName(it) => it.into(),
            JsAnyObjectMemberName::JsLiteralMemberName(it) => it.into(),
        }
    }
}
impl From<JsAnyObjectMemberName> for SyntaxElement {
    fn from(n: JsAnyObjectMemberName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsRestParameter> for JsAnyParameter {
    fn from(node: JsRestParameter) -> JsAnyParameter { JsAnyParameter::JsRestParameter(node) }
}
impl From<TsThisParameter> for JsAnyParameter {
    fn from(node: TsThisParameter) -> JsAnyParameter { JsAnyParameter::TsThisParameter(node) }
}
impl AstNode for JsAnyParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_REST_PARAMETER | TS_THIS_PARAMETER => true,
            k if JsAnyFormalParameter::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REST_PARAMETER => JsAnyParameter::JsRestParameter(JsRestParameter { syntax }),
            TS_THIS_PARAMETER => JsAnyParameter::TsThisParameter(TsThisParameter { syntax }),
            _ => {
                if let Some(js_any_formal_parameter) = JsAnyFormalParameter::cast(syntax) {
                    return Some(JsAnyParameter::JsAnyFormalParameter(
                        js_any_formal_parameter,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyParameter::JsRestParameter(it) => &it.syntax,
            JsAnyParameter::TsThisParameter(it) => &it.syntax,
            JsAnyParameter::JsAnyFormalParameter(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyParameter::JsRestParameter(it) => it.syntax,
            JsAnyParameter::TsThisParameter(it) => it.syntax,
            JsAnyParameter::JsAnyFormalParameter(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsAnyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyParameter::JsAnyFormalParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyParameter::JsRestParameter(it) => std::fmt::Debug::fmt(it, f),
            JsAnyParameter::TsThisParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyParameter> for SyntaxNode {
    fn from(n: JsAnyParameter) -> SyntaxNode {
        match n {
            JsAnyParameter::JsAnyFormalParameter(it) => it.into(),
            JsAnyParameter::JsRestParameter(it) => it.into(),
            JsAnyParameter::TsThisParameter(it) => it.into(),
        }
    }
}
impl From<JsAnyParameter> for SyntaxElement {
    fn from(n: JsAnyParameter) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for JsAnyPropertyModifier {
    fn from(node: JsStaticModifier) -> JsAnyPropertyModifier {
        JsAnyPropertyModifier::JsStaticModifier(node)
    }
}
impl From<TsAccessibilityModifier> for JsAnyPropertyModifier {
    fn from(node: TsAccessibilityModifier) -> JsAnyPropertyModifier {
        JsAnyPropertyModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for JsAnyPropertyModifier {
    fn from(node: TsOverrideModifier) -> JsAnyPropertyModifier {
        JsAnyPropertyModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for JsAnyPropertyModifier {
    fn from(node: TsReadonlyModifier) -> JsAnyPropertyModifier {
        JsAnyPropertyModifier::TsReadonlyModifier(node)
    }
}
impl AstNode for JsAnyPropertyModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_OVERRIDE_MODIFIER
                | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                JsAnyPropertyModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                JsAnyPropertyModifier::TsAccessibilityModifier(TsAccessibilityModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                JsAnyPropertyModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                JsAnyPropertyModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyPropertyModifier::JsStaticModifier(it) => &it.syntax,
            JsAnyPropertyModifier::TsAccessibilityModifier(it) => &it.syntax,
            JsAnyPropertyModifier::TsOverrideModifier(it) => &it.syntax,
            JsAnyPropertyModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyPropertyModifier::JsStaticModifier(it) => it.syntax,
            JsAnyPropertyModifier::TsAccessibilityModifier(it) => it.syntax,
            JsAnyPropertyModifier::TsOverrideModifier(it) => it.syntax,
            JsAnyPropertyModifier::TsReadonlyModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyPropertyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyPropertyModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyPropertyModifier::TsAccessibilityModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyPropertyModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            JsAnyPropertyModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyPropertyModifier> for SyntaxNode {
    fn from(n: JsAnyPropertyModifier) -> SyntaxNode {
        match n {
            JsAnyPropertyModifier::JsStaticModifier(it) => it.into(),
            JsAnyPropertyModifier::TsAccessibilityModifier(it) => it.into(),
            JsAnyPropertyModifier::TsOverrideModifier(it) => it.into(),
            JsAnyPropertyModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<JsAnyPropertyModifier> for SyntaxElement {
    fn from(n: JsAnyPropertyModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExpressionSnipped> for JsAnyRoot {
    fn from(node: JsExpressionSnipped) -> JsAnyRoot { JsAnyRoot::JsExpressionSnipped(node) }
}
impl From<JsModule> for JsAnyRoot {
    fn from(node: JsModule) -> JsAnyRoot { JsAnyRoot::JsModule(node) }
}
impl From<JsScript> for JsAnyRoot {
    fn from(node: JsScript) -> JsAnyRoot { JsAnyRoot::JsScript(node) }
}
impl AstNode for JsAnyRoot {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_EXPRESSION_SNIPPED | JS_MODULE | JS_SCRIPT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPRESSION_SNIPPED => JsAnyRoot::JsExpressionSnipped(JsExpressionSnipped { syntax }),
            JS_MODULE => JsAnyRoot::JsModule(JsModule { syntax }),
            JS_SCRIPT => JsAnyRoot::JsScript(JsScript { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyRoot::JsExpressionSnipped(it) => &it.syntax,
            JsAnyRoot::JsModule(it) => &it.syntax,
            JsAnyRoot::JsScript(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyRoot::JsExpressionSnipped(it) => it.syntax,
            JsAnyRoot::JsModule(it) => it.syntax,
            JsAnyRoot::JsScript(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyRoot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyRoot::JsExpressionSnipped(it) => std::fmt::Debug::fmt(it, f),
            JsAnyRoot::JsModule(it) => std::fmt::Debug::fmt(it, f),
            JsAnyRoot::JsScript(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyRoot> for SyntaxNode {
    fn from(n: JsAnyRoot) -> SyntaxNode {
        match n {
            JsAnyRoot::JsExpressionSnipped(it) => it.into(),
            JsAnyRoot::JsModule(it) => it.into(),
            JsAnyRoot::JsScript(it) => it.into(),
        }
    }
}
impl From<JsAnyRoot> for SyntaxElement {
    fn from(n: JsAnyRoot) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBlockStatement> for JsAnyStatement {
    fn from(node: JsBlockStatement) -> JsAnyStatement { JsAnyStatement::JsBlockStatement(node) }
}
impl From<JsBreakStatement> for JsAnyStatement {
    fn from(node: JsBreakStatement) -> JsAnyStatement { JsAnyStatement::JsBreakStatement(node) }
}
impl From<JsClassDeclaration> for JsAnyStatement {
    fn from(node: JsClassDeclaration) -> JsAnyStatement { JsAnyStatement::JsClassDeclaration(node) }
}
impl From<JsContinueStatement> for JsAnyStatement {
    fn from(node: JsContinueStatement) -> JsAnyStatement {
        JsAnyStatement::JsContinueStatement(node)
    }
}
impl From<JsDebuggerStatement> for JsAnyStatement {
    fn from(node: JsDebuggerStatement) -> JsAnyStatement {
        JsAnyStatement::JsDebuggerStatement(node)
    }
}
impl From<JsDoWhileStatement> for JsAnyStatement {
    fn from(node: JsDoWhileStatement) -> JsAnyStatement { JsAnyStatement::JsDoWhileStatement(node) }
}
impl From<JsEmptyStatement> for JsAnyStatement {
    fn from(node: JsEmptyStatement) -> JsAnyStatement { JsAnyStatement::JsEmptyStatement(node) }
}
impl From<JsExpressionStatement> for JsAnyStatement {
    fn from(node: JsExpressionStatement) -> JsAnyStatement {
        JsAnyStatement::JsExpressionStatement(node)
    }
}
impl From<JsForInStatement> for JsAnyStatement {
    fn from(node: JsForInStatement) -> JsAnyStatement { JsAnyStatement::JsForInStatement(node) }
}
impl From<JsForOfStatement> for JsAnyStatement {
    fn from(node: JsForOfStatement) -> JsAnyStatement { JsAnyStatement::JsForOfStatement(node) }
}
impl From<JsForStatement> for JsAnyStatement {
    fn from(node: JsForStatement) -> JsAnyStatement { JsAnyStatement::JsForStatement(node) }
}
impl From<JsFunctionDeclaration> for JsAnyStatement {
    fn from(node: JsFunctionDeclaration) -> JsAnyStatement {
        JsAnyStatement::JsFunctionDeclaration(node)
    }
}
impl From<JsIfStatement> for JsAnyStatement {
    fn from(node: JsIfStatement) -> JsAnyStatement { JsAnyStatement::JsIfStatement(node) }
}
impl From<JsLabeledStatement> for JsAnyStatement {
    fn from(node: JsLabeledStatement) -> JsAnyStatement { JsAnyStatement::JsLabeledStatement(node) }
}
impl From<JsReturnStatement> for JsAnyStatement {
    fn from(node: JsReturnStatement) -> JsAnyStatement { JsAnyStatement::JsReturnStatement(node) }
}
impl From<JsSwitchStatement> for JsAnyStatement {
    fn from(node: JsSwitchStatement) -> JsAnyStatement { JsAnyStatement::JsSwitchStatement(node) }
}
impl From<JsThrowStatement> for JsAnyStatement {
    fn from(node: JsThrowStatement) -> JsAnyStatement { JsAnyStatement::JsThrowStatement(node) }
}
impl From<JsTryFinallyStatement> for JsAnyStatement {
    fn from(node: JsTryFinallyStatement) -> JsAnyStatement {
        JsAnyStatement::JsTryFinallyStatement(node)
    }
}
impl From<JsTryStatement> for JsAnyStatement {
    fn from(node: JsTryStatement) -> JsAnyStatement { JsAnyStatement::JsTryStatement(node) }
}
impl From<JsUnknownStatement> for JsAnyStatement {
    fn from(node: JsUnknownStatement) -> JsAnyStatement { JsAnyStatement::JsUnknownStatement(node) }
}
impl From<JsVariableStatement> for JsAnyStatement {
    fn from(node: JsVariableStatement) -> JsAnyStatement {
        JsAnyStatement::JsVariableStatement(node)
    }
}
impl From<JsWhileStatement> for JsAnyStatement {
    fn from(node: JsWhileStatement) -> JsAnyStatement { JsAnyStatement::JsWhileStatement(node) }
}
impl From<JsWithStatement> for JsAnyStatement {
    fn from(node: JsWithStatement) -> JsAnyStatement { JsAnyStatement::JsWithStatement(node) }
}
impl From<TsDeclareFunctionDeclaration> for JsAnyStatement {
    fn from(node: TsDeclareFunctionDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsDeclareStatement> for JsAnyStatement {
    fn from(node: TsDeclareStatement) -> JsAnyStatement { JsAnyStatement::TsDeclareStatement(node) }
}
impl From<TsEnumDeclaration> for JsAnyStatement {
    fn from(node: TsEnumDeclaration) -> JsAnyStatement { JsAnyStatement::TsEnumDeclaration(node) }
}
impl From<TsExternalModuleDeclaration> for JsAnyStatement {
    fn from(node: TsExternalModuleDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for JsAnyStatement {
    fn from(node: TsGlobalDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for JsAnyStatement {
    fn from(node: TsImportEqualsDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for JsAnyStatement {
    fn from(node: TsInterfaceDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for JsAnyStatement {
    fn from(node: TsModuleDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for JsAnyStatement {
    fn from(node: TsTypeAliasDeclaration) -> JsAnyStatement {
        JsAnyStatement::TsTypeAliasDeclaration(node)
    }
}
impl AstNode for JsAnyStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BLOCK_STATEMENT
                | JS_BREAK_STATEMENT
                | JS_CLASS_DECLARATION
                | JS_CONTINUE_STATEMENT
                | JS_DEBUGGER_STATEMENT
                | JS_DO_WHILE_STATEMENT
                | JS_EMPTY_STATEMENT
                | JS_EXPRESSION_STATEMENT
                | JS_FOR_IN_STATEMENT
                | JS_FOR_OF_STATEMENT
                | JS_FOR_STATEMENT
                | JS_FUNCTION_DECLARATION
                | JS_IF_STATEMENT
                | JS_LABELED_STATEMENT
                | JS_RETURN_STATEMENT
                | JS_SWITCH_STATEMENT
                | JS_THROW_STATEMENT
                | JS_TRY_FINALLY_STATEMENT
                | JS_TRY_STATEMENT
                | JS_UNKNOWN_STATEMENT
                | JS_VARIABLE_STATEMENT
                | JS_WHILE_STATEMENT
                | JS_WITH_STATEMENT
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_DECLARE_STATEMENT
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BLOCK_STATEMENT => JsAnyStatement::JsBlockStatement(JsBlockStatement { syntax }),
            JS_BREAK_STATEMENT => JsAnyStatement::JsBreakStatement(JsBreakStatement { syntax }),
            JS_CLASS_DECLARATION => {
                JsAnyStatement::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_CONTINUE_STATEMENT => {
                JsAnyStatement::JsContinueStatement(JsContinueStatement { syntax })
            }
            JS_DEBUGGER_STATEMENT => {
                JsAnyStatement::JsDebuggerStatement(JsDebuggerStatement { syntax })
            }
            JS_DO_WHILE_STATEMENT => {
                JsAnyStatement::JsDoWhileStatement(JsDoWhileStatement { syntax })
            }
            JS_EMPTY_STATEMENT => JsAnyStatement::JsEmptyStatement(JsEmptyStatement { syntax }),
            JS_EXPRESSION_STATEMENT => {
                JsAnyStatement::JsExpressionStatement(JsExpressionStatement { syntax })
            }
            JS_FOR_IN_STATEMENT => JsAnyStatement::JsForInStatement(JsForInStatement { syntax }),
            JS_FOR_OF_STATEMENT => JsAnyStatement::JsForOfStatement(JsForOfStatement { syntax }),
            JS_FOR_STATEMENT => JsAnyStatement::JsForStatement(JsForStatement { syntax }),
            JS_FUNCTION_DECLARATION => {
                JsAnyStatement::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_IF_STATEMENT => JsAnyStatement::JsIfStatement(JsIfStatement { syntax }),
            JS_LABELED_STATEMENT => {
                JsAnyStatement::JsLabeledStatement(JsLabeledStatement { syntax })
            }
            JS_RETURN_STATEMENT => JsAnyStatement::JsReturnStatement(JsReturnStatement { syntax }),
            JS_SWITCH_STATEMENT => JsAnyStatement::JsSwitchStatement(JsSwitchStatement { syntax }),
            JS_THROW_STATEMENT => JsAnyStatement::JsThrowStatement(JsThrowStatement { syntax }),
            JS_TRY_FINALLY_STATEMENT => {
                JsAnyStatement::JsTryFinallyStatement(JsTryFinallyStatement { syntax })
            }
            JS_TRY_STATEMENT => JsAnyStatement::JsTryStatement(JsTryStatement { syntax }),
            JS_UNKNOWN_STATEMENT => {
                JsAnyStatement::JsUnknownStatement(JsUnknownStatement { syntax })
            }
            JS_VARIABLE_STATEMENT => {
                JsAnyStatement::JsVariableStatement(JsVariableStatement { syntax })
            }
            JS_WHILE_STATEMENT => JsAnyStatement::JsWhileStatement(JsWhileStatement { syntax }),
            JS_WITH_STATEMENT => JsAnyStatement::JsWithStatement(JsWithStatement { syntax }),
            TS_DECLARE_FUNCTION_DECLARATION => {
                JsAnyStatement::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_DECLARE_STATEMENT => {
                JsAnyStatement::TsDeclareStatement(TsDeclareStatement { syntax })
            }
            TS_ENUM_DECLARATION => JsAnyStatement::TsEnumDeclaration(TsEnumDeclaration { syntax }),
            TS_EXTERNAL_MODULE_DECLARATION => {
                JsAnyStatement::TsExternalModuleDeclaration(TsExternalModuleDeclaration { syntax })
            }
            TS_GLOBAL_DECLARATION => {
                JsAnyStatement::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                JsAnyStatement::TsImportEqualsDeclaration(TsImportEqualsDeclaration { syntax })
            }
            TS_INTERFACE_DECLARATION => {
                JsAnyStatement::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                JsAnyStatement::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                JsAnyStatement::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyStatement::JsBlockStatement(it) => &it.syntax,
            JsAnyStatement::JsBreakStatement(it) => &it.syntax,
            JsAnyStatement::JsClassDeclaration(it) => &it.syntax,
            JsAnyStatement::JsContinueStatement(it) => &it.syntax,
            JsAnyStatement::JsDebuggerStatement(it) => &it.syntax,
            JsAnyStatement::JsDoWhileStatement(it) => &it.syntax,
            JsAnyStatement::JsEmptyStatement(it) => &it.syntax,
            JsAnyStatement::JsExpressionStatement(it) => &it.syntax,
            JsAnyStatement::JsForInStatement(it) => &it.syntax,
            JsAnyStatement::JsForOfStatement(it) => &it.syntax,
            JsAnyStatement::JsForStatement(it) => &it.syntax,
            JsAnyStatement::JsFunctionDeclaration(it) => &it.syntax,
            JsAnyStatement::JsIfStatement(it) => &it.syntax,
            JsAnyStatement::JsLabeledStatement(it) => &it.syntax,
            JsAnyStatement::JsReturnStatement(it) => &it.syntax,
            JsAnyStatement::JsSwitchStatement(it) => &it.syntax,
            JsAnyStatement::JsThrowStatement(it) => &it.syntax,
            JsAnyStatement::JsTryFinallyStatement(it) => &it.syntax,
            JsAnyStatement::JsTryStatement(it) => &it.syntax,
            JsAnyStatement::JsUnknownStatement(it) => &it.syntax,
            JsAnyStatement::JsVariableStatement(it) => &it.syntax,
            JsAnyStatement::JsWhileStatement(it) => &it.syntax,
            JsAnyStatement::JsWithStatement(it) => &it.syntax,
            JsAnyStatement::TsDeclareFunctionDeclaration(it) => &it.syntax,
            JsAnyStatement::TsDeclareStatement(it) => &it.syntax,
            JsAnyStatement::TsEnumDeclaration(it) => &it.syntax,
            JsAnyStatement::TsExternalModuleDeclaration(it) => &it.syntax,
            JsAnyStatement::TsGlobalDeclaration(it) => &it.syntax,
            JsAnyStatement::TsImportEqualsDeclaration(it) => &it.syntax,
            JsAnyStatement::TsInterfaceDeclaration(it) => &it.syntax,
            JsAnyStatement::TsModuleDeclaration(it) => &it.syntax,
            JsAnyStatement::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyStatement::JsBlockStatement(it) => it.syntax,
            JsAnyStatement::JsBreakStatement(it) => it.syntax,
            JsAnyStatement::JsClassDeclaration(it) => it.syntax,
            JsAnyStatement::JsContinueStatement(it) => it.syntax,
            JsAnyStatement::JsDebuggerStatement(it) => it.syntax,
            JsAnyStatement::JsDoWhileStatement(it) => it.syntax,
            JsAnyStatement::JsEmptyStatement(it) => it.syntax,
            JsAnyStatement::JsExpressionStatement(it) => it.syntax,
            JsAnyStatement::JsForInStatement(it) => it.syntax,
            JsAnyStatement::JsForOfStatement(it) => it.syntax,
            JsAnyStatement::JsForStatement(it) => it.syntax,
            JsAnyStatement::JsFunctionDeclaration(it) => it.syntax,
            JsAnyStatement::JsIfStatement(it) => it.syntax,
            JsAnyStatement::JsLabeledStatement(it) => it.syntax,
            JsAnyStatement::JsReturnStatement(it) => it.syntax,
            JsAnyStatement::JsSwitchStatement(it) => it.syntax,
            JsAnyStatement::JsThrowStatement(it) => it.syntax,
            JsAnyStatement::JsTryFinallyStatement(it) => it.syntax,
            JsAnyStatement::JsTryStatement(it) => it.syntax,
            JsAnyStatement::JsUnknownStatement(it) => it.syntax,
            JsAnyStatement::JsVariableStatement(it) => it.syntax,
            JsAnyStatement::JsWhileStatement(it) => it.syntax,
            JsAnyStatement::JsWithStatement(it) => it.syntax,
            JsAnyStatement::TsDeclareFunctionDeclaration(it) => it.syntax,
            JsAnyStatement::TsDeclareStatement(it) => it.syntax,
            JsAnyStatement::TsEnumDeclaration(it) => it.syntax,
            JsAnyStatement::TsExternalModuleDeclaration(it) => it.syntax,
            JsAnyStatement::TsGlobalDeclaration(it) => it.syntax,
            JsAnyStatement::TsImportEqualsDeclaration(it) => it.syntax,
            JsAnyStatement::TsInterfaceDeclaration(it) => it.syntax,
            JsAnyStatement::TsModuleDeclaration(it) => it.syntax,
            JsAnyStatement::TsTypeAliasDeclaration(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyStatement::JsBlockStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsBreakStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsContinueStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsDebuggerStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsDoWhileStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsEmptyStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsExpressionStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsForInStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsForOfStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsForStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsIfStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsLabeledStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsReturnStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsSwitchStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsThrowStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsTryFinallyStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsTryStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsUnknownStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsVariableStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsWhileStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::JsWithStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsDeclareStatement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            JsAnyStatement::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyStatement> for SyntaxNode {
    fn from(n: JsAnyStatement) -> SyntaxNode {
        match n {
            JsAnyStatement::JsBlockStatement(it) => it.into(),
            JsAnyStatement::JsBreakStatement(it) => it.into(),
            JsAnyStatement::JsClassDeclaration(it) => it.into(),
            JsAnyStatement::JsContinueStatement(it) => it.into(),
            JsAnyStatement::JsDebuggerStatement(it) => it.into(),
            JsAnyStatement::JsDoWhileStatement(it) => it.into(),
            JsAnyStatement::JsEmptyStatement(it) => it.into(),
            JsAnyStatement::JsExpressionStatement(it) => it.into(),
            JsAnyStatement::JsForInStatement(it) => it.into(),
            JsAnyStatement::JsForOfStatement(it) => it.into(),
            JsAnyStatement::JsForStatement(it) => it.into(),
            JsAnyStatement::JsFunctionDeclaration(it) => it.into(),
            JsAnyStatement::JsIfStatement(it) => it.into(),
            JsAnyStatement::JsLabeledStatement(it) => it.into(),
            JsAnyStatement::JsReturnStatement(it) => it.into(),
            JsAnyStatement::JsSwitchStatement(it) => it.into(),
            JsAnyStatement::JsThrowStatement(it) => it.into(),
            JsAnyStatement::JsTryFinallyStatement(it) => it.into(),
            JsAnyStatement::JsTryStatement(it) => it.into(),
            JsAnyStatement::JsUnknownStatement(it) => it.into(),
            JsAnyStatement::JsVariableStatement(it) => it.into(),
            JsAnyStatement::JsWhileStatement(it) => it.into(),
            JsAnyStatement::JsWithStatement(it) => it.into(),
            JsAnyStatement::TsDeclareFunctionDeclaration(it) => it.into(),
            JsAnyStatement::TsDeclareStatement(it) => it.into(),
            JsAnyStatement::TsEnumDeclaration(it) => it.into(),
            JsAnyStatement::TsExternalModuleDeclaration(it) => it.into(),
            JsAnyStatement::TsGlobalDeclaration(it) => it.into(),
            JsAnyStatement::TsImportEqualsDeclaration(it) => it.into(),
            JsAnyStatement::TsInterfaceDeclaration(it) => it.into(),
            JsAnyStatement::TsModuleDeclaration(it) => it.into(),
            JsAnyStatement::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<JsAnyStatement> for SyntaxElement {
    fn from(n: JsAnyStatement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsCaseClause> for JsAnySwitchClause {
    fn from(node: JsCaseClause) -> JsAnySwitchClause { JsAnySwitchClause::JsCaseClause(node) }
}
impl From<JsDefaultClause> for JsAnySwitchClause {
    fn from(node: JsDefaultClause) -> JsAnySwitchClause { JsAnySwitchClause::JsDefaultClause(node) }
}
impl AstNode for JsAnySwitchClause {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JS_CASE_CLAUSE | JS_DEFAULT_CLAUSE) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CASE_CLAUSE => JsAnySwitchClause::JsCaseClause(JsCaseClause { syntax }),
            JS_DEFAULT_CLAUSE => JsAnySwitchClause::JsDefaultClause(JsDefaultClause { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnySwitchClause::JsCaseClause(it) => &it.syntax,
            JsAnySwitchClause::JsDefaultClause(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnySwitchClause::JsCaseClause(it) => it.syntax,
            JsAnySwitchClause::JsDefaultClause(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnySwitchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnySwitchClause::JsCaseClause(it) => std::fmt::Debug::fmt(it, f),
            JsAnySwitchClause::JsDefaultClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnySwitchClause> for SyntaxNode {
    fn from(n: JsAnySwitchClause) -> SyntaxNode {
        match n {
            JsAnySwitchClause::JsCaseClause(it) => it.into(),
            JsAnySwitchClause::JsDefaultClause(it) => it.into(),
        }
    }
}
impl From<JsAnySwitchClause> for SyntaxElement {
    fn from(n: JsAnySwitchClause) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsTemplateChunkElement> for JsAnyTemplateElement {
    fn from(node: JsTemplateChunkElement) -> JsAnyTemplateElement {
        JsAnyTemplateElement::JsTemplateChunkElement(node)
    }
}
impl From<JsTemplateElement> for JsAnyTemplateElement {
    fn from(node: JsTemplateElement) -> JsAnyTemplateElement {
        JsAnyTemplateElement::JsTemplateElement(node)
    }
}
impl AstNode for JsAnyTemplateElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_TEMPLATE_CHUNK_ELEMENT | JS_TEMPLATE_ELEMENT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_TEMPLATE_CHUNK_ELEMENT => {
                JsAnyTemplateElement::JsTemplateChunkElement(JsTemplateChunkElement { syntax })
            }
            JS_TEMPLATE_ELEMENT => {
                JsAnyTemplateElement::JsTemplateElement(JsTemplateElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsAnyTemplateElement::JsTemplateChunkElement(it) => &it.syntax,
            JsAnyTemplateElement::JsTemplateElement(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsAnyTemplateElement::JsTemplateChunkElement(it) => it.syntax,
            JsAnyTemplateElement::JsTemplateElement(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsAnyTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsAnyTemplateElement::JsTemplateChunkElement(it) => std::fmt::Debug::fmt(it, f),
            JsAnyTemplateElement::JsTemplateElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsAnyTemplateElement> for SyntaxNode {
    fn from(n: JsAnyTemplateElement) -> SyntaxNode {
        match n {
            JsAnyTemplateElement::JsTemplateChunkElement(it) => it.into(),
            JsAnyTemplateElement::JsTemplateElement(it) => it.into(),
        }
    }
}
impl From<JsAnyTemplateElement> for SyntaxElement {
    fn from(n: JsAnyTemplateElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxAttribute> for JsxAnyAttribute {
    fn from(node: JsxAttribute) -> JsxAnyAttribute { JsxAnyAttribute::JsxAttribute(node) }
}
impl From<JsxSpreadAttribute> for JsxAnyAttribute {
    fn from(node: JsxSpreadAttribute) -> JsxAnyAttribute {
        JsxAnyAttribute::JsxSpreadAttribute(node)
    }
}
impl AstNode for JsxAnyAttribute {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JSX_ATTRIBUTE | JSX_SPREAD_ATTRIBUTE) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ATTRIBUTE => JsxAnyAttribute::JsxAttribute(JsxAttribute { syntax }),
            JSX_SPREAD_ATTRIBUTE => {
                JsxAnyAttribute::JsxSpreadAttribute(JsxSpreadAttribute { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsxAnyAttribute::JsxAttribute(it) => &it.syntax,
            JsxAnyAttribute::JsxSpreadAttribute(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsxAnyAttribute::JsxAttribute(it) => it.syntax,
            JsxAnyAttribute::JsxSpreadAttribute(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyAttribute::JsxAttribute(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyAttribute::JsxSpreadAttribute(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyAttribute> for SyntaxNode {
    fn from(n: JsxAnyAttribute) -> SyntaxNode {
        match n {
            JsxAnyAttribute::JsxAttribute(it) => it.into(),
            JsxAnyAttribute::JsxSpreadAttribute(it) => it.into(),
        }
    }
}
impl From<JsxAnyAttribute> for SyntaxElement {
    fn from(n: JsxAnyAttribute) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxName> for JsxAnyAttributeName {
    fn from(node: JsxName) -> JsxAnyAttributeName { JsxAnyAttributeName::JsxName(node) }
}
impl From<JsxNamespaceName> for JsxAnyAttributeName {
    fn from(node: JsxNamespaceName) -> JsxAnyAttributeName {
        JsxAnyAttributeName::JsxNamespaceName(node)
    }
}
impl AstNode for JsxAnyAttributeName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JSX_NAME | JSX_NAMESPACE_NAME) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_NAME => JsxAnyAttributeName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => {
                JsxAnyAttributeName::JsxNamespaceName(JsxNamespaceName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsxAnyAttributeName::JsxName(it) => &it.syntax,
            JsxAnyAttributeName::JsxNamespaceName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsxAnyAttributeName::JsxName(it) => it.syntax,
            JsxAnyAttributeName::JsxNamespaceName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyAttributeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyAttributeName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyAttributeName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyAttributeName> for SyntaxNode {
    fn from(n: JsxAnyAttributeName) -> SyntaxNode {
        match n {
            JsxAnyAttributeName::JsxName(it) => it.into(),
            JsxAnyAttributeName::JsxNamespaceName(it) => it.into(),
        }
    }
}
impl From<JsxAnyAttributeName> for SyntaxElement {
    fn from(n: JsxAnyAttributeName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxExpressionAttributeValue> for JsxAnyAttributeValue {
    fn from(node: JsxExpressionAttributeValue) -> JsxAnyAttributeValue {
        JsxAnyAttributeValue::JsxExpressionAttributeValue(node)
    }
}
impl From<JsxString> for JsxAnyAttributeValue {
    fn from(node: JsxString) -> JsxAnyAttributeValue { JsxAnyAttributeValue::JsxString(node) }
}
impl AstNode for JsxAnyAttributeValue {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JSX_EXPRESSION_ATTRIBUTE_VALUE | JSX_STRING => true,
            k if JsxAnyTag::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_EXPRESSION_ATTRIBUTE_VALUE => {
                JsxAnyAttributeValue::JsxExpressionAttributeValue(JsxExpressionAttributeValue {
                    syntax,
                })
            }
            JSX_STRING => JsxAnyAttributeValue::JsxString(JsxString { syntax }),
            _ => {
                if let Some(jsx_any_tag) = JsxAnyTag::cast(syntax) {
                    return Some(JsxAnyAttributeValue::JsxAnyTag(jsx_any_tag));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsxAnyAttributeValue::JsxExpressionAttributeValue(it) => &it.syntax,
            JsxAnyAttributeValue::JsxString(it) => &it.syntax,
            JsxAnyAttributeValue::JsxAnyTag(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsxAnyAttributeValue::JsxExpressionAttributeValue(it) => it.syntax,
            JsxAnyAttributeValue::JsxString(it) => it.syntax,
            JsxAnyAttributeValue::JsxAnyTag(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for JsxAnyAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyAttributeValue::JsxAnyTag(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyAttributeValue::JsxExpressionAttributeValue(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyAttributeValue::JsxString(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyAttributeValue> for SyntaxNode {
    fn from(n: JsxAnyAttributeValue) -> SyntaxNode {
        match n {
            JsxAnyAttributeValue::JsxAnyTag(it) => it.into(),
            JsxAnyAttributeValue::JsxExpressionAttributeValue(it) => it.into(),
            JsxAnyAttributeValue::JsxString(it) => it.into(),
        }
    }
}
impl From<JsxAnyAttributeValue> for SyntaxElement {
    fn from(n: JsxAnyAttributeValue) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxElement> for JsxAnyChild {
    fn from(node: JsxElement) -> JsxAnyChild { JsxAnyChild::JsxElement(node) }
}
impl From<JsxExpressionChild> for JsxAnyChild {
    fn from(node: JsxExpressionChild) -> JsxAnyChild { JsxAnyChild::JsxExpressionChild(node) }
}
impl From<JsxFragment> for JsxAnyChild {
    fn from(node: JsxFragment) -> JsxAnyChild { JsxAnyChild::JsxFragment(node) }
}
impl From<JsxSelfClosingElement> for JsxAnyChild {
    fn from(node: JsxSelfClosingElement) -> JsxAnyChild { JsxAnyChild::JsxSelfClosingElement(node) }
}
impl From<JsxSpreadChild> for JsxAnyChild {
    fn from(node: JsxSpreadChild) -> JsxAnyChild { JsxAnyChild::JsxSpreadChild(node) }
}
impl From<JsxText> for JsxAnyChild {
    fn from(node: JsxText) -> JsxAnyChild { JsxAnyChild::JsxText(node) }
}
impl AstNode for JsxAnyChild {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JSX_ELEMENT
                | JSX_EXPRESSION_CHILD
                | JSX_FRAGMENT
                | JSX_SELF_CLOSING_ELEMENT
                | JSX_SPREAD_CHILD
                | JSX_TEXT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ELEMENT => JsxAnyChild::JsxElement(JsxElement { syntax }),
            JSX_EXPRESSION_CHILD => JsxAnyChild::JsxExpressionChild(JsxExpressionChild { syntax }),
            JSX_FRAGMENT => JsxAnyChild::JsxFragment(JsxFragment { syntax }),
            JSX_SELF_CLOSING_ELEMENT => {
                JsxAnyChild::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
            }
            JSX_SPREAD_CHILD => JsxAnyChild::JsxSpreadChild(JsxSpreadChild { syntax }),
            JSX_TEXT => JsxAnyChild::JsxText(JsxText { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsxAnyChild::JsxElement(it) => &it.syntax,
            JsxAnyChild::JsxExpressionChild(it) => &it.syntax,
            JsxAnyChild::JsxFragment(it) => &it.syntax,
            JsxAnyChild::JsxSelfClosingElement(it) => &it.syntax,
            JsxAnyChild::JsxSpreadChild(it) => &it.syntax,
            JsxAnyChild::JsxText(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsxAnyChild::JsxElement(it) => it.syntax,
            JsxAnyChild::JsxExpressionChild(it) => it.syntax,
            JsxAnyChild::JsxFragment(it) => it.syntax,
            JsxAnyChild::JsxSelfClosingElement(it) => it.syntax,
            JsxAnyChild::JsxSpreadChild(it) => it.syntax,
            JsxAnyChild::JsxText(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyChild::JsxElement(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxExpressionChild(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxFragment(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxSelfClosingElement(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxSpreadChild(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyChild::JsxText(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyChild> for SyntaxNode {
    fn from(n: JsxAnyChild) -> SyntaxNode {
        match n {
            JsxAnyChild::JsxElement(it) => it.into(),
            JsxAnyChild::JsxExpressionChild(it) => it.into(),
            JsxAnyChild::JsxFragment(it) => it.into(),
            JsxAnyChild::JsxSelfClosingElement(it) => it.into(),
            JsxAnyChild::JsxSpreadChild(it) => it.into(),
            JsxAnyChild::JsxText(it) => it.into(),
        }
    }
}
impl From<JsxAnyChild> for SyntaxElement {
    fn from(n: JsxAnyChild) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxMemberName> for JsxAnyElementName {
    fn from(node: JsxMemberName) -> JsxAnyElementName { JsxAnyElementName::JsxMemberName(node) }
}
impl From<JsxName> for JsxAnyElementName {
    fn from(node: JsxName) -> JsxAnyElementName { JsxAnyElementName::JsxName(node) }
}
impl From<JsxNamespaceName> for JsxAnyElementName {
    fn from(node: JsxNamespaceName) -> JsxAnyElementName {
        JsxAnyElementName::JsxNamespaceName(node)
    }
}
impl From<JsxReferenceIdentifier> for JsxAnyElementName {
    fn from(node: JsxReferenceIdentifier) -> JsxAnyElementName {
        JsxAnyElementName::JsxReferenceIdentifier(node)
    }
}
impl AstNode for JsxAnyElementName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JSX_MEMBER_NAME | JSX_NAME | JSX_NAMESPACE_NAME | JSX_REFERENCE_IDENTIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_MEMBER_NAME => JsxAnyElementName::JsxMemberName(JsxMemberName { syntax }),
            JSX_NAME => JsxAnyElementName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => JsxAnyElementName::JsxNamespaceName(JsxNamespaceName { syntax }),
            JSX_REFERENCE_IDENTIFIER => {
                JsxAnyElementName::JsxReferenceIdentifier(JsxReferenceIdentifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsxAnyElementName::JsxMemberName(it) => &it.syntax,
            JsxAnyElementName::JsxName(it) => &it.syntax,
            JsxAnyElementName::JsxNamespaceName(it) => &it.syntax,
            JsxAnyElementName::JsxReferenceIdentifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsxAnyElementName::JsxMemberName(it) => it.syntax,
            JsxAnyElementName::JsxName(it) => it.syntax,
            JsxAnyElementName::JsxNamespaceName(it) => it.syntax,
            JsxAnyElementName::JsxReferenceIdentifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyElementName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyElementName::JsxMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyElementName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyElementName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyElementName::JsxReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyElementName> for SyntaxNode {
    fn from(n: JsxAnyElementName) -> SyntaxNode {
        match n {
            JsxAnyElementName::JsxMemberName(it) => it.into(),
            JsxAnyElementName::JsxName(it) => it.into(),
            JsxAnyElementName::JsxNamespaceName(it) => it.into(),
            JsxAnyElementName::JsxReferenceIdentifier(it) => it.into(),
        }
    }
}
impl From<JsxAnyElementName> for SyntaxElement {
    fn from(n: JsxAnyElementName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxName> for JsxAnyName {
    fn from(node: JsxName) -> JsxAnyName { JsxAnyName::JsxName(node) }
}
impl From<JsxNamespaceName> for JsxAnyName {
    fn from(node: JsxNamespaceName) -> JsxAnyName { JsxAnyName::JsxNamespaceName(node) }
}
impl AstNode for JsxAnyName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JSX_NAME | JSX_NAMESPACE_NAME) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_NAME => JsxAnyName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => JsxAnyName::JsxNamespaceName(JsxNamespaceName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsxAnyName::JsxName(it) => &it.syntax,
            JsxAnyName::JsxNamespaceName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsxAnyName::JsxName(it) => it.syntax,
            JsxAnyName::JsxNamespaceName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyName> for SyntaxNode {
    fn from(n: JsxAnyName) -> SyntaxNode {
        match n {
            JsxAnyName::JsxName(it) => it.into(),
            JsxAnyName::JsxNamespaceName(it) => it.into(),
        }
    }
}
impl From<JsxAnyName> for SyntaxElement {
    fn from(n: JsxAnyName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxMemberName> for JsxAnyObjectName {
    fn from(node: JsxMemberName) -> JsxAnyObjectName { JsxAnyObjectName::JsxMemberName(node) }
}
impl From<JsxNamespaceName> for JsxAnyObjectName {
    fn from(node: JsxNamespaceName) -> JsxAnyObjectName { JsxAnyObjectName::JsxNamespaceName(node) }
}
impl From<JsxReferenceIdentifier> for JsxAnyObjectName {
    fn from(node: JsxReferenceIdentifier) -> JsxAnyObjectName {
        JsxAnyObjectName::JsxReferenceIdentifier(node)
    }
}
impl AstNode for JsxAnyObjectName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JSX_MEMBER_NAME | JSX_NAMESPACE_NAME | JSX_REFERENCE_IDENTIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_MEMBER_NAME => JsxAnyObjectName::JsxMemberName(JsxMemberName { syntax }),
            JSX_NAMESPACE_NAME => JsxAnyObjectName::JsxNamespaceName(JsxNamespaceName { syntax }),
            JSX_REFERENCE_IDENTIFIER => {
                JsxAnyObjectName::JsxReferenceIdentifier(JsxReferenceIdentifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsxAnyObjectName::JsxMemberName(it) => &it.syntax,
            JsxAnyObjectName::JsxNamespaceName(it) => &it.syntax,
            JsxAnyObjectName::JsxReferenceIdentifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsxAnyObjectName::JsxMemberName(it) => it.syntax,
            JsxAnyObjectName::JsxNamespaceName(it) => it.syntax,
            JsxAnyObjectName::JsxReferenceIdentifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyObjectName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyObjectName::JsxMemberName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyObjectName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyObjectName::JsxReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyObjectName> for SyntaxNode {
    fn from(n: JsxAnyObjectName) -> SyntaxNode {
        match n {
            JsxAnyObjectName::JsxMemberName(it) => it.into(),
            JsxAnyObjectName::JsxNamespaceName(it) => it.into(),
            JsxAnyObjectName::JsxReferenceIdentifier(it) => it.into(),
        }
    }
}
impl From<JsxAnyObjectName> for SyntaxElement {
    fn from(n: JsxAnyObjectName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxElement> for JsxAnyTag {
    fn from(node: JsxElement) -> JsxAnyTag { JsxAnyTag::JsxElement(node) }
}
impl From<JsxFragment> for JsxAnyTag {
    fn from(node: JsxFragment) -> JsxAnyTag { JsxAnyTag::JsxFragment(node) }
}
impl From<JsxSelfClosingElement> for JsxAnyTag {
    fn from(node: JsxSelfClosingElement) -> JsxAnyTag { JsxAnyTag::JsxSelfClosingElement(node) }
}
impl AstNode for JsxAnyTag {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JSX_ELEMENT | JSX_FRAGMENT | JSX_SELF_CLOSING_ELEMENT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ELEMENT => JsxAnyTag::JsxElement(JsxElement { syntax }),
            JSX_FRAGMENT => JsxAnyTag::JsxFragment(JsxFragment { syntax }),
            JSX_SELF_CLOSING_ELEMENT => {
                JsxAnyTag::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            JsxAnyTag::JsxElement(it) => &it.syntax,
            JsxAnyTag::JsxFragment(it) => &it.syntax,
            JsxAnyTag::JsxSelfClosingElement(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            JsxAnyTag::JsxElement(it) => it.syntax,
            JsxAnyTag::JsxFragment(it) => it.syntax,
            JsxAnyTag::JsxSelfClosingElement(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for JsxAnyTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsxAnyTag::JsxElement(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyTag::JsxFragment(it) => std::fmt::Debug::fmt(it, f),
            JsxAnyTag::JsxSelfClosingElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<JsxAnyTag> for SyntaxNode {
    fn from(n: JsxAnyTag) -> SyntaxNode {
        match n {
            JsxAnyTag::JsxElement(it) => it.into(),
            JsxAnyTag::JsxFragment(it) => it.into(),
            JsxAnyTag::JsxSelfClosingElement(it) => it.into(),
        }
    }
}
impl From<JsxAnyTag> for SyntaxElement {
    fn from(n: JsxAnyTag) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsEmptyExternalModuleDeclarationBody> for TsAnyExternalModuleDeclarationBody {
    fn from(node: TsEmptyExternalModuleDeclarationBody) -> TsAnyExternalModuleDeclarationBody {
        TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(node)
    }
}
impl From<TsModuleBlock> for TsAnyExternalModuleDeclarationBody {
    fn from(node: TsModuleBlock) -> TsAnyExternalModuleDeclarationBody {
        TsAnyExternalModuleDeclarationBody::TsModuleBlock(node)
    }
}
impl AstNode for TsAnyExternalModuleDeclarationBody {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY | TS_MODULE_BLOCK
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY => {
                TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(
                    TsEmptyExternalModuleDeclarationBody { syntax },
                )
            }
            TS_MODULE_BLOCK => {
                TsAnyExternalModuleDeclarationBody::TsModuleBlock(TsModuleBlock { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                &it.syntax
            }
            TsAnyExternalModuleDeclarationBody::TsModuleBlock(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                it.syntax
            }
            TsAnyExternalModuleDeclarationBody::TsModuleBlock(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyExternalModuleDeclarationBody::TsModuleBlock(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyExternalModuleDeclarationBody> for SyntaxNode {
    fn from(n: TsAnyExternalModuleDeclarationBody) -> SyntaxNode {
        match n {
            TsAnyExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                it.into()
            }
            TsAnyExternalModuleDeclarationBody::TsModuleBlock(it) => it.into(),
        }
    }
}
impl From<TsAnyExternalModuleDeclarationBody> for SyntaxElement {
    fn from(n: TsAnyExternalModuleDeclarationBody) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for TsAnyIndexSignatureModifier {
    fn from(node: JsStaticModifier) -> TsAnyIndexSignatureModifier {
        TsAnyIndexSignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsReadonlyModifier> for TsAnyIndexSignatureModifier {
    fn from(node: TsReadonlyModifier) -> TsAnyIndexSignatureModifier {
        TsAnyIndexSignatureModifier::TsReadonlyModifier(node)
    }
}
impl AstNode for TsAnyIndexSignatureModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_STATIC_MODIFIER | TS_READONLY_MODIFIER)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                TsAnyIndexSignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                TsAnyIndexSignatureModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyIndexSignatureModifier::JsStaticModifier(it) => &it.syntax,
            TsAnyIndexSignatureModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyIndexSignatureModifier::JsStaticModifier(it) => it.syntax,
            TsAnyIndexSignatureModifier::TsReadonlyModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyIndexSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyIndexSignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyIndexSignatureModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyIndexSignatureModifier> for SyntaxNode {
    fn from(n: TsAnyIndexSignatureModifier) -> SyntaxNode {
        match n {
            TsAnyIndexSignatureModifier::JsStaticModifier(it) => it.into(),
            TsAnyIndexSignatureModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<TsAnyIndexSignatureModifier> for SyntaxElement {
    fn from(n: TsAnyIndexSignatureModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for TsAnyMethodSignatureModifier {
    fn from(node: JsStaticModifier) -> TsAnyMethodSignatureModifier {
        TsAnyMethodSignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsAbstractModifier> for TsAnyMethodSignatureModifier {
    fn from(node: TsAbstractModifier) -> TsAnyMethodSignatureModifier {
        TsAnyMethodSignatureModifier::TsAbstractModifier(node)
    }
}
impl From<TsAccessibilityModifier> for TsAnyMethodSignatureModifier {
    fn from(node: TsAccessibilityModifier) -> TsAnyMethodSignatureModifier {
        TsAnyMethodSignatureModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for TsAnyMethodSignatureModifier {
    fn from(node: TsOverrideModifier) -> TsAnyMethodSignatureModifier {
        TsAnyMethodSignatureModifier::TsOverrideModifier(node)
    }
}
impl AstNode for TsAnyMethodSignatureModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER
                | TS_ABSTRACT_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_OVERRIDE_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                TsAnyMethodSignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ABSTRACT_MODIFIER => {
                TsAnyMethodSignatureModifier::TsAbstractModifier(TsAbstractModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                TsAnyMethodSignatureModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_OVERRIDE_MODIFIER => {
                TsAnyMethodSignatureModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyMethodSignatureModifier::JsStaticModifier(it) => &it.syntax,
            TsAnyMethodSignatureModifier::TsAbstractModifier(it) => &it.syntax,
            TsAnyMethodSignatureModifier::TsAccessibilityModifier(it) => &it.syntax,
            TsAnyMethodSignatureModifier::TsOverrideModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyMethodSignatureModifier::JsStaticModifier(it) => it.syntax,
            TsAnyMethodSignatureModifier::TsAbstractModifier(it) => it.syntax,
            TsAnyMethodSignatureModifier::TsAccessibilityModifier(it) => it.syntax,
            TsAnyMethodSignatureModifier::TsOverrideModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyMethodSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyMethodSignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyMethodSignatureModifier::TsAbstractModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyMethodSignatureModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyMethodSignatureModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyMethodSignatureModifier> for SyntaxNode {
    fn from(n: TsAnyMethodSignatureModifier) -> SyntaxNode {
        match n {
            TsAnyMethodSignatureModifier::JsStaticModifier(it) => it.into(),
            TsAnyMethodSignatureModifier::TsAbstractModifier(it) => it.into(),
            TsAnyMethodSignatureModifier::TsAccessibilityModifier(it) => it.into(),
            TsAnyMethodSignatureModifier::TsOverrideModifier(it) => it.into(),
        }
    }
}
impl From<TsAnyMethodSignatureModifier> for SyntaxElement {
    fn from(n: TsAnyMethodSignatureModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsIdentifierBinding> for TsAnyModuleName {
    fn from(node: TsIdentifierBinding) -> TsAnyModuleName {
        TsAnyModuleName::TsIdentifierBinding(node)
    }
}
impl From<TsQualifiedModuleName> for TsAnyModuleName {
    fn from(node: TsQualifiedModuleName) -> TsAnyModuleName {
        TsAnyModuleName::TsQualifiedModuleName(node)
    }
}
impl AstNode for TsAnyModuleName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_IDENTIFIER_BINDING | TS_QUALIFIED_MODULE_NAME)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_IDENTIFIER_BINDING => {
                TsAnyModuleName::TsIdentifierBinding(TsIdentifierBinding { syntax })
            }
            TS_QUALIFIED_MODULE_NAME => {
                TsAnyModuleName::TsQualifiedModuleName(TsQualifiedModuleName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyModuleName::TsIdentifierBinding(it) => &it.syntax,
            TsAnyModuleName::TsQualifiedModuleName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyModuleName::TsIdentifierBinding(it) => it.syntax,
            TsAnyModuleName::TsQualifiedModuleName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyModuleName::TsIdentifierBinding(it) => std::fmt::Debug::fmt(it, f),
            TsAnyModuleName::TsQualifiedModuleName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyModuleName> for SyntaxNode {
    fn from(n: TsAnyModuleName) -> SyntaxNode {
        match n {
            TsAnyModuleName::TsIdentifierBinding(it) => it.into(),
            TsAnyModuleName::TsQualifiedModuleName(it) => it.into(),
        }
    }
}
impl From<TsAnyModuleName> for SyntaxElement {
    fn from(n: TsAnyModuleName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsExternalModuleReference> for TsAnyModuleReference {
    fn from(node: TsExternalModuleReference) -> TsAnyModuleReference {
        TsAnyModuleReference::TsExternalModuleReference(node)
    }
}
impl AstNode for TsAnyModuleReference {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TS_EXTERNAL_MODULE_REFERENCE => true,
            k if TsAnyName::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_EXTERNAL_MODULE_REFERENCE => {
                TsAnyModuleReference::TsExternalModuleReference(TsExternalModuleReference {
                    syntax,
                })
            }
            _ => {
                if let Some(ts_any_name) = TsAnyName::cast(syntax) {
                    return Some(TsAnyModuleReference::TsAnyName(ts_any_name));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyModuleReference::TsExternalModuleReference(it) => &it.syntax,
            TsAnyModuleReference::TsAnyName(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyModuleReference::TsExternalModuleReference(it) => it.syntax,
            TsAnyModuleReference::TsAnyName(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for TsAnyModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyModuleReference::TsAnyName(it) => std::fmt::Debug::fmt(it, f),
            TsAnyModuleReference::TsExternalModuleReference(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyModuleReference> for SyntaxNode {
    fn from(n: TsAnyModuleReference) -> SyntaxNode {
        match n {
            TsAnyModuleReference::TsAnyName(it) => it.into(),
            TsAnyModuleReference::TsExternalModuleReference(it) => it.into(),
        }
    }
}
impl From<TsAnyModuleReference> for SyntaxElement {
    fn from(n: TsAnyModuleReference) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsReferenceIdentifier> for TsAnyName {
    fn from(node: JsReferenceIdentifier) -> TsAnyName { TsAnyName::JsReferenceIdentifier(node) }
}
impl From<TsQualifiedName> for TsAnyName {
    fn from(node: TsQualifiedName) -> TsAnyName { TsAnyName::TsQualifiedName(node) }
}
impl AstNode for TsAnyName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_REFERENCE_IDENTIFIER | TS_QUALIFIED_NAME)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REFERENCE_IDENTIFIER => {
                TsAnyName::JsReferenceIdentifier(JsReferenceIdentifier { syntax })
            }
            TS_QUALIFIED_NAME => TsAnyName::TsQualifiedName(TsQualifiedName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyName::JsReferenceIdentifier(it) => &it.syntax,
            TsAnyName::TsQualifiedName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyName::JsReferenceIdentifier(it) => it.syntax,
            TsAnyName::TsQualifiedName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyName::JsReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyName::TsQualifiedName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyName> for SyntaxNode {
    fn from(n: TsAnyName) -> SyntaxNode {
        match n {
            TsAnyName::JsReferenceIdentifier(it) => it.into(),
            TsAnyName::TsQualifiedName(it) => it.into(),
        }
    }
}
impl From<TsAnyName> for SyntaxElement {
    fn from(n: TsAnyName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsDefinitePropertyAnnotation> for TsAnyPropertyAnnotation {
    fn from(node: TsDefinitePropertyAnnotation) -> TsAnyPropertyAnnotation {
        TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(node)
    }
}
impl From<TsOptionalPropertyAnnotation> for TsAnyPropertyAnnotation {
    fn from(node: TsOptionalPropertyAnnotation) -> TsAnyPropertyAnnotation {
        TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for TsAnyPropertyAnnotation {
    fn from(node: TsTypeAnnotation) -> TsAnyPropertyAnnotation {
        TsAnyPropertyAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode for TsAnyPropertyAnnotation {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TS_DEFINITE_PROPERTY_ANNOTATION | TS_OPTIONAL_PROPERTY_ANNOTATION | TS_TYPE_ANNOTATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_DEFINITE_PROPERTY_ANNOTATION => {
                TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(
                    TsDefinitePropertyAnnotation { syntax },
                )
            }
            TS_OPTIONAL_PROPERTY_ANNOTATION => {
                TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(
                    TsOptionalPropertyAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                TsAnyPropertyAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(it) => &it.syntax,
            TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(it) => &it.syntax,
            TsAnyPropertyAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(it) => it.syntax,
            TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(it) => it.syntax,
            TsAnyPropertyAnnotation::TsTypeAnnotation(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertyAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyPropertyAnnotation> for SyntaxNode {
    fn from(n: TsAnyPropertyAnnotation) -> SyntaxNode {
        match n {
            TsAnyPropertyAnnotation::TsDefinitePropertyAnnotation(it) => it.into(),
            TsAnyPropertyAnnotation::TsOptionalPropertyAnnotation(it) => it.into(),
            TsAnyPropertyAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<TsAnyPropertyAnnotation> for SyntaxElement {
    fn from(n: TsAnyPropertyAnnotation) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAccessibilityModifier> for TsAnyPropertyParameterModifier {
    fn from(node: TsAccessibilityModifier) -> TsAnyPropertyParameterModifier {
        TsAnyPropertyParameterModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for TsAnyPropertyParameterModifier {
    fn from(node: TsOverrideModifier) -> TsAnyPropertyParameterModifier {
        TsAnyPropertyParameterModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for TsAnyPropertyParameterModifier {
    fn from(node: TsReadonlyModifier) -> TsAnyPropertyParameterModifier {
        TsAnyPropertyParameterModifier::TsReadonlyModifier(node)
    }
}
impl AstNode for TsAnyPropertyParameterModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TS_ACCESSIBILITY_MODIFIER | TS_OVERRIDE_MODIFIER | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ACCESSIBILITY_MODIFIER => {
                TsAnyPropertyParameterModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_OVERRIDE_MODIFIER => {
                TsAnyPropertyParameterModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                TsAnyPropertyParameterModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyPropertyParameterModifier::TsAccessibilityModifier(it) => &it.syntax,
            TsAnyPropertyParameterModifier::TsOverrideModifier(it) => &it.syntax,
            TsAnyPropertyParameterModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyPropertyParameterModifier::TsAccessibilityModifier(it) => it.syntax,
            TsAnyPropertyParameterModifier::TsOverrideModifier(it) => it.syntax,
            TsAnyPropertyParameterModifier::TsReadonlyModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyPropertyParameterModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyPropertyParameterModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertyParameterModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertyParameterModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyPropertyParameterModifier> for SyntaxNode {
    fn from(n: TsAnyPropertyParameterModifier) -> SyntaxNode {
        match n {
            TsAnyPropertyParameterModifier::TsAccessibilityModifier(it) => it.into(),
            TsAnyPropertyParameterModifier::TsOverrideModifier(it) => it.into(),
            TsAnyPropertyParameterModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<TsAnyPropertyParameterModifier> for SyntaxElement {
    fn from(n: TsAnyPropertyParameterModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsOptionalPropertyAnnotation> for TsAnyPropertySignatureAnnotation {
    fn from(node: TsOptionalPropertyAnnotation) -> TsAnyPropertySignatureAnnotation {
        TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for TsAnyPropertySignatureAnnotation {
    fn from(node: TsTypeAnnotation) -> TsAnyPropertySignatureAnnotation {
        TsAnyPropertySignatureAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode for TsAnyPropertySignatureAnnotation {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_OPTIONAL_PROPERTY_ANNOTATION | TS_TYPE_ANNOTATION)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_OPTIONAL_PROPERTY_ANNOTATION => {
                TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(
                    TsOptionalPropertyAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                TsAnyPropertySignatureAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => &it.syntax,
            TsAnyPropertySignatureAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => it.syntax,
            TsAnyPropertySignatureAnnotation::TsTypeAnnotation(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyPropertySignatureAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertySignatureAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyPropertySignatureAnnotation> for SyntaxNode {
    fn from(n: TsAnyPropertySignatureAnnotation) -> SyntaxNode {
        match n {
            TsAnyPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => it.into(),
            TsAnyPropertySignatureAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<TsAnyPropertySignatureAnnotation> for SyntaxElement {
    fn from(n: TsAnyPropertySignatureAnnotation) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for TsAnyPropertySignatureModifier {
    fn from(node: JsStaticModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsAbstractModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsAbstractModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsAbstractModifier(node)
    }
}
impl From<TsAccessibilityModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsAccessibilityModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsDeclareModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsDeclareModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsDeclareModifier(node)
    }
}
impl From<TsOverrideModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsOverrideModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for TsAnyPropertySignatureModifier {
    fn from(node: TsReadonlyModifier) -> TsAnyPropertySignatureModifier {
        TsAnyPropertySignatureModifier::TsReadonlyModifier(node)
    }
}
impl AstNode for TsAnyPropertySignatureModifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER
                | TS_ABSTRACT_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_DECLARE_MODIFIER
                | TS_OVERRIDE_MODIFIER
                | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                TsAnyPropertySignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ABSTRACT_MODIFIER => {
                TsAnyPropertySignatureModifier::TsAbstractModifier(TsAbstractModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                TsAnyPropertySignatureModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_DECLARE_MODIFIER => {
                TsAnyPropertySignatureModifier::TsDeclareModifier(TsDeclareModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                TsAnyPropertySignatureModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                TsAnyPropertySignatureModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyPropertySignatureModifier::JsStaticModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsAbstractModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsAccessibilityModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsDeclareModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsOverrideModifier(it) => &it.syntax,
            TsAnyPropertySignatureModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyPropertySignatureModifier::JsStaticModifier(it) => it.syntax,
            TsAnyPropertySignatureModifier::TsAbstractModifier(it) => it.syntax,
            TsAnyPropertySignatureModifier::TsAccessibilityModifier(it) => it.syntax,
            TsAnyPropertySignatureModifier::TsDeclareModifier(it) => it.syntax,
            TsAnyPropertySignatureModifier::TsOverrideModifier(it) => it.syntax,
            TsAnyPropertySignatureModifier::TsReadonlyModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyPropertySignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyPropertySignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertySignatureModifier::TsAbstractModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertySignatureModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyPropertySignatureModifier::TsDeclareModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertySignatureModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            TsAnyPropertySignatureModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyPropertySignatureModifier> for SyntaxNode {
    fn from(n: TsAnyPropertySignatureModifier) -> SyntaxNode {
        match n {
            TsAnyPropertySignatureModifier::JsStaticModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsAbstractModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsAccessibilityModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsDeclareModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsOverrideModifier(it) => it.into(),
            TsAnyPropertySignatureModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<TsAnyPropertySignatureModifier> for SyntaxElement {
    fn from(n: TsAnyPropertySignatureModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAssertsReturnType> for TsAnyReturnType {
    fn from(node: TsAssertsReturnType) -> TsAnyReturnType {
        TsAnyReturnType::TsAssertsReturnType(node)
    }
}
impl From<TsPredicateReturnType> for TsAnyReturnType {
    fn from(node: TsPredicateReturnType) -> TsAnyReturnType {
        TsAnyReturnType::TsPredicateReturnType(node)
    }
}
impl AstNode for TsAnyReturnType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TS_ASSERTS_RETURN_TYPE | TS_PREDICATE_RETURN_TYPE => true,
            k if TsType::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ASSERTS_RETURN_TYPE => {
                TsAnyReturnType::TsAssertsReturnType(TsAssertsReturnType { syntax })
            }
            TS_PREDICATE_RETURN_TYPE => {
                TsAnyReturnType::TsPredicateReturnType(TsPredicateReturnType { syntax })
            }
            _ => {
                if let Some(ts_type) = TsType::cast(syntax) {
                    return Some(TsAnyReturnType::TsType(ts_type));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyReturnType::TsAssertsReturnType(it) => &it.syntax,
            TsAnyReturnType::TsPredicateReturnType(it) => &it.syntax,
            TsAnyReturnType::TsType(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyReturnType::TsAssertsReturnType(it) => it.syntax,
            TsAnyReturnType::TsPredicateReturnType(it) => it.syntax,
            TsAnyReturnType::TsType(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for TsAnyReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyReturnType::TsAssertsReturnType(it) => std::fmt::Debug::fmt(it, f),
            TsAnyReturnType::TsPredicateReturnType(it) => std::fmt::Debug::fmt(it, f),
            TsAnyReturnType::TsType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyReturnType> for SyntaxNode {
    fn from(n: TsAnyReturnType) -> SyntaxNode {
        match n {
            TsAnyReturnType::TsAssertsReturnType(it) => it.into(),
            TsAnyReturnType::TsPredicateReturnType(it) => it.into(),
            TsAnyReturnType::TsType(it) => it.into(),
        }
    }
}
impl From<TsAnyReturnType> for SyntaxElement {
    fn from(n: TsAnyReturnType) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsTemplateChunkElement> for TsAnyTemplateElement {
    fn from(node: TsTemplateChunkElement) -> TsAnyTemplateElement {
        TsAnyTemplateElement::TsTemplateChunkElement(node)
    }
}
impl From<TsTemplateElement> for TsAnyTemplateElement {
    fn from(node: TsTemplateElement) -> TsAnyTemplateElement {
        TsAnyTemplateElement::TsTemplateElement(node)
    }
}
impl AstNode for TsAnyTemplateElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_TEMPLATE_CHUNK_ELEMENT | TS_TEMPLATE_ELEMENT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_TEMPLATE_CHUNK_ELEMENT => {
                TsAnyTemplateElement::TsTemplateChunkElement(TsTemplateChunkElement { syntax })
            }
            TS_TEMPLATE_ELEMENT => {
                TsAnyTemplateElement::TsTemplateElement(TsTemplateElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyTemplateElement::TsTemplateChunkElement(it) => &it.syntax,
            TsAnyTemplateElement::TsTemplateElement(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyTemplateElement::TsTemplateChunkElement(it) => it.syntax,
            TsAnyTemplateElement::TsTemplateElement(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyTemplateElement::TsTemplateChunkElement(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTemplateElement::TsTemplateElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyTemplateElement> for SyntaxNode {
    fn from(n: TsAnyTemplateElement) -> SyntaxNode {
        match n {
            TsAnyTemplateElement::TsTemplateChunkElement(it) => it.into(),
            TsAnyTemplateElement::TsTemplateElement(it) => it.into(),
        }
    }
}
impl From<TsAnyTemplateElement> for SyntaxElement {
    fn from(n: TsAnyTemplateElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsNamedTupleTypeElement> for TsAnyTupleTypeElement {
    fn from(node: TsNamedTupleTypeElement) -> TsAnyTupleTypeElement {
        TsAnyTupleTypeElement::TsNamedTupleTypeElement(node)
    }
}
impl From<TsOptionalTupleTypeElement> for TsAnyTupleTypeElement {
    fn from(node: TsOptionalTupleTypeElement) -> TsAnyTupleTypeElement {
        TsAnyTupleTypeElement::TsOptionalTupleTypeElement(node)
    }
}
impl From<TsRestTupleTypeElement> for TsAnyTupleTypeElement {
    fn from(node: TsRestTupleTypeElement) -> TsAnyTupleTypeElement {
        TsAnyTupleTypeElement::TsRestTupleTypeElement(node)
    }
}
impl AstNode for TsAnyTupleTypeElement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TS_NAMED_TUPLE_TYPE_ELEMENT
            | TS_OPTIONAL_TUPLE_TYPE_ELEMENT
            | TS_REST_TUPLE_TYPE_ELEMENT => true,
            k if TsType::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_NAMED_TUPLE_TYPE_ELEMENT => {
                TsAnyTupleTypeElement::TsNamedTupleTypeElement(TsNamedTupleTypeElement { syntax })
            }
            TS_OPTIONAL_TUPLE_TYPE_ELEMENT => {
                TsAnyTupleTypeElement::TsOptionalTupleTypeElement(TsOptionalTupleTypeElement {
                    syntax,
                })
            }
            TS_REST_TUPLE_TYPE_ELEMENT => {
                TsAnyTupleTypeElement::TsRestTupleTypeElement(TsRestTupleTypeElement { syntax })
            }
            _ => {
                if let Some(ts_type) = TsType::cast(syntax) {
                    return Some(TsAnyTupleTypeElement::TsType(ts_type));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyTupleTypeElement::TsNamedTupleTypeElement(it) => &it.syntax,
            TsAnyTupleTypeElement::TsOptionalTupleTypeElement(it) => &it.syntax,
            TsAnyTupleTypeElement::TsRestTupleTypeElement(it) => &it.syntax,
            TsAnyTupleTypeElement::TsType(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyTupleTypeElement::TsNamedTupleTypeElement(it) => it.syntax,
            TsAnyTupleTypeElement::TsOptionalTupleTypeElement(it) => it.syntax,
            TsAnyTupleTypeElement::TsRestTupleTypeElement(it) => it.syntax,
            TsAnyTupleTypeElement::TsType(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for TsAnyTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyTupleTypeElement::TsNamedTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTupleTypeElement::TsOptionalTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTupleTypeElement::TsRestTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTupleTypeElement::TsType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyTupleTypeElement> for SyntaxNode {
    fn from(n: TsAnyTupleTypeElement) -> SyntaxNode {
        match n {
            TsAnyTupleTypeElement::TsNamedTupleTypeElement(it) => it.into(),
            TsAnyTupleTypeElement::TsOptionalTupleTypeElement(it) => it.into(),
            TsAnyTupleTypeElement::TsRestTupleTypeElement(it) => it.into(),
            TsAnyTupleTypeElement::TsType(it) => it.into(),
        }
    }
}
impl From<TsAnyTupleTypeElement> for SyntaxElement {
    fn from(n: TsAnyTupleTypeElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsUnknownMember> for TsAnyTypeMember {
    fn from(node: JsUnknownMember) -> TsAnyTypeMember { TsAnyTypeMember::JsUnknownMember(node) }
}
impl From<TsCallSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsCallSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsCallSignatureTypeMember(node)
    }
}
impl From<TsConstructSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsConstructSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsConstructSignatureTypeMember(node)
    }
}
impl From<TsGetterSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsGetterSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsGetterSignatureTypeMember(node)
    }
}
impl From<TsIndexSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsIndexSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsIndexSignatureTypeMember(node)
    }
}
impl From<TsMethodSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsMethodSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsMethodSignatureTypeMember(node)
    }
}
impl From<TsPropertySignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsPropertySignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsPropertySignatureTypeMember(node)
    }
}
impl From<TsSetterSignatureTypeMember> for TsAnyTypeMember {
    fn from(node: TsSetterSignatureTypeMember) -> TsAnyTypeMember {
        TsAnyTypeMember::TsSetterSignatureTypeMember(node)
    }
}
impl AstNode for TsAnyTypeMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_UNKNOWN_MEMBER
                | TS_CALL_SIGNATURE_TYPE_MEMBER
                | TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER
                | TS_GETTER_SIGNATURE_TYPE_MEMBER
                | TS_INDEX_SIGNATURE_TYPE_MEMBER
                | TS_METHOD_SIGNATURE_TYPE_MEMBER
                | TS_PROPERTY_SIGNATURE_TYPE_MEMBER
                | TS_SETTER_SIGNATURE_TYPE_MEMBER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_UNKNOWN_MEMBER => TsAnyTypeMember::JsUnknownMember(JsUnknownMember { syntax }),
            TS_CALL_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsCallSignatureTypeMember(TsCallSignatureTypeMember { syntax })
            }
            TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsConstructSignatureTypeMember(TsConstructSignatureTypeMember {
                    syntax,
                })
            }
            TS_GETTER_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsGetterSignatureTypeMember(TsGetterSignatureTypeMember { syntax })
            }
            TS_INDEX_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsIndexSignatureTypeMember(TsIndexSignatureTypeMember { syntax })
            }
            TS_METHOD_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsMethodSignatureTypeMember(TsMethodSignatureTypeMember { syntax })
            }
            TS_PROPERTY_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsPropertySignatureTypeMember(TsPropertySignatureTypeMember {
                    syntax,
                })
            }
            TS_SETTER_SIGNATURE_TYPE_MEMBER => {
                TsAnyTypeMember::TsSetterSignatureTypeMember(TsSetterSignatureTypeMember { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyTypeMember::JsUnknownMember(it) => &it.syntax,
            TsAnyTypeMember::TsCallSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsConstructSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsGetterSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsIndexSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsMethodSignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsPropertySignatureTypeMember(it) => &it.syntax,
            TsAnyTypeMember::TsSetterSignatureTypeMember(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyTypeMember::JsUnknownMember(it) => it.syntax,
            TsAnyTypeMember::TsCallSignatureTypeMember(it) => it.syntax,
            TsAnyTypeMember::TsConstructSignatureTypeMember(it) => it.syntax,
            TsAnyTypeMember::TsGetterSignatureTypeMember(it) => it.syntax,
            TsAnyTypeMember::TsIndexSignatureTypeMember(it) => it.syntax,
            TsAnyTypeMember::TsMethodSignatureTypeMember(it) => it.syntax,
            TsAnyTypeMember::TsPropertySignatureTypeMember(it) => it.syntax,
            TsAnyTypeMember::TsSetterSignatureTypeMember(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyTypeMember::JsUnknownMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsCallSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsConstructSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsGetterSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsIndexSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsMethodSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsPropertySignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            TsAnyTypeMember::TsSetterSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyTypeMember> for SyntaxNode {
    fn from(n: TsAnyTypeMember) -> SyntaxNode {
        match n {
            TsAnyTypeMember::JsUnknownMember(it) => it.into(),
            TsAnyTypeMember::TsCallSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsConstructSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsGetterSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsIndexSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsMethodSignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsPropertySignatureTypeMember(it) => it.into(),
            TsAnyTypeMember::TsSetterSignatureTypeMember(it) => it.into(),
        }
    }
}
impl From<TsAnyTypeMember> for SyntaxElement {
    fn from(n: TsAnyTypeMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsReferenceIdentifier> for TsAnyTypePredicateParameterName {
    fn from(node: JsReferenceIdentifier) -> TsAnyTypePredicateParameterName {
        TsAnyTypePredicateParameterName::JsReferenceIdentifier(node)
    }
}
impl From<TsThisType> for TsAnyTypePredicateParameterName {
    fn from(node: TsThisType) -> TsAnyTypePredicateParameterName {
        TsAnyTypePredicateParameterName::TsThisType(node)
    }
}
impl AstNode for TsAnyTypePredicateParameterName {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JS_REFERENCE_IDENTIFIER | TS_THIS_TYPE) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REFERENCE_IDENTIFIER => {
                TsAnyTypePredicateParameterName::JsReferenceIdentifier(JsReferenceIdentifier {
                    syntax,
                })
            }
            TS_THIS_TYPE => TsAnyTypePredicateParameterName::TsThisType(TsThisType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyTypePredicateParameterName::JsReferenceIdentifier(it) => &it.syntax,
            TsAnyTypePredicateParameterName::TsThisType(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyTypePredicateParameterName::JsReferenceIdentifier(it) => it.syntax,
            TsAnyTypePredicateParameterName::TsThisType(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyTypePredicateParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyTypePredicateParameterName::JsReferenceIdentifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyTypePredicateParameterName::TsThisType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyTypePredicateParameterName> for SyntaxNode {
    fn from(n: TsAnyTypePredicateParameterName) -> SyntaxNode {
        match n {
            TsAnyTypePredicateParameterName::JsReferenceIdentifier(it) => it.into(),
            TsAnyTypePredicateParameterName::TsThisType(it) => it.into(),
        }
    }
}
impl From<TsAnyTypePredicateParameterName> for SyntaxElement {
    fn from(n: TsAnyTypePredicateParameterName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsDefiniteVariableAnnotation> for TsAnyVariableAnnotation {
    fn from(node: TsDefiniteVariableAnnotation) -> TsAnyVariableAnnotation {
        TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for TsAnyVariableAnnotation {
    fn from(node: TsTypeAnnotation) -> TsAnyVariableAnnotation {
        TsAnyVariableAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode for TsAnyVariableAnnotation {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_DEFINITE_VARIABLE_ANNOTATION | TS_TYPE_ANNOTATION)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_DEFINITE_VARIABLE_ANNOTATION => {
                TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(
                    TsDefiniteVariableAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                TsAnyVariableAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(it) => &it.syntax,
            TsAnyVariableAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(it) => it.syntax,
            TsAnyVariableAnnotation::TsTypeAnnotation(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsAnyVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            TsAnyVariableAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsAnyVariableAnnotation> for SyntaxNode {
    fn from(n: TsAnyVariableAnnotation) -> SyntaxNode {
        match n {
            TsAnyVariableAnnotation::TsDefiniteVariableAnnotation(it) => it.into(),
            TsAnyVariableAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<TsAnyVariableAnnotation> for SyntaxElement {
    fn from(n: TsAnyVariableAnnotation) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAnyType> for TsType {
    fn from(node: TsAnyType) -> TsType { TsType::TsAnyType(node) }
}
impl From<TsArrayType> for TsType {
    fn from(node: TsArrayType) -> TsType { TsType::TsArrayType(node) }
}
impl From<TsBigIntLiteralType> for TsType {
    fn from(node: TsBigIntLiteralType) -> TsType { TsType::TsBigIntLiteralType(node) }
}
impl From<TsBigintType> for TsType {
    fn from(node: TsBigintType) -> TsType { TsType::TsBigintType(node) }
}
impl From<TsBooleanLiteralType> for TsType {
    fn from(node: TsBooleanLiteralType) -> TsType { TsType::TsBooleanLiteralType(node) }
}
impl From<TsBooleanType> for TsType {
    fn from(node: TsBooleanType) -> TsType { TsType::TsBooleanType(node) }
}
impl From<TsConditionalType> for TsType {
    fn from(node: TsConditionalType) -> TsType { TsType::TsConditionalType(node) }
}
impl From<TsConstructorType> for TsType {
    fn from(node: TsConstructorType) -> TsType { TsType::TsConstructorType(node) }
}
impl From<TsFunctionType> for TsType {
    fn from(node: TsFunctionType) -> TsType { TsType::TsFunctionType(node) }
}
impl From<TsImportType> for TsType {
    fn from(node: TsImportType) -> TsType { TsType::TsImportType(node) }
}
impl From<TsIndexedAccessType> for TsType {
    fn from(node: TsIndexedAccessType) -> TsType { TsType::TsIndexedAccessType(node) }
}
impl From<TsInferType> for TsType {
    fn from(node: TsInferType) -> TsType { TsType::TsInferType(node) }
}
impl From<TsIntersectionType> for TsType {
    fn from(node: TsIntersectionType) -> TsType { TsType::TsIntersectionType(node) }
}
impl From<TsMappedType> for TsType {
    fn from(node: TsMappedType) -> TsType { TsType::TsMappedType(node) }
}
impl From<TsNeverType> for TsType {
    fn from(node: TsNeverType) -> TsType { TsType::TsNeverType(node) }
}
impl From<TsNonPrimitiveType> for TsType {
    fn from(node: TsNonPrimitiveType) -> TsType { TsType::TsNonPrimitiveType(node) }
}
impl From<TsNullLiteralType> for TsType {
    fn from(node: TsNullLiteralType) -> TsType { TsType::TsNullLiteralType(node) }
}
impl From<TsNumberLiteralType> for TsType {
    fn from(node: TsNumberLiteralType) -> TsType { TsType::TsNumberLiteralType(node) }
}
impl From<TsNumberType> for TsType {
    fn from(node: TsNumberType) -> TsType { TsType::TsNumberType(node) }
}
impl From<TsObjectType> for TsType {
    fn from(node: TsObjectType) -> TsType { TsType::TsObjectType(node) }
}
impl From<TsParenthesizedType> for TsType {
    fn from(node: TsParenthesizedType) -> TsType { TsType::TsParenthesizedType(node) }
}
impl From<TsReferenceType> for TsType {
    fn from(node: TsReferenceType) -> TsType { TsType::TsReferenceType(node) }
}
impl From<TsStringLiteralType> for TsType {
    fn from(node: TsStringLiteralType) -> TsType { TsType::TsStringLiteralType(node) }
}
impl From<TsStringType> for TsType {
    fn from(node: TsStringType) -> TsType { TsType::TsStringType(node) }
}
impl From<TsSymbolType> for TsType {
    fn from(node: TsSymbolType) -> TsType { TsType::TsSymbolType(node) }
}
impl From<TsTemplateLiteralType> for TsType {
    fn from(node: TsTemplateLiteralType) -> TsType { TsType::TsTemplateLiteralType(node) }
}
impl From<TsThisType> for TsType {
    fn from(node: TsThisType) -> TsType { TsType::TsThisType(node) }
}
impl From<TsTupleType> for TsType {
    fn from(node: TsTupleType) -> TsType { TsType::TsTupleType(node) }
}
impl From<TsTypeOperatorType> for TsType {
    fn from(node: TsTypeOperatorType) -> TsType { TsType::TsTypeOperatorType(node) }
}
impl From<TsTypeofType> for TsType {
    fn from(node: TsTypeofType) -> TsType { TsType::TsTypeofType(node) }
}
impl From<TsUndefinedType> for TsType {
    fn from(node: TsUndefinedType) -> TsType { TsType::TsUndefinedType(node) }
}
impl From<TsUnionType> for TsType {
    fn from(node: TsUnionType) -> TsType { TsType::TsUnionType(node) }
}
impl From<TsUnknownType> for TsType {
    fn from(node: TsUnknownType) -> TsType { TsType::TsUnknownType(node) }
}
impl From<TsVoidType> for TsType {
    fn from(node: TsVoidType) -> TsType { TsType::TsVoidType(node) }
}
impl AstNode for TsType {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TS_ANY_TYPE
                | TS_ARRAY_TYPE
                | TS_BIG_INT_LITERAL_TYPE
                | TS_BIGINT_TYPE
                | TS_BOOLEAN_LITERAL_TYPE
                | TS_BOOLEAN_TYPE
                | TS_CONDITIONAL_TYPE
                | TS_CONSTRUCTOR_TYPE
                | TS_FUNCTION_TYPE
                | TS_IMPORT_TYPE
                | TS_INDEXED_ACCESS_TYPE
                | TS_INFER_TYPE
                | TS_INTERSECTION_TYPE
                | TS_MAPPED_TYPE
                | TS_NEVER_TYPE
                | TS_NON_PRIMITIVE_TYPE
                | TS_NULL_LITERAL_TYPE
                | TS_NUMBER_LITERAL_TYPE
                | TS_NUMBER_TYPE
                | TS_OBJECT_TYPE
                | TS_PARENTHESIZED_TYPE
                | TS_REFERENCE_TYPE
                | TS_STRING_LITERAL_TYPE
                | TS_STRING_TYPE
                | TS_SYMBOL_TYPE
                | TS_TEMPLATE_LITERAL_TYPE
                | TS_THIS_TYPE
                | TS_TUPLE_TYPE
                | TS_TYPE_OPERATOR_TYPE
                | TS_TYPEOF_TYPE
                | TS_UNDEFINED_TYPE
                | TS_UNION_TYPE
                | TS_UNKNOWN_TYPE
                | TS_VOID_TYPE
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ANY_TYPE => TsType::TsAnyType(TsAnyType { syntax }),
            TS_ARRAY_TYPE => TsType::TsArrayType(TsArrayType { syntax }),
            TS_BIG_INT_LITERAL_TYPE => TsType::TsBigIntLiteralType(TsBigIntLiteralType { syntax }),
            TS_BIGINT_TYPE => TsType::TsBigintType(TsBigintType { syntax }),
            TS_BOOLEAN_LITERAL_TYPE => {
                TsType::TsBooleanLiteralType(TsBooleanLiteralType { syntax })
            }
            TS_BOOLEAN_TYPE => TsType::TsBooleanType(TsBooleanType { syntax }),
            TS_CONDITIONAL_TYPE => TsType::TsConditionalType(TsConditionalType { syntax }),
            TS_CONSTRUCTOR_TYPE => TsType::TsConstructorType(TsConstructorType { syntax }),
            TS_FUNCTION_TYPE => TsType::TsFunctionType(TsFunctionType { syntax }),
            TS_IMPORT_TYPE => TsType::TsImportType(TsImportType { syntax }),
            TS_INDEXED_ACCESS_TYPE => TsType::TsIndexedAccessType(TsIndexedAccessType { syntax }),
            TS_INFER_TYPE => TsType::TsInferType(TsInferType { syntax }),
            TS_INTERSECTION_TYPE => TsType::TsIntersectionType(TsIntersectionType { syntax }),
            TS_MAPPED_TYPE => TsType::TsMappedType(TsMappedType { syntax }),
            TS_NEVER_TYPE => TsType::TsNeverType(TsNeverType { syntax }),
            TS_NON_PRIMITIVE_TYPE => TsType::TsNonPrimitiveType(TsNonPrimitiveType { syntax }),
            TS_NULL_LITERAL_TYPE => TsType::TsNullLiteralType(TsNullLiteralType { syntax }),
            TS_NUMBER_LITERAL_TYPE => TsType::TsNumberLiteralType(TsNumberLiteralType { syntax }),
            TS_NUMBER_TYPE => TsType::TsNumberType(TsNumberType { syntax }),
            TS_OBJECT_TYPE => TsType::TsObjectType(TsObjectType { syntax }),
            TS_PARENTHESIZED_TYPE => TsType::TsParenthesizedType(TsParenthesizedType { syntax }),
            TS_REFERENCE_TYPE => TsType::TsReferenceType(TsReferenceType { syntax }),
            TS_STRING_LITERAL_TYPE => TsType::TsStringLiteralType(TsStringLiteralType { syntax }),
            TS_STRING_TYPE => TsType::TsStringType(TsStringType { syntax }),
            TS_SYMBOL_TYPE => TsType::TsSymbolType(TsSymbolType { syntax }),
            TS_TEMPLATE_LITERAL_TYPE => {
                TsType::TsTemplateLiteralType(TsTemplateLiteralType { syntax })
            }
            TS_THIS_TYPE => TsType::TsThisType(TsThisType { syntax }),
            TS_TUPLE_TYPE => TsType::TsTupleType(TsTupleType { syntax }),
            TS_TYPE_OPERATOR_TYPE => TsType::TsTypeOperatorType(TsTypeOperatorType { syntax }),
            TS_TYPEOF_TYPE => TsType::TsTypeofType(TsTypeofType { syntax }),
            TS_UNDEFINED_TYPE => TsType::TsUndefinedType(TsUndefinedType { syntax }),
            TS_UNION_TYPE => TsType::TsUnionType(TsUnionType { syntax }),
            TS_UNKNOWN_TYPE => TsType::TsUnknownType(TsUnknownType { syntax }),
            TS_VOID_TYPE => TsType::TsVoidType(TsVoidType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TsType::TsAnyType(it) => &it.syntax,
            TsType::TsArrayType(it) => &it.syntax,
            TsType::TsBigIntLiteralType(it) => &it.syntax,
            TsType::TsBigintType(it) => &it.syntax,
            TsType::TsBooleanLiteralType(it) => &it.syntax,
            TsType::TsBooleanType(it) => &it.syntax,
            TsType::TsConditionalType(it) => &it.syntax,
            TsType::TsConstructorType(it) => &it.syntax,
            TsType::TsFunctionType(it) => &it.syntax,
            TsType::TsImportType(it) => &it.syntax,
            TsType::TsIndexedAccessType(it) => &it.syntax,
            TsType::TsInferType(it) => &it.syntax,
            TsType::TsIntersectionType(it) => &it.syntax,
            TsType::TsMappedType(it) => &it.syntax,
            TsType::TsNeverType(it) => &it.syntax,
            TsType::TsNonPrimitiveType(it) => &it.syntax,
            TsType::TsNullLiteralType(it) => &it.syntax,
            TsType::TsNumberLiteralType(it) => &it.syntax,
            TsType::TsNumberType(it) => &it.syntax,
            TsType::TsObjectType(it) => &it.syntax,
            TsType::TsParenthesizedType(it) => &it.syntax,
            TsType::TsReferenceType(it) => &it.syntax,
            TsType::TsStringLiteralType(it) => &it.syntax,
            TsType::TsStringType(it) => &it.syntax,
            TsType::TsSymbolType(it) => &it.syntax,
            TsType::TsTemplateLiteralType(it) => &it.syntax,
            TsType::TsThisType(it) => &it.syntax,
            TsType::TsTupleType(it) => &it.syntax,
            TsType::TsTypeOperatorType(it) => &it.syntax,
            TsType::TsTypeofType(it) => &it.syntax,
            TsType::TsUndefinedType(it) => &it.syntax,
            TsType::TsUnionType(it) => &it.syntax,
            TsType::TsUnknownType(it) => &it.syntax,
            TsType::TsVoidType(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            TsType::TsAnyType(it) => it.syntax,
            TsType::TsArrayType(it) => it.syntax,
            TsType::TsBigIntLiteralType(it) => it.syntax,
            TsType::TsBigintType(it) => it.syntax,
            TsType::TsBooleanLiteralType(it) => it.syntax,
            TsType::TsBooleanType(it) => it.syntax,
            TsType::TsConditionalType(it) => it.syntax,
            TsType::TsConstructorType(it) => it.syntax,
            TsType::TsFunctionType(it) => it.syntax,
            TsType::TsImportType(it) => it.syntax,
            TsType::TsIndexedAccessType(it) => it.syntax,
            TsType::TsInferType(it) => it.syntax,
            TsType::TsIntersectionType(it) => it.syntax,
            TsType::TsMappedType(it) => it.syntax,
            TsType::TsNeverType(it) => it.syntax,
            TsType::TsNonPrimitiveType(it) => it.syntax,
            TsType::TsNullLiteralType(it) => it.syntax,
            TsType::TsNumberLiteralType(it) => it.syntax,
            TsType::TsNumberType(it) => it.syntax,
            TsType::TsObjectType(it) => it.syntax,
            TsType::TsParenthesizedType(it) => it.syntax,
            TsType::TsReferenceType(it) => it.syntax,
            TsType::TsStringLiteralType(it) => it.syntax,
            TsType::TsStringType(it) => it.syntax,
            TsType::TsSymbolType(it) => it.syntax,
            TsType::TsTemplateLiteralType(it) => it.syntax,
            TsType::TsThisType(it) => it.syntax,
            TsType::TsTupleType(it) => it.syntax,
            TsType::TsTypeOperatorType(it) => it.syntax,
            TsType::TsTypeofType(it) => it.syntax,
            TsType::TsUndefinedType(it) => it.syntax,
            TsType::TsUnionType(it) => it.syntax,
            TsType::TsUnknownType(it) => it.syntax,
            TsType::TsVoidType(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for TsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TsType::TsAnyType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsArrayType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsBigIntLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsBigintType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsBooleanLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsBooleanType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsConditionalType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsConstructorType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsFunctionType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsImportType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsIndexedAccessType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsInferType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsIntersectionType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsMappedType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNeverType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNonPrimitiveType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNullLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNumberLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsNumberType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsObjectType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsParenthesizedType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsReferenceType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsStringLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsStringType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsSymbolType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsTemplateLiteralType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsThisType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsTupleType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsTypeOperatorType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsTypeofType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsUndefinedType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsUnionType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsUnknownType(it) => std::fmt::Debug::fmt(it, f),
            TsType::TsVoidType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<TsType> for SyntaxNode {
    fn from(n: TsType) -> SyntaxNode {
        match n {
            TsType::TsAnyType(it) => it.into(),
            TsType::TsArrayType(it) => it.into(),
            TsType::TsBigIntLiteralType(it) => it.into(),
            TsType::TsBigintType(it) => it.into(),
            TsType::TsBooleanLiteralType(it) => it.into(),
            TsType::TsBooleanType(it) => it.into(),
            TsType::TsConditionalType(it) => it.into(),
            TsType::TsConstructorType(it) => it.into(),
            TsType::TsFunctionType(it) => it.into(),
            TsType::TsImportType(it) => it.into(),
            TsType::TsIndexedAccessType(it) => it.into(),
            TsType::TsInferType(it) => it.into(),
            TsType::TsIntersectionType(it) => it.into(),
            TsType::TsMappedType(it) => it.into(),
            TsType::TsNeverType(it) => it.into(),
            TsType::TsNonPrimitiveType(it) => it.into(),
            TsType::TsNullLiteralType(it) => it.into(),
            TsType::TsNumberLiteralType(it) => it.into(),
            TsType::TsNumberType(it) => it.into(),
            TsType::TsObjectType(it) => it.into(),
            TsType::TsParenthesizedType(it) => it.into(),
            TsType::TsReferenceType(it) => it.into(),
            TsType::TsStringLiteralType(it) => it.into(),
            TsType::TsStringType(it) => it.into(),
            TsType::TsSymbolType(it) => it.into(),
            TsType::TsTemplateLiteralType(it) => it.into(),
            TsType::TsThisType(it) => it.into(),
            TsType::TsTupleType(it) => it.into(),
            TsType::TsTypeOperatorType(it) => it.into(),
            TsType::TsTypeofType(it) => it.into(),
            TsType::TsUndefinedType(it) => it.into(),
            TsType::TsUnionType(it) => it.into(),
            TsType::TsUnknownType(it) => it.into(),
            TsType::TsVoidType(it) => it.into(),
        }
    }
}
impl From<TsType> for SyntaxElement {
    fn from(n: TsType) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl std::fmt::Display for JsAnyArrayAssignmentPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyArrayBindingPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyArrayElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyArrowFunctionParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyCallArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyConstructorParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyExportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyForInOrOfInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyForInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyImportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyInProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyMethodModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyModuleItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyNamedImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyObjectAssignmentPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyObjectBindingPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyObjectMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyPropertyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyRoot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnySwitchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAnyTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyAttributeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyElementName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyObjectName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAnyTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyIndexSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyMethodSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyPropertyParameterModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyPropertySignatureAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyPropertySignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyTypePredicateParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImportMeta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayAssignmentPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayBindingPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayHole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrowFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAssignmentExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAssignmentWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAwaitExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBigIntLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBinaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBindingPatternWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBlockStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBooleanLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBreakStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCallArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCaseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCatchDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConditionalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConstructorClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConstructorParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsContinueStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDebuggerStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDefaultImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDoWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsElseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsEmptyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsEmptyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportDefaultDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportDefaultExpressionClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedFromSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedShorthandSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExpressionSnipped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExpressionStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFinallyClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForInStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForOfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsGetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsGetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportAssertion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportBareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInstanceofExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLabeledStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLiteralExportName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLiteralMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLogicalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsMethodClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsMethodObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsModuleSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamedImportSpecifiers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamespaceImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNewExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNullLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNumberLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParenthesizedAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParenthesizedExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPostUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPreUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPrivateClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPrivateName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPropertyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsRegexLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsRestParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsReturnStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSequenceExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsShorthandNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsShorthandPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSpread {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticInitializationBlockClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStringLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSuperExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSwitchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsThisExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsThrowStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTryFinallyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTryStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsUnaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclarator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsWithStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsYieldArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsYieldExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAttributeInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxClosingFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxExpressionAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxExpressionChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxNamespaceName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxOpeningElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxOpeningFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSelfClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSpreadAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSpreadChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxTagExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NewTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAbstractModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAccessibilityModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAsAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAsExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAssertsCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAssertsReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBigIntLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBigintType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBooleanLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBooleanType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsCallSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConditionalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructorSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefaultTypeClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefinitePropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefiniteVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEmptyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEnumDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEnumMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportAsNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportAssignmentClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportDeclareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExternalModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExternalModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsFunctionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGlobalDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImplementsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportEqualsDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportTypeQualifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexedAccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInterfaceDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIntersectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeOptionalModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeReadonlyModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMethodSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMethodSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsModuleBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNameWithTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNamedTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonNullAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonNullAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonPrimitiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNullLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNumberLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNumberType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsObjectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOptionalPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOptionalTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOverrideModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsParenthesizedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPredicateReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertySignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertySignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsQualifiedModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsQualifiedName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReadonlyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReferenceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsRestTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReturnTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsStringLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsStringType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSymbolType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsThisParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsThisType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAliasDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeConstraintClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeOperatorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeofType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUndefinedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUnionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUnknownType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsVoidType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknown {
    syntax: SyntaxNode,
}
impl JsUnknown {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknown {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknown {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknown")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknown> for SyntaxNode {
    fn from(n: JsUnknown) -> SyntaxNode { n.syntax }
}
impl From<JsUnknown> for SyntaxElement {
    fn from(n: JsUnknown) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknownAssignment {
    syntax: SyntaxNode,
}
impl JsUnknownAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknownAssignment {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknownAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownAssignment")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownAssignment> for SyntaxNode {
    fn from(n: JsUnknownAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsUnknownAssignment> for SyntaxElement {
    fn from(n: JsUnknownAssignment) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknownBinding {
    syntax: SyntaxNode,
}
impl JsUnknownBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknownBinding {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN_BINDING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknownBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownBinding")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownBinding> for SyntaxNode {
    fn from(n: JsUnknownBinding) -> SyntaxNode { n.syntax }
}
impl From<JsUnknownBinding> for SyntaxElement {
    fn from(n: JsUnknownBinding) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknownExpression {
    syntax: SyntaxNode,
}
impl JsUnknownExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknownExpression {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknownExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownExpression")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownExpression> for SyntaxNode {
    fn from(n: JsUnknownExpression) -> SyntaxNode { n.syntax }
}
impl From<JsUnknownExpression> for SyntaxElement {
    fn from(n: JsUnknownExpression) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknownImportAssertionEntry {
    syntax: SyntaxNode,
}
impl JsUnknownImportAssertionEntry {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknownImportAssertionEntry {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN_IMPORT_ASSERTION_ENTRY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknownImportAssertionEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownImportAssertionEntry")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownImportAssertionEntry> for SyntaxNode {
    fn from(n: JsUnknownImportAssertionEntry) -> SyntaxNode { n.syntax }
}
impl From<JsUnknownImportAssertionEntry> for SyntaxElement {
    fn from(n: JsUnknownImportAssertionEntry) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknownMember {
    syntax: SyntaxNode,
}
impl JsUnknownMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknownMember {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknownMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownMember")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownMember> for SyntaxNode {
    fn from(n: JsUnknownMember) -> SyntaxNode { n.syntax }
}
impl From<JsUnknownMember> for SyntaxElement {
    fn from(n: JsUnknownMember) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknownNamedImportSpecifier {
    syntax: SyntaxNode,
}
impl JsUnknownNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknownNamedImportSpecifier {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN_NAMED_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknownNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownNamedImportSpecifier")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownNamedImportSpecifier> for SyntaxNode {
    fn from(n: JsUnknownNamedImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsUnknownNamedImportSpecifier> for SyntaxElement {
    fn from(n: JsUnknownNamedImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknownParameter {
    syntax: SyntaxNode,
}
impl JsUnknownParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknownParameter {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknownParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownParameter")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownParameter> for SyntaxNode {
    fn from(n: JsUnknownParameter) -> SyntaxNode { n.syntax }
}
impl From<JsUnknownParameter> for SyntaxElement {
    fn from(n: JsUnknownParameter) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
#[cfg_attr(feature = "serde", serde(crate = "serde_crate"))]
pub struct JsUnknownStatement {
    syntax: SyntaxNode,
}
impl JsUnknownStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsUnknownStatement {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNKNOWN_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnknownStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnknownStatement")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsUnknownStatement> for SyntaxNode {
    fn from(n: JsUnknownStatement) -> SyntaxNode { n.syntax }
}
impl From<JsUnknownStatement> for SyntaxElement {
    fn from(n: JsUnknownStatement) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayAssignmentPatternElementList {
    syntax_list: SyntaxList,
}
impl JsArrayAssignmentPatternElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsArrayAssignmentPatternElementList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_ASSIGNMENT_PATTERN_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsArrayAssignmentPatternElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayAssignmentPatternElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayAssignmentPatternElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsArrayAssignmentPatternElementList {
    type Language = Language;
    type Node = JsAnyArrayAssignmentPatternElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsArrayAssignmentPatternElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayAssignmentPatternElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayAssignmentPatternElementList {
    type Item = SyntaxResult<JsAnyArrayAssignmentPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyArrayAssignmentPatternElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsArrayAssignmentPatternElementList {
    type Item = SyntaxResult<JsAnyArrayAssignmentPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyArrayAssignmentPatternElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayBindingPatternElementList {
    syntax_list: SyntaxList,
}
impl JsArrayBindingPatternElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsArrayBindingPatternElementList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_BINDING_PATTERN_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsArrayBindingPatternElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayBindingPatternElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayBindingPatternElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsArrayBindingPatternElementList {
    type Language = Language;
    type Node = JsAnyArrayBindingPatternElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsArrayBindingPatternElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayBindingPatternElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayBindingPatternElementList {
    type Item = SyntaxResult<JsAnyArrayBindingPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyArrayBindingPatternElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsArrayBindingPatternElementList {
    type Item = SyntaxResult<JsAnyArrayBindingPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyArrayBindingPatternElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayElementList {
    syntax_list: SyntaxList,
}
impl JsArrayElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsArrayElementList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsArrayElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsArrayElementList {
    type Language = Language;
    type Node = JsAnyArrayElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsArrayElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayElementList {
    type Item = SyntaxResult<JsAnyArrayElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyArrayElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsArrayElementList {
    type Item = SyntaxResult<JsAnyArrayElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyArrayElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsCallArgumentList {
    syntax_list: SyntaxList,
}
impl JsCallArgumentList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsCallArgumentList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CALL_ARGUMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsCallArgumentList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsCallArgumentList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsCallArgumentList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsCallArgumentList {
    type Language = Language;
    type Node = JsAnyCallArgument;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsCallArgumentList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsCallArgumentList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsCallArgumentList {
    type Item = SyntaxResult<JsAnyCallArgument>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyCallArgument>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsCallArgumentList {
    type Item = SyntaxResult<JsAnyCallArgument>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyCallArgument>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsClassMemberList {
    syntax_list: SyntaxList,
}
impl JsClassMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsClassMemberList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CLASS_MEMBER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsClassMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsClassMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsClassMemberList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsClassMemberList {
    type Language = Language;
    type Node = JsAnyClassMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsClassMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsClassMemberList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsClassMemberList {
    type Item = JsAnyClassMember;
    type IntoIter = AstNodeListIterator<Language, JsAnyClassMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsClassMemberList {
    type Item = JsAnyClassMember;
    type IntoIter = AstNodeListIterator<Language, JsAnyClassMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsConstructorModifierList {
    syntax_list: SyntaxList,
}
impl JsConstructorModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsConstructorModifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONSTRUCTOR_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsConstructorModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsConstructorModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsConstructorModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsConstructorModifierList {
    type Language = Language;
    type Node = TsAccessibilityModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsConstructorModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsConstructorModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsConstructorModifierList {
    type Item = TsAccessibilityModifier;
    type IntoIter = AstNodeListIterator<Language, TsAccessibilityModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsConstructorModifierList {
    type Item = TsAccessibilityModifier;
    type IntoIter = AstNodeListIterator<Language, TsAccessibilityModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsConstructorParameterList {
    syntax_list: SyntaxList,
}
impl JsConstructorParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsConstructorParameterList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONSTRUCTOR_PARAMETER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsConstructorParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsConstructorParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsConstructorParameterList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsConstructorParameterList {
    type Language = Language;
    type Node = JsAnyConstructorParameter;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsConstructorParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsConstructorParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsConstructorParameterList {
    type Item = SyntaxResult<JsAnyConstructorParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyConstructorParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsConstructorParameterList {
    type Item = SyntaxResult<JsAnyConstructorParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyConstructorParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsDirectiveList {
    syntax_list: SyntaxList,
}
impl JsDirectiveList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsDirectiveList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DIRECTIVE_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsDirectiveList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsDirectiveList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsDirectiveList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsDirectiveList {
    type Language = Language;
    type Node = JsDirective;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsDirectiveList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsDirectiveList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsDirectiveList {
    type Item = JsDirective;
    type IntoIter = AstNodeListIterator<Language, JsDirective>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsDirectiveList {
    type Item = JsDirective;
    type IntoIter = AstNodeListIterator<Language, JsDirective>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsExportNamedFromSpecifierList {
    syntax_list: SyntaxList,
}
impl JsExportNamedFromSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsExportNamedFromSpecifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_FROM_SPECIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsExportNamedFromSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsExportNamedFromSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedFromSpecifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsExportNamedFromSpecifierList {
    type Language = Language;
    type Node = JsExportNamedFromSpecifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsExportNamedFromSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsExportNamedFromSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsExportNamedFromSpecifierList {
    type Item = SyntaxResult<JsExportNamedFromSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsExportNamedFromSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsExportNamedFromSpecifierList {
    type Item = SyntaxResult<JsExportNamedFromSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsExportNamedFromSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsExportNamedSpecifierList {
    syntax_list: SyntaxList,
}
impl JsExportNamedSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsExportNamedSpecifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_SPECIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsExportNamedSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsExportNamedSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedSpecifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsExportNamedSpecifierList {
    type Language = Language;
    type Node = JsAnyExportNamedSpecifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsExportNamedSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsExportNamedSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsExportNamedSpecifierList {
    type Item = SyntaxResult<JsAnyExportNamedSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyExportNamedSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsExportNamedSpecifierList {
    type Item = SyntaxResult<JsAnyExportNamedSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyExportNamedSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsImportAssertionEntryList {
    syntax_list: SyntaxList,
}
impl JsImportAssertionEntryList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsImportAssertionEntryList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_ASSERTION_ENTRY_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsImportAssertionEntryList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsImportAssertionEntryList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportAssertionEntryList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsImportAssertionEntryList {
    type Language = Language;
    type Node = JsAnyImportAssertionEntry;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsImportAssertionEntryList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsImportAssertionEntryList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsImportAssertionEntryList {
    type Item = SyntaxResult<JsAnyImportAssertionEntry>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyImportAssertionEntry>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsImportAssertionEntryList {
    type Item = SyntaxResult<JsAnyImportAssertionEntry>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyImportAssertionEntry>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsMethodModifierList {
    syntax_list: SyntaxList,
}
impl JsMethodModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsMethodModifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_METHOD_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsMethodModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsMethodModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsMethodModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsMethodModifierList {
    type Language = Language;
    type Node = JsAnyMethodModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsMethodModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsMethodModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsMethodModifierList {
    type Item = JsAnyMethodModifier;
    type IntoIter = AstNodeListIterator<Language, JsAnyMethodModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsMethodModifierList {
    type Item = JsAnyMethodModifier;
    type IntoIter = AstNodeListIterator<Language, JsAnyMethodModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsModuleItemList {
    syntax_list: SyntaxList,
}
impl JsModuleItemList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsModuleItemList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_MODULE_ITEM_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsModuleItemList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsModuleItemList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsModuleItemList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsModuleItemList {
    type Language = Language;
    type Node = JsAnyModuleItem;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsModuleItemList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsModuleItemList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsModuleItemList {
    type Item = JsAnyModuleItem;
    type IntoIter = AstNodeListIterator<Language, JsAnyModuleItem>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsModuleItemList {
    type Item = JsAnyModuleItem;
    type IntoIter = AstNodeListIterator<Language, JsAnyModuleItem>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsNamedImportSpecifierList {
    syntax_list: SyntaxList,
}
impl JsNamedImportSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsNamedImportSpecifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAMED_IMPORT_SPECIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsNamedImportSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsNamedImportSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsNamedImportSpecifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsNamedImportSpecifierList {
    type Language = Language;
    type Node = JsAnyNamedImportSpecifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsNamedImportSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsNamedImportSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsNamedImportSpecifierList {
    type Item = SyntaxResult<JsAnyNamedImportSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyNamedImportSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsNamedImportSpecifierList {
    type Item = SyntaxResult<JsAnyNamedImportSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyNamedImportSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectAssignmentPatternPropertyList {
    syntax_list: SyntaxList,
}
impl JsObjectAssignmentPatternPropertyList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsObjectAssignmentPatternPropertyList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsObjectAssignmentPatternPropertyList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectAssignmentPatternPropertyList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPatternPropertyList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsObjectAssignmentPatternPropertyList {
    type Language = Language;
    type Node = JsAnyObjectAssignmentPatternMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsObjectAssignmentPatternPropertyList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectAssignmentPatternPropertyList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectAssignmentPatternPropertyList {
    type Item = SyntaxResult<JsAnyObjectAssignmentPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyObjectAssignmentPatternMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsObjectAssignmentPatternPropertyList {
    type Item = SyntaxResult<JsAnyObjectAssignmentPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyObjectAssignmentPatternMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectBindingPatternPropertyList {
    syntax_list: SyntaxList,
}
impl JsObjectBindingPatternPropertyList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsObjectBindingPatternPropertyList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN_PROPERTY_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsObjectBindingPatternPropertyList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectBindingPatternPropertyList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPatternPropertyList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsObjectBindingPatternPropertyList {
    type Language = Language;
    type Node = JsAnyObjectBindingPatternMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsObjectBindingPatternPropertyList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectBindingPatternPropertyList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectBindingPatternPropertyList {
    type Item = SyntaxResult<JsAnyObjectBindingPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyObjectBindingPatternMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsObjectBindingPatternPropertyList {
    type Item = SyntaxResult<JsAnyObjectBindingPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyObjectBindingPatternMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectMemberList {
    syntax_list: SyntaxList,
}
impl JsObjectMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsObjectMemberList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_MEMBER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsObjectMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectMemberList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsObjectMemberList {
    type Language = Language;
    type Node = JsAnyObjectMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsObjectMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectMemberList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectMemberList {
    type Item = SyntaxResult<JsAnyObjectMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyObjectMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsObjectMemberList {
    type Item = SyntaxResult<JsAnyObjectMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyObjectMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsParameterList {
    syntax_list: SyntaxList,
}
impl JsParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsParameterList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PARAMETER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsParameterList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsParameterList {
    type Language = Language;
    type Node = JsAnyParameter;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsParameterList {
    type Item = SyntaxResult<JsAnyParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsParameterList {
    type Item = SyntaxResult<JsAnyParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsAnyParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsPropertyModifierList {
    syntax_list: SyntaxList,
}
impl JsPropertyModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsPropertyModifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PROPERTY_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsPropertyModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsPropertyModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsPropertyModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsPropertyModifierList {
    type Language = Language;
    type Node = JsAnyPropertyModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsPropertyModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsPropertyModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsPropertyModifierList {
    type Item = JsAnyPropertyModifier;
    type IntoIter = AstNodeListIterator<Language, JsAnyPropertyModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsPropertyModifierList {
    type Item = JsAnyPropertyModifier;
    type IntoIter = AstNodeListIterator<Language, JsAnyPropertyModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsStatementList {
    syntax_list: SyntaxList,
}
impl JsStatementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsStatementList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsStatementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsStatementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsStatementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsStatementList {
    type Language = Language;
    type Node = JsAnyStatement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsStatementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsStatementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsStatementList {
    type Item = JsAnyStatement;
    type IntoIter = AstNodeListIterator<Language, JsAnyStatement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsStatementList {
    type Item = JsAnyStatement;
    type IntoIter = AstNodeListIterator<Language, JsAnyStatement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsSwitchCaseList {
    syntax_list: SyntaxList,
}
impl JsSwitchCaseList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsSwitchCaseList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SWITCH_CASE_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsSwitchCaseList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsSwitchCaseList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsSwitchCaseList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsSwitchCaseList {
    type Language = Language;
    type Node = JsAnySwitchClause;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsSwitchCaseList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsSwitchCaseList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsSwitchCaseList {
    type Item = JsAnySwitchClause;
    type IntoIter = AstNodeListIterator<Language, JsAnySwitchClause>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsSwitchCaseList {
    type Item = JsAnySwitchClause;
    type IntoIter = AstNodeListIterator<Language, JsAnySwitchClause>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsTemplateElementList {
    syntax_list: SyntaxList,
}
impl JsTemplateElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsTemplateElementList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TEMPLATE_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsTemplateElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsTemplateElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsTemplateElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsTemplateElementList {
    type Language = Language;
    type Node = JsAnyTemplateElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsTemplateElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsTemplateElementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsTemplateElementList {
    type Item = JsAnyTemplateElement;
    type IntoIter = AstNodeListIterator<Language, JsAnyTemplateElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsTemplateElementList {
    type Item = JsAnyTemplateElement;
    type IntoIter = AstNodeListIterator<Language, JsAnyTemplateElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsVariableDeclaratorList {
    syntax_list: SyntaxList,
}
impl JsVariableDeclaratorList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsVariableDeclaratorList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_DECLARATOR_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsVariableDeclaratorList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsVariableDeclaratorList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableDeclaratorList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsVariableDeclaratorList {
    type Language = Language;
    type Node = JsVariableDeclarator;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsVariableDeclaratorList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsVariableDeclaratorList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsVariableDeclaratorList {
    type Item = SyntaxResult<JsVariableDeclarator>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsVariableDeclarator>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsVariableDeclaratorList {
    type Item = SyntaxResult<JsVariableDeclarator>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsVariableDeclarator>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsxAttributeList {
    syntax_list: SyntaxList,
}
impl JsxAttributeList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsxAttributeList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_ATTRIBUTE_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsxAttributeList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsxAttributeList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsxAttributeList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsxAttributeList {
    type Language = Language;
    type Node = JsxAnyAttribute;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsxAttributeList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsxAttributeList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsxAttributeList {
    type Item = JsxAnyAttribute;
    type IntoIter = AstNodeListIterator<Language, JsxAnyAttribute>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsxAttributeList {
    type Item = JsxAnyAttribute;
    type IntoIter = AstNodeListIterator<Language, JsxAnyAttribute>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsxChildList {
    syntax_list: SyntaxList,
}
impl JsxChildList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsxChildList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_CHILD_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsxChildList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsxChildList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsxChildList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsxChildList {
    type Language = Language;
    type Node = JsxAnyChild;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for JsxChildList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsxChildList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsxChildList {
    type Item = JsxAnyChild;
    type IntoIter = AstNodeListIterator<Language, JsxAnyChild>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsxChildList {
    type Item = JsxAnyChild;
    type IntoIter = AstNodeListIterator<Language, JsxAnyChild>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsEnumMemberList {
    syntax_list: SyntaxList,
}
impl TsEnumMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsEnumMemberList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ENUM_MEMBER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsEnumMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsEnumMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsEnumMemberList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsEnumMemberList {
    type Language = Language;
    type Node = TsEnumMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsEnumMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsEnumMemberList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsEnumMemberList {
    type Item = SyntaxResult<TsEnumMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsEnumMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsEnumMemberList {
    type Item = SyntaxResult<TsEnumMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsEnumMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsIndexSignatureModifierList {
    syntax_list: SyntaxList,
}
impl TsIndexSignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsIndexSignatureModifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEX_SIGNATURE_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsIndexSignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsIndexSignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexSignatureModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsIndexSignatureModifierList {
    type Language = Language;
    type Node = TsAnyIndexSignatureModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsIndexSignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsIndexSignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsIndexSignatureModifierList {
    type Item = TsAnyIndexSignatureModifier;
    type IntoIter = AstNodeListIterator<Language, TsAnyIndexSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsIndexSignatureModifierList {
    type Item = TsAnyIndexSignatureModifier;
    type IntoIter = AstNodeListIterator<Language, TsAnyIndexSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsIntersectionTypeElementList {
    syntax_list: SyntaxList,
}
impl TsIntersectionTypeElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsIntersectionTypeElementList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INTERSECTION_TYPE_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsIntersectionTypeElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsIntersectionTypeElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsIntersectionTypeElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsIntersectionTypeElementList {
    type Language = Language;
    type Node = TsType;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsIntersectionTypeElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsIntersectionTypeElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsIntersectionTypeElementList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsIntersectionTypeElementList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsMethodSignatureModifierList {
    syntax_list: SyntaxList,
}
impl TsMethodSignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsMethodSignatureModifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_METHOD_SIGNATURE_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsMethodSignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsMethodSignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsMethodSignatureModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsMethodSignatureModifierList {
    type Language = Language;
    type Node = TsAnyMethodSignatureModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsMethodSignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsMethodSignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsMethodSignatureModifierList {
    type Item = TsAnyMethodSignatureModifier;
    type IntoIter = AstNodeListIterator<Language, TsAnyMethodSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsMethodSignatureModifierList {
    type Item = TsAnyMethodSignatureModifier;
    type IntoIter = AstNodeListIterator<Language, TsAnyMethodSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsPropertyParameterModifierList {
    syntax_list: SyntaxList,
}
impl TsPropertyParameterModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsPropertyParameterModifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_PARAMETER_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsPropertyParameterModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsPropertyParameterModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertyParameterModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsPropertyParameterModifierList {
    type Language = Language;
    type Node = TsAnyPropertyParameterModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsPropertyParameterModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsPropertyParameterModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsPropertyParameterModifierList {
    type Item = TsAnyPropertyParameterModifier;
    type IntoIter = AstNodeListIterator<Language, TsAnyPropertyParameterModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsPropertyParameterModifierList {
    type Item = TsAnyPropertyParameterModifier;
    type IntoIter = AstNodeListIterator<Language, TsAnyPropertyParameterModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsPropertySignatureModifierList {
    syntax_list: SyntaxList,
}
impl TsPropertySignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsPropertySignatureModifierList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_SIGNATURE_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsPropertySignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsPropertySignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertySignatureModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsPropertySignatureModifierList {
    type Language = Language;
    type Node = TsAnyPropertySignatureModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsPropertySignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsPropertySignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsPropertySignatureModifierList {
    type Item = TsAnyPropertySignatureModifier;
    type IntoIter = AstNodeListIterator<Language, TsAnyPropertySignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsPropertySignatureModifierList {
    type Item = TsAnyPropertySignatureModifier;
    type IntoIter = AstNodeListIterator<Language, TsAnyPropertySignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTemplateElementList {
    syntax_list: SyntaxList,
}
impl TsTemplateElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTemplateElementList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TEMPLATE_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTemplateElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTemplateElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTemplateElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsTemplateElementList {
    type Language = Language;
    type Node = TsAnyTemplateElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsTemplateElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTemplateElementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsTemplateElementList {
    type Item = TsAnyTemplateElement;
    type IntoIter = AstNodeListIterator<Language, TsAnyTemplateElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsTemplateElementList {
    type Item = TsAnyTemplateElement;
    type IntoIter = AstNodeListIterator<Language, TsAnyTemplateElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTupleTypeElementList {
    syntax_list: SyntaxList,
}
impl TsTupleTypeElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTupleTypeElementList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TUPLE_TYPE_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTupleTypeElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTupleTypeElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTupleTypeElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsTupleTypeElementList {
    type Language = Language;
    type Node = TsAnyTupleTypeElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsTupleTypeElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTupleTypeElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTupleTypeElementList {
    type Item = SyntaxResult<TsAnyTupleTypeElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsAnyTupleTypeElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsTupleTypeElementList {
    type Item = SyntaxResult<TsAnyTupleTypeElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsAnyTupleTypeElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeArgumentList {
    syntax_list: SyntaxList,
}
impl TsTypeArgumentList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeArgumentList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ARGUMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeArgumentList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeArgumentList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeArgumentList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsTypeArgumentList {
    type Language = Language;
    type Node = TsType;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsTypeArgumentList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeArgumentList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeArgumentList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsTypeArgumentList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeList {
    syntax_list: SyntaxList,
}
impl TsTypeList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsTypeList {
    type Language = Language;
    type Node = TsNameWithTypeArguments;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsTypeList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeList {
    type Item = SyntaxResult<TsNameWithTypeArguments>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsNameWithTypeArguments>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsTypeList {
    type Item = SyntaxResult<TsNameWithTypeArguments>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsNameWithTypeArguments>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeMemberList {
    syntax_list: SyntaxList,
}
impl TsTypeMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeMemberList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_MEMBER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeMemberList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsTypeMemberList {
    type Language = Language;
    type Node = TsAnyTypeMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsTypeMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeMemberList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsTypeMemberList {
    type Item = TsAnyTypeMember;
    type IntoIter = AstNodeListIterator<Language, TsAnyTypeMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsTypeMemberList {
    type Item = TsAnyTypeMember;
    type IntoIter = AstNodeListIterator<Language, TsAnyTypeMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeParameterList {
    syntax_list: SyntaxList,
}
impl TsTypeParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeParameterList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameterList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsTypeParameterList {
    type Language = Language;
    type Node = TsTypeParameter;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsTypeParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeParameterList {
    type Item = SyntaxResult<TsTypeParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsTypeParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsTypeParameterList {
    type Item = SyntaxResult<TsTypeParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsTypeParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsUnionTypeVariantList {
    syntax_list: SyntaxList,
}
impl TsUnionTypeVariantList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsUnionTypeVariantList {
    type Language = Language;
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_UNION_TYPE_VARIANT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsUnionTypeVariantList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsUnionTypeVariantList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsUnionTypeVariantList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsUnionTypeVariantList {
    type Language = Language;
    type Node = TsType;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
}
impl Debug for TsUnionTypeVariantList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsUnionTypeVariantList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsUnionTypeVariantList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsUnionTypeVariantList {
    type Item = SyntaxResult<TsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone)]
pub struct DebugSyntaxElementChildren(pub SyntaxElementChildren);
impl Debug for DebugSyntaxElementChildren {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_list()
            .entries(self.clone().0.map(DebugSyntaxElement))
            .finish()
    }
}
struct DebugSyntaxElement(SyntaxElement);
impl Debug for DebugSyntaxElement {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match &self.0 {
            SyntaxElement::Node(node) => {
                map_syntax_node ! (node . clone () , node => std :: fmt :: Debug :: fmt (& node , f))
            }
            SyntaxElement::Token(token) => Debug::fmt(token, f),
        }
    }
}
