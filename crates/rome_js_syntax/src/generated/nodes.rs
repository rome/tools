//! Generated file, do not edit by hand, see `xtask/codegen`

#![allow(clippy::enum_variant_names)]
#![allow(clippy::match_like_matches_macro)]
use crate::{
    macros::map_syntax_node,
    JsLanguage as Language, JsSyntaxElement as SyntaxElement,
    JsSyntaxElementChildren as SyntaxElementChildren,
    JsSyntaxKind::{self as SyntaxKind, *},
    JsSyntaxList as SyntaxList, JsSyntaxNode as SyntaxNode, JsSyntaxToken as SyntaxToken,
};
use rome_rowan::{support, AstNode, RawSyntaxKind, SyntaxKindSet, SyntaxResult};
#[allow(unused)]
use rome_rowan::{
    AstNodeList, AstNodeListIterator, AstSeparatedList, AstSeparatedListNodesIterator,
};
#[cfg(feature = "serde")]
use serde::ser::SerializeSeq;
#[cfg(feature = "serde")]
use serde::{Serialize, Serializer};
use std::fmt::{Debug, Formatter};
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAccessorModifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsAccessorModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsAccessorModifierFields {
        JsAccessorModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsAccessorModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsAccessorModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayAssignmentPattern {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayAssignmentPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayAssignmentPatternFields {
        JsArrayAssignmentPatternFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayAssignmentPatternElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayAssignmentPattern {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsArrayAssignmentPatternFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub elements: JsArrayAssignmentPatternElementList,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayAssignmentPatternRestElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayAssignmentPatternRestElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayAssignmentPatternRestElementFields {
        JsArrayAssignmentPatternRestElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            pattern: self.pattern(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn pattern(&self) -> SyntaxResult<AnyJsAssignmentPattern> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayAssignmentPatternRestElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsArrayAssignmentPatternRestElementFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub pattern: SyntaxResult<AnyJsAssignmentPattern>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayBindingPattern {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayBindingPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayBindingPatternFields {
        JsArrayBindingPatternFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayBindingPatternElementList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayBindingPattern {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsArrayBindingPatternFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub elements: JsArrayBindingPatternElementList,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayBindingPatternRestElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayBindingPatternRestElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayBindingPatternRestElementFields {
        JsArrayBindingPatternRestElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            pattern: self.pattern(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn pattern(&self) -> SyntaxResult<AnyJsBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayBindingPatternRestElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsArrayBindingPatternRestElementFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub pattern: SyntaxResult<AnyJsBindingPattern>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayExpressionFields {
        JsArrayExpressionFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> JsArrayElementList { support::list(&self.syntax, 1usize) }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsArrayExpressionFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub elements: JsArrayElementList,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrayHole {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrayHole {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrayHoleFields { JsArrayHoleFields {} }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayHole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsArrayHoleFields {}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsArrowFunctionExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsArrowFunctionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsArrowFunctionExpressionFields {
        JsArrowFunctionExpressionFields {
            async_token: self.async_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            fat_arrow_token: self.fat_arrow_token(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<AnyJsArrowFunctionParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn body(&self) -> SyntaxResult<AnyJsFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrowFunctionExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsArrowFunctionExpressionFields {
    pub async_token: Option<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<AnyJsArrowFunctionParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub fat_arrow_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<AnyJsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAssignmentExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsAssignmentExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsAssignmentExpressionFields {
        JsAssignmentExpressionFields {
            left: self.left(),
            operator_token: self.operator_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<AnyJsAssignmentPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsAssignmentExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsAssignmentExpressionFields {
    pub left: SyntaxResult<AnyJsAssignmentPattern>,
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAssignmentWithDefault {
    pub(crate) syntax: SyntaxNode,
}
impl JsAssignmentWithDefault {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsAssignmentWithDefaultFields {
        JsAssignmentWithDefaultFields {
            pattern: self.pattern(),
            eq_token: self.eq_token(),
            default: self.default(),
        }
    }
    pub fn pattern(&self) -> SyntaxResult<AnyJsAssignmentPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn default(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsAssignmentWithDefault {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsAssignmentWithDefaultFields {
    pub pattern: SyntaxResult<AnyJsAssignmentPattern>,
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub default: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsAwaitExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsAwaitExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsAwaitExpressionFields {
        JsAwaitExpressionFields {
            await_token: self.await_token(),
            argument: self.argument(),
        }
    }
    pub fn await_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsAwaitExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsAwaitExpressionFields {
    pub await_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBigintLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsBigintLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBigintLiteralExpressionFields {
        JsBigintLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBigintLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBigintLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBinaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsBinaryExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBinaryExpressionFields {
        JsBinaryExpressionFields {
            left: self.left(),
            operator_token: self.operator_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBinaryExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBinaryExpressionFields {
    pub left: SyntaxResult<AnyJsExpression>,
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBindingPatternWithDefault {
    pub(crate) syntax: SyntaxNode,
}
impl JsBindingPatternWithDefault {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBindingPatternWithDefaultFields {
        JsBindingPatternWithDefaultFields {
            pattern: self.pattern(),
            eq_token: self.eq_token(),
            default: self.default(),
        }
    }
    pub fn pattern(&self) -> SyntaxResult<AnyJsBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn default(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBindingPatternWithDefault {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBindingPatternWithDefaultFields {
    pub pattern: SyntaxResult<AnyJsBindingPattern>,
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub default: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBlockStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsBlockStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBlockStatementFields {
        JsBlockStatementFields {
            l_curly_token: self.l_curly_token(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn statements(&self) -> JsStatementList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBlockStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBlockStatementFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBooleanLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsBooleanLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBooleanLiteralExpressionFields {
        JsBooleanLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsBooleanLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBooleanLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsBreakStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsBreakStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsBreakStatementFields {
        JsBreakStatementFields {
            break_token: self.break_token(),
            label_token: self.label_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn break_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn label_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsBreakStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBreakStatementFields {
    pub break_token: SyntaxResult<SyntaxToken>,
    pub label_token: Option<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCallArguments {
    pub(crate) syntax: SyntaxNode,
}
impl JsCallArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCallArgumentsFields {
        JsCallArgumentsFields {
            l_paren_token: self.l_paren_token(),
            args: self.args(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn args(&self) -> JsCallArgumentList { support::list(&self.syntax, 1usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsCallArguments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsCallArgumentsFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub args: JsCallArgumentList,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCallExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsCallExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCallExpressionFields {
        JsCallExpressionFields {
            callee: self.callee(),
            optional_chain_token: self.optional_chain_token(),
            type_arguments: self.type_arguments(),
            arguments: self.arguments(),
        }
    }
    pub fn callee(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_chain_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
    pub fn arguments(&self) -> SyntaxResult<JsCallArguments> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsCallExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsCallExpressionFields {
    pub callee: SyntaxResult<AnyJsExpression>,
    pub optional_chain_token: Option<SyntaxToken>,
    pub type_arguments: Option<TsTypeArguments>,
    pub arguments: SyntaxResult<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCaseClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsCaseClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCaseClauseFields {
        JsCaseClauseFields {
            case_token: self.case_token(),
            test: self.test(),
            colon_token: self.colon_token(),
            consequent: self.consequent(),
        }
    }
    pub fn case_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn test(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn consequent(&self) -> JsStatementList { support::list(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsCaseClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsCaseClauseFields {
    pub case_token: SyntaxResult<SyntaxToken>,
    pub test: SyntaxResult<AnyJsExpression>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub consequent: JsStatementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCatchClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsCatchClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCatchClauseFields {
        JsCatchClauseFields {
            catch_token: self.catch_token(),
            declaration: self.declaration(),
            body: self.body(),
        }
    }
    pub fn catch_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> Option<JsCatchDeclaration> { support::node(&self.syntax, 1usize) }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsCatchClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsCatchClauseFields {
    pub catch_token: SyntaxResult<SyntaxToken>,
    pub declaration: Option<JsCatchDeclaration>,
    pub body: SyntaxResult<JsBlockStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsCatchDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsCatchDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsCatchDeclarationFields {
        JsCatchDeclarationFields {
            l_paren_token: self.l_paren_token(),
            binding: self.binding(),
            type_annotation: self.type_annotation(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<AnyJsBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsCatchDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsCatchDeclarationFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub binding: SyntaxResult<AnyJsBindingPattern>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsClassDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsClassDeclarationFields {
        JsClassDeclarationFields {
            decorators: self.decorators(),
            abstract_token: self.abstract_token(),
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn decorators(&self) -> JsDecoratorList { support::list(&self.syntax, 0usize) }
    pub fn abstract_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn class_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn id(&self) -> SyntaxResult<AnyJsBinding> { support::required_node(&self.syntax, 3usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> { support::node(&self.syntax, 5usize) }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 6usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
    pub fn members(&self) -> JsClassMemberList { support::list(&self.syntax, 8usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 9usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsClassDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsClassDeclarationFields {
    pub decorators: JsDecoratorList,
    pub abstract_token: Option<SyntaxToken>,
    pub class_token: SyntaxResult<SyntaxToken>,
    pub id: SyntaxResult<AnyJsBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassExportDefaultDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsClassExportDefaultDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsClassExportDefaultDeclarationFields {
        JsClassExportDefaultDeclarationFields {
            decorators: self.decorators(),
            abstract_token: self.abstract_token(),
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn decorators(&self) -> JsDecoratorList { support::list(&self.syntax, 0usize) }
    pub fn abstract_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn class_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn id(&self) -> Option<AnyJsBinding> { support::node(&self.syntax, 3usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> { support::node(&self.syntax, 5usize) }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 6usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
    pub fn members(&self) -> JsClassMemberList { support::list(&self.syntax, 8usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 9usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsClassExportDefaultDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsClassExportDefaultDeclarationFields {
    pub decorators: JsDecoratorList,
    pub abstract_token: Option<SyntaxToken>,
    pub class_token: SyntaxResult<SyntaxToken>,
    pub id: Option<AnyJsBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsClassExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsClassExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsClassExpressionFields {
        JsClassExpressionFields {
            decorators: self.decorators(),
            class_token: self.class_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            implements_clause: self.implements_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn decorators(&self) -> JsDecoratorList { support::list(&self.syntax, 0usize) }
    pub fn class_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> Option<AnyJsBinding> { support::node(&self.syntax, 2usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn extends_clause(&self) -> Option<JsExtendsClause> { support::node(&self.syntax, 4usize) }
    pub fn implements_clause(&self) -> Option<TsImplementsClause> {
        support::node(&self.syntax, 5usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
    pub fn members(&self) -> JsClassMemberList { support::list(&self.syntax, 7usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 8usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsClassExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsClassExpressionFields {
    pub decorators: JsDecoratorList,
    pub class_token: SyntaxResult<SyntaxToken>,
    pub id: Option<AnyJsBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<JsExtendsClause>,
    pub implements_clause: Option<TsImplementsClause>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: JsClassMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl JsComputedMemberAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsComputedMemberAssignmentFields {
        JsComputedMemberAssignmentFields {
            object: self.object(),
            l_brack_token: self.l_brack_token(),
            member: self.member(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsComputedMemberAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsComputedMemberAssignmentFields {
    pub object: SyntaxResult<AnyJsExpression>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<AnyJsExpression>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsComputedMemberExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsComputedMemberExpressionFields {
        JsComputedMemberExpressionFields {
            object: self.object(),
            optional_chain_token: self.optional_chain_token(),
            l_brack_token: self.l_brack_token(),
            member: self.member(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_chain_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn member(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsComputedMemberExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsComputedMemberExpressionFields {
    pub object: SyntaxResult<AnyJsExpression>,
    pub optional_chain_token: Option<SyntaxToken>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<AnyJsExpression>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsComputedMemberName {
    pub(crate) syntax: SyntaxNode,
}
impl JsComputedMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsComputedMemberNameFields {
        JsComputedMemberNameFields {
            l_brack_token: self.l_brack_token(),
            expression: self.expression(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsComputedMemberName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsComputedMemberNameFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConditionalExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsConditionalExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsConditionalExpressionFields {
        JsConditionalExpressionFields {
            test: self.test(),
            question_mark_token: self.question_mark_token(),
            consequent: self.consequent(),
            colon_token: self.colon_token(),
            alternate: self.alternate(),
        }
    }
    pub fn test(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn consequent(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn alternate(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsConditionalExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsConditionalExpressionFields {
    pub test: SyntaxResult<AnyJsExpression>,
    pub question_mark_token: SyntaxResult<SyntaxToken>,
    pub consequent: SyntaxResult<AnyJsExpression>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub alternate: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConstructorClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsConstructorClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsConstructorClassMemberFields {
        JsConstructorClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            parameters: self.parameters(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsConstructorModifierList { support::list(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsLiteralMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsConstructorParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsConstructorClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsConstructorClassMemberFields {
    pub modifiers: JsConstructorModifierList,
    pub name: SyntaxResult<JsLiteralMemberName>,
    pub parameters: SyntaxResult<JsConstructorParameters>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsConstructorParameters {
    pub(crate) syntax: SyntaxNode,
}
impl JsConstructorParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsConstructorParametersFields {
        JsConstructorParametersFields {
            l_paren_token: self.l_paren_token(),
            parameters: self.parameters(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> JsConstructorParameterList { support::list(&self.syntax, 1usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsConstructorParameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsConstructorParametersFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameters: JsConstructorParameterList,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsContinueStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsContinueStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsContinueStatementFields {
        JsContinueStatementFields {
            continue_token: self.continue_token(),
            label_token: self.label_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn continue_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn label_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsContinueStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsContinueStatementFields {
    pub continue_token: SyntaxResult<SyntaxToken>,
    pub label_token: Option<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDebuggerStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsDebuggerStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDebuggerStatementFields {
        JsDebuggerStatementFields {
            debugger_token: self.debugger_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn debugger_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsDebuggerStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsDebuggerStatementFields {
    pub debugger_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDecorator {
    pub(crate) syntax: SyntaxNode,
}
impl JsDecorator {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDecoratorFields {
        JsDecoratorFields {
            at_token: self.at_token(),
            expression: self.expression(),
        }
    }
    pub fn at_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsDecorator> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsDecorator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsDecoratorFields {
    pub at_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsDecorator>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDefaultClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsDefaultClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDefaultClauseFields {
        JsDefaultClauseFields {
            default_token: self.default_token(),
            colon_token: self.colon_token(),
            consequent: self.consequent(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn consequent(&self) -> JsStatementList { support::list(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsDefaultClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsDefaultClauseFields {
    pub default_token: SyntaxResult<SyntaxToken>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub consequent: JsStatementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDefaultImportSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsDefaultImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDefaultImportSpecifierFields {
        JsDefaultImportSpecifierFields {
            local_name: self.local_name(),
            trailing_comma_token: self.trailing_comma_token(),
        }
    }
    pub fn local_name(&self) -> SyntaxResult<AnyJsBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn trailing_comma_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsDefaultImportSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsDefaultImportSpecifierFields {
    pub local_name: SyntaxResult<AnyJsBinding>,
    pub trailing_comma_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDirective {
    pub(crate) syntax: SyntaxNode,
}
impl JsDirective {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDirectiveFields {
        JsDirectiveFields {
            value_token: self.value_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsDirective {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsDirectiveFields {
    pub value_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsDoWhileStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsDoWhileStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsDoWhileStatementFields {
        JsDoWhileStatementFields {
            do_token: self.do_token(),
            body: self.body(),
            while_token: self.while_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn do_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn while_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn test(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsDoWhileStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsDoWhileStatementFields {
    pub do_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<AnyJsStatement>,
    pub while_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub test: SyntaxResult<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsElseClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsElseClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsElseClauseFields {
        JsElseClauseFields {
            else_token: self.else_token(),
            alternate: self.alternate(),
        }
    }
    pub fn else_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn alternate(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsElseClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsElseClauseFields {
    pub else_token: SyntaxResult<SyntaxToken>,
    pub alternate: SyntaxResult<AnyJsStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsEmptyClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsEmptyClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsEmptyClassMemberFields {
        JsEmptyClassMemberFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsEmptyClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsEmptyClassMemberFields {
    pub semicolon_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsEmptyStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsEmptyStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsEmptyStatementFields {
        JsEmptyStatementFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsEmptyStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsEmptyStatementFields {
    pub semicolon_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExport {
    pub(crate) syntax: SyntaxNode,
}
impl JsExport {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportFields {
        JsExportFields {
            decorators: self.decorators(),
            export_token: self.export_token(),
            export_clause: self.export_clause(),
        }
    }
    pub fn decorators(&self) -> JsDecoratorList { support::list(&self.syntax, 0usize) }
    pub fn export_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn export_clause(&self) -> SyntaxResult<AnyJsExportClause> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportFields {
    pub decorators: JsDecoratorList,
    pub export_token: SyntaxResult<SyntaxToken>,
    pub export_clause: SyntaxResult<AnyJsExportClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportAsClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportAsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportAsClauseFields {
        JsExportAsClauseFields {
            as_token: self.as_token(),
            exported_name: self.exported_name(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn exported_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportAsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportAsClauseFields {
    pub as_token: SyntaxResult<SyntaxToken>,
    pub exported_name: SyntaxResult<JsLiteralExportName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportDefaultDeclarationClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportDefaultDeclarationClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportDefaultDeclarationClauseFields {
        JsExportDefaultDeclarationClauseFields {
            default_token: self.default_token(),
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<AnyJsExportDefaultDeclaration> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportDefaultDeclarationClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportDefaultDeclarationClauseFields {
    pub default_token: SyntaxResult<SyntaxToken>,
    pub declaration: SyntaxResult<AnyJsExportDefaultDeclaration>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportDefaultExpressionClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportDefaultExpressionClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportDefaultExpressionClauseFields {
        JsExportDefaultExpressionClauseFields {
            default_token: self.default_token(),
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn default_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportDefaultExpressionClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportDefaultExpressionClauseFields {
    pub default_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportFromClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportFromClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportFromClauseFields {
        JsExportFromClauseFields {
            type_token: self.type_token(),
            star_token: self.star_token(),
            export_as: self.export_as(),
            from_token: self.from_token(),
            source: self.source(),
            attribute: self.attribute(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn export_as(&self) -> Option<JsExportAsClause> { support::node(&self.syntax, 2usize) }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn attribute(&self) -> Option<JsImportAttribute> { support::node(&self.syntax, 5usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportFromClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportFromClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub star_token: SyntaxResult<SyntaxToken>,
    pub export_as: Option<JsExportAsClause>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub attribute: Option<JsImportAttribute>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedClauseFields {
        JsExportNamedClauseFields {
            type_token: self.type_token(),
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn specifiers(&self) -> JsExportNamedSpecifierList { support::list(&self.syntax, 2usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportNamedClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub specifiers: JsExportNamedSpecifierList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedFromClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedFromClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedFromClauseFields {
        JsExportNamedFromClauseFields {
            type_token: self.type_token(),
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
            from_token: self.from_token(),
            source: self.source(),
            attribute: self.attribute(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn specifiers(&self) -> JsExportNamedFromSpecifierList {
        support::list(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn attribute(&self) -> Option<JsImportAttribute> { support::node(&self.syntax, 6usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 7usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedFromClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportNamedFromClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub specifiers: JsExportNamedFromSpecifierList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub attribute: Option<JsImportAttribute>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedFromSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedFromSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedFromSpecifierFields {
        JsExportNamedFromSpecifierFields {
            type_token: self.type_token(),
            source_name: self.source_name(),
            export_as: self.export_as(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn source_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn export_as(&self) -> Option<JsExportAsClause> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedFromSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportNamedFromSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub source_name: SyntaxResult<JsLiteralExportName>,
    pub export_as: Option<JsExportAsClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedShorthandSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedShorthandSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedShorthandSpecifierFields {
        JsExportNamedShorthandSpecifierFields {
            type_token: self.type_token(),
            name: self.name(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedShorthandSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportNamedShorthandSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExportNamedSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsExportNamedSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExportNamedSpecifierFields {
        JsExportNamedSpecifierFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
            as_token: self.as_token(),
            exported_name: self.exported_name(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn local_name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn exported_name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExportNamedSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub local_name: SyntaxResult<JsReferenceIdentifier>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub exported_name: SyntaxResult<JsLiteralExportName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExpressionSnipped {
    pub(crate) syntax: SyntaxNode,
}
impl JsExpressionSnipped {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExpressionSnippedFields {
        JsExpressionSnippedFields {
            expression: self.expression(),
            eof_token: self.eof_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn eof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsExpressionSnipped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExpressionSnippedFields {
    pub expression: SyntaxResult<AnyJsExpression>,
    pub eof_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExpressionStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsExpressionStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExpressionStatementFields {
        JsExpressionStatementFields {
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExpressionStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExpressionStatementFields {
    pub expression: SyntaxResult<AnyJsExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsExtendsClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsExtendsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsExtendsClauseFields {
        JsExtendsClauseFields {
            extends_token: self.extends_token(),
            super_class: self.super_class(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn super_class(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsExtendsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsExtendsClauseFields {
    pub extends_token: SyntaxResult<SyntaxToken>,
    pub super_class: SyntaxResult<AnyJsExpression>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFinallyClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsFinallyClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFinallyClauseFields {
        JsFinallyClauseFields {
            finally_token: self.finally_token(),
            body: self.body(),
        }
    }
    pub fn finally_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFinallyClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsFinallyClauseFields {
    pub finally_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForInStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsForInStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsForInStatementFields {
        JsForInStatementFields {
            for_token: self.for_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            in_token: self.in_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> SyntaxResult<AnyJsForInOrOfInitializer> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn in_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsForInStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsForInStatementFields {
    pub for_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub initializer: SyntaxResult<AnyJsForInOrOfInitializer>,
    pub in_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<AnyJsStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForOfStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsForOfStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsForOfStatementFields {
        JsForOfStatementFields {
            for_token: self.for_token(),
            await_token: self.await_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            of_token: self.of_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn initializer(&self) -> SyntaxResult<AnyJsForInOrOfInitializer> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn of_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsForOfStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsForOfStatementFields {
    pub for_token: SyntaxResult<SyntaxToken>,
    pub await_token: Option<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub initializer: SyntaxResult<AnyJsForInOrOfInitializer>,
    pub of_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<AnyJsStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsForStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsForStatementFields {
        JsForStatementFields {
            for_token: self.for_token(),
            l_paren_token: self.l_paren_token(),
            initializer: self.initializer(),
            first_semi_token: self.first_semi_token(),
            test: self.test(),
            second_semi_token: self.second_semi_token(),
            update: self.update(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn for_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> Option<AnyJsForInitializer> { support::node(&self.syntax, 2usize) }
    pub fn first_semi_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn test(&self) -> Option<AnyJsExpression> { support::node(&self.syntax, 4usize) }
    pub fn second_semi_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn update(&self) -> Option<AnyJsExpression> { support::node(&self.syntax, 6usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
    pub fn body(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 8usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsForStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsForStatementFields {
    pub for_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub initializer: Option<AnyJsForInitializer>,
    pub first_semi_token: SyntaxResult<SyntaxToken>,
    pub test: Option<AnyJsExpression>,
    pub second_semi_token: SyntaxResult<SyntaxToken>,
    pub update: Option<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<AnyJsStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsForVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsForVariableDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsForVariableDeclarationFields {
        JsForVariableDeclarationFields {
            kind_token: self.kind_token(),
            declarator: self.declarator(),
        }
    }
    pub fn kind_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declarator(&self) -> SyntaxResult<JsVariableDeclarator> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsForVariableDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsForVariableDeclarationFields {
    pub kind_token: SyntaxResult<SyntaxToken>,
    pub declarator: SyntaxResult<JsVariableDeclarator>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFormalParameter {
    pub(crate) syntax: SyntaxNode,
}
impl JsFormalParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFormalParameterFields {
        JsFormalParameterFields {
            binding: self.binding(),
            question_mark_token: self.question_mark_token(),
            type_annotation: self.type_annotation(),
            initializer: self.initializer(),
        }
    }
    pub fn binding(&self) -> SyntaxResult<AnyJsBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsFormalParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsFormalParameterFields {
    pub binding: SyntaxResult<AnyJsBindingPattern>,
    pub question_mark_token: Option<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionBody {
    pub(crate) syntax: SyntaxNode,
}
impl JsFunctionBody {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFunctionBodyFields {
        JsFunctionBodyFields {
            l_curly_token: self.l_curly_token(),
            directives: self.directives(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn directives(&self) -> JsDirectiveList { support::list(&self.syntax, 1usize) }
    pub fn statements(&self) -> JsStatementList { support::list(&self.syntax, 2usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFunctionBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsFunctionBodyFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub directives: JsDirectiveList,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsFunctionDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFunctionDeclarationFields {
        JsFunctionDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn id(&self) -> SyntaxResult<AnyJsBinding> { support::required_node(&self.syntax, 3usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFunctionDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsFunctionDeclarationFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub id: SyntaxResult<AnyJsBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionExportDefaultDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsFunctionExportDefaultDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFunctionExportDefaultDeclarationFields {
        JsFunctionExportDefaultDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn id(&self) -> Option<AnyJsBinding> { support::node(&self.syntax, 3usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFunctionExportDefaultDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsFunctionExportDefaultDeclarationFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub id: Option<AnyJsBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsFunctionExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsFunctionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsFunctionExpressionFields {
        JsFunctionExpressionFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            star_token: self.star_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn id(&self) -> Option<AnyJsBinding> { support::node(&self.syntax, 3usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 7usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsFunctionExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsFunctionExpressionFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub id: Option<AnyJsBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsGetterClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsGetterClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsGetterClassMemberFields {
        JsGetterClassMemberFields {
            modifiers: self.modifiers(),
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList { support::list(&self.syntax, 0usize) }
    pub fn get_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> { support::node(&self.syntax, 5usize) }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsGetterClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsGetterClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub get_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsGetterObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsGetterObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsGetterObjectMemberFields {
        JsGetterObjectMemberFields {
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            body: self.body(),
        }
    }
    pub fn get_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> { support::node(&self.syntax, 4usize) }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsGetterObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsGetterObjectMemberFields {
    pub get_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl JsIdentifierAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsIdentifierAssignmentFields {
        JsIdentifierAssignmentFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsIdentifierAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsIdentifierAssignmentFields {
    pub name_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierBinding {
    pub(crate) syntax: SyntaxNode,
}
impl JsIdentifierBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsIdentifierBindingFields {
        JsIdentifierBindingFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsIdentifierBinding {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsIdentifierBindingFields {
    pub name_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIdentifierExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsIdentifierExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsIdentifierExpressionFields {
        JsIdentifierExpressionFields { name: self.name() }
    }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsIdentifierExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsIdentifierExpressionFields {
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsIfStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsIfStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsIfStatementFields {
        JsIfStatementFields {
            if_token: self.if_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            consequent: self.consequent(),
            else_clause: self.else_clause(),
        }
    }
    pub fn if_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn test(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn consequent(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn else_clause(&self) -> Option<JsElseClause> { support::node(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsIfStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsIfStatementFields {
    pub if_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub test: SyntaxResult<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub consequent: SyntaxResult<AnyJsStatement>,
    pub else_clause: Option<JsElseClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImport {
    pub(crate) syntax: SyntaxNode,
}
impl JsImport {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportFields {
        JsImportFields {
            import_token: self.import_token(),
            import_clause: self.import_clause(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn import_clause(&self) -> SyntaxResult<AnyJsImportClause> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImport {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportFields {
    pub import_token: SyntaxResult<SyntaxToken>,
    pub import_clause: SyntaxResult<AnyJsImportClause>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportAttribute {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportAttributeFields {
        JsImportAttributeFields {
            with_token: self.with_token(),
            l_curly_token: self.l_curly_token(),
            attributes: self.attributes(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn with_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn attributes(&self) -> JsImportAttributeEntryList { support::list(&self.syntax, 2usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportAttribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportAttributeFields {
    pub with_token: SyntaxResult<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub attributes: JsImportAttributeEntryList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportAttributeEntry {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportAttributeEntry {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportAttributeEntryFields {
        JsImportAttributeEntryFields {
            key: self.key(),
            colon_token: self.colon_token(),
            value_token: self.value_token(),
        }
    }
    pub fn key(&self) -> SyntaxResult<SyntaxToken> { support::required_token(&self.syntax, 0usize) }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportAttributeEntry {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportAttributeEntryFields {
    pub key: SyntaxResult<SyntaxToken>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportBareClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportBareClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportBareClauseFields {
        JsImportBareClauseFields {
            source: self.source(),
            attribute: self.attribute(),
        }
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn attribute(&self) -> Option<JsImportAttribute> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportBareClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportBareClauseFields {
    pub source: SyntaxResult<JsModuleSource>,
    pub attribute: Option<JsImportAttribute>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportCallExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportCallExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportCallExpressionFields {
        JsImportCallExpressionFields {
            import_token: self.import_token(),
            arguments: self.arguments(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn arguments(&self) -> SyntaxResult<JsCallArguments> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportCallExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportCallExpressionFields {
    pub import_token: SyntaxResult<SyntaxToken>,
    pub arguments: SyntaxResult<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportDefaultClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportDefaultClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportDefaultClauseFields {
        JsImportDefaultClauseFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
            from_token: self.from_token(),
            source: self.source(),
            attribute: self.attribute(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn local_name(&self) -> SyntaxResult<AnyJsBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn attribute(&self) -> Option<JsImportAttribute> { support::node(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportDefaultClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportDefaultClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub local_name: SyntaxResult<AnyJsBinding>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub attribute: Option<JsImportAttribute>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportMetaExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportMetaExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportMetaExpressionFields {
        JsImportMetaExpressionFields {
            import_token: self.import_token(),
            dot_token: self.dot_token(),
            meta_token: self.meta_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn meta_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportMetaExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportMetaExpressionFields {
    pub import_token: SyntaxResult<SyntaxToken>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub meta_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportNamedClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportNamedClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportNamedClauseFields {
        JsImportNamedClauseFields {
            type_token: self.type_token(),
            default_specifier: self.default_specifier(),
            named_import: self.named_import(),
            from_token: self.from_token(),
            source: self.source(),
            attribute: self.attribute(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn default_specifier(&self) -> Option<JsDefaultImportSpecifier> {
        support::node(&self.syntax, 1usize)
    }
    pub fn named_import(&self) -> SyntaxResult<AnyJsNamedImport> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn attribute(&self) -> Option<JsImportAttribute> { support::node(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportNamedClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportNamedClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub default_specifier: Option<JsDefaultImportSpecifier>,
    pub named_import: SyntaxResult<AnyJsNamedImport>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub attribute: Option<JsImportAttribute>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsImportNamespaceClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsImportNamespaceClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsImportNamespaceClauseFields {
        JsImportNamespaceClauseFields {
            type_token: self.type_token(),
            star_token: self.star_token(),
            as_token: self.as_token(),
            local_name: self.local_name(),
            from_token: self.from_token(),
            source: self.source(),
            attribute: self.attribute(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn local_name(&self) -> SyntaxResult<AnyJsBinding> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn from_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn attribute(&self) -> Option<JsImportAttribute> { support::node(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportNamespaceClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsImportNamespaceClauseFields {
    pub type_token: Option<SyntaxToken>,
    pub star_token: SyntaxResult<SyntaxToken>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub local_name: SyntaxResult<AnyJsBinding>,
    pub from_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub attribute: Option<JsImportAttribute>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsInExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsInExpressionFields {
        JsInExpressionFields {
            property: self.property(),
            in_token: self.in_token(),
            object: self.object(),
        }
    }
    pub fn property(&self) -> SyntaxResult<AnyJsInProperty> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn in_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn object(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsInExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsInExpressionFields {
    pub property: SyntaxResult<AnyJsInProperty>,
    pub in_token: SyntaxResult<SyntaxToken>,
    pub object: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInitializerClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsInitializerClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsInitializerClauseFields {
        JsInitializerClauseFields {
            eq_token: self.eq_token(),
            expression: self.expression(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsInitializerClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsInitializerClauseFields {
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsInstanceofExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsInstanceofExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsInstanceofExpressionFields {
        JsInstanceofExpressionFields {
            left: self.left(),
            instanceof_token: self.instanceof_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn instanceof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsInstanceofExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsInstanceofExpressionFields {
    pub left: SyntaxResult<AnyJsExpression>,
    pub instanceof_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLabeledStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsLabeledStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsLabeledStatementFields {
        JsLabeledStatementFields {
            label_token: self.label_token(),
            colon_token: self.colon_token(),
            body: self.body(),
        }
    }
    pub fn label_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn body(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsLabeledStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsLabeledStatementFields {
    pub label_token: SyntaxResult<SyntaxToken>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<AnyJsStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLiteralExportName {
    pub(crate) syntax: SyntaxNode,
}
impl JsLiteralExportName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsLiteralExportNameFields {
        JsLiteralExportNameFields {
            value: self.value(),
        }
    }
    pub fn value(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsLiteralExportName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsLiteralExportNameFields {
    pub value: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLiteralMemberName {
    pub(crate) syntax: SyntaxNode,
}
impl JsLiteralMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsLiteralMemberNameFields {
        JsLiteralMemberNameFields {
            value: self.value(),
        }
    }
    pub fn value(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsLiteralMemberName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsLiteralMemberNameFields {
    pub value: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsLogicalExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsLogicalExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsLogicalExpressionFields {
        JsLogicalExpressionFields {
            left: self.left(),
            operator_token: self.operator_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsLogicalExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsLogicalExpressionFields {
    pub left: SyntaxResult<AnyJsExpression>,
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsMethodClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsMethodClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsMethodClassMemberFields {
        JsMethodClassMemberFields {
            modifiers: self.modifiers(),
            async_token: self.async_token(),
            star_token: self.star_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList { support::list(&self.syntax, 0usize) }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 4usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 5usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 6usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 7usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 8usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsMethodClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsMethodClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub async_token: Option<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub question_mark_token: Option<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsMethodObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsMethodObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsMethodObjectMemberFields {
        JsMethodObjectMemberFields {
            async_token: self.async_token(),
            star_token: self.star_token(),
            name: self.name(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            body: self.body(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsMethodObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsMethodObjectMemberFields {
    pub async_token: Option<SyntaxToken>,
    pub star_token: Option<SyntaxToken>,
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsModule {
    pub(crate) syntax: SyntaxNode,
}
impl JsModule {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsModuleFields {
        JsModuleFields {
            interpreter_token: self.interpreter_token(),
            directives: self.directives(),
            items: self.items(),
            eof_token: self.eof_token(),
        }
    }
    pub fn interpreter_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn directives(&self) -> JsDirectiveList { support::list(&self.syntax, 1usize) }
    pub fn items(&self) -> JsModuleItemList { support::list(&self.syntax, 2usize) }
    pub fn eof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsModule {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsModuleFields {
    pub interpreter_token: Option<SyntaxToken>,
    pub directives: JsDirectiveList,
    pub items: JsModuleItemList,
    pub eof_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsModuleSource {
    pub(crate) syntax: SyntaxNode,
}
impl JsModuleSource {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsModuleSourceFields {
        JsModuleSourceFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsModuleSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsModuleSourceFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsName {
    pub(crate) syntax: SyntaxNode,
}
impl JsName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNameFields {
        JsNameFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsNameFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamedImportSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNamedImportSpecifierFields {
        JsNamedImportSpecifierFields {
            type_token: self.type_token(),
            name: self.name(),
            as_token: self.as_token(),
            local_name: self.local_name(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsLiteralExportName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn local_name(&self) -> SyntaxResult<AnyJsBinding> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNamedImportSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsNamedImportSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsLiteralExportName>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub local_name: SyntaxResult<AnyJsBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamedImportSpecifiers {
    pub(crate) syntax: SyntaxNode,
}
impl JsNamedImportSpecifiers {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNamedImportSpecifiersFields {
        JsNamedImportSpecifiersFields {
            l_curly_token: self.l_curly_token(),
            specifiers: self.specifiers(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn specifiers(&self) -> JsNamedImportSpecifierList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNamedImportSpecifiers {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsNamedImportSpecifiersFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub specifiers: JsNamedImportSpecifierList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNamespaceImportSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsNamespaceImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNamespaceImportSpecifierFields {
        JsNamespaceImportSpecifierFields {
            star_token: self.star_token(),
            as_token: self.as_token(),
            local_name: self.local_name(),
        }
    }
    pub fn star_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn local_name(&self) -> SyntaxResult<AnyJsBinding> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNamespaceImportSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsNamespaceImportSpecifierFields {
    pub star_token: SyntaxResult<SyntaxToken>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub local_name: SyntaxResult<AnyJsBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNewExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsNewExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNewExpressionFields {
        JsNewExpressionFields {
            new_token: self.new_token(),
            callee: self.callee(),
            type_arguments: self.type_arguments(),
            arguments: self.arguments(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn callee(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
    pub fn arguments(&self) -> Option<JsCallArguments> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsNewExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsNewExpressionFields {
    pub new_token: SyntaxResult<SyntaxToken>,
    pub callee: SyntaxResult<AnyJsExpression>,
    pub type_arguments: Option<TsTypeArguments>,
    pub arguments: Option<JsCallArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNewTargetExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsNewTargetExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNewTargetExpressionFields {
        JsNewTargetExpressionFields {
            new_token: self.new_token(),
            dot_token: self.dot_token(),
            target_token: self.target_token(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn target_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNewTargetExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsNewTargetExpressionFields {
    pub new_token: SyntaxResult<SyntaxToken>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub target_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNullLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsNullLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNullLiteralExpressionFields {
        JsNullLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNullLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsNullLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsNumberLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsNumberLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsNumberLiteralExpressionFields {
        JsNumberLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsNumberLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsNumberLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPattern {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectAssignmentPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternFields {
        JsObjectAssignmentPatternFields {
            l_curly_token: self.l_curly_token(),
            properties: self.properties(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn properties(&self) -> JsObjectAssignmentPatternPropertyList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPattern {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectAssignmentPatternFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub properties: JsObjectAssignmentPatternPropertyList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternProperty {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectAssignmentPatternProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternPropertyFields {
        JsObjectAssignmentPatternPropertyFields {
            member: self.member(),
            colon_token: self.colon_token(),
            pattern: self.pattern(),
            init: self.init(),
        }
    }
    pub fn member(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn pattern(&self) -> SyntaxResult<AnyJsAssignmentPattern> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPatternProperty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectAssignmentPatternPropertyFields {
    pub member: SyntaxResult<AnyJsObjectMemberName>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub pattern: SyntaxResult<AnyJsAssignmentPattern>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternRest {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectAssignmentPatternRest {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternRestFields {
        JsObjectAssignmentPatternRestFields {
            dotdotdot_token: self.dotdotdot_token(),
            target: self.target(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn target(&self) -> SyntaxResult<AnyJsAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPatternRest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectAssignmentPatternRestFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub target: SyntaxResult<AnyJsAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectAssignmentPatternShorthandProperty {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectAssignmentPatternShorthandProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectAssignmentPatternShorthandPropertyFields {
        JsObjectAssignmentPatternShorthandPropertyFields {
            identifier: self.identifier(),
            init: self.init(),
        }
    }
    pub fn identifier(&self) -> SyntaxResult<JsIdentifierAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPatternShorthandProperty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectAssignmentPatternShorthandPropertyFields {
    pub identifier: SyntaxResult<JsIdentifierAssignment>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPattern {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectBindingPattern {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectBindingPatternFields {
        JsObjectBindingPatternFields {
            l_curly_token: self.l_curly_token(),
            properties: self.properties(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn properties(&self) -> JsObjectBindingPatternPropertyList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPattern {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectBindingPatternFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub properties: JsObjectBindingPatternPropertyList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternProperty {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectBindingPatternProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectBindingPatternPropertyFields {
        JsObjectBindingPatternPropertyFields {
            member: self.member(),
            colon_token: self.colon_token(),
            pattern: self.pattern(),
            init: self.init(),
        }
    }
    pub fn member(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn pattern(&self) -> SyntaxResult<AnyJsBindingPattern> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPatternProperty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectBindingPatternPropertyFields {
    pub member: SyntaxResult<AnyJsObjectMemberName>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub pattern: SyntaxResult<AnyJsBindingPattern>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternRest {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectBindingPatternRest {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectBindingPatternRestFields {
        JsObjectBindingPatternRestFields {
            dotdotdot_token: self.dotdotdot_token(),
            binding: self.binding(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<AnyJsBinding> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPatternRest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectBindingPatternRestFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub binding: SyntaxResult<AnyJsBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectBindingPatternShorthandProperty {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectBindingPatternShorthandProperty {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectBindingPatternShorthandPropertyFields {
        JsObjectBindingPatternShorthandPropertyFields {
            identifier: self.identifier(),
            init: self.init(),
        }
    }
    pub fn identifier(&self) -> SyntaxResult<AnyJsBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn init(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPatternShorthandProperty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectBindingPatternShorthandPropertyFields {
    pub identifier: SyntaxResult<AnyJsBinding>,
    pub init: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsObjectExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsObjectExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsObjectExpressionFields {
        JsObjectExpressionFields {
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn members(&self) -> JsObjectMemberList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsObjectExpressionFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: JsObjectMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParameters {
    pub(crate) syntax: SyntaxNode,
}
impl JsParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsParametersFields {
        JsParametersFields {
            l_paren_token: self.l_paren_token(),
            items: self.items(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> JsParameterList { support::list(&self.syntax, 1usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsParameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsParametersFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub items: JsParameterList,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParenthesizedAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl JsParenthesizedAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsParenthesizedAssignmentFields {
        JsParenthesizedAssignmentFields {
            l_paren_token: self.l_paren_token(),
            assignment: self.assignment(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn assignment(&self) -> SyntaxResult<AnyJsAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsParenthesizedAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsParenthesizedAssignmentFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub assignment: SyntaxResult<AnyJsAssignment>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsParenthesizedExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsParenthesizedExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsParenthesizedExpressionFields {
        JsParenthesizedExpressionFields {
            l_paren_token: self.l_paren_token(),
            expression: self.expression(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsParenthesizedExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsParenthesizedExpressionFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPostUpdateExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsPostUpdateExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPostUpdateExpressionFields {
        JsPostUpdateExpressionFields {
            operand: self.operand(),
            operator_token: self.operator_token(),
        }
    }
    pub fn operand(&self) -> SyntaxResult<AnyJsAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPostUpdateExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsPostUpdateExpressionFields {
    pub operand: SyntaxResult<AnyJsAssignment>,
    pub operator_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPreUpdateExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsPreUpdateExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPreUpdateExpressionFields {
        JsPreUpdateExpressionFields {
            operator_token: self.operator_token(),
            operand: self.operand(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn operand(&self) -> SyntaxResult<AnyJsAssignment> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPreUpdateExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsPreUpdateExpressionFields {
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub operand: SyntaxResult<AnyJsAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPrivateClassMemberName {
    pub(crate) syntax: SyntaxNode,
}
impl JsPrivateClassMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPrivateClassMemberNameFields {
        JsPrivateClassMemberNameFields {
            hash_token: self.hash_token(),
            id_token: self.id_token(),
        }
    }
    pub fn hash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn id_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPrivateClassMemberName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsPrivateClassMemberNameFields {
    pub hash_token: SyntaxResult<SyntaxToken>,
    pub id_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPrivateName {
    pub(crate) syntax: SyntaxNode,
}
impl JsPrivateName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPrivateNameFields {
        JsPrivateNameFields {
            hash_token: self.hash_token(),
            value_token: self.value_token(),
        }
    }
    pub fn hash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPrivateName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsPrivateNameFields {
    pub hash_token: SyntaxResult<SyntaxToken>,
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPropertyClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsPropertyClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPropertyClassMemberFields {
        JsPropertyClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            property_annotation: self.property_annotation(),
            value: self.value(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> JsPropertyModifierList { support::list(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn property_annotation(&self) -> Option<AnyTsPropertyAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn value(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 3usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsPropertyClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsPropertyClassMemberFields {
    pub modifiers: JsPropertyModifierList,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub property_annotation: Option<AnyTsPropertyAnnotation>,
    pub value: Option<JsInitializerClause>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsPropertyObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsPropertyObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsPropertyObjectMemberFields {
        JsPropertyObjectMemberFields {
            name: self.name(),
            colon_token: self.colon_token(),
            value: self.value(),
        }
    }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn value(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsPropertyObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsPropertyObjectMemberFields {
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub value: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsReferenceIdentifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsReferenceIdentifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsReferenceIdentifierFields {
        JsReferenceIdentifierFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsReferenceIdentifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsReferenceIdentifierFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsRegexLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsRegexLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsRegexLiteralExpressionFields {
        JsRegexLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsRegexLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsRegexLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsRestParameter {
    pub(crate) syntax: SyntaxNode,
}
impl JsRestParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsRestParameterFields {
        JsRestParameterFields {
            dotdotdot_token: self.dotdotdot_token(),
            binding: self.binding(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding(&self) -> SyntaxResult<AnyJsBindingPattern> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsRestParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsRestParameterFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub binding: SyntaxResult<AnyJsBindingPattern>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsReturnStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsReturnStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsReturnStatementFields {
        JsReturnStatementFields {
            return_token: self.return_token(),
            argument: self.argument(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn return_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> Option<AnyJsExpression> { support::node(&self.syntax, 1usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsReturnStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsReturnStatementFields {
    pub return_token: SyntaxResult<SyntaxToken>,
    pub argument: Option<AnyJsExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsScript {
    pub(crate) syntax: SyntaxNode,
}
impl JsScript {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsScriptFields {
        JsScriptFields {
            interpreter_token: self.interpreter_token(),
            directives: self.directives(),
            statements: self.statements(),
            eof_token: self.eof_token(),
        }
    }
    pub fn interpreter_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn directives(&self) -> JsDirectiveList { support::list(&self.syntax, 1usize) }
    pub fn statements(&self) -> JsStatementList { support::list(&self.syntax, 2usize) }
    pub fn eof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsScript {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsScriptFields {
    pub interpreter_token: Option<SyntaxToken>,
    pub directives: JsDirectiveList,
    pub statements: JsStatementList,
    pub eof_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSequenceExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsSequenceExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSequenceExpressionFields {
        JsSequenceExpressionFields {
            left: self.left(),
            comma_token: self.comma_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn comma_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSequenceExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsSequenceExpressionFields {
    pub left: SyntaxResult<AnyJsExpression>,
    pub comma_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSetterClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsSetterClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSetterClassMemberFields {
        JsSetterClassMemberFields {
            modifiers: self.modifiers(),
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn modifiers(&self) -> JsMethodModifierList { support::list(&self.syntax, 0usize) }
    pub fn set_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn parameter(&self) -> SyntaxResult<AnyJsFormalParameter> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSetterClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsSetterClassMemberFields {
    pub modifiers: JsMethodModifierList,
    pub set_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<AnyJsFormalParameter>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSetterObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsSetterObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSetterObjectMemberFields {
        JsSetterObjectMemberFields {
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn set_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn parameter(&self) -> SyntaxResult<AnyJsFormalParameter> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn body(&self) -> SyntaxResult<JsFunctionBody> {
        support::required_node(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSetterObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsSetterObjectMemberFields {
    pub set_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<AnyJsFormalParameter>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsFunctionBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsShorthandNamedImportSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsShorthandNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsShorthandNamedImportSpecifierFields {
        JsShorthandNamedImportSpecifierFields {
            type_token: self.type_token(),
            local_name: self.local_name(),
        }
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn local_name(&self) -> SyntaxResult<AnyJsBinding> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsShorthandNamedImportSpecifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsShorthandNamedImportSpecifierFields {
    pub type_token: Option<SyntaxToken>,
    pub local_name: SyntaxResult<AnyJsBinding>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsShorthandPropertyObjectMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsShorthandPropertyObjectMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsShorthandPropertyObjectMemberFields {
        JsShorthandPropertyObjectMemberFields { name: self.name() }
    }
    pub fn name(&self) -> SyntaxResult<JsReferenceIdentifier> {
        support::required_node(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsShorthandPropertyObjectMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsShorthandPropertyObjectMemberFields {
    pub name: SyntaxResult<JsReferenceIdentifier>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSpread {
    pub(crate) syntax: SyntaxNode,
}
impl JsSpread {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSpreadFields {
        JsSpreadFields {
            dotdotdot_token: self.dotdotdot_token(),
            argument: self.argument(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSpread {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsSpreadFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticInitializationBlockClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl JsStaticInitializationBlockClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStaticInitializationBlockClassMemberFields {
        JsStaticInitializationBlockClassMemberFields {
            static_token: self.static_token(),
            l_curly_token: self.l_curly_token(),
            statements: self.statements(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn static_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn statements(&self) -> JsStatementList { support::list(&self.syntax, 2usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsStaticInitializationBlockClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsStaticInitializationBlockClassMemberFields {
    pub static_token: SyntaxResult<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub statements: JsStatementList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticMemberAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl JsStaticMemberAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStaticMemberAssignmentFields {
        JsStaticMemberAssignmentFields {
            object: self.object(),
            dot_token: self.dot_token(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<AnyJsName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsStaticMemberAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsStaticMemberAssignmentFields {
    pub object: SyntaxResult<AnyJsExpression>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<AnyJsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticMemberExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsStaticMemberExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStaticMemberExpressionFields {
        JsStaticMemberExpressionFields {
            object: self.object(),
            operator_token: self.operator_token(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<AnyJsName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsStaticMemberExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsStaticMemberExpressionFields {
    pub object: SyntaxResult<AnyJsExpression>,
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<AnyJsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStaticModifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsStaticModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStaticModifierFields {
        JsStaticModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsStaticModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsStaticModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsStringLiteralExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsStringLiteralExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsStringLiteralExpressionFields {
        JsStringLiteralExpressionFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsStringLiteralExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsStringLiteralExpressionFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSuperExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsSuperExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSuperExpressionFields {
        JsSuperExpressionFields {
            super_token: self.super_token(),
        }
    }
    pub fn super_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSuperExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsSuperExpressionFields {
    pub super_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsSwitchStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsSwitchStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsSwitchStatementFields {
        JsSwitchStatementFields {
            switch_token: self.switch_token(),
            l_paren_token: self.l_paren_token(),
            discriminant: self.discriminant(),
            r_paren_token: self.r_paren_token(),
            l_curly_token: self.l_curly_token(),
            cases: self.cases(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn switch_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn discriminant(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn cases(&self) -> JsSwitchCaseList { support::list(&self.syntax, 5usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsSwitchStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsSwitchStatementFields {
    pub switch_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub discriminant: SyntaxResult<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub cases: JsSwitchCaseList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplateChunkElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsTemplateChunkElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTemplateChunkElementFields {
        JsTemplateChunkElementFields {
            template_chunk_token: self.template_chunk_token(),
        }
    }
    pub fn template_chunk_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTemplateChunkElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsTemplateChunkElementFields {
    pub template_chunk_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplateElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsTemplateElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTemplateElementFields {
        JsTemplateElementFields {
            dollar_curly_token: self.dollar_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn dollar_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTemplateElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsTemplateElementFields {
    pub dollar_curly_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTemplateExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsTemplateExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTemplateExpressionFields {
        JsTemplateExpressionFields {
            tag: self.tag(),
            type_arguments: self.type_arguments(),
            l_tick_token: self.l_tick_token(),
            elements: self.elements(),
            r_tick_token: self.r_tick_token(),
        }
    }
    pub fn tag(&self) -> Option<AnyJsExpression> { support::node(&self.syntax, 0usize) }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 1usize) }
    pub fn l_tick_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn elements(&self) -> JsTemplateElementList { support::list(&self.syntax, 3usize) }
    pub fn r_tick_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTemplateExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsTemplateExpressionFields {
    pub tag: Option<AnyJsExpression>,
    pub type_arguments: Option<TsTypeArguments>,
    pub l_tick_token: SyntaxResult<SyntaxToken>,
    pub elements: JsTemplateElementList,
    pub r_tick_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsThisExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsThisExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsThisExpressionFields {
        JsThisExpressionFields {
            this_token: self.this_token(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsThisExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsThisExpressionFields {
    pub this_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsThrowStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsThrowStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsThrowStatementFields {
        JsThrowStatementFields {
            throw_token: self.throw_token(),
            argument: self.argument(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn throw_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsThrowStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsThrowStatementFields {
    pub throw_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<AnyJsExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTryFinallyStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsTryFinallyStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTryFinallyStatementFields {
        JsTryFinallyStatementFields {
            try_token: self.try_token(),
            body: self.body(),
            catch_clause: self.catch_clause(),
            finally_clause: self.finally_clause(),
        }
    }
    pub fn try_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn catch_clause(&self) -> Option<JsCatchClause> { support::node(&self.syntax, 2usize) }
    pub fn finally_clause(&self) -> SyntaxResult<JsFinallyClause> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTryFinallyStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsTryFinallyStatementFields {
    pub try_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
    pub catch_clause: Option<JsCatchClause>,
    pub finally_clause: SyntaxResult<JsFinallyClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsTryStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsTryStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsTryStatementFields {
        JsTryStatementFields {
            try_token: self.try_token(),
            body: self.body(),
            catch_clause: self.catch_clause(),
        }
    }
    pub fn try_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<JsBlockStatement> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn catch_clause(&self) -> SyntaxResult<JsCatchClause> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsTryStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsTryStatementFields {
    pub try_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<JsBlockStatement>,
    pub catch_clause: SyntaxResult<JsCatchClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsUnaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsUnaryExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsUnaryExpressionFields {
        JsUnaryExpressionFields {
            operator_token: self.operator_token(),
            argument: self.argument(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsUnaryExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsUnaryExpressionFields {
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl JsVariableDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsVariableDeclarationFields {
        JsVariableDeclarationFields {
            kind: self.kind(),
            declarators: self.declarators(),
        }
    }
    pub fn kind(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declarators(&self) -> JsVariableDeclaratorList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsVariableDeclarationFields {
    pub kind: SyntaxResult<SyntaxToken>,
    pub declarators: JsVariableDeclaratorList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclarationClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsVariableDeclarationClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsVariableDeclarationClauseFields {
        JsVariableDeclarationClauseFields {
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn declaration(&self) -> SyntaxResult<JsVariableDeclaration> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableDeclarationClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsVariableDeclarationClauseFields {
    pub declaration: SyntaxResult<JsVariableDeclaration>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableDeclarator {
    pub(crate) syntax: SyntaxNode,
}
impl JsVariableDeclarator {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsVariableDeclaratorFields {
        JsVariableDeclaratorFields {
            id: self.id(),
            variable_annotation: self.variable_annotation(),
            initializer: self.initializer(),
        }
    }
    pub fn id(&self) -> SyntaxResult<AnyJsBindingPattern> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn variable_annotation(&self) -> Option<AnyTsVariableAnnotation> {
        support::node(&self.syntax, 1usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableDeclarator {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsVariableDeclaratorFields {
    pub id: SyntaxResult<AnyJsBindingPattern>,
    pub variable_annotation: Option<AnyTsVariableAnnotation>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsVariableStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsVariableStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsVariableStatementFields {
        JsVariableStatementFields {
            declaration: self.declaration(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn declaration(&self) -> SyntaxResult<JsVariableDeclaration> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsVariableStatementFields {
    pub declaration: SyntaxResult<JsVariableDeclaration>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsWhileStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsWhileStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsWhileStatementFields {
        JsWhileStatementFields {
            while_token: self.while_token(),
            l_paren_token: self.l_paren_token(),
            test: self.test(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn while_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn test(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn body(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsWhileStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsWhileStatementFields {
    pub while_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub test: SyntaxResult<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<AnyJsStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsWithStatement {
    pub(crate) syntax: SyntaxNode,
}
impl JsWithStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsWithStatementFields {
        JsWithStatementFields {
            with_token: self.with_token(),
            l_paren_token: self.l_paren_token(),
            object: self.object(),
            r_paren_token: self.r_paren_token(),
            body: self.body(),
        }
    }
    pub fn with_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn object(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn body(&self) -> SyntaxResult<AnyJsStatement> {
        support::required_node(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsWithStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsWithStatementFields {
    pub with_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub object: SyntaxResult<AnyJsExpression>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<AnyJsStatement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsYieldArgument {
    pub(crate) syntax: SyntaxNode,
}
impl JsYieldArgument {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsYieldArgumentFields {
        JsYieldArgumentFields {
            star_token: self.star_token(),
            expression: self.expression(),
        }
    }
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsYieldArgument {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsYieldArgumentFields {
    pub star_token: Option<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsYieldExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsYieldExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsYieldExpressionFields {
        JsYieldExpressionFields {
            yield_token: self.yield_token(),
            argument: self.argument(),
        }
    }
    pub fn yield_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn argument(&self) -> Option<JsYieldArgument> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsYieldExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsYieldExpressionFields {
    pub yield_token: SyntaxResult<SyntaxToken>,
    pub argument: Option<JsYieldArgument>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl JsxAttribute {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxAttributeFields {
        JsxAttributeFields {
            name: self.name(),
            initializer: self.initializer(),
        }
    }
    pub fn name(&self) -> SyntaxResult<AnyJsxAttributeName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn initializer(&self) -> Option<JsxAttributeInitializerClause> {
        support::node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxAttribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxAttributeFields {
    pub name: SyntaxResult<AnyJsxAttributeName>,
    pub initializer: Option<JsxAttributeInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxAttributeInitializerClause {
    pub(crate) syntax: SyntaxNode,
}
impl JsxAttributeInitializerClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxAttributeInitializerClauseFields {
        JsxAttributeInitializerClauseFields {
            eq_token: self.eq_token(),
            value: self.value(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn value(&self) -> SyntaxResult<AnyJsxAttributeValue> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxAttributeInitializerClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxAttributeInitializerClauseFields {
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub value: SyntaxResult<AnyJsxAttributeValue>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxClosingElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsxClosingElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxClosingElementFields {
        JsxClosingElementFields {
            l_angle_token: self.l_angle_token(),
            slash_token: self.slash_token(),
            name: self.name(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn slash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsxElementName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxClosingElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxClosingElementFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub slash_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsxElementName>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxClosingFragment {
    pub(crate) syntax: SyntaxNode,
}
impl JsxClosingFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxClosingFragmentFields {
        JsxClosingFragmentFields {
            l_angle_token: self.l_angle_token(),
            slash_token: self.slash_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn slash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxClosingFragment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxClosingFragmentFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub slash_token: SyntaxResult<SyntaxToken>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsxElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxElementFields {
        JsxElementFields {
            opening_element: self.opening_element(),
            children: self.children(),
            closing_element: self.closing_element(),
        }
    }
    pub fn opening_element(&self) -> SyntaxResult<JsxOpeningElement> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn children(&self) -> JsxChildList { support::list(&self.syntax, 1usize) }
    pub fn closing_element(&self) -> SyntaxResult<JsxClosingElement> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxElementFields {
    pub opening_element: SyntaxResult<JsxOpeningElement>,
    pub children: JsxChildList,
    pub closing_element: SyntaxResult<JsxClosingElement>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxExpressionAttributeValue {
    pub(crate) syntax: SyntaxNode,
}
impl JsxExpressionAttributeValue {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxExpressionAttributeValueFields {
        JsxExpressionAttributeValueFields {
            l_curly_token: self.l_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxExpressionAttributeValue {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxExpressionAttributeValueFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxExpressionChild {
    pub(crate) syntax: SyntaxNode,
}
impl JsxExpressionChild {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxExpressionChildFields {
        JsxExpressionChildFields {
            l_curly_token: self.l_curly_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> Option<AnyJsExpression> { support::node(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxExpressionChild {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxExpressionChildFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub expression: Option<AnyJsExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxFragment {
    pub(crate) syntax: SyntaxNode,
}
impl JsxFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxFragmentFields {
        JsxFragmentFields {
            opening_fragment: self.opening_fragment(),
            children: self.children(),
            closing_fragment: self.closing_fragment(),
        }
    }
    pub fn opening_fragment(&self) -> SyntaxResult<JsxOpeningFragment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn children(&self) -> JsxChildList { support::list(&self.syntax, 1usize) }
    pub fn closing_fragment(&self) -> SyntaxResult<JsxClosingFragment> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxFragment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxFragmentFields {
    pub opening_fragment: SyntaxResult<JsxOpeningFragment>,
    pub children: JsxChildList,
    pub closing_fragment: SyntaxResult<JsxClosingFragment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxMemberName {
    pub(crate) syntax: SyntaxNode,
}
impl JsxMemberName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxMemberNameFields {
        JsxMemberNameFields {
            object: self.object(),
            dot_token: self.dot_token(),
            member: self.member(),
        }
    }
    pub fn object(&self) -> SyntaxResult<AnyJsxObjectName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn member(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsxMemberName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxMemberNameFields {
    pub object: SyntaxResult<AnyJsxObjectName>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub member: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxName {
    pub(crate) syntax: SyntaxNode,
}
impl JsxName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxNameFields {
        JsxNameFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxNameFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxNamespaceName {
    pub(crate) syntax: SyntaxNode,
}
impl JsxNamespaceName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxNamespaceNameFields {
        JsxNamespaceNameFields {
            namespace: self.namespace(),
            colon_token: self.colon_token(),
            name: self.name(),
        }
    }
    pub fn namespace(&self) -> SyntaxResult<JsxName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsxName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsxNamespaceName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxNamespaceNameFields {
    pub namespace: SyntaxResult<JsxName>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsxName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxOpeningElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsxOpeningElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxOpeningElementFields {
        JsxOpeningElementFields {
            l_angle_token: self.l_angle_token(),
            name: self.name(),
            type_arguments: self.type_arguments(),
            attributes: self.attributes(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsxElementName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
    pub fn attributes(&self) -> JsxAttributeList { support::list(&self.syntax, 3usize) }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxOpeningElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxOpeningElementFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsxElementName>,
    pub type_arguments: Option<TsTypeArguments>,
    pub attributes: JsxAttributeList,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxOpeningFragment {
    pub(crate) syntax: SyntaxNode,
}
impl JsxOpeningFragment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxOpeningFragmentFields {
        JsxOpeningFragmentFields {
            l_angle_token: self.l_angle_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxOpeningFragment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxOpeningFragmentFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxReferenceIdentifier {
    pub(crate) syntax: SyntaxNode,
}
impl JsxReferenceIdentifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxReferenceIdentifierFields {
        JsxReferenceIdentifierFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxReferenceIdentifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxReferenceIdentifierFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSelfClosingElement {
    pub(crate) syntax: SyntaxNode,
}
impl JsxSelfClosingElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxSelfClosingElementFields {
        JsxSelfClosingElementFields {
            l_angle_token: self.l_angle_token(),
            name: self.name(),
            type_arguments: self.type_arguments(),
            attributes: self.attributes(),
            slash_token: self.slash_token(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsxElementName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
    pub fn attributes(&self) -> JsxAttributeList { support::list(&self.syntax, 3usize) }
    pub fn slash_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxSelfClosingElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxSelfClosingElementFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsxElementName>,
    pub type_arguments: Option<TsTypeArguments>,
    pub attributes: JsxAttributeList,
    pub slash_token: SyntaxResult<SyntaxToken>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSpreadAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl JsxSpreadAttribute {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxSpreadAttributeFields {
        JsxSpreadAttributeFields {
            l_curly_token: self.l_curly_token(),
            dotdotdot_token: self.dotdotdot_token(),
            argument: self.argument(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn argument(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxSpreadAttribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxSpreadAttributeFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub argument: SyntaxResult<AnyJsExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxSpreadChild {
    pub(crate) syntax: SyntaxNode,
}
impl JsxSpreadChild {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxSpreadChildFields {
        JsxSpreadChildFields {
            l_curly_token: self.l_curly_token(),
            dotdotdot_token: self.dotdotdot_token(),
            expression: self.expression(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxSpreadChild {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxSpreadChildFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxString {
    pub(crate) syntax: SyntaxNode,
}
impl JsxString {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxStringFields {
        JsxStringFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxString {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxStringFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxTagExpression {
    pub(crate) syntax: SyntaxNode,
}
impl JsxTagExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxTagExpressionFields { JsxTagExpressionFields { tag: self.tag() } }
    pub fn tag(&self) -> SyntaxResult<AnyJsxTag> { support::required_node(&self.syntax, 0usize) }
}
#[cfg(feature = "serde")]
impl Serialize for JsxTagExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxTagExpressionFields {
    pub tag: SyntaxResult<AnyJsxTag>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct JsxText {
    pub(crate) syntax: SyntaxNode,
}
impl JsxText {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> JsxTextFields {
        JsxTextFields {
            value_token: self.value_token(),
        }
    }
    pub fn value_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for JsxText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsxTextFields {
    pub value_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAbstractModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsAbstractModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAbstractModifierFields {
        TsAbstractModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsAbstractModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsAbstractModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAccessibilityModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsAccessibilityModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAccessibilityModifierFields {
        TsAccessibilityModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsAccessibilityModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsAccessibilityModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAnyType {
    pub(crate) syntax: SyntaxNode,
}
impl TsAnyType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAnyTypeFields {
        TsAnyTypeFields {
            any_token: self.any_token(),
        }
    }
    pub fn any_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsAnyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsAnyTypeFields {
    pub any_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsArrayType {
    pub(crate) syntax: SyntaxNode,
}
impl TsArrayType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsArrayTypeFields {
        TsArrayTypeFields {
            element_type: self.element_type(),
            l_brack_token: self.l_brack_token(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn element_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsArrayType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsArrayTypeFields {
    pub element_type: SyntaxResult<AnyTsType>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAsAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl TsAsAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAsAssignmentFields {
        TsAsAssignmentFields {
            assignment: self.assignment(),
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn assignment(&self) -> SyntaxResult<AnyJsAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsAsAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsAsAssignmentFields {
    pub assignment: SyntaxResult<AnyJsAssignment>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAsExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TsAsExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAsExpressionFields {
        TsAsExpressionFields {
            expression: self.expression(),
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsAsExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsAsExpressionFields {
    pub expression: SyntaxResult<AnyJsExpression>,
    pub as_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAssertsCondition {
    pub(crate) syntax: SyntaxNode,
}
impl TsAssertsCondition {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAssertsConditionFields {
        TsAssertsConditionFields {
            is_token: self.is_token(),
            ty: self.ty(),
        }
    }
    pub fn is_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsAssertsCondition {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsAssertsConditionFields {
    pub is_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsAssertsReturnType {
    pub(crate) syntax: SyntaxNode,
}
impl TsAssertsReturnType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsAssertsReturnTypeFields {
        TsAssertsReturnTypeFields {
            asserts_token: self.asserts_token(),
            parameter_name: self.parameter_name(),
            predicate: self.predicate(),
        }
    }
    pub fn asserts_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn parameter_name(&self) -> SyntaxResult<AnyTsTypePredicateParameterName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn predicate(&self) -> Option<TsAssertsCondition> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsAssertsReturnType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsAssertsReturnTypeFields {
    pub asserts_token: SyntaxResult<SyntaxToken>,
    pub parameter_name: SyntaxResult<AnyTsTypePredicateParameterName>,
    pub predicate: Option<TsAssertsCondition>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBigintLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsBigintLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsBigintLiteralTypeFields {
        TsBigintLiteralTypeFields {
            minus_token: self.minus_token(),
            literal_token: self.literal_token(),
        }
    }
    pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn literal_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsBigintLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsBigintLiteralTypeFields {
    pub minus_token: Option<SyntaxToken>,
    pub literal_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBigintType {
    pub(crate) syntax: SyntaxNode,
}
impl TsBigintType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsBigintTypeFields {
        TsBigintTypeFields {
            bigint_token: self.bigint_token(),
        }
    }
    pub fn bigint_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsBigintType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsBigintTypeFields {
    pub bigint_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBooleanLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsBooleanLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsBooleanLiteralTypeFields {
        TsBooleanLiteralTypeFields {
            literal: self.literal(),
        }
    }
    pub fn literal(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsBooleanLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsBooleanLiteralTypeFields {
    pub literal: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsBooleanType {
    pub(crate) syntax: SyntaxNode,
}
impl TsBooleanType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsBooleanTypeFields {
        TsBooleanTypeFields {
            boolean_token: self.boolean_token(),
        }
    }
    pub fn boolean_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsBooleanType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsBooleanTypeFields {
    pub boolean_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsCallSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsCallSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsCallSignatureTypeMemberFields {
        TsCallSignatureTypeMemberFields {
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsCallSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsCallSignatureTypeMemberFields {
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConditionalType {
    pub(crate) syntax: SyntaxNode,
}
impl TsConditionalType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConditionalTypeFields {
        TsConditionalTypeFields {
            check_type: self.check_type(),
            extends_token: self.extends_token(),
            extends_type: self.extends_type(),
            question_mark_token: self.question_mark_token(),
            true_type: self.true_type(),
            colon_token: self.colon_token(),
            false_type: self.false_type(),
        }
    }
    pub fn check_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn extends_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn extends_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn true_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn false_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsConditionalType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsConditionalTypeFields {
    pub check_type: SyntaxResult<AnyTsType>,
    pub extends_token: SyntaxResult<SyntaxToken>,
    pub extends_type: SyntaxResult<AnyTsType>,
    pub question_mark_token: SyntaxResult<SyntaxToken>,
    pub true_type: SyntaxResult<AnyTsType>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub false_type: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsConstModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConstModifierFields {
        TsConstModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsConstModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsConstModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsConstructSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConstructSignatureTypeMemberFields {
        TsConstructSignatureTypeMemberFields {
            new_token: self.new_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn new_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsConstructSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsConstructSignatureTypeMemberFields {
    pub new_token: SyntaxResult<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructorSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsConstructorSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConstructorSignatureClassMemberFields {
        TsConstructorSignatureClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            parameters: self.parameters(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> JsConstructorModifierList { support::list(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsLiteralMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsConstructorParameters> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsConstructorSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsConstructorSignatureClassMemberFields {
    pub modifiers: JsConstructorModifierList,
    pub name: SyntaxResult<JsLiteralMemberName>,
    pub parameters: SyntaxResult<JsConstructorParameters>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsConstructorType {
    pub(crate) syntax: SyntaxNode,
}
impl TsConstructorType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsConstructorTypeFields {
        TsConstructorTypeFields {
            abstract_token: self.abstract_token(),
            new_token: self.new_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            fat_arrow_token: self.fat_arrow_token(),
            return_type: self.return_type(),
        }
    }
    pub fn abstract_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn new_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsConstructorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsConstructorTypeFields {
    pub abstract_token: Option<SyntaxToken>,
    pub new_token: SyntaxResult<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub fat_arrow_token: SyntaxResult<SyntaxToken>,
    pub return_type: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareFunctionDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsDeclareFunctionDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDeclareFunctionDeclarationFields {
        TsDeclareFunctionDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<AnyJsBinding> { support::required_node(&self.syntax, 2usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsDeclareFunctionDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsDeclareFunctionDeclarationFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub id: SyntaxResult<AnyJsBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareFunctionExportDefaultDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsDeclareFunctionExportDefaultDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDeclareFunctionExportDefaultDeclarationFields {
        TsDeclareFunctionExportDefaultDeclarationFields {
            async_token: self.async_token(),
            function_token: self.function_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn function_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> Option<AnyJsBinding> { support::node(&self.syntax, 2usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 3usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsDeclareFunctionExportDefaultDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsDeclareFunctionExportDefaultDeclarationFields {
    pub async_token: Option<SyntaxToken>,
    pub function_token: SyntaxResult<SyntaxToken>,
    pub id: Option<AnyJsBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsDeclareModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDeclareModifierFields {
        TsDeclareModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsDeclareModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsDeclareModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDeclareStatement {
    pub(crate) syntax: SyntaxNode,
}
impl TsDeclareStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDeclareStatementFields {
        TsDeclareStatementFields {
            declare_token: self.declare_token(),
            declaration: self.declaration(),
        }
    }
    pub fn declare_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<AnyJsDeclarationClause> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsDeclareStatement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsDeclareStatementFields {
    pub declare_token: SyntaxResult<SyntaxToken>,
    pub declaration: SyntaxResult<AnyJsDeclarationClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefaultTypeClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsDefaultTypeClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDefaultTypeClauseFields {
        TsDefaultTypeClauseFields {
            eq_token: self.eq_token(),
            ty: self.ty(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsDefaultTypeClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsDefaultTypeClauseFields {
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefinitePropertyAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsDefinitePropertyAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDefinitePropertyAnnotationFields {
        TsDefinitePropertyAnnotationFields {
            excl_token: self.excl_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn excl_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsDefinitePropertyAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsDefinitePropertyAnnotationFields {
    pub excl_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsDefiniteVariableAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsDefiniteVariableAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsDefiniteVariableAnnotationFields {
        TsDefiniteVariableAnnotationFields {
            excl_token: self.excl_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn excl_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsDefiniteVariableAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsDefiniteVariableAnnotationFields {
    pub excl_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEmptyExternalModuleDeclarationBody {
    pub(crate) syntax: SyntaxNode,
}
impl TsEmptyExternalModuleDeclarationBody {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsEmptyExternalModuleDeclarationBodyFields {
        TsEmptyExternalModuleDeclarationBodyFields {
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn semicolon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsEmptyExternalModuleDeclarationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsEmptyExternalModuleDeclarationBodyFields {
    pub semicolon_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEnumDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsEnumDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsEnumDeclarationFields {
        TsEnumDeclarationFields {
            const_token: self.const_token(),
            enum_token: self.enum_token(),
            id: self.id(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn enum_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn id(&self) -> SyntaxResult<AnyJsBinding> { support::required_node(&self.syntax, 2usize) }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn members(&self) -> TsEnumMemberList { support::list(&self.syntax, 4usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsEnumDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsEnumDeclarationFields {
    pub const_token: Option<SyntaxToken>,
    pub enum_token: SyntaxResult<SyntaxToken>,
    pub id: SyntaxResult<AnyJsBinding>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: TsEnumMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsEnumMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsEnumMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsEnumMemberFields {
        TsEnumMemberFields {
            name: self.name(),
            initializer: self.initializer(),
        }
    }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn initializer(&self) -> Option<JsInitializerClause> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsEnumMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsEnumMemberFields {
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub initializer: Option<JsInitializerClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportAsNamespaceClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsExportAsNamespaceClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExportAsNamespaceClauseFields {
        TsExportAsNamespaceClauseFields {
            as_token: self.as_token(),
            namespace_token: self.namespace_token(),
            name: self.name(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn namespace_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 2usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsExportAsNamespaceClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsExportAsNamespaceClauseFields {
    pub as_token: SyntaxResult<SyntaxToken>,
    pub namespace_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<JsName>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportAssignmentClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsExportAssignmentClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExportAssignmentClauseFields {
        TsExportAssignmentClauseFields {
            eq_token: self.eq_token(),
            expression: self.expression(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsExportAssignmentClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsExportAssignmentClauseFields {
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExportDeclareClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsExportDeclareClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExportDeclareClauseFields {
        TsExportDeclareClauseFields {
            declare_token: self.declare_token(),
            declaration: self.declaration(),
        }
    }
    pub fn declare_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn declaration(&self) -> SyntaxResult<AnyJsDeclarationClause> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsExportDeclareClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsExportDeclareClauseFields {
    pub declare_token: SyntaxResult<SyntaxToken>,
    pub declaration: SyntaxResult<AnyJsDeclarationClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExtendsClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsExtendsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExtendsClauseFields {
        TsExtendsClauseFields {
            extends_token: self.extends_token(),
            types: self.types(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsTypeList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsExtendsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsExtendsClauseFields {
    pub extends_token: SyntaxResult<SyntaxToken>,
    pub types: TsTypeList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExternalModuleDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsExternalModuleDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExternalModuleDeclarationFields {
        TsExternalModuleDeclarationFields {
            module_token: self.module_token(),
            source: self.source(),
            body: self.body(),
        }
    }
    pub fn module_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn body(&self) -> Option<AnyTsExternalModuleDeclarationBody> {
        support::node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsExternalModuleDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsExternalModuleDeclarationFields {
    pub module_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub body: Option<AnyTsExternalModuleDeclarationBody>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsExternalModuleReference {
    pub(crate) syntax: SyntaxNode,
}
impl TsExternalModuleReference {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsExternalModuleReferenceFields {
        TsExternalModuleReferenceFields {
            require_token: self.require_token(),
            l_paren_token: self.l_paren_token(),
            source: self.source(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn require_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn source(&self) -> SyntaxResult<JsModuleSource> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsExternalModuleReference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsExternalModuleReferenceFields {
    pub require_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub source: SyntaxResult<JsModuleSource>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsFunctionType {
    pub(crate) syntax: SyntaxNode,
}
impl TsFunctionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsFunctionTypeFields {
        TsFunctionTypeFields {
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            fat_arrow_token: self.fat_arrow_token(),
            return_type: self.return_type(),
        }
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 0usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn fat_arrow_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn return_type(&self) -> SyntaxResult<AnyTsReturnType> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsFunctionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsFunctionTypeFields {
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub fat_arrow_token: SyntaxResult<SyntaxToken>,
    pub return_type: SyntaxResult<AnyTsReturnType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGetterSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsGetterSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsGetterSignatureClassMemberFields {
        TsGetterSignatureClassMemberFields {
            modifiers: self.modifiers(),
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            return_type: self.return_type(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList { support::list(&self.syntax, 0usize) }
    pub fn get_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn return_type(&self) -> Option<TsTypeAnnotation> { support::node(&self.syntax, 5usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsGetterSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsGetterSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub get_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub return_type: Option<TsTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGetterSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsGetterSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsGetterSignatureTypeMemberFields {
        TsGetterSignatureTypeMemberFields {
            get_token: self.get_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            r_paren_token: self.r_paren_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn get_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsGetterSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsGetterSignatureTypeMemberFields {
    pub get_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsGlobalDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsGlobalDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsGlobalDeclarationFields {
        TsGlobalDeclarationFields {
            global_token: self.global_token(),
            body: self.body(),
        }
    }
    pub fn global_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn body(&self) -> SyntaxResult<TsModuleBlock> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsGlobalDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsGlobalDeclarationFields {
    pub global_token: SyntaxResult<SyntaxToken>,
    pub body: SyntaxResult<TsModuleBlock>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIdentifierBinding {
    pub(crate) syntax: SyntaxNode,
}
impl TsIdentifierBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIdentifierBindingFields {
        TsIdentifierBindingFields {
            name_token: self.name_token(),
        }
    }
    pub fn name_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsIdentifierBinding {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsIdentifierBindingFields {
    pub name_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImplementsClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsImplementsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsImplementsClauseFields {
        TsImplementsClauseFields {
            implements_token: self.implements_token(),
            types: self.types(),
        }
    }
    pub fn implements_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsTypeList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsImplementsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsImplementsClauseFields {
    pub implements_token: SyntaxResult<SyntaxToken>,
    pub types: TsTypeList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportEqualsDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsImportEqualsDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsImportEqualsDeclarationFields {
        TsImportEqualsDeclarationFields {
            import_token: self.import_token(),
            type_token: self.type_token(),
            id: self.id(),
            eq_token: self.eq_token(),
            module_reference: self.module_reference(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn id(&self) -> SyntaxResult<AnyJsBinding> { support::required_node(&self.syntax, 2usize) }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn module_reference(&self) -> SyntaxResult<AnyTsModuleReference> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsImportEqualsDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsImportEqualsDeclarationFields {
    pub import_token: SyntaxResult<SyntaxToken>,
    pub type_token: Option<SyntaxToken>,
    pub id: SyntaxResult<AnyJsBinding>,
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub module_reference: SyntaxResult<AnyTsModuleReference>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportType {
    pub(crate) syntax: SyntaxNode,
}
impl TsImportType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsImportTypeFields {
        TsImportTypeFields {
            typeof_token: self.typeof_token(),
            import_token: self.import_token(),
            l_paren_token: self.l_paren_token(),
            argument_token: self.argument_token(),
            r_paren_token: self.r_paren_token(),
            qualifier_clause: self.qualifier_clause(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn typeof_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn import_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn argument_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn qualifier_clause(&self) -> Option<TsImportTypeQualifier> {
        support::node(&self.syntax, 5usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsImportType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsImportTypeFields {
    pub typeof_token: Option<SyntaxToken>,
    pub import_token: SyntaxResult<SyntaxToken>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub argument_token: SyntaxResult<SyntaxToken>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub qualifier_clause: Option<TsImportTypeQualifier>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsImportTypeQualifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsImportTypeQualifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsImportTypeQualifierFields {
        TsImportTypeQualifierFields {
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn right(&self) -> SyntaxResult<AnyTsName> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsImportTypeQualifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsImportTypeQualifierFields {
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<AnyTsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsInModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsInModifierFields {
        TsInModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsInModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsInModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsIndexSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIndexSignatureClassMemberFields {
        TsIndexSignatureClassMemberFields {
            modifiers: self.modifiers(),
            l_brack_token: self.l_brack_token(),
            parameter: self.parameter(),
            r_brack_token: self.r_brack_token(),
            type_annotation: self.type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsIndexSignatureModifierList { support::list(&self.syntax, 0usize) }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn parameter(&self) -> SyntaxResult<TsIndexSignatureParameter> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsIndexSignatureClassMemberFields {
    pub modifiers: TsIndexSignatureModifierList,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<TsIndexSignatureParameter>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureParameter {
    pub(crate) syntax: SyntaxNode,
}
impl TsIndexSignatureParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIndexSignatureParameterFields {
        TsIndexSignatureParameterFields {
            binding: self.binding(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn binding(&self) -> SyntaxResult<JsIdentifierBinding> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexSignatureParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsIndexSignatureParameterFields {
    pub binding: SyntaxResult<JsIdentifierBinding>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsIndexSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIndexSignatureTypeMemberFields {
        TsIndexSignatureTypeMemberFields {
            readonly_token: self.readonly_token(),
            l_brack_token: self.l_brack_token(),
            parameter: self.parameter(),
            r_brack_token: self.r_brack_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn readonly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn parameter(&self) -> SyntaxResult<TsIndexSignatureParameter> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn type_annotation(&self) -> SyntaxResult<TsTypeAnnotation> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsIndexSignatureTypeMemberFields {
    pub readonly_token: Option<SyntaxToken>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<TsIndexSignatureParameter>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: SyntaxResult<TsTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIndexedAccessType {
    pub(crate) syntax: SyntaxNode,
}
impl TsIndexedAccessType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIndexedAccessTypeFields {
        TsIndexedAccessTypeFields {
            object_type: self.object_type(),
            l_brack_token: self.l_brack_token(),
            index_type: self.index_type(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn object_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn index_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexedAccessType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsIndexedAccessTypeFields {
    pub object_type: SyntaxResult<AnyTsType>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub index_type: SyntaxResult<AnyTsType>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInferType {
    pub(crate) syntax: SyntaxNode,
}
impl TsInferType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsInferTypeFields {
        TsInferTypeFields {
            infer_token: self.infer_token(),
            name: self.name(),
            constraint: self.constraint(),
        }
    }
    pub fn infer_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn constraint(&self) -> Option<TsTypeConstraintClause> {
        support::node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsInferType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsInferTypeFields {
    pub infer_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<TsTypeParameterName>,
    pub constraint: Option<TsTypeConstraintClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInitializedPropertySignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsInitializedPropertySignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsInitializedPropertySignatureClassMemberFields {
        TsInitializedPropertySignatureClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            value: self.value(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsPropertySignatureModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn value(&self) -> SyntaxResult<JsInitializerClause> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsInitializedPropertySignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsInitializedPropertySignatureClassMemberFields {
    pub modifiers: TsPropertySignatureModifierList,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub question_mark_token: Option<SyntaxToken>,
    pub value: SyntaxResult<JsInitializerClause>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInstantiationExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TsInstantiationExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsInstantiationExpressionFields {
        TsInstantiationExpressionFields {
            expression: self.expression(),
            arguments: self.arguments(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn arguments(&self) -> SyntaxResult<TsTypeArguments> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsInstantiationExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsInstantiationExpressionFields {
    pub expression: SyntaxResult<AnyJsExpression>,
    pub arguments: SyntaxResult<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsInterfaceDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsInterfaceDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsInterfaceDeclarationFields {
        TsInterfaceDeclarationFields {
            interface_token: self.interface_token(),
            id: self.id(),
            type_parameters: self.type_parameters(),
            extends_clause: self.extends_clause(),
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn interface_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn id(&self) -> SyntaxResult<TsIdentifierBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn extends_clause(&self) -> Option<TsExtendsClause> { support::node(&self.syntax, 3usize) }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn members(&self) -> TsTypeMemberList { support::list(&self.syntax, 5usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 6usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsInterfaceDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsInterfaceDeclarationFields {
    pub interface_token: SyntaxResult<SyntaxToken>,
    pub id: SyntaxResult<TsIdentifierBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub extends_clause: Option<TsExtendsClause>,
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: TsTypeMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsIntersectionType {
    pub(crate) syntax: SyntaxNode,
}
impl TsIntersectionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsIntersectionTypeFields {
        TsIntersectionTypeFields {
            leading_separator_token: self.leading_separator_token(),
            types: self.types(),
        }
    }
    pub fn leading_separator_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsIntersectionTypeElementList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsIntersectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsIntersectionTypeFields {
    pub leading_separator_token: Option<SyntaxToken>,
    pub types: TsIntersectionTypeElementList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedType {
    pub(crate) syntax: SyntaxNode,
}
impl TsMappedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMappedTypeFields {
        TsMappedTypeFields {
            l_curly_token: self.l_curly_token(),
            readonly_modifier: self.readonly_modifier(),
            l_brack_token: self.l_brack_token(),
            property_name: self.property_name(),
            in_token: self.in_token(),
            keys_type: self.keys_type(),
            as_clause: self.as_clause(),
            r_brack_token: self.r_brack_token(),
            optional_modifier: self.optional_modifier(),
            mapped_type: self.mapped_type(),
            semicolon_token: self.semicolon_token(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn readonly_modifier(&self) -> Option<TsMappedTypeReadonlyModifierClause> {
        support::node(&self.syntax, 1usize)
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn property_name(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn in_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn keys_type(&self) -> SyntaxResult<AnyTsType> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn as_clause(&self) -> Option<TsMappedTypeAsClause> { support::node(&self.syntax, 6usize) }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 7usize)
    }
    pub fn optional_modifier(&self) -> Option<TsMappedTypeOptionalModifierClause> {
        support::node(&self.syntax, 8usize)
    }
    pub fn mapped_type(&self) -> Option<TsTypeAnnotation> { support::node(&self.syntax, 9usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 10usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 11usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsMappedType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsMappedTypeFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub readonly_modifier: Option<TsMappedTypeReadonlyModifierClause>,
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub property_name: SyntaxResult<TsTypeParameterName>,
    pub in_token: SyntaxResult<SyntaxToken>,
    pub keys_type: SyntaxResult<AnyTsType>,
    pub as_clause: Option<TsMappedTypeAsClause>,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
    pub optional_modifier: Option<TsMappedTypeOptionalModifierClause>,
    pub mapped_type: Option<TsTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeAsClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsMappedTypeAsClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMappedTypeAsClauseFields {
        TsMappedTypeAsClauseFields {
            as_token: self.as_token(),
            ty: self.ty(),
        }
    }
    pub fn as_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsMappedTypeAsClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsMappedTypeAsClauseFields {
    pub as_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeOptionalModifierClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsMappedTypeOptionalModifierClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMappedTypeOptionalModifierClauseFields {
        TsMappedTypeOptionalModifierClauseFields {
            operator_token: self.operator_token(),
            question_mark_token: self.question_mark_token(),
        }
    }
    pub fn operator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsMappedTypeOptionalModifierClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsMappedTypeOptionalModifierClauseFields {
    pub operator_token: Option<SyntaxToken>,
    pub question_mark_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMappedTypeReadonlyModifierClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsMappedTypeReadonlyModifierClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMappedTypeReadonlyModifierClauseFields {
        TsMappedTypeReadonlyModifierClauseFields {
            operator_token: self.operator_token(),
            readonly_token: self.readonly_token(),
        }
    }
    pub fn operator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn readonly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsMappedTypeReadonlyModifierClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsMappedTypeReadonlyModifierClauseFields {
    pub operator_token: Option<SyntaxToken>,
    pub readonly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMethodSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsMethodSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMethodSignatureClassMemberFields {
        TsMethodSignatureClassMemberFields {
            modifiers: self.modifiers(),
            async_token: self.async_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList { support::list(&self.syntax, 0usize) }
    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 3usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 4usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 5usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 6usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 7usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsMethodSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsMethodSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub async_token: Option<SyntaxToken>,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub question_mark_token: Option<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsMethodSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsMethodSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsMethodSignatureTypeMemberFields {
        TsMethodSignatureTypeMemberFields {
            name: self.name(),
            optional_token: self.optional_token(),
            type_parameters: self.type_parameters(),
            parameters: self.parameters(),
            return_type_annotation: self.return_type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn optional_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 1usize) }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn parameters(&self) -> SyntaxResult<JsParameters> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn return_type_annotation(&self) -> Option<TsReturnTypeAnnotation> {
        support::node(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsMethodSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsMethodSignatureTypeMemberFields {
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub optional_token: Option<SyntaxToken>,
    pub type_parameters: Option<TsTypeParameters>,
    pub parameters: SyntaxResult<JsParameters>,
    pub return_type_annotation: Option<TsReturnTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsModuleBlock {
    pub(crate) syntax: SyntaxNode,
}
impl TsModuleBlock {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsModuleBlockFields {
        TsModuleBlockFields {
            l_curly_token: self.l_curly_token(),
            items: self.items(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> JsModuleItemList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsModuleBlock {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsModuleBlockFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub items: JsModuleItemList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsModuleDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsModuleDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsModuleDeclarationFields {
        TsModuleDeclarationFields {
            module_or_namespace: self.module_or_namespace(),
            name: self.name(),
            body: self.body(),
        }
    }
    pub fn module_or_namespace(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyTsModuleName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn body(&self) -> SyntaxResult<TsModuleBlock> {
        support::required_node(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsModuleDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsModuleDeclarationFields {
    pub module_or_namespace: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyTsModuleName>,
    pub body: SyntaxResult<TsModuleBlock>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNameWithTypeArguments {
    pub(crate) syntax: SyntaxNode,
}
impl TsNameWithTypeArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNameWithTypeArgumentsFields {
        TsNameWithTypeArgumentsFields {
            name: self.name(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn name(&self) -> SyntaxResult<AnyTsName> { support::required_node(&self.syntax, 0usize) }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsNameWithTypeArguments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNameWithTypeArgumentsFields {
    pub name: SyntaxResult<AnyTsName>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNamedTupleTypeElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsNamedTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNamedTupleTypeElementFields {
        TsNamedTupleTypeElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            name: self.name(),
            question_mark_token: self.question_mark_token(),
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 1usize) }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 2usize)
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsNamedTupleTypeElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNamedTupleTypeElementFields {
    pub dotdotdot_token: Option<SyntaxToken>,
    pub name: SyntaxResult<JsName>,
    pub question_mark_token: Option<SyntaxToken>,
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNeverType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNeverType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNeverTypeFields {
        TsNeverTypeFields {
            never_token: self.never_token(),
        }
    }
    pub fn never_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNeverType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNeverTypeFields {
    pub never_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonNullAssertionAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl TsNonNullAssertionAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNonNullAssertionAssignmentFields {
        TsNonNullAssertionAssignmentFields {
            assignment: self.assignment(),
            excl_token: self.excl_token(),
        }
    }
    pub fn assignment(&self) -> SyntaxResult<AnyJsAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn excl_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNonNullAssertionAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNonNullAssertionAssignmentFields {
    pub assignment: SyntaxResult<AnyJsAssignment>,
    pub excl_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonNullAssertionExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TsNonNullAssertionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNonNullAssertionExpressionFields {
        TsNonNullAssertionExpressionFields {
            expression: self.expression(),
            excl_token: self.excl_token(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn excl_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNonNullAssertionExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNonNullAssertionExpressionFields {
    pub expression: SyntaxResult<AnyJsExpression>,
    pub excl_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNonPrimitiveType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNonPrimitiveType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNonPrimitiveTypeFields {
        TsNonPrimitiveTypeFields {
            object_token: self.object_token(),
        }
    }
    pub fn object_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNonPrimitiveType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNonPrimitiveTypeFields {
    pub object_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNullLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNullLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNullLiteralTypeFields {
        TsNullLiteralTypeFields {
            literal_token: self.literal_token(),
        }
    }
    pub fn literal_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNullLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNullLiteralTypeFields {
    pub literal_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNumberLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNumberLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNumberLiteralTypeFields {
        TsNumberLiteralTypeFields {
            minus_token: self.minus_token(),
            literal_token: self.literal_token(),
        }
    }
    pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn literal_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNumberLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNumberLiteralTypeFields {
    pub minus_token: Option<SyntaxToken>,
    pub literal_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsNumberType {
    pub(crate) syntax: SyntaxNode,
}
impl TsNumberType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsNumberTypeFields {
        TsNumberTypeFields {
            number_token: self.number_token(),
        }
    }
    pub fn number_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsNumberType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsNumberTypeFields {
    pub number_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsObjectType {
    pub(crate) syntax: SyntaxNode,
}
impl TsObjectType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsObjectTypeFields {
        TsObjectTypeFields {
            l_curly_token: self.l_curly_token(),
            members: self.members(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn l_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn members(&self) -> TsTypeMemberList { support::list(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsObjectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsObjectTypeFields {
    pub l_curly_token: SyntaxResult<SyntaxToken>,
    pub members: TsTypeMemberList,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOptionalPropertyAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsOptionalPropertyAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsOptionalPropertyAnnotationFields {
        TsOptionalPropertyAnnotationFields {
            question_mark_token: self.question_mark_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsOptionalPropertyAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsOptionalPropertyAnnotationFields {
    pub question_mark_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOptionalTupleTypeElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsOptionalTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsOptionalTupleTypeElementFields {
        TsOptionalTupleTypeElementFields {
            ty: self.ty(),
            question_mark_token: self.question_mark_token(),
        }
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 0usize) }
    pub fn question_mark_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsOptionalTupleTypeElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsOptionalTupleTypeElementFields {
    pub ty: SyntaxResult<AnyTsType>,
    pub question_mark_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOutModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsOutModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsOutModifierFields {
        TsOutModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsOutModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsOutModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsOverrideModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsOverrideModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsOverrideModifierFields {
        TsOverrideModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsOverrideModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsOverrideModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsParenthesizedType {
    pub(crate) syntax: SyntaxNode,
}
impl TsParenthesizedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsParenthesizedTypeFields {
        TsParenthesizedTypeFields {
            l_paren_token: self.l_paren_token(),
            ty: self.ty(),
            r_paren_token: self.r_paren_token(),
        }
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsParenthesizedType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsParenthesizedTypeFields {
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPredicateReturnType {
    pub(crate) syntax: SyntaxNode,
}
impl TsPredicateReturnType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsPredicateReturnTypeFields {
        TsPredicateReturnTypeFields {
            parameter_name: self.parameter_name(),
            is_token: self.is_token(),
            ty: self.ty(),
        }
    }
    pub fn parameter_name(&self) -> SyntaxResult<AnyTsTypePredicateParameterName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn is_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsPredicateReturnType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsPredicateReturnTypeFields {
    pub parameter_name: SyntaxResult<AnyTsTypePredicateParameterName>,
    pub is_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertyParameter {
    pub(crate) syntax: SyntaxNode,
}
impl TsPropertyParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsPropertyParameterFields {
        TsPropertyParameterFields {
            modifiers: self.modifiers(),
            formal_parameter: self.formal_parameter(),
        }
    }
    pub fn modifiers(&self) -> TsPropertyParameterModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn formal_parameter(&self) -> SyntaxResult<AnyJsFormalParameter> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertyParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsPropertyParameterFields {
    pub modifiers: TsPropertyParameterModifierList,
    pub formal_parameter: SyntaxResult<AnyJsFormalParameter>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertySignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsPropertySignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsPropertySignatureClassMemberFields {
        TsPropertySignatureClassMemberFields {
            modifiers: self.modifiers(),
            name: self.name(),
            property_annotation: self.property_annotation(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsPropertySignatureModifierList {
        support::list(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn property_annotation(&self) -> Option<AnyTsPropertySignatureAnnotation> {
        support::node(&self.syntax, 2usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertySignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsPropertySignatureClassMemberFields {
    pub modifiers: TsPropertySignatureModifierList,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub property_annotation: Option<AnyTsPropertySignatureAnnotation>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsPropertySignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsPropertySignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsPropertySignatureTypeMemberFields {
        TsPropertySignatureTypeMemberFields {
            readonly_token: self.readonly_token(),
            name: self.name(),
            optional_token: self.optional_token(),
            type_annotation: self.type_annotation(),
            separator_token: self.separator_token(),
        }
    }
    pub fn readonly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn optional_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 2usize) }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 3usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 4usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertySignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsPropertySignatureTypeMemberFields {
    pub readonly_token: Option<SyntaxToken>,
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub optional_token: Option<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsQualifiedModuleName {
    pub(crate) syntax: SyntaxNode,
}
impl TsQualifiedModuleName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsQualifiedModuleNameFields {
        TsQualifiedModuleNameFields {
            left: self.left(),
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<AnyTsModuleName> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsQualifiedModuleName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsQualifiedModuleNameFields {
    pub left: SyntaxResult<AnyTsModuleName>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsQualifiedName {
    pub(crate) syntax: SyntaxNode,
}
impl TsQualifiedName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsQualifiedNameFields {
        TsQualifiedNameFields {
            left: self.left(),
            dot_token: self.dot_token(),
            right: self.right(),
        }
    }
    pub fn left(&self) -> SyntaxResult<AnyTsName> { support::required_node(&self.syntax, 0usize) }
    pub fn dot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn right(&self) -> SyntaxResult<JsName> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsQualifiedName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsQualifiedNameFields {
    pub left: SyntaxResult<AnyTsName>,
    pub dot_token: SyntaxResult<SyntaxToken>,
    pub right: SyntaxResult<JsName>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReadonlyModifier {
    pub(crate) syntax: SyntaxNode,
}
impl TsReadonlyModifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsReadonlyModifierFields {
        TsReadonlyModifierFields {
            modifier_token: self.modifier_token(),
        }
    }
    pub fn modifier_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsReadonlyModifier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsReadonlyModifierFields {
    pub modifier_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReferenceType {
    pub(crate) syntax: SyntaxNode,
}
impl TsReferenceType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsReferenceTypeFields {
        TsReferenceTypeFields {
            name: self.name(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn name(&self) -> SyntaxResult<AnyTsName> { support::required_node(&self.syntax, 0usize) }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsReferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsReferenceTypeFields {
    pub name: SyntaxResult<AnyTsName>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsRestTupleTypeElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsRestTupleTypeElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsRestTupleTypeElementFields {
        TsRestTupleTypeElementFields {
            dotdotdot_token: self.dotdotdot_token(),
            ty: self.ty(),
        }
    }
    pub fn dotdotdot_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsRestTupleTypeElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsRestTupleTypeElementFields {
    pub dotdotdot_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsReturnTypeAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsReturnTypeAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsReturnTypeAnnotationFields {
        TsReturnTypeAnnotationFields {
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsReturnType> {
        support::required_node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsReturnTypeAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsReturnTypeAnnotationFields {
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsReturnType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSatisfiesAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl TsSatisfiesAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsSatisfiesAssignmentFields {
        TsSatisfiesAssignmentFields {
            assignment: self.assignment(),
            satisfies_token: self.satisfies_token(),
            ty: self.ty(),
        }
    }
    pub fn assignment(&self) -> SyntaxResult<AnyJsAssignment> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn satisfies_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsSatisfiesAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsSatisfiesAssignmentFields {
    pub assignment: SyntaxResult<AnyJsAssignment>,
    pub satisfies_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSatisfiesExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TsSatisfiesExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsSatisfiesExpressionFields {
        TsSatisfiesExpressionFields {
            expression: self.expression(),
            satisfies_token: self.satisfies_token(),
            ty: self.ty(),
        }
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 0usize)
    }
    pub fn satisfies_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsSatisfiesExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsSatisfiesExpressionFields {
    pub expression: SyntaxResult<AnyJsExpression>,
    pub satisfies_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSetterSignatureClassMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsSetterSignatureClassMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsSetterSignatureClassMemberFields {
        TsSetterSignatureClassMemberFields {
            modifiers: self.modifiers(),
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn modifiers(&self) -> TsMethodSignatureModifierList { support::list(&self.syntax, 0usize) }
    pub fn set_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 1usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsClassMemberName> {
        support::required_node(&self.syntax, 2usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn parameter(&self) -> SyntaxResult<AnyJsFormalParameter> {
        support::required_node(&self.syntax, 4usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 5usize)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 6usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsSetterSignatureClassMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsSetterSignatureClassMemberFields {
    pub modifiers: TsMethodSignatureModifierList,
    pub set_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsClassMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<AnyJsFormalParameter>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSetterSignatureTypeMember {
    pub(crate) syntax: SyntaxNode,
}
impl TsSetterSignatureTypeMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsSetterSignatureTypeMemberFields {
        TsSetterSignatureTypeMemberFields {
            set_token: self.set_token(),
            name: self.name(),
            l_paren_token: self.l_paren_token(),
            parameter: self.parameter(),
            r_paren_token: self.r_paren_token(),
            separator_token: self.separator_token(),
        }
    }
    pub fn set_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn name(&self) -> SyntaxResult<AnyJsObjectMemberName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn l_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn parameter(&self) -> SyntaxResult<AnyJsFormalParameter> {
        support::required_node(&self.syntax, 3usize)
    }
    pub fn r_paren_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 4usize)
    }
    pub fn separator_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsSetterSignatureTypeMember {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsSetterSignatureTypeMemberFields {
    pub set_token: SyntaxResult<SyntaxToken>,
    pub name: SyntaxResult<AnyJsObjectMemberName>,
    pub l_paren_token: SyntaxResult<SyntaxToken>,
    pub parameter: SyntaxResult<AnyJsFormalParameter>,
    pub r_paren_token: SyntaxResult<SyntaxToken>,
    pub separator_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsStringLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsStringLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsStringLiteralTypeFields {
        TsStringLiteralTypeFields {
            literal_token: self.literal_token(),
        }
    }
    pub fn literal_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsStringLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsStringLiteralTypeFields {
    pub literal_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsStringType {
    pub(crate) syntax: SyntaxNode,
}
impl TsStringType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsStringTypeFields {
        TsStringTypeFields {
            string_token: self.string_token(),
        }
    }
    pub fn string_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsStringType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsStringTypeFields {
    pub string_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsSymbolType {
    pub(crate) syntax: SyntaxNode,
}
impl TsSymbolType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsSymbolTypeFields {
        TsSymbolTypeFields {
            symbol_token: self.symbol_token(),
        }
    }
    pub fn symbol_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsSymbolType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsSymbolTypeFields {
    pub symbol_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateChunkElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsTemplateChunkElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTemplateChunkElementFields {
        TsTemplateChunkElementFields {
            template_chunk_token: self.template_chunk_token(),
        }
    }
    pub fn template_chunk_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTemplateChunkElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTemplateChunkElementFields {
    pub template_chunk_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateElement {
    pub(crate) syntax: SyntaxNode,
}
impl TsTemplateElement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTemplateElementFields {
        TsTemplateElementFields {
            dollar_curly_token: self.dollar_curly_token(),
            ty: self.ty(),
            r_curly_token: self.r_curly_token(),
        }
    }
    pub fn dollar_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
    pub fn r_curly_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTemplateElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTemplateElementFields {
    pub dollar_curly_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
    pub r_curly_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTemplateLiteralType {
    pub(crate) syntax: SyntaxNode,
}
impl TsTemplateLiteralType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTemplateLiteralTypeFields {
        TsTemplateLiteralTypeFields {
            l_tick_token: self.l_tick_token(),
            elements: self.elements(),
            r_tick_token: self.r_tick_token(),
        }
    }
    pub fn l_tick_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> TsTemplateElementList { support::list(&self.syntax, 1usize) }
    pub fn r_tick_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTemplateLiteralType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTemplateLiteralTypeFields {
    pub l_tick_token: SyntaxResult<SyntaxToken>,
    pub elements: TsTemplateElementList,
    pub r_tick_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsThisParameter {
    pub(crate) syntax: SyntaxNode,
}
impl TsThisParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsThisParameterFields {
        TsThisParameterFields {
            this_token: self.this_token(),
            type_annotation: self.type_annotation(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn type_annotation(&self) -> Option<TsTypeAnnotation> {
        support::node(&self.syntax, 1usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsThisParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsThisParameterFields {
    pub this_token: SyntaxResult<SyntaxToken>,
    pub type_annotation: Option<TsTypeAnnotation>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsThisType {
    pub(crate) syntax: SyntaxNode,
}
impl TsThisType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsThisTypeFields {
        TsThisTypeFields {
            this_token: self.this_token(),
        }
    }
    pub fn this_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsThisType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsThisTypeFields {
    pub this_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTupleType {
    pub(crate) syntax: SyntaxNode,
}
impl TsTupleType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTupleTypeFields {
        TsTupleTypeFields {
            l_brack_token: self.l_brack_token(),
            elements: self.elements(),
            r_brack_token: self.r_brack_token(),
        }
    }
    pub fn l_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn elements(&self) -> TsTupleTypeElementList { support::list(&self.syntax, 1usize) }
    pub fn r_brack_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTupleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTupleTypeFields {
    pub l_brack_token: SyntaxResult<SyntaxToken>,
    pub elements: TsTupleTypeElementList,
    pub r_brack_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAliasDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeAliasDeclaration {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeAliasDeclarationFields {
        TsTypeAliasDeclarationFields {
            type_token: self.type_token(),
            binding_identifier: self.binding_identifier(),
            type_parameters: self.type_parameters(),
            eq_token: self.eq_token(),
            ty: self.ty(),
            semicolon_token: self.semicolon_token(),
        }
    }
    pub fn type_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn binding_identifier(&self) -> SyntaxResult<TsIdentifierBinding> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_parameters(&self) -> Option<TsTypeParameters> {
        support::node(&self.syntax, 2usize)
    }
    pub fn eq_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 3usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 4usize) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, 5usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeAliasDeclaration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeAliasDeclarationFields {
    pub type_token: SyntaxResult<SyntaxToken>,
    pub binding_identifier: SyntaxResult<TsIdentifierBinding>,
    pub type_parameters: Option<TsTypeParameters>,
    pub eq_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
    pub semicolon_token: Option<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAnnotation {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeAnnotation {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeAnnotationFields {
        TsTypeAnnotationFields {
            colon_token: self.colon_token(),
            ty: self.ty(),
        }
    }
    pub fn colon_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeAnnotationFields {
    pub colon_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeArguments {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeArguments {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeArgumentsFields {
        TsTypeArgumentsFields {
            l_angle_token: self.l_angle_token(),
            ts_type_argument_list: self.ts_type_argument_list(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ts_type_argument_list(&self) -> TsTypeArgumentList {
        support::list(&self.syntax, 1usize)
    }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeArguments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeArgumentsFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub ts_type_argument_list: TsTypeArgumentList,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAssertionAssignment {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeAssertionAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeAssertionAssignmentFields {
        TsTypeAssertionAssignmentFields {
            l_angle_token: self.l_angle_token(),
            ty: self.ty(),
            r_angle_token: self.r_angle_token(),
            assignment: self.assignment(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn assignment(&self) -> SyntaxResult<AnyJsAssignment> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeAssertionAssignment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeAssertionAssignmentFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
    pub assignment: SyntaxResult<AnyJsAssignment>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeAssertionExpression {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeAssertionExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeAssertionExpressionFields {
        TsTypeAssertionExpressionFields {
            l_angle_token: self.l_angle_token(),
            ty: self.ty(),
            r_angle_token: self.r_angle_token(),
            expression: self.expression(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
    pub fn expression(&self) -> SyntaxResult<AnyJsExpression> {
        support::required_node(&self.syntax, 3usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeAssertionExpression {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeAssertionExpressionFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
    pub expression: SyntaxResult<AnyJsExpression>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeConstraintClause {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeConstraintClause {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeConstraintClauseFields {
        TsTypeConstraintClauseFields {
            extends_token: self.extends_token(),
            ty: self.ty(),
        }
    }
    pub fn extends_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeConstraintClause {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeConstraintClauseFields {
    pub extends_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeOperatorType {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeOperatorType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeOperatorTypeFields {
        TsTypeOperatorTypeFields {
            operator_token: self.operator_token(),
            ty: self.ty(),
        }
    }
    pub fn operator_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn ty(&self) -> SyntaxResult<AnyTsType> { support::required_node(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeOperatorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeOperatorTypeFields {
    pub operator_token: SyntaxResult<SyntaxToken>,
    pub ty: SyntaxResult<AnyTsType>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameter {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeParameterFields {
        TsTypeParameterFields {
            modifiers: self.modifiers(),
            name: self.name(),
            constraint: self.constraint(),
            default: self.default(),
        }
    }
    pub fn modifiers(&self) -> TsTypeParameterModifierList { support::list(&self.syntax, 0usize) }
    pub fn name(&self) -> SyntaxResult<TsTypeParameterName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn constraint(&self) -> Option<TsTypeConstraintClause> {
        support::node(&self.syntax, 2usize)
    }
    pub fn default(&self) -> Option<TsDefaultTypeClause> { support::node(&self.syntax, 3usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeParameterFields {
    pub modifiers: TsTypeParameterModifierList,
    pub name: SyntaxResult<TsTypeParameterName>,
    pub constraint: Option<TsTypeConstraintClause>,
    pub default: Option<TsDefaultTypeClause>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameterName {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeParameterName {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeParameterNameFields {
        TsTypeParameterNameFields {
            ident_token: self.ident_token(),
        }
    }
    pub fn ident_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameterName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeParameterNameFields {
    pub ident_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeParameters {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeParameters {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeParametersFields {
        TsTypeParametersFields {
            l_angle_token: self.l_angle_token(),
            items: self.items(),
            r_angle_token: self.r_angle_token(),
        }
    }
    pub fn l_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn items(&self) -> TsTypeParameterList { support::list(&self.syntax, 1usize) }
    pub fn r_angle_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 2usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeParametersFields {
    pub l_angle_token: SyntaxResult<SyntaxToken>,
    pub items: TsTypeParameterList,
    pub r_angle_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsTypeofType {
    pub(crate) syntax: SyntaxNode,
}
impl TsTypeofType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsTypeofTypeFields {
        TsTypeofTypeFields {
            typeof_token: self.typeof_token(),
            expression_name: self.expression_name(),
            type_arguments: self.type_arguments(),
        }
    }
    pub fn typeof_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
    pub fn expression_name(&self) -> SyntaxResult<AnyTsName> {
        support::required_node(&self.syntax, 1usize)
    }
    pub fn type_arguments(&self) -> Option<TsTypeArguments> { support::node(&self.syntax, 2usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeofType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsTypeofTypeFields {
    pub typeof_token: SyntaxResult<SyntaxToken>,
    pub expression_name: SyntaxResult<AnyTsName>,
    pub type_arguments: Option<TsTypeArguments>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUndefinedType {
    pub(crate) syntax: SyntaxNode,
}
impl TsUndefinedType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsUndefinedTypeFields {
        TsUndefinedTypeFields {
            undefined_token: self.undefined_token(),
        }
    }
    pub fn undefined_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsUndefinedType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsUndefinedTypeFields {
    pub undefined_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUnionType {
    pub(crate) syntax: SyntaxNode,
}
impl TsUnionType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsUnionTypeFields {
        TsUnionTypeFields {
            leading_separator_token: self.leading_separator_token(),
            types: self.types(),
        }
    }
    pub fn leading_separator_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, 0usize)
    }
    pub fn types(&self) -> TsUnionTypeVariantList { support::list(&self.syntax, 1usize) }
}
#[cfg(feature = "serde")]
impl Serialize for TsUnionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsUnionTypeFields {
    pub leading_separator_token: Option<SyntaxToken>,
    pub types: TsUnionTypeVariantList,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsUnknownType {
    pub(crate) syntax: SyntaxNode,
}
impl TsUnknownType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsUnknownTypeFields {
        TsUnknownTypeFields {
            unknown_token: self.unknown_token(),
        }
    }
    pub fn unknown_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsUnknownType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsUnknownTypeFields {
    pub unknown_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct TsVoidType {
    pub(crate) syntax: SyntaxNode,
}
impl TsVoidType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn as_fields(&self) -> TsVoidTypeFields {
        TsVoidTypeFields {
            void_token: self.void_token(),
        }
    }
    pub fn void_token(&self) -> SyntaxResult<SyntaxToken> {
        support::required_token(&self.syntax, 0usize)
    }
}
#[cfg(feature = "serde")]
impl Serialize for TsVoidType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.as_fields().serialize(serializer)
    }
}
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsVoidTypeFields {
    pub void_token: SyntaxResult<SyntaxToken>,
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsArrayAssignmentPatternElement {
    AnyJsAssignmentPattern(AnyJsAssignmentPattern),
    JsArrayAssignmentPatternRestElement(JsArrayAssignmentPatternRestElement),
    JsArrayHole(JsArrayHole),
    JsAssignmentWithDefault(JsAssignmentWithDefault),
}
impl AnyJsArrayAssignmentPatternElement {
    pub fn as_any_js_assignment_pattern(&self) -> Option<&AnyJsAssignmentPattern> {
        match &self {
            AnyJsArrayAssignmentPatternElement::AnyJsAssignmentPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_assignment_pattern_rest_element(
        &self,
    ) -> Option<&JsArrayAssignmentPatternRestElement> {
        match &self {
            AnyJsArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(item) => {
                Some(item)
            }
            _ => None,
        }
    }
    pub fn as_js_array_hole(&self) -> Option<&JsArrayHole> {
        match &self {
            AnyJsArrayAssignmentPatternElement::JsArrayHole(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_assignment_with_default(&self) -> Option<&JsAssignmentWithDefault> {
        match &self {
            AnyJsArrayAssignmentPatternElement::JsAssignmentWithDefault(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsArrayBindingPatternElement {
    AnyJsBindingPattern(AnyJsBindingPattern),
    JsArrayBindingPatternRestElement(JsArrayBindingPatternRestElement),
    JsArrayHole(JsArrayHole),
    JsBindingPatternWithDefault(JsBindingPatternWithDefault),
}
impl AnyJsArrayBindingPatternElement {
    pub fn as_any_js_binding_pattern(&self) -> Option<&AnyJsBindingPattern> {
        match &self {
            AnyJsArrayBindingPatternElement::AnyJsBindingPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_binding_pattern_rest_element(
        &self,
    ) -> Option<&JsArrayBindingPatternRestElement> {
        match &self {
            AnyJsArrayBindingPatternElement::JsArrayBindingPatternRestElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_hole(&self) -> Option<&JsArrayHole> {
        match &self {
            AnyJsArrayBindingPatternElement::JsArrayHole(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_binding_pattern_with_default(&self) -> Option<&JsBindingPatternWithDefault> {
        match &self {
            AnyJsArrayBindingPatternElement::JsBindingPatternWithDefault(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsArrayElement {
    AnyJsExpression(AnyJsExpression),
    JsArrayHole(JsArrayHole),
    JsSpread(JsSpread),
}
impl AnyJsArrayElement {
    pub fn as_any_js_expression(&self) -> Option<&AnyJsExpression> {
        match &self {
            AnyJsArrayElement::AnyJsExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_hole(&self) -> Option<&JsArrayHole> {
        match &self {
            AnyJsArrayElement::JsArrayHole(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_spread(&self) -> Option<&JsSpread> {
        match &self {
            AnyJsArrayElement::JsSpread(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsArrowFunctionParameters {
    AnyJsBinding(AnyJsBinding),
    JsParameters(JsParameters),
}
impl AnyJsArrowFunctionParameters {
    pub fn as_any_js_binding(&self) -> Option<&AnyJsBinding> {
        match &self {
            AnyJsArrowFunctionParameters::AnyJsBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_parameters(&self) -> Option<&JsParameters> {
        match &self {
            AnyJsArrowFunctionParameters::JsParameters(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsAssignment {
    JsBogusAssignment(JsBogusAssignment),
    JsComputedMemberAssignment(JsComputedMemberAssignment),
    JsIdentifierAssignment(JsIdentifierAssignment),
    JsParenthesizedAssignment(JsParenthesizedAssignment),
    JsStaticMemberAssignment(JsStaticMemberAssignment),
    TsAsAssignment(TsAsAssignment),
    TsNonNullAssertionAssignment(TsNonNullAssertionAssignment),
    TsSatisfiesAssignment(TsSatisfiesAssignment),
    TsTypeAssertionAssignment(TsTypeAssertionAssignment),
}
impl AnyJsAssignment {
    pub fn as_js_bogus_assignment(&self) -> Option<&JsBogusAssignment> {
        match &self {
            AnyJsAssignment::JsBogusAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_computed_member_assignment(&self) -> Option<&JsComputedMemberAssignment> {
        match &self {
            AnyJsAssignment::JsComputedMemberAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_identifier_assignment(&self) -> Option<&JsIdentifierAssignment> {
        match &self {
            AnyJsAssignment::JsIdentifierAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_parenthesized_assignment(&self) -> Option<&JsParenthesizedAssignment> {
        match &self {
            AnyJsAssignment::JsParenthesizedAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_member_assignment(&self) -> Option<&JsStaticMemberAssignment> {
        match &self {
            AnyJsAssignment::JsStaticMemberAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_as_assignment(&self) -> Option<&TsAsAssignment> {
        match &self {
            AnyJsAssignment::TsAsAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_non_null_assertion_assignment(&self) -> Option<&TsNonNullAssertionAssignment> {
        match &self {
            AnyJsAssignment::TsNonNullAssertionAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_satisfies_assignment(&self) -> Option<&TsSatisfiesAssignment> {
        match &self {
            AnyJsAssignment::TsSatisfiesAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_assertion_assignment(&self) -> Option<&TsTypeAssertionAssignment> {
        match &self {
            AnyJsAssignment::TsTypeAssertionAssignment(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsAssignmentPattern {
    AnyJsAssignment(AnyJsAssignment),
    JsArrayAssignmentPattern(JsArrayAssignmentPattern),
    JsObjectAssignmentPattern(JsObjectAssignmentPattern),
}
impl AnyJsAssignmentPattern {
    pub fn as_any_js_assignment(&self) -> Option<&AnyJsAssignment> {
        match &self {
            AnyJsAssignmentPattern::AnyJsAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_assignment_pattern(&self) -> Option<&JsArrayAssignmentPattern> {
        match &self {
            AnyJsAssignmentPattern::JsArrayAssignmentPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_assignment_pattern(&self) -> Option<&JsObjectAssignmentPattern> {
        match &self {
            AnyJsAssignmentPattern::JsObjectAssignmentPattern(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsBinding {
    JsBogusBinding(JsBogusBinding),
    JsIdentifierBinding(JsIdentifierBinding),
}
impl AnyJsBinding {
    pub fn as_js_bogus_binding(&self) -> Option<&JsBogusBinding> {
        match &self {
            AnyJsBinding::JsBogusBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_identifier_binding(&self) -> Option<&JsIdentifierBinding> {
        match &self {
            AnyJsBinding::JsIdentifierBinding(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsBindingPattern {
    AnyJsBinding(AnyJsBinding),
    JsArrayBindingPattern(JsArrayBindingPattern),
    JsObjectBindingPattern(JsObjectBindingPattern),
}
impl AnyJsBindingPattern {
    pub fn as_any_js_binding(&self) -> Option<&AnyJsBinding> {
        match &self {
            AnyJsBindingPattern::AnyJsBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_binding_pattern(&self) -> Option<&JsArrayBindingPattern> {
        match &self {
            AnyJsBindingPattern::JsArrayBindingPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_binding_pattern(&self) -> Option<&JsObjectBindingPattern> {
        match &self {
            AnyJsBindingPattern::JsObjectBindingPattern(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsCallArgument {
    AnyJsExpression(AnyJsExpression),
    JsSpread(JsSpread),
}
impl AnyJsCallArgument {
    pub fn as_any_js_expression(&self) -> Option<&AnyJsExpression> {
        match &self {
            AnyJsCallArgument::AnyJsExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_spread(&self) -> Option<&JsSpread> {
        match &self {
            AnyJsCallArgument::JsSpread(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsClass {
    JsClassDeclaration(JsClassDeclaration),
    JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration),
    JsClassExpression(JsClassExpression),
}
impl AnyJsClass {
    pub fn as_js_class_declaration(&self) -> Option<&JsClassDeclaration> {
        match &self {
            AnyJsClass::JsClassDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_class_export_default_declaration(
        &self,
    ) -> Option<&JsClassExportDefaultDeclaration> {
        match &self {
            AnyJsClass::JsClassExportDefaultDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_class_expression(&self) -> Option<&JsClassExpression> {
        match &self {
            AnyJsClass::JsClassExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsClassMember {
    JsBogusMember(JsBogusMember),
    JsConstructorClassMember(JsConstructorClassMember),
    JsEmptyClassMember(JsEmptyClassMember),
    JsGetterClassMember(JsGetterClassMember),
    JsMethodClassMember(JsMethodClassMember),
    JsPropertyClassMember(JsPropertyClassMember),
    JsSetterClassMember(JsSetterClassMember),
    JsStaticInitializationBlockClassMember(JsStaticInitializationBlockClassMember),
    TsConstructorSignatureClassMember(TsConstructorSignatureClassMember),
    TsGetterSignatureClassMember(TsGetterSignatureClassMember),
    TsIndexSignatureClassMember(TsIndexSignatureClassMember),
    TsInitializedPropertySignatureClassMember(TsInitializedPropertySignatureClassMember),
    TsMethodSignatureClassMember(TsMethodSignatureClassMember),
    TsPropertySignatureClassMember(TsPropertySignatureClassMember),
    TsSetterSignatureClassMember(TsSetterSignatureClassMember),
}
impl AnyJsClassMember {
    pub fn as_js_bogus_member(&self) -> Option<&JsBogusMember> {
        match &self {
            AnyJsClassMember::JsBogusMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_constructor_class_member(&self) -> Option<&JsConstructorClassMember> {
        match &self {
            AnyJsClassMember::JsConstructorClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_empty_class_member(&self) -> Option<&JsEmptyClassMember> {
        match &self {
            AnyJsClassMember::JsEmptyClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_getter_class_member(&self) -> Option<&JsGetterClassMember> {
        match &self {
            AnyJsClassMember::JsGetterClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_method_class_member(&self) -> Option<&JsMethodClassMember> {
        match &self {
            AnyJsClassMember::JsMethodClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_property_class_member(&self) -> Option<&JsPropertyClassMember> {
        match &self {
            AnyJsClassMember::JsPropertyClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_setter_class_member(&self) -> Option<&JsSetterClassMember> {
        match &self {
            AnyJsClassMember::JsSetterClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_initialization_block_class_member(
        &self,
    ) -> Option<&JsStaticInitializationBlockClassMember> {
        match &self {
            AnyJsClassMember::JsStaticInitializationBlockClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_constructor_signature_class_member(
        &self,
    ) -> Option<&TsConstructorSignatureClassMember> {
        match &self {
            AnyJsClassMember::TsConstructorSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_getter_signature_class_member(&self) -> Option<&TsGetterSignatureClassMember> {
        match &self {
            AnyJsClassMember::TsGetterSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_index_signature_class_member(&self) -> Option<&TsIndexSignatureClassMember> {
        match &self {
            AnyJsClassMember::TsIndexSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_initialized_property_signature_class_member(
        &self,
    ) -> Option<&TsInitializedPropertySignatureClassMember> {
        match &self {
            AnyJsClassMember::TsInitializedPropertySignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_method_signature_class_member(&self) -> Option<&TsMethodSignatureClassMember> {
        match &self {
            AnyJsClassMember::TsMethodSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_property_signature_class_member(&self) -> Option<&TsPropertySignatureClassMember> {
        match &self {
            AnyJsClassMember::TsPropertySignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_setter_signature_class_member(&self) -> Option<&TsSetterSignatureClassMember> {
        match &self {
            AnyJsClassMember::TsSetterSignatureClassMember(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsClassMemberName {
    JsComputedMemberName(JsComputedMemberName),
    JsLiteralMemberName(JsLiteralMemberName),
    JsPrivateClassMemberName(JsPrivateClassMemberName),
}
impl AnyJsClassMemberName {
    pub fn as_js_computed_member_name(&self) -> Option<&JsComputedMemberName> {
        match &self {
            AnyJsClassMemberName::JsComputedMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_literal_member_name(&self) -> Option<&JsLiteralMemberName> {
        match &self {
            AnyJsClassMemberName::JsLiteralMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_private_class_member_name(&self) -> Option<&JsPrivateClassMemberName> {
        match &self {
            AnyJsClassMemberName::JsPrivateClassMemberName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsConstructorParameter {
    AnyJsFormalParameter(AnyJsFormalParameter),
    JsRestParameter(JsRestParameter),
    TsPropertyParameter(TsPropertyParameter),
}
impl AnyJsConstructorParameter {
    pub fn as_any_js_formal_parameter(&self) -> Option<&AnyJsFormalParameter> {
        match &self {
            AnyJsConstructorParameter::AnyJsFormalParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_rest_parameter(&self) -> Option<&JsRestParameter> {
        match &self {
            AnyJsConstructorParameter::JsRestParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_property_parameter(&self) -> Option<&TsPropertyParameter> {
        match &self {
            AnyJsConstructorParameter::TsPropertyParameter(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsDeclaration {
    JsClassDeclaration(JsClassDeclaration),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsVariableDeclaration(JsVariableDeclaration),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
impl AnyJsDeclaration {
    pub fn as_js_class_declaration(&self) -> Option<&JsClassDeclaration> {
        match &self {
            AnyJsDeclaration::JsClassDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_declaration(&self) -> Option<&JsFunctionDeclaration> {
        match &self {
            AnyJsDeclaration::JsFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_variable_declaration(&self) -> Option<&JsVariableDeclaration> {
        match &self {
            AnyJsDeclaration::JsVariableDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_function_declaration(&self) -> Option<&TsDeclareFunctionDeclaration> {
        match &self {
            AnyJsDeclaration::TsDeclareFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_enum_declaration(&self) -> Option<&TsEnumDeclaration> {
        match &self {
            AnyJsDeclaration::TsEnumDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_external_module_declaration(&self) -> Option<&TsExternalModuleDeclaration> {
        match &self {
            AnyJsDeclaration::TsExternalModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_global_declaration(&self) -> Option<&TsGlobalDeclaration> {
        match &self {
            AnyJsDeclaration::TsGlobalDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_import_equals_declaration(&self) -> Option<&TsImportEqualsDeclaration> {
        match &self {
            AnyJsDeclaration::TsImportEqualsDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_interface_declaration(&self) -> Option<&TsInterfaceDeclaration> {
        match &self {
            AnyJsDeclaration::TsInterfaceDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_module_declaration(&self) -> Option<&TsModuleDeclaration> {
        match &self {
            AnyJsDeclaration::TsModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_alias_declaration(&self) -> Option<&TsTypeAliasDeclaration> {
        match &self {
            AnyJsDeclaration::TsTypeAliasDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsDeclarationClause {
    JsClassDeclaration(JsClassDeclaration),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsVariableDeclarationClause(JsVariableDeclarationClause),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
impl AnyJsDeclarationClause {
    pub fn as_js_class_declaration(&self) -> Option<&JsClassDeclaration> {
        match &self {
            AnyJsDeclarationClause::JsClassDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_declaration(&self) -> Option<&JsFunctionDeclaration> {
        match &self {
            AnyJsDeclarationClause::JsFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_variable_declaration_clause(&self) -> Option<&JsVariableDeclarationClause> {
        match &self {
            AnyJsDeclarationClause::JsVariableDeclarationClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_function_declaration(&self) -> Option<&TsDeclareFunctionDeclaration> {
        match &self {
            AnyJsDeclarationClause::TsDeclareFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_enum_declaration(&self) -> Option<&TsEnumDeclaration> {
        match &self {
            AnyJsDeclarationClause::TsEnumDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_external_module_declaration(&self) -> Option<&TsExternalModuleDeclaration> {
        match &self {
            AnyJsDeclarationClause::TsExternalModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_global_declaration(&self) -> Option<&TsGlobalDeclaration> {
        match &self {
            AnyJsDeclarationClause::TsGlobalDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_import_equals_declaration(&self) -> Option<&TsImportEqualsDeclaration> {
        match &self {
            AnyJsDeclarationClause::TsImportEqualsDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_interface_declaration(&self) -> Option<&TsInterfaceDeclaration> {
        match &self {
            AnyJsDeclarationClause::TsInterfaceDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_module_declaration(&self) -> Option<&TsModuleDeclaration> {
        match &self {
            AnyJsDeclarationClause::TsModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_alias_declaration(&self) -> Option<&TsTypeAliasDeclaration> {
        match &self {
            AnyJsDeclarationClause::TsTypeAliasDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsDecorator {
    JsBogusExpression(JsBogusExpression),
    JsCallExpression(JsCallExpression),
    JsIdentifierExpression(JsIdentifierExpression),
    JsParenthesizedExpression(JsParenthesizedExpression),
    JsStaticMemberExpression(JsStaticMemberExpression),
}
impl AnyJsDecorator {
    pub fn as_js_bogus_expression(&self) -> Option<&JsBogusExpression> {
        match &self {
            AnyJsDecorator::JsBogusExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_call_expression(&self) -> Option<&JsCallExpression> {
        match &self {
            AnyJsDecorator::JsCallExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_identifier_expression(&self) -> Option<&JsIdentifierExpression> {
        match &self {
            AnyJsDecorator::JsIdentifierExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_parenthesized_expression(&self) -> Option<&JsParenthesizedExpression> {
        match &self {
            AnyJsDecorator::JsParenthesizedExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_member_expression(&self) -> Option<&JsStaticMemberExpression> {
        match &self {
            AnyJsDecorator::JsStaticMemberExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsExportClause {
    AnyJsDeclarationClause(AnyJsDeclarationClause),
    JsExportDefaultDeclarationClause(JsExportDefaultDeclarationClause),
    JsExportDefaultExpressionClause(JsExportDefaultExpressionClause),
    JsExportFromClause(JsExportFromClause),
    JsExportNamedClause(JsExportNamedClause),
    JsExportNamedFromClause(JsExportNamedFromClause),
    TsExportAsNamespaceClause(TsExportAsNamespaceClause),
    TsExportAssignmentClause(TsExportAssignmentClause),
    TsExportDeclareClause(TsExportDeclareClause),
}
impl AnyJsExportClause {
    pub fn as_any_js_declaration_clause(&self) -> Option<&AnyJsDeclarationClause> {
        match &self {
            AnyJsExportClause::AnyJsDeclarationClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_default_declaration_clause(
        &self,
    ) -> Option<&JsExportDefaultDeclarationClause> {
        match &self {
            AnyJsExportClause::JsExportDefaultDeclarationClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_default_expression_clause(
        &self,
    ) -> Option<&JsExportDefaultExpressionClause> {
        match &self {
            AnyJsExportClause::JsExportDefaultExpressionClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_from_clause(&self) -> Option<&JsExportFromClause> {
        match &self {
            AnyJsExportClause::JsExportFromClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_named_clause(&self) -> Option<&JsExportNamedClause> {
        match &self {
            AnyJsExportClause::JsExportNamedClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_named_from_clause(&self) -> Option<&JsExportNamedFromClause> {
        match &self {
            AnyJsExportClause::JsExportNamedFromClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_export_as_namespace_clause(&self) -> Option<&TsExportAsNamespaceClause> {
        match &self {
            AnyJsExportClause::TsExportAsNamespaceClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_export_assignment_clause(&self) -> Option<&TsExportAssignmentClause> {
        match &self {
            AnyJsExportClause::TsExportAssignmentClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_export_declare_clause(&self) -> Option<&TsExportDeclareClause> {
        match &self {
            AnyJsExportClause::TsExportDeclareClause(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsExportDefaultDeclaration {
    JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration),
    JsFunctionExportDefaultDeclaration(JsFunctionExportDefaultDeclaration),
    TsDeclareFunctionExportDefaultDeclaration(TsDeclareFunctionExportDefaultDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
}
impl AnyJsExportDefaultDeclaration {
    pub fn as_js_class_export_default_declaration(
        &self,
    ) -> Option<&JsClassExportDefaultDeclaration> {
        match &self {
            AnyJsExportDefaultDeclaration::JsClassExportDefaultDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_export_default_declaration(
        &self,
    ) -> Option<&JsFunctionExportDefaultDeclaration> {
        match &self {
            AnyJsExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_function_export_default_declaration(
        &self,
    ) -> Option<&TsDeclareFunctionExportDefaultDeclaration> {
        match &self {
            AnyJsExportDefaultDeclaration::TsDeclareFunctionExportDefaultDeclaration(item) => {
                Some(item)
            }
            _ => None,
        }
    }
    pub fn as_ts_interface_declaration(&self) -> Option<&TsInterfaceDeclaration> {
        match &self {
            AnyJsExportDefaultDeclaration::TsInterfaceDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsExportNamedSpecifier {
    JsExportNamedShorthandSpecifier(JsExportNamedShorthandSpecifier),
    JsExportNamedSpecifier(JsExportNamedSpecifier),
}
impl AnyJsExportNamedSpecifier {
    pub fn as_js_export_named_shorthand_specifier(
        &self,
    ) -> Option<&JsExportNamedShorthandSpecifier> {
        match &self {
            AnyJsExportNamedSpecifier::JsExportNamedShorthandSpecifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export_named_specifier(&self) -> Option<&JsExportNamedSpecifier> {
        match &self {
            AnyJsExportNamedSpecifier::JsExportNamedSpecifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsExpression {
    AnyJsLiteralExpression(AnyJsLiteralExpression),
    JsArrayExpression(JsArrayExpression),
    JsArrowFunctionExpression(JsArrowFunctionExpression),
    JsAssignmentExpression(JsAssignmentExpression),
    JsAwaitExpression(JsAwaitExpression),
    JsBinaryExpression(JsBinaryExpression),
    JsBogusExpression(JsBogusExpression),
    JsCallExpression(JsCallExpression),
    JsClassExpression(JsClassExpression),
    JsComputedMemberExpression(JsComputedMemberExpression),
    JsConditionalExpression(JsConditionalExpression),
    JsFunctionExpression(JsFunctionExpression),
    JsIdentifierExpression(JsIdentifierExpression),
    JsImportCallExpression(JsImportCallExpression),
    JsImportMetaExpression(JsImportMetaExpression),
    JsInExpression(JsInExpression),
    JsInstanceofExpression(JsInstanceofExpression),
    JsLogicalExpression(JsLogicalExpression),
    JsNewExpression(JsNewExpression),
    JsNewTargetExpression(JsNewTargetExpression),
    JsObjectExpression(JsObjectExpression),
    JsParenthesizedExpression(JsParenthesizedExpression),
    JsPostUpdateExpression(JsPostUpdateExpression),
    JsPreUpdateExpression(JsPreUpdateExpression),
    JsSequenceExpression(JsSequenceExpression),
    JsStaticMemberExpression(JsStaticMemberExpression),
    JsSuperExpression(JsSuperExpression),
    JsTemplateExpression(JsTemplateExpression),
    JsThisExpression(JsThisExpression),
    JsUnaryExpression(JsUnaryExpression),
    JsYieldExpression(JsYieldExpression),
    JsxTagExpression(JsxTagExpression),
    TsAsExpression(TsAsExpression),
    TsInstantiationExpression(TsInstantiationExpression),
    TsNonNullAssertionExpression(TsNonNullAssertionExpression),
    TsSatisfiesExpression(TsSatisfiesExpression),
    TsTypeAssertionExpression(TsTypeAssertionExpression),
}
impl AnyJsExpression {
    pub fn as_any_js_literal_expression(&self) -> Option<&AnyJsLiteralExpression> {
        match &self {
            AnyJsExpression::AnyJsLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_array_expression(&self) -> Option<&JsArrayExpression> {
        match &self {
            AnyJsExpression::JsArrayExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_arrow_function_expression(&self) -> Option<&JsArrowFunctionExpression> {
        match &self {
            AnyJsExpression::JsArrowFunctionExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_assignment_expression(&self) -> Option<&JsAssignmentExpression> {
        match &self {
            AnyJsExpression::JsAssignmentExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_await_expression(&self) -> Option<&JsAwaitExpression> {
        match &self {
            AnyJsExpression::JsAwaitExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_binary_expression(&self) -> Option<&JsBinaryExpression> {
        match &self {
            AnyJsExpression::JsBinaryExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_bogus_expression(&self) -> Option<&JsBogusExpression> {
        match &self {
            AnyJsExpression::JsBogusExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_call_expression(&self) -> Option<&JsCallExpression> {
        match &self {
            AnyJsExpression::JsCallExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_class_expression(&self) -> Option<&JsClassExpression> {
        match &self {
            AnyJsExpression::JsClassExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_computed_member_expression(&self) -> Option<&JsComputedMemberExpression> {
        match &self {
            AnyJsExpression::JsComputedMemberExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_conditional_expression(&self) -> Option<&JsConditionalExpression> {
        match &self {
            AnyJsExpression::JsConditionalExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_expression(&self) -> Option<&JsFunctionExpression> {
        match &self {
            AnyJsExpression::JsFunctionExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_identifier_expression(&self) -> Option<&JsIdentifierExpression> {
        match &self {
            AnyJsExpression::JsIdentifierExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_call_expression(&self) -> Option<&JsImportCallExpression> {
        match &self {
            AnyJsExpression::JsImportCallExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_meta_expression(&self) -> Option<&JsImportMetaExpression> {
        match &self {
            AnyJsExpression::JsImportMetaExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_in_expression(&self) -> Option<&JsInExpression> {
        match &self {
            AnyJsExpression::JsInExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_instanceof_expression(&self) -> Option<&JsInstanceofExpression> {
        match &self {
            AnyJsExpression::JsInstanceofExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_logical_expression(&self) -> Option<&JsLogicalExpression> {
        match &self {
            AnyJsExpression::JsLogicalExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_new_expression(&self) -> Option<&JsNewExpression> {
        match &self {
            AnyJsExpression::JsNewExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_new_target_expression(&self) -> Option<&JsNewTargetExpression> {
        match &self {
            AnyJsExpression::JsNewTargetExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_expression(&self) -> Option<&JsObjectExpression> {
        match &self {
            AnyJsExpression::JsObjectExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_parenthesized_expression(&self) -> Option<&JsParenthesizedExpression> {
        match &self {
            AnyJsExpression::JsParenthesizedExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_post_update_expression(&self) -> Option<&JsPostUpdateExpression> {
        match &self {
            AnyJsExpression::JsPostUpdateExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_pre_update_expression(&self) -> Option<&JsPreUpdateExpression> {
        match &self {
            AnyJsExpression::JsPreUpdateExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_sequence_expression(&self) -> Option<&JsSequenceExpression> {
        match &self {
            AnyJsExpression::JsSequenceExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_member_expression(&self) -> Option<&JsStaticMemberExpression> {
        match &self {
            AnyJsExpression::JsStaticMemberExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_super_expression(&self) -> Option<&JsSuperExpression> {
        match &self {
            AnyJsExpression::JsSuperExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_template_expression(&self) -> Option<&JsTemplateExpression> {
        match &self {
            AnyJsExpression::JsTemplateExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_this_expression(&self) -> Option<&JsThisExpression> {
        match &self {
            AnyJsExpression::JsThisExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_unary_expression(&self) -> Option<&JsUnaryExpression> {
        match &self {
            AnyJsExpression::JsUnaryExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_yield_expression(&self) -> Option<&JsYieldExpression> {
        match &self {
            AnyJsExpression::JsYieldExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_tag_expression(&self) -> Option<&JsxTagExpression> {
        match &self {
            AnyJsExpression::JsxTagExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_as_expression(&self) -> Option<&TsAsExpression> {
        match &self {
            AnyJsExpression::TsAsExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_instantiation_expression(&self) -> Option<&TsInstantiationExpression> {
        match &self {
            AnyJsExpression::TsInstantiationExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_non_null_assertion_expression(&self) -> Option<&TsNonNullAssertionExpression> {
        match &self {
            AnyJsExpression::TsNonNullAssertionExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_satisfies_expression(&self) -> Option<&TsSatisfiesExpression> {
        match &self {
            AnyJsExpression::TsSatisfiesExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_assertion_expression(&self) -> Option<&TsTypeAssertionExpression> {
        match &self {
            AnyJsExpression::TsTypeAssertionExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsForInOrOfInitializer {
    AnyJsAssignmentPattern(AnyJsAssignmentPattern),
    JsForVariableDeclaration(JsForVariableDeclaration),
}
impl AnyJsForInOrOfInitializer {
    pub fn as_any_js_assignment_pattern(&self) -> Option<&AnyJsAssignmentPattern> {
        match &self {
            AnyJsForInOrOfInitializer::AnyJsAssignmentPattern(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_for_variable_declaration(&self) -> Option<&JsForVariableDeclaration> {
        match &self {
            AnyJsForInOrOfInitializer::JsForVariableDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsForInitializer {
    AnyJsExpression(AnyJsExpression),
    JsVariableDeclaration(JsVariableDeclaration),
}
impl AnyJsForInitializer {
    pub fn as_any_js_expression(&self) -> Option<&AnyJsExpression> {
        match &self {
            AnyJsForInitializer::AnyJsExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_variable_declaration(&self) -> Option<&JsVariableDeclaration> {
        match &self {
            AnyJsForInitializer::JsVariableDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsFormalParameter {
    JsBogusParameter(JsBogusParameter),
    JsFormalParameter(JsFormalParameter),
}
impl AnyJsFormalParameter {
    pub fn as_js_bogus_parameter(&self) -> Option<&JsBogusParameter> {
        match &self {
            AnyJsFormalParameter::JsBogusParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_formal_parameter(&self) -> Option<&JsFormalParameter> {
        match &self {
            AnyJsFormalParameter::JsFormalParameter(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsFunction {
    JsArrowFunctionExpression(JsArrowFunctionExpression),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsFunctionExportDefaultDeclaration(JsFunctionExportDefaultDeclaration),
    JsFunctionExpression(JsFunctionExpression),
}
impl AnyJsFunction {
    pub fn as_js_arrow_function_expression(&self) -> Option<&JsArrowFunctionExpression> {
        match &self {
            AnyJsFunction::JsArrowFunctionExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_declaration(&self) -> Option<&JsFunctionDeclaration> {
        match &self {
            AnyJsFunction::JsFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_export_default_declaration(
        &self,
    ) -> Option<&JsFunctionExportDefaultDeclaration> {
        match &self {
            AnyJsFunction::JsFunctionExportDefaultDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_expression(&self) -> Option<&JsFunctionExpression> {
        match &self {
            AnyJsFunction::JsFunctionExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsFunctionBody {
    AnyJsExpression(AnyJsExpression),
    JsFunctionBody(JsFunctionBody),
}
impl AnyJsFunctionBody {
    pub fn as_any_js_expression(&self) -> Option<&AnyJsExpression> {
        match &self {
            AnyJsFunctionBody::AnyJsExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_body(&self) -> Option<&JsFunctionBody> {
        match &self {
            AnyJsFunctionBody::JsFunctionBody(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsImportAttributeEntry {
    JsBogusImportAttributeEntry(JsBogusImportAttributeEntry),
    JsImportAttributeEntry(JsImportAttributeEntry),
}
impl AnyJsImportAttributeEntry {
    pub fn as_js_bogus_import_attribute_entry(&self) -> Option<&JsBogusImportAttributeEntry> {
        match &self {
            AnyJsImportAttributeEntry::JsBogusImportAttributeEntry(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_attribute_entry(&self) -> Option<&JsImportAttributeEntry> {
        match &self {
            AnyJsImportAttributeEntry::JsImportAttributeEntry(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsImportClause {
    JsImportBareClause(JsImportBareClause),
    JsImportDefaultClause(JsImportDefaultClause),
    JsImportNamedClause(JsImportNamedClause),
    JsImportNamespaceClause(JsImportNamespaceClause),
}
impl AnyJsImportClause {
    pub fn as_js_import_bare_clause(&self) -> Option<&JsImportBareClause> {
        match &self {
            AnyJsImportClause::JsImportBareClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_default_clause(&self) -> Option<&JsImportDefaultClause> {
        match &self {
            AnyJsImportClause::JsImportDefaultClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_named_clause(&self) -> Option<&JsImportNamedClause> {
        match &self {
            AnyJsImportClause::JsImportNamedClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import_namespace_clause(&self) -> Option<&JsImportNamespaceClause> {
        match &self {
            AnyJsImportClause::JsImportNamespaceClause(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsInProperty {
    AnyJsExpression(AnyJsExpression),
    JsPrivateName(JsPrivateName),
}
impl AnyJsInProperty {
    pub fn as_any_js_expression(&self) -> Option<&AnyJsExpression> {
        match &self {
            AnyJsInProperty::AnyJsExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_private_name(&self) -> Option<&JsPrivateName> {
        match &self {
            AnyJsInProperty::JsPrivateName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsLiteralExpression {
    JsBigintLiteralExpression(JsBigintLiteralExpression),
    JsBooleanLiteralExpression(JsBooleanLiteralExpression),
    JsNullLiteralExpression(JsNullLiteralExpression),
    JsNumberLiteralExpression(JsNumberLiteralExpression),
    JsRegexLiteralExpression(JsRegexLiteralExpression),
    JsStringLiteralExpression(JsStringLiteralExpression),
}
impl AnyJsLiteralExpression {
    pub fn as_js_bigint_literal_expression(&self) -> Option<&JsBigintLiteralExpression> {
        match &self {
            AnyJsLiteralExpression::JsBigintLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_boolean_literal_expression(&self) -> Option<&JsBooleanLiteralExpression> {
        match &self {
            AnyJsLiteralExpression::JsBooleanLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_null_literal_expression(&self) -> Option<&JsNullLiteralExpression> {
        match &self {
            AnyJsLiteralExpression::JsNullLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_number_literal_expression(&self) -> Option<&JsNumberLiteralExpression> {
        match &self {
            AnyJsLiteralExpression::JsNumberLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_regex_literal_expression(&self) -> Option<&JsRegexLiteralExpression> {
        match &self {
            AnyJsLiteralExpression::JsRegexLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_string_literal_expression(&self) -> Option<&JsStringLiteralExpression> {
        match &self {
            AnyJsLiteralExpression::JsStringLiteralExpression(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsMethodModifier {
    JsStaticModifier(JsStaticModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
}
impl AnyJsMethodModifier {
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            AnyJsMethodModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            AnyJsMethodModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            AnyJsMethodModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsModuleItem {
    AnyJsStatement(AnyJsStatement),
    JsExport(JsExport),
    JsImport(JsImport),
}
impl AnyJsModuleItem {
    pub fn as_any_js_statement(&self) -> Option<&AnyJsStatement> {
        match &self {
            AnyJsModuleItem::AnyJsStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_export(&self) -> Option<&JsExport> {
        match &self {
            AnyJsModuleItem::JsExport(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_import(&self) -> Option<&JsImport> {
        match &self {
            AnyJsModuleItem::JsImport(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsName {
    JsName(JsName),
    JsPrivateName(JsPrivateName),
}
impl AnyJsName {
    pub fn as_js_name(&self) -> Option<&JsName> {
        match &self {
            AnyJsName::JsName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_private_name(&self) -> Option<&JsPrivateName> {
        match &self {
            AnyJsName::JsPrivateName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsNamedImport {
    JsNamedImportSpecifiers(JsNamedImportSpecifiers),
    JsNamespaceImportSpecifier(JsNamespaceImportSpecifier),
}
impl AnyJsNamedImport {
    pub fn as_js_named_import_specifiers(&self) -> Option<&JsNamedImportSpecifiers> {
        match &self {
            AnyJsNamedImport::JsNamedImportSpecifiers(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_namespace_import_specifier(&self) -> Option<&JsNamespaceImportSpecifier> {
        match &self {
            AnyJsNamedImport::JsNamespaceImportSpecifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsNamedImportSpecifier {
    JsBogusNamedImportSpecifier(JsBogusNamedImportSpecifier),
    JsNamedImportSpecifier(JsNamedImportSpecifier),
    JsShorthandNamedImportSpecifier(JsShorthandNamedImportSpecifier),
}
impl AnyJsNamedImportSpecifier {
    pub fn as_js_bogus_named_import_specifier(&self) -> Option<&JsBogusNamedImportSpecifier> {
        match &self {
            AnyJsNamedImportSpecifier::JsBogusNamedImportSpecifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_named_import_specifier(&self) -> Option<&JsNamedImportSpecifier> {
        match &self {
            AnyJsNamedImportSpecifier::JsNamedImportSpecifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_shorthand_named_import_specifier(
        &self,
    ) -> Option<&JsShorthandNamedImportSpecifier> {
        match &self {
            AnyJsNamedImportSpecifier::JsShorthandNamedImportSpecifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsObjectAssignmentPatternMember {
    JsBogusAssignment(JsBogusAssignment),
    JsObjectAssignmentPatternProperty(JsObjectAssignmentPatternProperty),
    JsObjectAssignmentPatternRest(JsObjectAssignmentPatternRest),
    JsObjectAssignmentPatternShorthandProperty(JsObjectAssignmentPatternShorthandProperty),
}
impl AnyJsObjectAssignmentPatternMember {
    pub fn as_js_bogus_assignment(&self) -> Option<&JsBogusAssignment> {
        match &self {
            AnyJsObjectAssignmentPatternMember::JsBogusAssignment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_assignment_pattern_property(
        &self,
    ) -> Option<&JsObjectAssignmentPatternProperty> {
        match &self {
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(item) => {
                Some(item)
            }
            _ => None,
        }
    }
    pub fn as_js_object_assignment_pattern_rest(&self) -> Option<&JsObjectAssignmentPatternRest> {
        match &self {
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_assignment_pattern_shorthand_property(
        &self,
    ) -> Option<&JsObjectAssignmentPatternShorthandProperty> {
        match &self {
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(
                item,
            ) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsObjectBindingPatternMember {
    JsBogusBinding(JsBogusBinding),
    JsObjectBindingPatternProperty(JsObjectBindingPatternProperty),
    JsObjectBindingPatternRest(JsObjectBindingPatternRest),
    JsObjectBindingPatternShorthandProperty(JsObjectBindingPatternShorthandProperty),
}
impl AnyJsObjectBindingPatternMember {
    pub fn as_js_bogus_binding(&self) -> Option<&JsBogusBinding> {
        match &self {
            AnyJsObjectBindingPatternMember::JsBogusBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_binding_pattern_property(&self) -> Option<&JsObjectBindingPatternProperty> {
        match &self {
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternProperty(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_binding_pattern_rest(&self) -> Option<&JsObjectBindingPatternRest> {
        match &self {
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternRest(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_object_binding_pattern_shorthand_property(
        &self,
    ) -> Option<&JsObjectBindingPatternShorthandProperty> {
        match &self {
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(item) => {
                Some(item)
            }
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsObjectMember {
    JsBogusMember(JsBogusMember),
    JsGetterObjectMember(JsGetterObjectMember),
    JsMethodObjectMember(JsMethodObjectMember),
    JsPropertyObjectMember(JsPropertyObjectMember),
    JsSetterObjectMember(JsSetterObjectMember),
    JsShorthandPropertyObjectMember(JsShorthandPropertyObjectMember),
    JsSpread(JsSpread),
}
impl AnyJsObjectMember {
    pub fn as_js_bogus_member(&self) -> Option<&JsBogusMember> {
        match &self {
            AnyJsObjectMember::JsBogusMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_getter_object_member(&self) -> Option<&JsGetterObjectMember> {
        match &self {
            AnyJsObjectMember::JsGetterObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_method_object_member(&self) -> Option<&JsMethodObjectMember> {
        match &self {
            AnyJsObjectMember::JsMethodObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_property_object_member(&self) -> Option<&JsPropertyObjectMember> {
        match &self {
            AnyJsObjectMember::JsPropertyObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_setter_object_member(&self) -> Option<&JsSetterObjectMember> {
        match &self {
            AnyJsObjectMember::JsSetterObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_shorthand_property_object_member(
        &self,
    ) -> Option<&JsShorthandPropertyObjectMember> {
        match &self {
            AnyJsObjectMember::JsShorthandPropertyObjectMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_spread(&self) -> Option<&JsSpread> {
        match &self {
            AnyJsObjectMember::JsSpread(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsObjectMemberName {
    JsComputedMemberName(JsComputedMemberName),
    JsLiteralMemberName(JsLiteralMemberName),
}
impl AnyJsObjectMemberName {
    pub fn as_js_computed_member_name(&self) -> Option<&JsComputedMemberName> {
        match &self {
            AnyJsObjectMemberName::JsComputedMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_literal_member_name(&self) -> Option<&JsLiteralMemberName> {
        match &self {
            AnyJsObjectMemberName::JsLiteralMemberName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsParameter {
    AnyJsFormalParameter(AnyJsFormalParameter),
    JsRestParameter(JsRestParameter),
    TsThisParameter(TsThisParameter),
}
impl AnyJsParameter {
    pub fn as_any_js_formal_parameter(&self) -> Option<&AnyJsFormalParameter> {
        match &self {
            AnyJsParameter::AnyJsFormalParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_rest_parameter(&self) -> Option<&JsRestParameter> {
        match &self {
            AnyJsParameter::JsRestParameter(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_this_parameter(&self) -> Option<&TsThisParameter> {
        match &self {
            AnyJsParameter::TsThisParameter(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsPropertyModifier {
    JsAccessorModifier(JsAccessorModifier),
    JsStaticModifier(JsStaticModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
impl AnyJsPropertyModifier {
    pub fn as_js_accessor_modifier(&self) -> Option<&JsAccessorModifier> {
        match &self {
            AnyJsPropertyModifier::JsAccessorModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            AnyJsPropertyModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            AnyJsPropertyModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            AnyJsPropertyModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_readonly_modifier(&self) -> Option<&TsReadonlyModifier> {
        match &self {
            AnyJsPropertyModifier::TsReadonlyModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsRoot {
    JsExpressionSnipped(JsExpressionSnipped),
    JsModule(JsModule),
    JsScript(JsScript),
}
impl AnyJsRoot {
    pub fn as_js_expression_snipped(&self) -> Option<&JsExpressionSnipped> {
        match &self {
            AnyJsRoot::JsExpressionSnipped(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_module(&self) -> Option<&JsModule> {
        match &self {
            AnyJsRoot::JsModule(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_script(&self) -> Option<&JsScript> {
        match &self {
            AnyJsRoot::JsScript(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsStatement {
    JsBlockStatement(JsBlockStatement),
    JsBogusStatement(JsBogusStatement),
    JsBreakStatement(JsBreakStatement),
    JsClassDeclaration(JsClassDeclaration),
    JsContinueStatement(JsContinueStatement),
    JsDebuggerStatement(JsDebuggerStatement),
    JsDoWhileStatement(JsDoWhileStatement),
    JsEmptyStatement(JsEmptyStatement),
    JsExpressionStatement(JsExpressionStatement),
    JsForInStatement(JsForInStatement),
    JsForOfStatement(JsForOfStatement),
    JsForStatement(JsForStatement),
    JsFunctionDeclaration(JsFunctionDeclaration),
    JsIfStatement(JsIfStatement),
    JsLabeledStatement(JsLabeledStatement),
    JsReturnStatement(JsReturnStatement),
    JsSwitchStatement(JsSwitchStatement),
    JsThrowStatement(JsThrowStatement),
    JsTryFinallyStatement(JsTryFinallyStatement),
    JsTryStatement(JsTryStatement),
    JsVariableStatement(JsVariableStatement),
    JsWhileStatement(JsWhileStatement),
    JsWithStatement(JsWithStatement),
    TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration),
    TsDeclareStatement(TsDeclareStatement),
    TsEnumDeclaration(TsEnumDeclaration),
    TsExternalModuleDeclaration(TsExternalModuleDeclaration),
    TsGlobalDeclaration(TsGlobalDeclaration),
    TsImportEqualsDeclaration(TsImportEqualsDeclaration),
    TsInterfaceDeclaration(TsInterfaceDeclaration),
    TsModuleDeclaration(TsModuleDeclaration),
    TsTypeAliasDeclaration(TsTypeAliasDeclaration),
}
impl AnyJsStatement {
    pub fn as_js_block_statement(&self) -> Option<&JsBlockStatement> {
        match &self {
            AnyJsStatement::JsBlockStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_bogus_statement(&self) -> Option<&JsBogusStatement> {
        match &self {
            AnyJsStatement::JsBogusStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_break_statement(&self) -> Option<&JsBreakStatement> {
        match &self {
            AnyJsStatement::JsBreakStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_class_declaration(&self) -> Option<&JsClassDeclaration> {
        match &self {
            AnyJsStatement::JsClassDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_continue_statement(&self) -> Option<&JsContinueStatement> {
        match &self {
            AnyJsStatement::JsContinueStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_debugger_statement(&self) -> Option<&JsDebuggerStatement> {
        match &self {
            AnyJsStatement::JsDebuggerStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_do_while_statement(&self) -> Option<&JsDoWhileStatement> {
        match &self {
            AnyJsStatement::JsDoWhileStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_empty_statement(&self) -> Option<&JsEmptyStatement> {
        match &self {
            AnyJsStatement::JsEmptyStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_expression_statement(&self) -> Option<&JsExpressionStatement> {
        match &self {
            AnyJsStatement::JsExpressionStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_for_in_statement(&self) -> Option<&JsForInStatement> {
        match &self {
            AnyJsStatement::JsForInStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_for_of_statement(&self) -> Option<&JsForOfStatement> {
        match &self {
            AnyJsStatement::JsForOfStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_for_statement(&self) -> Option<&JsForStatement> {
        match &self {
            AnyJsStatement::JsForStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_function_declaration(&self) -> Option<&JsFunctionDeclaration> {
        match &self {
            AnyJsStatement::JsFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_if_statement(&self) -> Option<&JsIfStatement> {
        match &self {
            AnyJsStatement::JsIfStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_labeled_statement(&self) -> Option<&JsLabeledStatement> {
        match &self {
            AnyJsStatement::JsLabeledStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_return_statement(&self) -> Option<&JsReturnStatement> {
        match &self {
            AnyJsStatement::JsReturnStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_switch_statement(&self) -> Option<&JsSwitchStatement> {
        match &self {
            AnyJsStatement::JsSwitchStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_throw_statement(&self) -> Option<&JsThrowStatement> {
        match &self {
            AnyJsStatement::JsThrowStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_try_finally_statement(&self) -> Option<&JsTryFinallyStatement> {
        match &self {
            AnyJsStatement::JsTryFinallyStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_try_statement(&self) -> Option<&JsTryStatement> {
        match &self {
            AnyJsStatement::JsTryStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_variable_statement(&self) -> Option<&JsVariableStatement> {
        match &self {
            AnyJsStatement::JsVariableStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_while_statement(&self) -> Option<&JsWhileStatement> {
        match &self {
            AnyJsStatement::JsWhileStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_with_statement(&self) -> Option<&JsWithStatement> {
        match &self {
            AnyJsStatement::JsWithStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_function_declaration(&self) -> Option<&TsDeclareFunctionDeclaration> {
        match &self {
            AnyJsStatement::TsDeclareFunctionDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_statement(&self) -> Option<&TsDeclareStatement> {
        match &self {
            AnyJsStatement::TsDeclareStatement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_enum_declaration(&self) -> Option<&TsEnumDeclaration> {
        match &self {
            AnyJsStatement::TsEnumDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_external_module_declaration(&self) -> Option<&TsExternalModuleDeclaration> {
        match &self {
            AnyJsStatement::TsExternalModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_global_declaration(&self) -> Option<&TsGlobalDeclaration> {
        match &self {
            AnyJsStatement::TsGlobalDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_import_equals_declaration(&self) -> Option<&TsImportEqualsDeclaration> {
        match &self {
            AnyJsStatement::TsImportEqualsDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_interface_declaration(&self) -> Option<&TsInterfaceDeclaration> {
        match &self {
            AnyJsStatement::TsInterfaceDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_module_declaration(&self) -> Option<&TsModuleDeclaration> {
        match &self {
            AnyJsStatement::TsModuleDeclaration(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_alias_declaration(&self) -> Option<&TsTypeAliasDeclaration> {
        match &self {
            AnyJsStatement::TsTypeAliasDeclaration(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsSwitchClause {
    JsCaseClause(JsCaseClause),
    JsDefaultClause(JsDefaultClause),
}
impl AnyJsSwitchClause {
    pub fn as_js_case_clause(&self) -> Option<&JsCaseClause> {
        match &self {
            AnyJsSwitchClause::JsCaseClause(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_default_clause(&self) -> Option<&JsDefaultClause> {
        match &self {
            AnyJsSwitchClause::JsDefaultClause(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsTemplateElement {
    JsTemplateChunkElement(JsTemplateChunkElement),
    JsTemplateElement(JsTemplateElement),
}
impl AnyJsTemplateElement {
    pub fn as_js_template_chunk_element(&self) -> Option<&JsTemplateChunkElement> {
        match &self {
            AnyJsTemplateElement::JsTemplateChunkElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_template_element(&self) -> Option<&JsTemplateElement> {
        match &self {
            AnyJsTemplateElement::JsTemplateElement(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsxAttribute {
    JsxAttribute(JsxAttribute),
    JsxSpreadAttribute(JsxSpreadAttribute),
}
impl AnyJsxAttribute {
    pub fn as_jsx_attribute(&self) -> Option<&JsxAttribute> {
        match &self {
            AnyJsxAttribute::JsxAttribute(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_spread_attribute(&self) -> Option<&JsxSpreadAttribute> {
        match &self {
            AnyJsxAttribute::JsxSpreadAttribute(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsxAttributeName {
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
}
impl AnyJsxAttributeName {
    pub fn as_jsx_name(&self) -> Option<&JsxName> {
        match &self {
            AnyJsxAttributeName::JsxName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_namespace_name(&self) -> Option<&JsxNamespaceName> {
        match &self {
            AnyJsxAttributeName::JsxNamespaceName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsxAttributeValue {
    AnyJsxTag(AnyJsxTag),
    JsxExpressionAttributeValue(JsxExpressionAttributeValue),
    JsxString(JsxString),
}
impl AnyJsxAttributeValue {
    pub fn as_any_jsx_tag(&self) -> Option<&AnyJsxTag> {
        match &self {
            AnyJsxAttributeValue::AnyJsxTag(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_expression_attribute_value(&self) -> Option<&JsxExpressionAttributeValue> {
        match &self {
            AnyJsxAttributeValue::JsxExpressionAttributeValue(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_string(&self) -> Option<&JsxString> {
        match &self {
            AnyJsxAttributeValue::JsxString(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsxChild {
    JsxElement(JsxElement),
    JsxExpressionChild(JsxExpressionChild),
    JsxFragment(JsxFragment),
    JsxSelfClosingElement(JsxSelfClosingElement),
    JsxSpreadChild(JsxSpreadChild),
    JsxText(JsxText),
}
impl AnyJsxChild {
    pub fn as_jsx_element(&self) -> Option<&JsxElement> {
        match &self {
            AnyJsxChild::JsxElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_expression_child(&self) -> Option<&JsxExpressionChild> {
        match &self {
            AnyJsxChild::JsxExpressionChild(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_fragment(&self) -> Option<&JsxFragment> {
        match &self {
            AnyJsxChild::JsxFragment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_self_closing_element(&self) -> Option<&JsxSelfClosingElement> {
        match &self {
            AnyJsxChild::JsxSelfClosingElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_spread_child(&self) -> Option<&JsxSpreadChild> {
        match &self {
            AnyJsxChild::JsxSpreadChild(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_text(&self) -> Option<&JsxText> {
        match &self {
            AnyJsxChild::JsxText(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsxElementName {
    JsxMemberName(JsxMemberName),
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
    JsxReferenceIdentifier(JsxReferenceIdentifier),
}
impl AnyJsxElementName {
    pub fn as_jsx_member_name(&self) -> Option<&JsxMemberName> {
        match &self {
            AnyJsxElementName::JsxMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_name(&self) -> Option<&JsxName> {
        match &self {
            AnyJsxElementName::JsxName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_namespace_name(&self) -> Option<&JsxNamespaceName> {
        match &self {
            AnyJsxElementName::JsxNamespaceName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_reference_identifier(&self) -> Option<&JsxReferenceIdentifier> {
        match &self {
            AnyJsxElementName::JsxReferenceIdentifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsxName {
    JsxName(JsxName),
    JsxNamespaceName(JsxNamespaceName),
}
impl AnyJsxName {
    pub fn as_jsx_name(&self) -> Option<&JsxName> {
        match &self {
            AnyJsxName::JsxName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_namespace_name(&self) -> Option<&JsxNamespaceName> {
        match &self {
            AnyJsxName::JsxNamespaceName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsxObjectName {
    JsxMemberName(JsxMemberName),
    JsxNamespaceName(JsxNamespaceName),
    JsxReferenceIdentifier(JsxReferenceIdentifier),
}
impl AnyJsxObjectName {
    pub fn as_jsx_member_name(&self) -> Option<&JsxMemberName> {
        match &self {
            AnyJsxObjectName::JsxMemberName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_namespace_name(&self) -> Option<&JsxNamespaceName> {
        match &self {
            AnyJsxObjectName::JsxNamespaceName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_reference_identifier(&self) -> Option<&JsxReferenceIdentifier> {
        match &self {
            AnyJsxObjectName::JsxReferenceIdentifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyJsxTag {
    JsxElement(JsxElement),
    JsxFragment(JsxFragment),
    JsxSelfClosingElement(JsxSelfClosingElement),
}
impl AnyJsxTag {
    pub fn as_jsx_element(&self) -> Option<&JsxElement> {
        match &self {
            AnyJsxTag::JsxElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_fragment(&self) -> Option<&JsxFragment> {
        match &self {
            AnyJsxTag::JsxFragment(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_jsx_self_closing_element(&self) -> Option<&JsxSelfClosingElement> {
        match &self {
            AnyJsxTag::JsxSelfClosingElement(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsExternalModuleDeclarationBody {
    TsEmptyExternalModuleDeclarationBody(TsEmptyExternalModuleDeclarationBody),
    TsModuleBlock(TsModuleBlock),
}
impl AnyTsExternalModuleDeclarationBody {
    pub fn as_ts_empty_external_module_declaration_body(
        &self,
    ) -> Option<&TsEmptyExternalModuleDeclarationBody> {
        match &self {
            AnyTsExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(item) => {
                Some(item)
            }
            _ => None,
        }
    }
    pub fn as_ts_module_block(&self) -> Option<&TsModuleBlock> {
        match &self {
            AnyTsExternalModuleDeclarationBody::TsModuleBlock(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsIndexSignatureModifier {
    JsStaticModifier(JsStaticModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
impl AnyTsIndexSignatureModifier {
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            AnyTsIndexSignatureModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_readonly_modifier(&self) -> Option<&TsReadonlyModifier> {
        match &self {
            AnyTsIndexSignatureModifier::TsReadonlyModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsMethodSignatureModifier {
    JsStaticModifier(JsStaticModifier),
    TsAbstractModifier(TsAbstractModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
}
impl AnyTsMethodSignatureModifier {
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            AnyTsMethodSignatureModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_abstract_modifier(&self) -> Option<&TsAbstractModifier> {
        match &self {
            AnyTsMethodSignatureModifier::TsAbstractModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            AnyTsMethodSignatureModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            AnyTsMethodSignatureModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsModuleName {
    TsIdentifierBinding(TsIdentifierBinding),
    TsQualifiedModuleName(TsQualifiedModuleName),
}
impl AnyTsModuleName {
    pub fn as_ts_identifier_binding(&self) -> Option<&TsIdentifierBinding> {
        match &self {
            AnyTsModuleName::TsIdentifierBinding(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_qualified_module_name(&self) -> Option<&TsQualifiedModuleName> {
        match &self {
            AnyTsModuleName::TsQualifiedModuleName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsModuleReference {
    AnyTsName(AnyTsName),
    TsExternalModuleReference(TsExternalModuleReference),
}
impl AnyTsModuleReference {
    pub fn as_any_ts_name(&self) -> Option<&AnyTsName> {
        match &self {
            AnyTsModuleReference::AnyTsName(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_external_module_reference(&self) -> Option<&TsExternalModuleReference> {
        match &self {
            AnyTsModuleReference::TsExternalModuleReference(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsName {
    JsReferenceIdentifier(JsReferenceIdentifier),
    TsQualifiedName(TsQualifiedName),
}
impl AnyTsName {
    pub fn as_js_reference_identifier(&self) -> Option<&JsReferenceIdentifier> {
        match &self {
            AnyTsName::JsReferenceIdentifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_qualified_name(&self) -> Option<&TsQualifiedName> {
        match &self {
            AnyTsName::TsQualifiedName(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsPropertyAnnotation {
    TsDefinitePropertyAnnotation(TsDefinitePropertyAnnotation),
    TsOptionalPropertyAnnotation(TsOptionalPropertyAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
impl AnyTsPropertyAnnotation {
    pub fn as_ts_definite_property_annotation(&self) -> Option<&TsDefinitePropertyAnnotation> {
        match &self {
            AnyTsPropertyAnnotation::TsDefinitePropertyAnnotation(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_optional_property_annotation(&self) -> Option<&TsOptionalPropertyAnnotation> {
        match &self {
            AnyTsPropertyAnnotation::TsOptionalPropertyAnnotation(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_annotation(&self) -> Option<&TsTypeAnnotation> {
        match &self {
            AnyTsPropertyAnnotation::TsTypeAnnotation(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsPropertyParameterModifier {
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
impl AnyTsPropertyParameterModifier {
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            AnyTsPropertyParameterModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            AnyTsPropertyParameterModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_readonly_modifier(&self) -> Option<&TsReadonlyModifier> {
        match &self {
            AnyTsPropertyParameterModifier::TsReadonlyModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsPropertySignatureAnnotation {
    TsOptionalPropertyAnnotation(TsOptionalPropertyAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
impl AnyTsPropertySignatureAnnotation {
    pub fn as_ts_optional_property_annotation(&self) -> Option<&TsOptionalPropertyAnnotation> {
        match &self {
            AnyTsPropertySignatureAnnotation::TsOptionalPropertyAnnotation(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_annotation(&self) -> Option<&TsTypeAnnotation> {
        match &self {
            AnyTsPropertySignatureAnnotation::TsTypeAnnotation(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsPropertySignatureModifier {
    JsAccessorModifier(JsAccessorModifier),
    JsStaticModifier(JsStaticModifier),
    TsAbstractModifier(TsAbstractModifier),
    TsAccessibilityModifier(TsAccessibilityModifier),
    TsDeclareModifier(TsDeclareModifier),
    TsOverrideModifier(TsOverrideModifier),
    TsReadonlyModifier(TsReadonlyModifier),
}
impl AnyTsPropertySignatureModifier {
    pub fn as_js_accessor_modifier(&self) -> Option<&JsAccessorModifier> {
        match &self {
            AnyTsPropertySignatureModifier::JsAccessorModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_js_static_modifier(&self) -> Option<&JsStaticModifier> {
        match &self {
            AnyTsPropertySignatureModifier::JsStaticModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_abstract_modifier(&self) -> Option<&TsAbstractModifier> {
        match &self {
            AnyTsPropertySignatureModifier::TsAbstractModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_accessibility_modifier(&self) -> Option<&TsAccessibilityModifier> {
        match &self {
            AnyTsPropertySignatureModifier::TsAccessibilityModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_declare_modifier(&self) -> Option<&TsDeclareModifier> {
        match &self {
            AnyTsPropertySignatureModifier::TsDeclareModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_override_modifier(&self) -> Option<&TsOverrideModifier> {
        match &self {
            AnyTsPropertySignatureModifier::TsOverrideModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_readonly_modifier(&self) -> Option<&TsReadonlyModifier> {
        match &self {
            AnyTsPropertySignatureModifier::TsReadonlyModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsReturnType {
    AnyTsType(AnyTsType),
    TsAssertsReturnType(TsAssertsReturnType),
    TsPredicateReturnType(TsPredicateReturnType),
}
impl AnyTsReturnType {
    pub fn as_any_ts_type(&self) -> Option<&AnyTsType> {
        match &self {
            AnyTsReturnType::AnyTsType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_asserts_return_type(&self) -> Option<&TsAssertsReturnType> {
        match &self {
            AnyTsReturnType::TsAssertsReturnType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_predicate_return_type(&self) -> Option<&TsPredicateReturnType> {
        match &self {
            AnyTsReturnType::TsPredicateReturnType(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsTemplateElement {
    TsTemplateChunkElement(TsTemplateChunkElement),
    TsTemplateElement(TsTemplateElement),
}
impl AnyTsTemplateElement {
    pub fn as_ts_template_chunk_element(&self) -> Option<&TsTemplateChunkElement> {
        match &self {
            AnyTsTemplateElement::TsTemplateChunkElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_template_element(&self) -> Option<&TsTemplateElement> {
        match &self {
            AnyTsTemplateElement::TsTemplateElement(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsTupleTypeElement {
    AnyTsType(AnyTsType),
    TsNamedTupleTypeElement(TsNamedTupleTypeElement),
    TsOptionalTupleTypeElement(TsOptionalTupleTypeElement),
    TsRestTupleTypeElement(TsRestTupleTypeElement),
}
impl AnyTsTupleTypeElement {
    pub fn as_any_ts_type(&self) -> Option<&AnyTsType> {
        match &self {
            AnyTsTupleTypeElement::AnyTsType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_named_tuple_type_element(&self) -> Option<&TsNamedTupleTypeElement> {
        match &self {
            AnyTsTupleTypeElement::TsNamedTupleTypeElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_optional_tuple_type_element(&self) -> Option<&TsOptionalTupleTypeElement> {
        match &self {
            AnyTsTupleTypeElement::TsOptionalTupleTypeElement(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_rest_tuple_type_element(&self) -> Option<&TsRestTupleTypeElement> {
        match &self {
            AnyTsTupleTypeElement::TsRestTupleTypeElement(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsType {
    TsAnyType(TsAnyType),
    TsArrayType(TsArrayType),
    TsBigintLiteralType(TsBigintLiteralType),
    TsBigintType(TsBigintType),
    TsBogusType(TsBogusType),
    TsBooleanLiteralType(TsBooleanLiteralType),
    TsBooleanType(TsBooleanType),
    TsConditionalType(TsConditionalType),
    TsConstructorType(TsConstructorType),
    TsFunctionType(TsFunctionType),
    TsImportType(TsImportType),
    TsIndexedAccessType(TsIndexedAccessType),
    TsInferType(TsInferType),
    TsIntersectionType(TsIntersectionType),
    TsMappedType(TsMappedType),
    TsNeverType(TsNeverType),
    TsNonPrimitiveType(TsNonPrimitiveType),
    TsNullLiteralType(TsNullLiteralType),
    TsNumberLiteralType(TsNumberLiteralType),
    TsNumberType(TsNumberType),
    TsObjectType(TsObjectType),
    TsParenthesizedType(TsParenthesizedType),
    TsReferenceType(TsReferenceType),
    TsStringLiteralType(TsStringLiteralType),
    TsStringType(TsStringType),
    TsSymbolType(TsSymbolType),
    TsTemplateLiteralType(TsTemplateLiteralType),
    TsThisType(TsThisType),
    TsTupleType(TsTupleType),
    TsTypeOperatorType(TsTypeOperatorType),
    TsTypeofType(TsTypeofType),
    TsUndefinedType(TsUndefinedType),
    TsUnionType(TsUnionType),
    TsUnknownType(TsUnknownType),
    TsVoidType(TsVoidType),
}
impl AnyTsType {
    pub fn as_ts_any_type(&self) -> Option<&TsAnyType> {
        match &self {
            AnyTsType::TsAnyType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_array_type(&self) -> Option<&TsArrayType> {
        match &self {
            AnyTsType::TsArrayType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_bigint_literal_type(&self) -> Option<&TsBigintLiteralType> {
        match &self {
            AnyTsType::TsBigintLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_bigint_type(&self) -> Option<&TsBigintType> {
        match &self {
            AnyTsType::TsBigintType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_bogus_type(&self) -> Option<&TsBogusType> {
        match &self {
            AnyTsType::TsBogusType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_boolean_literal_type(&self) -> Option<&TsBooleanLiteralType> {
        match &self {
            AnyTsType::TsBooleanLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_boolean_type(&self) -> Option<&TsBooleanType> {
        match &self {
            AnyTsType::TsBooleanType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_conditional_type(&self) -> Option<&TsConditionalType> {
        match &self {
            AnyTsType::TsConditionalType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_constructor_type(&self) -> Option<&TsConstructorType> {
        match &self {
            AnyTsType::TsConstructorType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_function_type(&self) -> Option<&TsFunctionType> {
        match &self {
            AnyTsType::TsFunctionType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_import_type(&self) -> Option<&TsImportType> {
        match &self {
            AnyTsType::TsImportType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_indexed_access_type(&self) -> Option<&TsIndexedAccessType> {
        match &self {
            AnyTsType::TsIndexedAccessType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_infer_type(&self) -> Option<&TsInferType> {
        match &self {
            AnyTsType::TsInferType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_intersection_type(&self) -> Option<&TsIntersectionType> {
        match &self {
            AnyTsType::TsIntersectionType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_mapped_type(&self) -> Option<&TsMappedType> {
        match &self {
            AnyTsType::TsMappedType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_never_type(&self) -> Option<&TsNeverType> {
        match &self {
            AnyTsType::TsNeverType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_non_primitive_type(&self) -> Option<&TsNonPrimitiveType> {
        match &self {
            AnyTsType::TsNonPrimitiveType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_null_literal_type(&self) -> Option<&TsNullLiteralType> {
        match &self {
            AnyTsType::TsNullLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_number_literal_type(&self) -> Option<&TsNumberLiteralType> {
        match &self {
            AnyTsType::TsNumberLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_number_type(&self) -> Option<&TsNumberType> {
        match &self {
            AnyTsType::TsNumberType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_object_type(&self) -> Option<&TsObjectType> {
        match &self {
            AnyTsType::TsObjectType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_parenthesized_type(&self) -> Option<&TsParenthesizedType> {
        match &self {
            AnyTsType::TsParenthesizedType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_reference_type(&self) -> Option<&TsReferenceType> {
        match &self {
            AnyTsType::TsReferenceType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_string_literal_type(&self) -> Option<&TsStringLiteralType> {
        match &self {
            AnyTsType::TsStringLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_string_type(&self) -> Option<&TsStringType> {
        match &self {
            AnyTsType::TsStringType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_symbol_type(&self) -> Option<&TsSymbolType> {
        match &self {
            AnyTsType::TsSymbolType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_template_literal_type(&self) -> Option<&TsTemplateLiteralType> {
        match &self {
            AnyTsType::TsTemplateLiteralType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_this_type(&self) -> Option<&TsThisType> {
        match &self {
            AnyTsType::TsThisType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_tuple_type(&self) -> Option<&TsTupleType> {
        match &self {
            AnyTsType::TsTupleType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_operator_type(&self) -> Option<&TsTypeOperatorType> {
        match &self {
            AnyTsType::TsTypeOperatorType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_typeof_type(&self) -> Option<&TsTypeofType> {
        match &self {
            AnyTsType::TsTypeofType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_undefined_type(&self) -> Option<&TsUndefinedType> {
        match &self {
            AnyTsType::TsUndefinedType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_union_type(&self) -> Option<&TsUnionType> {
        match &self {
            AnyTsType::TsUnionType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_unknown_type(&self) -> Option<&TsUnknownType> {
        match &self {
            AnyTsType::TsUnknownType(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_void_type(&self) -> Option<&TsVoidType> {
        match &self {
            AnyTsType::TsVoidType(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsTypeMember {
    JsBogusMember(JsBogusMember),
    TsCallSignatureTypeMember(TsCallSignatureTypeMember),
    TsConstructSignatureTypeMember(TsConstructSignatureTypeMember),
    TsGetterSignatureTypeMember(TsGetterSignatureTypeMember),
    TsIndexSignatureTypeMember(TsIndexSignatureTypeMember),
    TsMethodSignatureTypeMember(TsMethodSignatureTypeMember),
    TsPropertySignatureTypeMember(TsPropertySignatureTypeMember),
    TsSetterSignatureTypeMember(TsSetterSignatureTypeMember),
}
impl AnyTsTypeMember {
    pub fn as_js_bogus_member(&self) -> Option<&JsBogusMember> {
        match &self {
            AnyTsTypeMember::JsBogusMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_call_signature_type_member(&self) -> Option<&TsCallSignatureTypeMember> {
        match &self {
            AnyTsTypeMember::TsCallSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_construct_signature_type_member(&self) -> Option<&TsConstructSignatureTypeMember> {
        match &self {
            AnyTsTypeMember::TsConstructSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_getter_signature_type_member(&self) -> Option<&TsGetterSignatureTypeMember> {
        match &self {
            AnyTsTypeMember::TsGetterSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_index_signature_type_member(&self) -> Option<&TsIndexSignatureTypeMember> {
        match &self {
            AnyTsTypeMember::TsIndexSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_method_signature_type_member(&self) -> Option<&TsMethodSignatureTypeMember> {
        match &self {
            AnyTsTypeMember::TsMethodSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_property_signature_type_member(&self) -> Option<&TsPropertySignatureTypeMember> {
        match &self {
            AnyTsTypeMember::TsPropertySignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_setter_signature_type_member(&self) -> Option<&TsSetterSignatureTypeMember> {
        match &self {
            AnyTsTypeMember::TsSetterSignatureTypeMember(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsTypeParameterModifier {
    TsConstModifier(TsConstModifier),
    TsInModifier(TsInModifier),
    TsOutModifier(TsOutModifier),
}
impl AnyTsTypeParameterModifier {
    pub fn as_ts_const_modifier(&self) -> Option<&TsConstModifier> {
        match &self {
            AnyTsTypeParameterModifier::TsConstModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_in_modifier(&self) -> Option<&TsInModifier> {
        match &self {
            AnyTsTypeParameterModifier::TsInModifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_out_modifier(&self) -> Option<&TsOutModifier> {
        match &self {
            AnyTsTypeParameterModifier::TsOutModifier(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsTypePredicateParameterName {
    JsReferenceIdentifier(JsReferenceIdentifier),
    TsThisType(TsThisType),
}
impl AnyTsTypePredicateParameterName {
    pub fn as_js_reference_identifier(&self) -> Option<&JsReferenceIdentifier> {
        match &self {
            AnyTsTypePredicateParameterName::JsReferenceIdentifier(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_this_type(&self) -> Option<&TsThisType> {
        match &self {
            AnyTsTypePredicateParameterName::TsThisType(item) => Some(item),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub enum AnyTsVariableAnnotation {
    TsDefiniteVariableAnnotation(TsDefiniteVariableAnnotation),
    TsTypeAnnotation(TsTypeAnnotation),
}
impl AnyTsVariableAnnotation {
    pub fn as_ts_definite_variable_annotation(&self) -> Option<&TsDefiniteVariableAnnotation> {
        match &self {
            AnyTsVariableAnnotation::TsDefiniteVariableAnnotation(item) => Some(item),
            _ => None,
        }
    }
    pub fn as_ts_type_annotation(&self) -> Option<&TsTypeAnnotation> {
        match &self {
            AnyTsVariableAnnotation::TsTypeAnnotation(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for JsAccessorModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ACCESSOR_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ACCESSOR_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsAccessorModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAccessorModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<JsAccessorModifier> for SyntaxNode {
    fn from(n: JsAccessorModifier) -> SyntaxNode { n.syntax }
}
impl From<JsAccessorModifier> for SyntaxElement {
    fn from(n: JsAccessorModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayAssignmentPattern {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ARRAY_ASSIGNMENT_PATTERN as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_ASSIGNMENT_PATTERN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayAssignmentPattern")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayAssignmentPattern> for SyntaxNode {
    fn from(n: JsArrayAssignmentPattern) -> SyntaxNode { n.syntax }
}
impl From<JsArrayAssignmentPattern> for SyntaxElement {
    fn from(n: JsArrayAssignmentPattern) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayAssignmentPatternRestElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayAssignmentPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayAssignmentPatternRestElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .finish()
    }
}
impl From<JsArrayAssignmentPatternRestElement> for SyntaxNode {
    fn from(n: JsArrayAssignmentPatternRestElement) -> SyntaxNode { n.syntax }
}
impl From<JsArrayAssignmentPatternRestElement> for SyntaxElement {
    fn from(n: JsArrayAssignmentPatternRestElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayBindingPattern {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ARRAY_BINDING_PATTERN as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_BINDING_PATTERN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayBindingPattern")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayBindingPattern> for SyntaxNode {
    fn from(n: JsArrayBindingPattern) -> SyntaxNode { n.syntax }
}
impl From<JsArrayBindingPattern> for SyntaxElement {
    fn from(n: JsArrayBindingPattern) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayBindingPatternRestElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ARRAY_BINDING_PATTERN_REST_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_BINDING_PATTERN_REST_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayBindingPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayBindingPatternRestElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .finish()
    }
}
impl From<JsArrayBindingPatternRestElement> for SyntaxNode {
    fn from(n: JsArrayBindingPatternRestElement) -> SyntaxNode { n.syntax }
}
impl From<JsArrayBindingPatternRestElement> for SyntaxElement {
    fn from(n: JsArrayBindingPatternRestElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ARRAY_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayExpression")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsArrayExpression> for SyntaxNode {
    fn from(n: JsArrayExpression) -> SyntaxNode { n.syntax }
}
impl From<JsArrayExpression> for SyntaxElement {
    fn from(n: JsArrayExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrayHole {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ARRAY_HOLE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_HOLE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrayHole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrayHole").finish()
    }
}
impl From<JsArrayHole> for SyntaxNode {
    fn from(n: JsArrayHole) -> SyntaxNode { n.syntax }
}
impl From<JsArrayHole> for SyntaxElement {
    fn from(n: JsArrayHole) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsArrowFunctionExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ARROW_FUNCTION_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARROW_FUNCTION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsArrowFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsArrowFunctionExpression")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsArrowFunctionExpression> for SyntaxNode {
    fn from(n: JsArrowFunctionExpression) -> SyntaxNode { n.syntax }
}
impl From<JsArrowFunctionExpression> for SyntaxElement {
    fn from(n: JsArrowFunctionExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsAssignmentExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ASSIGNMENT_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ASSIGNMENT_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsAssignmentExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAssignmentExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsAssignmentExpression> for SyntaxNode {
    fn from(n: JsAssignmentExpression) -> SyntaxNode { n.syntax }
}
impl From<JsAssignmentExpression> for SyntaxElement {
    fn from(n: JsAssignmentExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsAssignmentWithDefault {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ASSIGNMENT_WITH_DEFAULT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ASSIGNMENT_WITH_DEFAULT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsAssignmentWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAssignmentWithDefault")
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("default", &support::DebugSyntaxResult(self.default()))
            .finish()
    }
}
impl From<JsAssignmentWithDefault> for SyntaxNode {
    fn from(n: JsAssignmentWithDefault) -> SyntaxNode { n.syntax }
}
impl From<JsAssignmentWithDefault> for SyntaxElement {
    fn from(n: JsAssignmentWithDefault) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsAwaitExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_AWAIT_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_AWAIT_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsAwaitExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsAwaitExpression")
            .field(
                "await_token",
                &support::DebugSyntaxResult(self.await_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsAwaitExpression> for SyntaxNode {
    fn from(n: JsAwaitExpression) -> SyntaxNode { n.syntax }
}
impl From<JsAwaitExpression> for SyntaxElement {
    fn from(n: JsAwaitExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBigintLiteralExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BIGINT_LITERAL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BIGINT_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBigintLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBigintLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsBigintLiteralExpression> for SyntaxNode {
    fn from(n: JsBigintLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsBigintLiteralExpression> for SyntaxElement {
    fn from(n: JsBigintLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBinaryExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BINARY_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BINARY_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBinaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBinaryExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsBinaryExpression> for SyntaxNode {
    fn from(n: JsBinaryExpression) -> SyntaxNode { n.syntax }
}
impl From<JsBinaryExpression> for SyntaxElement {
    fn from(n: JsBinaryExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBindingPatternWithDefault {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BINDING_PATTERN_WITH_DEFAULT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BINDING_PATTERN_WITH_DEFAULT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBindingPatternWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBindingPatternWithDefault")
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("default", &support::DebugSyntaxResult(self.default()))
            .finish()
    }
}
impl From<JsBindingPatternWithDefault> for SyntaxNode {
    fn from(n: JsBindingPatternWithDefault) -> SyntaxNode { n.syntax }
}
impl From<JsBindingPatternWithDefault> for SyntaxElement {
    fn from(n: JsBindingPatternWithDefault) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBlockStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BLOCK_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BLOCK_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBlockStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBlockStatement")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsBlockStatement> for SyntaxNode {
    fn from(n: JsBlockStatement) -> SyntaxNode { n.syntax }
}
impl From<JsBlockStatement> for SyntaxElement {
    fn from(n: JsBlockStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBooleanLiteralExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOOLEAN_LITERAL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOOLEAN_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBooleanLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBooleanLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsBooleanLiteralExpression> for SyntaxNode {
    fn from(n: JsBooleanLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsBooleanLiteralExpression> for SyntaxElement {
    fn from(n: JsBooleanLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsBreakStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BREAK_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BREAK_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBreakStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBreakStatement")
            .field(
                "break_token",
                &support::DebugSyntaxResult(self.break_token()),
            )
            .field(
                "label_token",
                &support::DebugOptionalElement(self.label_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsBreakStatement> for SyntaxNode {
    fn from(n: JsBreakStatement) -> SyntaxNode { n.syntax }
}
impl From<JsBreakStatement> for SyntaxElement {
    fn from(n: JsBreakStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCallArguments {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CALL_ARGUMENTS as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CALL_ARGUMENTS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCallArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCallArguments")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("args", &self.args())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsCallArguments> for SyntaxNode {
    fn from(n: JsCallArguments) -> SyntaxNode { n.syntax }
}
impl From<JsCallArguments> for SyntaxElement {
    fn from(n: JsCallArguments) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCallExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CALL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CALL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCallExpression")
            .field("callee", &support::DebugSyntaxResult(self.callee()))
            .field(
                "optional_chain_token",
                &support::DebugOptionalElement(self.optional_chain_token()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("arguments", &support::DebugSyntaxResult(self.arguments()))
            .finish()
    }
}
impl From<JsCallExpression> for SyntaxNode {
    fn from(n: JsCallExpression) -> SyntaxNode { n.syntax }
}
impl From<JsCallExpression> for SyntaxElement {
    fn from(n: JsCallExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCaseClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CASE_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CASE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCaseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCaseClause")
            .field("case_token", &support::DebugSyntaxResult(self.case_token()))
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("consequent", &self.consequent())
            .finish()
    }
}
impl From<JsCaseClause> for SyntaxNode {
    fn from(n: JsCaseClause) -> SyntaxNode { n.syntax }
}
impl From<JsCaseClause> for SyntaxElement {
    fn from(n: JsCaseClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCatchClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CATCH_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CATCH_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCatchClause")
            .field(
                "catch_token",
                &support::DebugSyntaxResult(self.catch_token()),
            )
            .field(
                "declaration",
                &support::DebugOptionalElement(self.declaration()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsCatchClause> for SyntaxNode {
    fn from(n: JsCatchClause) -> SyntaxNode { n.syntax }
}
impl From<JsCatchClause> for SyntaxElement {
    fn from(n: JsCatchClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsCatchDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CATCH_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CATCH_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsCatchDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsCatchDeclaration")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsCatchDeclaration> for SyntaxNode {
    fn from(n: JsCatchDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsCatchDeclaration> for SyntaxElement {
    fn from(n: JsCatchDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsClassDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CLASS_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CLASS_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsClassDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassDeclaration")
            .field("decorators", &self.decorators())
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassDeclaration> for SyntaxNode {
    fn from(n: JsClassDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsClassDeclaration> for SyntaxElement {
    fn from(n: JsClassDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsClassExportDefaultDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CLASS_EXPORT_DEFAULT_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CLASS_EXPORT_DEFAULT_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsClassExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassExportDefaultDeclaration")
            .field("decorators", &self.decorators())
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassExportDefaultDeclaration> for SyntaxNode {
    fn from(n: JsClassExportDefaultDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsClassExportDefaultDeclaration> for SyntaxElement {
    fn from(n: JsClassExportDefaultDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsClassExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CLASS_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CLASS_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsClassExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsClassExpression")
            .field("decorators", &self.decorators())
            .field(
                "class_token",
                &support::DebugSyntaxResult(self.class_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "implements_clause",
                &support::DebugOptionalElement(self.implements_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsClassExpression> for SyntaxNode {
    fn from(n: JsClassExpression) -> SyntaxNode { n.syntax }
}
impl From<JsClassExpression> for SyntaxElement {
    fn from(n: JsClassExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsComputedMemberAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_COMPUTED_MEMBER_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_COMPUTED_MEMBER_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsComputedMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberAssignment")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberAssignment> for SyntaxNode {
    fn from(n: JsComputedMemberAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsComputedMemberAssignment> for SyntaxElement {
    fn from(n: JsComputedMemberAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsComputedMemberExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_COMPUTED_MEMBER_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_COMPUTED_MEMBER_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsComputedMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberExpression")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "optional_chain_token",
                &support::DebugOptionalElement(self.optional_chain_token()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberExpression> for SyntaxNode {
    fn from(n: JsComputedMemberExpression) -> SyntaxNode { n.syntax }
}
impl From<JsComputedMemberExpression> for SyntaxElement {
    fn from(n: JsComputedMemberExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsComputedMemberName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_COMPUTED_MEMBER_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_COMPUTED_MEMBER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsComputedMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsComputedMemberName")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<JsComputedMemberName> for SyntaxNode {
    fn from(n: JsComputedMemberName) -> SyntaxNode { n.syntax }
}
impl From<JsComputedMemberName> for SyntaxElement {
    fn from(n: JsComputedMemberName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsConditionalExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CONDITIONAL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONDITIONAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsConditionalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConditionalExpression")
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field("consequent", &support::DebugSyntaxResult(self.consequent()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("alternate", &support::DebugSyntaxResult(self.alternate()))
            .finish()
    }
}
impl From<JsConditionalExpression> for SyntaxNode {
    fn from(n: JsConditionalExpression) -> SyntaxNode { n.syntax }
}
impl From<JsConditionalExpression> for SyntaxElement {
    fn from(n: JsConditionalExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsConstructorClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CONSTRUCTOR_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONSTRUCTOR_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsConstructorClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConstructorClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsConstructorClassMember> for SyntaxNode {
    fn from(n: JsConstructorClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsConstructorClassMember> for SyntaxElement {
    fn from(n: JsConstructorClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsConstructorParameters {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CONSTRUCTOR_PARAMETERS as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONSTRUCTOR_PARAMETERS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsConstructorParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsConstructorParameters")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameters", &self.parameters())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsConstructorParameters> for SyntaxNode {
    fn from(n: JsConstructorParameters) -> SyntaxNode { n.syntax }
}
impl From<JsConstructorParameters> for SyntaxElement {
    fn from(n: JsConstructorParameters) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsContinueStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CONTINUE_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONTINUE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsContinueStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsContinueStatement")
            .field(
                "continue_token",
                &support::DebugSyntaxResult(self.continue_token()),
            )
            .field(
                "label_token",
                &support::DebugOptionalElement(self.label_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsContinueStatement> for SyntaxNode {
    fn from(n: JsContinueStatement) -> SyntaxNode { n.syntax }
}
impl From<JsContinueStatement> for SyntaxElement {
    fn from(n: JsContinueStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDebuggerStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_DEBUGGER_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DEBUGGER_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDebuggerStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDebuggerStatement")
            .field(
                "debugger_token",
                &support::DebugSyntaxResult(self.debugger_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDebuggerStatement> for SyntaxNode {
    fn from(n: JsDebuggerStatement) -> SyntaxNode { n.syntax }
}
impl From<JsDebuggerStatement> for SyntaxElement {
    fn from(n: JsDebuggerStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDecorator {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_DECORATOR as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DECORATOR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDecorator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDecorator")
            .field("at_token", &support::DebugSyntaxResult(self.at_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<JsDecorator> for SyntaxNode {
    fn from(n: JsDecorator) -> SyntaxNode { n.syntax }
}
impl From<JsDecorator> for SyntaxElement {
    fn from(n: JsDecorator) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDefaultClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_DEFAULT_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DEFAULT_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDefaultClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("consequent", &self.consequent())
            .finish()
    }
}
impl From<JsDefaultClause> for SyntaxNode {
    fn from(n: JsDefaultClause) -> SyntaxNode { n.syntax }
}
impl From<JsDefaultClause> for SyntaxElement {
    fn from(n: JsDefaultClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDefaultImportSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_DEFAULT_IMPORT_SPECIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DEFAULT_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDefaultImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDefaultImportSpecifier")
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field(
                "trailing_comma_token",
                &support::DebugSyntaxResult(self.trailing_comma_token()),
            )
            .finish()
    }
}
impl From<JsDefaultImportSpecifier> for SyntaxNode {
    fn from(n: JsDefaultImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsDefaultImportSpecifier> for SyntaxElement {
    fn from(n: JsDefaultImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDirective {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_DIRECTIVE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DIRECTIVE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDirective")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDirective> for SyntaxNode {
    fn from(n: JsDirective) -> SyntaxNode { n.syntax }
}
impl From<JsDirective> for SyntaxElement {
    fn from(n: JsDirective) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsDoWhileStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_DO_WHILE_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DO_WHILE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsDoWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsDoWhileStatement")
            .field("do_token", &support::DebugSyntaxResult(self.do_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "while_token",
                &support::DebugSyntaxResult(self.while_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsDoWhileStatement> for SyntaxNode {
    fn from(n: JsDoWhileStatement) -> SyntaxNode { n.syntax }
}
impl From<JsDoWhileStatement> for SyntaxElement {
    fn from(n: JsDoWhileStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsElseClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ELSE_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ELSE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsElseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsElseClause")
            .field("else_token", &support::DebugSyntaxResult(self.else_token()))
            .field("alternate", &support::DebugSyntaxResult(self.alternate()))
            .finish()
    }
}
impl From<JsElseClause> for SyntaxNode {
    fn from(n: JsElseClause) -> SyntaxNode { n.syntax }
}
impl From<JsElseClause> for SyntaxElement {
    fn from(n: JsElseClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsEmptyClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EMPTY_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EMPTY_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsEmptyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsEmptyClassMember")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsEmptyClassMember> for SyntaxNode {
    fn from(n: JsEmptyClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsEmptyClassMember> for SyntaxElement {
    fn from(n: JsEmptyClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsEmptyStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EMPTY_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EMPTY_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsEmptyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsEmptyStatement")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsEmptyStatement> for SyntaxNode {
    fn from(n: JsEmptyStatement) -> SyntaxNode { n.syntax }
}
impl From<JsEmptyStatement> for SyntaxElement {
    fn from(n: JsEmptyStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExport {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExport")
            .field("decorators", &self.decorators())
            .field(
                "export_token",
                &support::DebugSyntaxResult(self.export_token()),
            )
            .field(
                "export_clause",
                &support::DebugSyntaxResult(self.export_clause()),
            )
            .finish()
    }
}
impl From<JsExport> for SyntaxNode {
    fn from(n: JsExport) -> SyntaxNode { n.syntax }
}
impl From<JsExport> for SyntaxElement {
    fn from(n: JsExport) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportAsClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_AS_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_AS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportAsClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "exported_name",
                &support::DebugSyntaxResult(self.exported_name()),
            )
            .finish()
    }
}
impl From<JsExportAsClause> for SyntaxNode {
    fn from(n: JsExportAsClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportAsClause> for SyntaxElement {
    fn from(n: JsExportAsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportDefaultDeclarationClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_DEFAULT_DECLARATION_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_DEFAULT_DECLARATION_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportDefaultDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportDefaultDeclarationClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportDefaultDeclarationClause> for SyntaxNode {
    fn from(n: JsExportDefaultDeclarationClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportDefaultDeclarationClause> for SyntaxElement {
    fn from(n: JsExportDefaultDeclarationClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportDefaultExpressionClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportDefaultExpressionClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportDefaultExpressionClause")
            .field(
                "default_token",
                &support::DebugSyntaxResult(self.default_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportDefaultExpressionClause> for SyntaxNode {
    fn from(n: JsExportDefaultExpressionClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportDefaultExpressionClause> for SyntaxElement {
    fn from(n: JsExportDefaultExpressionClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportFromClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_FROM_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_FROM_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportFromClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field(
                "export_as",
                &support::DebugOptionalElement(self.export_as()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "attribute",
                &support::DebugOptionalElement(self.attribute()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportFromClause> for SyntaxNode {
    fn from(n: JsExportFromClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportFromClause> for SyntaxElement {
    fn from(n: JsExportFromClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_NAMED_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportNamedClause> for SyntaxNode {
    fn from(n: JsExportNamedClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedClause> for SyntaxElement {
    fn from(n: JsExportNamedClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedFromClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_NAMED_FROM_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_FROM_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedFromClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "attribute",
                &support::DebugOptionalElement(self.attribute()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExportNamedFromClause> for SyntaxNode {
    fn from(n: JsExportNamedFromClause) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedFromClause> for SyntaxElement {
    fn from(n: JsExportNamedFromClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedFromSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_NAMED_FROM_SPECIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_FROM_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedFromSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedFromSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "source_name",
                &support::DebugSyntaxResult(self.source_name()),
            )
            .field(
                "export_as",
                &support::DebugOptionalElement(self.export_as()),
            )
            .finish()
    }
}
impl From<JsExportNamedFromSpecifier> for SyntaxNode {
    fn from(n: JsExportNamedFromSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedFromSpecifier> for SyntaxElement {
    fn from(n: JsExportNamedFromSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedShorthandSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_NAMED_SHORTHAND_SPECIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_SHORTHAND_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedShorthandSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedShorthandSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsExportNamedShorthandSpecifier> for SyntaxNode {
    fn from(n: JsExportNamedShorthandSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedShorthandSpecifier> for SyntaxElement {
    fn from(n: JsExportNamedShorthandSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExportNamedSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_NAMED_SPECIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExportNamedSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "exported_name",
                &support::DebugSyntaxResult(self.exported_name()),
            )
            .finish()
    }
}
impl From<JsExportNamedSpecifier> for SyntaxNode {
    fn from(n: JsExportNamedSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsExportNamedSpecifier> for SyntaxElement {
    fn from(n: JsExportNamedSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExpressionSnipped {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPRESSION_SNIPPED as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPRESSION_SNIPPED }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExpressionSnipped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExpressionSnipped")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsExpressionSnipped> for SyntaxNode {
    fn from(n: JsExpressionSnipped) -> SyntaxNode { n.syntax }
}
impl From<JsExpressionSnipped> for SyntaxElement {
    fn from(n: JsExpressionSnipped) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExpressionStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPRESSION_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPRESSION_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExpressionStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExpressionStatement")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsExpressionStatement> for SyntaxNode {
    fn from(n: JsExpressionStatement) -> SyntaxNode { n.syntax }
}
impl From<JsExpressionStatement> for SyntaxElement {
    fn from(n: JsExpressionStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsExtendsClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXTENDS_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXTENDS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsExtendsClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field(
                "super_class",
                &support::DebugSyntaxResult(self.super_class()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<JsExtendsClause> for SyntaxNode {
    fn from(n: JsExtendsClause) -> SyntaxNode { n.syntax }
}
impl From<JsExtendsClause> for SyntaxElement {
    fn from(n: JsExtendsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFinallyClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FINALLY_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FINALLY_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFinallyClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFinallyClause")
            .field(
                "finally_token",
                &support::DebugSyntaxResult(self.finally_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFinallyClause> for SyntaxNode {
    fn from(n: JsFinallyClause) -> SyntaxNode { n.syntax }
}
impl From<JsFinallyClause> for SyntaxElement {
    fn from(n: JsFinallyClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsForInStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FOR_IN_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FOR_IN_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsForInStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForInStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugSyntaxResult(self.initializer()),
            )
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForInStatement> for SyntaxNode {
    fn from(n: JsForInStatement) -> SyntaxNode { n.syntax }
}
impl From<JsForInStatement> for SyntaxElement {
    fn from(n: JsForInStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsForOfStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FOR_OF_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FOR_OF_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsForOfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForOfStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "await_token",
                &support::DebugOptionalElement(self.await_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugSyntaxResult(self.initializer()),
            )
            .field("of_token", &support::DebugSyntaxResult(self.of_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForOfStatement> for SyntaxNode {
    fn from(n: JsForOfStatement) -> SyntaxNode { n.syntax }
}
impl From<JsForOfStatement> for SyntaxElement {
    fn from(n: JsForOfStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsForStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FOR_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FOR_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsForStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForStatement")
            .field("for_token", &support::DebugSyntaxResult(self.for_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .field(
                "first_semi_token",
                &support::DebugSyntaxResult(self.first_semi_token()),
            )
            .field("test", &support::DebugOptionalElement(self.test()))
            .field(
                "second_semi_token",
                &support::DebugSyntaxResult(self.second_semi_token()),
            )
            .field("update", &support::DebugOptionalElement(self.update()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsForStatement> for SyntaxNode {
    fn from(n: JsForStatement) -> SyntaxNode { n.syntax }
}
impl From<JsForStatement> for SyntaxElement {
    fn from(n: JsForStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsForVariableDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FOR_VARIABLE_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FOR_VARIABLE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsForVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsForVariableDeclaration")
            .field("kind_token", &support::DebugSyntaxResult(self.kind_token()))
            .field("declarator", &support::DebugSyntaxResult(self.declarator()))
            .finish()
    }
}
impl From<JsForVariableDeclaration> for SyntaxNode {
    fn from(n: JsForVariableDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsForVariableDeclaration> for SyntaxElement {
    fn from(n: JsForVariableDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFormalParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FORMAL_PARAMETER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FORMAL_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFormalParameter")
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsFormalParameter> for SyntaxNode {
    fn from(n: JsFormalParameter) -> SyntaxNode { n.syntax }
}
impl From<JsFormalParameter> for SyntaxElement {
    fn from(n: JsFormalParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFunctionBody {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FUNCTION_BODY as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FUNCTION_BODY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionBody")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("directives", &self.directives())
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsFunctionBody> for SyntaxNode {
    fn from(n: JsFunctionBody) -> SyntaxNode { n.syntax }
}
impl From<JsFunctionBody> for SyntaxElement {
    fn from(n: JsFunctionBody) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFunctionDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FUNCTION_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FUNCTION_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionDeclaration> for SyntaxNode {
    fn from(n: JsFunctionDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsFunctionDeclaration> for SyntaxElement {
    fn from(n: JsFunctionDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFunctionExportDefaultDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FUNCTION_EXPORT_DEFAULT_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FUNCTION_EXPORT_DEFAULT_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFunctionExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionExportDefaultDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionExportDefaultDeclaration> for SyntaxNode {
    fn from(n: JsFunctionExportDefaultDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsFunctionExportDefaultDeclaration> for SyntaxElement {
    fn from(n: JsFunctionExportDefaultDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsFunctionExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_FUNCTION_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_FUNCTION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsFunctionExpression")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsFunctionExpression> for SyntaxNode {
    fn from(n: JsFunctionExpression) -> SyntaxNode { n.syntax }
}
impl From<JsFunctionExpression> for SyntaxElement {
    fn from(n: JsFunctionExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsGetterClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_GETTER_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_GETTER_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsGetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsGetterClassMember")
            .field("modifiers", &self.modifiers())
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsGetterClassMember> for SyntaxNode {
    fn from(n: JsGetterClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsGetterClassMember> for SyntaxElement {
    fn from(n: JsGetterClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsGetterObjectMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_GETTER_OBJECT_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_GETTER_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsGetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsGetterObjectMember")
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsGetterObjectMember> for SyntaxNode {
    fn from(n: JsGetterObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsGetterObjectMember> for SyntaxElement {
    fn from(n: JsGetterObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsIdentifierAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IDENTIFIER_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IDENTIFIER_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsIdentifierAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierAssignment")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<JsIdentifierAssignment> for SyntaxNode {
    fn from(n: JsIdentifierAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsIdentifierAssignment> for SyntaxElement {
    fn from(n: JsIdentifierAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsIdentifierBinding {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IDENTIFIER_BINDING as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IDENTIFIER_BINDING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierBinding")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<JsIdentifierBinding> for SyntaxNode {
    fn from(n: JsIdentifierBinding) -> SyntaxNode { n.syntax }
}
impl From<JsIdentifierBinding> for SyntaxElement {
    fn from(n: JsIdentifierBinding) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsIdentifierExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IDENTIFIER_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IDENTIFIER_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsIdentifierExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIdentifierExpression")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsIdentifierExpression> for SyntaxNode {
    fn from(n: JsIdentifierExpression) -> SyntaxNode { n.syntax }
}
impl From<JsIdentifierExpression> for SyntaxElement {
    fn from(n: JsIdentifierExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsIfStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IF_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IF_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsIfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsIfStatement")
            .field("if_token", &support::DebugSyntaxResult(self.if_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("consequent", &support::DebugSyntaxResult(self.consequent()))
            .field(
                "else_clause",
                &support::DebugOptionalElement(self.else_clause()),
            )
            .finish()
    }
}
impl From<JsIfStatement> for SyntaxNode {
    fn from(n: JsIfStatement) -> SyntaxNode { n.syntax }
}
impl From<JsIfStatement> for SyntaxElement {
    fn from(n: JsIfStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImport {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImport")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "import_clause",
                &support::DebugSyntaxResult(self.import_clause()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsImport> for SyntaxNode {
    fn from(n: JsImport) -> SyntaxNode { n.syntax }
}
impl From<JsImport> for SyntaxElement {
    fn from(n: JsImport) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportAttribute {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_ATTRIBUTE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_ATTRIBUTE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportAttribute")
            .field("with_token", &support::DebugSyntaxResult(self.with_token()))
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("attributes", &self.attributes())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsImportAttribute> for SyntaxNode {
    fn from(n: JsImportAttribute) -> SyntaxNode { n.syntax }
}
impl From<JsImportAttribute> for SyntaxElement {
    fn from(n: JsImportAttribute) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportAttributeEntry {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_ATTRIBUTE_ENTRY as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_ATTRIBUTE_ENTRY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportAttributeEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportAttributeEntry")
            .field("key", &support::DebugSyntaxResult(self.key()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsImportAttributeEntry> for SyntaxNode {
    fn from(n: JsImportAttributeEntry) -> SyntaxNode { n.syntax }
}
impl From<JsImportAttributeEntry> for SyntaxElement {
    fn from(n: JsImportAttributeEntry) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportBareClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_BARE_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_BARE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportBareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportBareClause")
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "attribute",
                &support::DebugOptionalElement(self.attribute()),
            )
            .finish()
    }
}
impl From<JsImportBareClause> for SyntaxNode {
    fn from(n: JsImportBareClause) -> SyntaxNode { n.syntax }
}
impl From<JsImportBareClause> for SyntaxElement {
    fn from(n: JsImportBareClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportCallExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_CALL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_CALL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportCallExpression")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field("arguments", &support::DebugSyntaxResult(self.arguments()))
            .finish()
    }
}
impl From<JsImportCallExpression> for SyntaxNode {
    fn from(n: JsImportCallExpression) -> SyntaxNode { n.syntax }
}
impl From<JsImportCallExpression> for SyntaxElement {
    fn from(n: JsImportCallExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportDefaultClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_DEFAULT_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_DEFAULT_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportDefaultClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "attribute",
                &support::DebugOptionalElement(self.attribute()),
            )
            .finish()
    }
}
impl From<JsImportDefaultClause> for SyntaxNode {
    fn from(n: JsImportDefaultClause) -> SyntaxNode { n.syntax }
}
impl From<JsImportDefaultClause> for SyntaxElement {
    fn from(n: JsImportDefaultClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportMetaExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_META_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_META_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportMetaExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportMetaExpression")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("meta_token", &support::DebugSyntaxResult(self.meta_token()))
            .finish()
    }
}
impl From<JsImportMetaExpression> for SyntaxNode {
    fn from(n: JsImportMetaExpression) -> SyntaxNode { n.syntax }
}
impl From<JsImportMetaExpression> for SyntaxElement {
    fn from(n: JsImportMetaExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportNamedClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_NAMED_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_NAMED_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportNamedClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field(
                "default_specifier",
                &support::DebugOptionalElement(self.default_specifier()),
            )
            .field(
                "named_import",
                &support::DebugSyntaxResult(self.named_import()),
            )
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "attribute",
                &support::DebugOptionalElement(self.attribute()),
            )
            .finish()
    }
}
impl From<JsImportNamedClause> for SyntaxNode {
    fn from(n: JsImportNamedClause) -> SyntaxNode { n.syntax }
}
impl From<JsImportNamedClause> for SyntaxElement {
    fn from(n: JsImportNamedClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsImportNamespaceClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_NAMESPACE_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_NAMESPACE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsImportNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsImportNamespaceClause")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .field("from_token", &support::DebugSyntaxResult(self.from_token()))
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "attribute",
                &support::DebugOptionalElement(self.attribute()),
            )
            .finish()
    }
}
impl From<JsImportNamespaceClause> for SyntaxNode {
    fn from(n: JsImportNamespaceClause) -> SyntaxNode { n.syntax }
}
impl From<JsImportNamespaceClause> for SyntaxElement {
    fn from(n: JsImportNamespaceClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsInExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IN_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IN_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsInExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInExpression")
            .field("property", &support::DebugSyntaxResult(self.property()))
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("object", &support::DebugSyntaxResult(self.object()))
            .finish()
    }
}
impl From<JsInExpression> for SyntaxNode {
    fn from(n: JsInExpression) -> SyntaxNode { n.syntax }
}
impl From<JsInExpression> for SyntaxElement {
    fn from(n: JsInExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsInitializerClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_INITIALIZER_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_INITIALIZER_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInitializerClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<JsInitializerClause> for SyntaxNode {
    fn from(n: JsInitializerClause) -> SyntaxNode { n.syntax }
}
impl From<JsInitializerClause> for SyntaxElement {
    fn from(n: JsInitializerClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsInstanceofExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_INSTANCEOF_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_INSTANCEOF_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsInstanceofExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsInstanceofExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "instanceof_token",
                &support::DebugSyntaxResult(self.instanceof_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsInstanceofExpression> for SyntaxNode {
    fn from(n: JsInstanceofExpression) -> SyntaxNode { n.syntax }
}
impl From<JsInstanceofExpression> for SyntaxElement {
    fn from(n: JsInstanceofExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsLabeledStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_LABELED_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_LABELED_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsLabeledStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLabeledStatement")
            .field(
                "label_token",
                &support::DebugSyntaxResult(self.label_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsLabeledStatement> for SyntaxNode {
    fn from(n: JsLabeledStatement) -> SyntaxNode { n.syntax }
}
impl From<JsLabeledStatement> for SyntaxElement {
    fn from(n: JsLabeledStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsLiteralExportName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_LITERAL_EXPORT_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_LITERAL_EXPORT_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsLiteralExportName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLiteralExportName")
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsLiteralExportName> for SyntaxNode {
    fn from(n: JsLiteralExportName) -> SyntaxNode { n.syntax }
}
impl From<JsLiteralExportName> for SyntaxElement {
    fn from(n: JsLiteralExportName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsLiteralMemberName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_LITERAL_MEMBER_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_LITERAL_MEMBER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsLiteralMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLiteralMemberName")
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsLiteralMemberName> for SyntaxNode {
    fn from(n: JsLiteralMemberName) -> SyntaxNode { n.syntax }
}
impl From<JsLiteralMemberName> for SyntaxElement {
    fn from(n: JsLiteralMemberName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsLogicalExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_LOGICAL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_LOGICAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsLogicalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsLogicalExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsLogicalExpression> for SyntaxNode {
    fn from(n: JsLogicalExpression) -> SyntaxNode { n.syntax }
}
impl From<JsLogicalExpression> for SyntaxElement {
    fn from(n: JsLogicalExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsMethodClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_METHOD_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_METHOD_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsMethodClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsMethodClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsMethodClassMember> for SyntaxNode {
    fn from(n: JsMethodClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsMethodClassMember> for SyntaxElement {
    fn from(n: JsMethodClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsMethodObjectMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_METHOD_OBJECT_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_METHOD_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsMethodObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsMethodObjectMember")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsMethodObjectMember> for SyntaxNode {
    fn from(n: JsMethodObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsMethodObjectMember> for SyntaxElement {
    fn from(n: JsMethodObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsModule {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_MODULE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_MODULE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsModule")
            .field(
                "interpreter_token",
                &support::DebugOptionalElement(self.interpreter_token()),
            )
            .field("directives", &self.directives())
            .field("items", &self.items())
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsModule> for SyntaxNode {
    fn from(n: JsModule) -> SyntaxNode { n.syntax }
}
impl From<JsModule> for SyntaxElement {
    fn from(n: JsModule) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsModuleSource {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_MODULE_SOURCE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_MODULE_SOURCE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsModuleSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsModuleSource")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsModuleSource> for SyntaxNode {
    fn from(n: JsModuleSource) -> SyntaxNode { n.syntax }
}
impl From<JsModuleSource> for SyntaxElement {
    fn from(n: JsModuleSource) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsName")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsName> for SyntaxNode {
    fn from(n: JsName) -> SyntaxNode { n.syntax }
}
impl From<JsName> for SyntaxElement {
    fn from(n: JsName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNamedImportSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NAMED_IMPORT_SPECIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAMED_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamedImportSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsNamedImportSpecifier> for SyntaxNode {
    fn from(n: JsNamedImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsNamedImportSpecifier> for SyntaxElement {
    fn from(n: JsNamedImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNamedImportSpecifiers {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NAMED_IMPORT_SPECIFIERS as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAMED_IMPORT_SPECIFIERS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNamedImportSpecifiers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamedImportSpecifiers")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("specifiers", &self.specifiers())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsNamedImportSpecifiers> for SyntaxNode {
    fn from(n: JsNamedImportSpecifiers) -> SyntaxNode { n.syntax }
}
impl From<JsNamedImportSpecifiers> for SyntaxElement {
    fn from(n: JsNamedImportSpecifiers) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNamespaceImportSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NAMESPACE_IMPORT_SPECIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAMESPACE_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNamespaceImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNamespaceImportSpecifier")
            .field("star_token", &support::DebugSyntaxResult(self.star_token()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsNamespaceImportSpecifier> for SyntaxNode {
    fn from(n: JsNamespaceImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsNamespaceImportSpecifier> for SyntaxElement {
    fn from(n: JsNamespaceImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNewExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NEW_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NEW_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNewExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNewExpression")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field("callee", &support::DebugSyntaxResult(self.callee()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field(
                "arguments",
                &support::DebugOptionalElement(self.arguments()),
            )
            .finish()
    }
}
impl From<JsNewExpression> for SyntaxNode {
    fn from(n: JsNewExpression) -> SyntaxNode { n.syntax }
}
impl From<JsNewExpression> for SyntaxElement {
    fn from(n: JsNewExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNewTargetExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NEW_TARGET_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NEW_TARGET_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNewTargetExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNewTargetExpression")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field(
                "target_token",
                &support::DebugSyntaxResult(self.target_token()),
            )
            .finish()
    }
}
impl From<JsNewTargetExpression> for SyntaxNode {
    fn from(n: JsNewTargetExpression) -> SyntaxNode { n.syntax }
}
impl From<JsNewTargetExpression> for SyntaxElement {
    fn from(n: JsNewTargetExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNullLiteralExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NULL_LITERAL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NULL_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNullLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNullLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsNullLiteralExpression> for SyntaxNode {
    fn from(n: JsNullLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsNullLiteralExpression> for SyntaxElement {
    fn from(n: JsNullLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsNumberLiteralExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NUMBER_LITERAL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NUMBER_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsNumberLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsNumberLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsNumberLiteralExpression> for SyntaxNode {
    fn from(n: JsNumberLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsNumberLiteralExpression> for SyntaxElement {
    fn from(n: JsNumberLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectAssignmentPattern {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_OBJECT_ASSIGNMENT_PATTERN as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_ASSIGNMENT_PATTERN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPattern")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("properties", &self.properties())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectAssignmentPattern> for SyntaxNode {
    fn from(n: JsObjectAssignmentPattern) -> SyntaxNode { n.syntax }
}
impl From<JsObjectAssignmentPattern> for SyntaxElement {
    fn from(n: JsObjectAssignmentPattern) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectAssignmentPatternProperty {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectAssignmentPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternProperty")
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternProperty> for SyntaxNode {
    fn from(n: JsObjectAssignmentPatternProperty) -> SyntaxNode { n.syntax }
}
impl From<JsObjectAssignmentPatternProperty> for SyntaxElement {
    fn from(n: JsObjectAssignmentPatternProperty) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectAssignmentPatternRest {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_OBJECT_ASSIGNMENT_PATTERN_REST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_ASSIGNMENT_PATTERN_REST }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectAssignmentPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternRest")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("target", &support::DebugSyntaxResult(self.target()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternRest> for SyntaxNode {
    fn from(n: JsObjectAssignmentPatternRest) -> SyntaxNode { n.syntax }
}
impl From<JsObjectAssignmentPatternRest> for SyntaxElement {
    fn from(n: JsObjectAssignmentPatternRest) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectAssignmentPatternShorthandProperty {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectAssignmentPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectAssignmentPatternShorthandProperty")
            .field("identifier", &support::DebugSyntaxResult(self.identifier()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for SyntaxNode {
    fn from(n: JsObjectAssignmentPatternShorthandProperty) -> SyntaxNode { n.syntax }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for SyntaxElement {
    fn from(n: JsObjectAssignmentPatternShorthandProperty) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectBindingPattern {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_OBJECT_BINDING_PATTERN as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPattern")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("properties", &self.properties())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectBindingPattern> for SyntaxNode {
    fn from(n: JsObjectBindingPattern) -> SyntaxNode { n.syntax }
}
impl From<JsObjectBindingPattern> for SyntaxElement {
    fn from(n: JsObjectBindingPattern) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectBindingPatternProperty {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_OBJECT_BINDING_PATTERN_PROPERTY as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN_PROPERTY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectBindingPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternProperty")
            .field("member", &support::DebugSyntaxResult(self.member()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("pattern", &support::DebugSyntaxResult(self.pattern()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectBindingPatternProperty> for SyntaxNode {
    fn from(n: JsObjectBindingPatternProperty) -> SyntaxNode { n.syntax }
}
impl From<JsObjectBindingPatternProperty> for SyntaxElement {
    fn from(n: JsObjectBindingPatternProperty) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectBindingPatternRest {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_OBJECT_BINDING_PATTERN_REST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN_REST }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectBindingPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternRest")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .finish()
    }
}
impl From<JsObjectBindingPatternRest> for SyntaxNode {
    fn from(n: JsObjectBindingPatternRest) -> SyntaxNode { n.syntax }
}
impl From<JsObjectBindingPatternRest> for SyntaxElement {
    fn from(n: JsObjectBindingPatternRest) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectBindingPatternShorthandProperty {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectBindingPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectBindingPatternShorthandProperty")
            .field("identifier", &support::DebugSyntaxResult(self.identifier()))
            .field("init", &support::DebugOptionalElement(self.init()))
            .finish()
    }
}
impl From<JsObjectBindingPatternShorthandProperty> for SyntaxNode {
    fn from(n: JsObjectBindingPatternShorthandProperty) -> SyntaxNode { n.syntax }
}
impl From<JsObjectBindingPatternShorthandProperty> for SyntaxElement {
    fn from(n: JsObjectBindingPatternShorthandProperty) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsObjectExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_OBJECT_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsObjectExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsObjectExpression")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsObjectExpression> for SyntaxNode {
    fn from(n: JsObjectExpression) -> SyntaxNode { n.syntax }
}
impl From<JsObjectExpression> for SyntaxElement {
    fn from(n: JsObjectExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsParameters {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PARAMETERS as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PARAMETERS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParameters")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("items", &self.items())
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParameters> for SyntaxNode {
    fn from(n: JsParameters) -> SyntaxNode { n.syntax }
}
impl From<JsParameters> for SyntaxElement {
    fn from(n: JsParameters) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsParenthesizedAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PARENTHESIZED_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PARENTHESIZED_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsParenthesizedAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParenthesizedAssignment")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParenthesizedAssignment> for SyntaxNode {
    fn from(n: JsParenthesizedAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsParenthesizedAssignment> for SyntaxElement {
    fn from(n: JsParenthesizedAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsParenthesizedExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PARENTHESIZED_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PARENTHESIZED_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsParenthesizedExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsParenthesizedExpression")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<JsParenthesizedExpression> for SyntaxNode {
    fn from(n: JsParenthesizedExpression) -> SyntaxNode { n.syntax }
}
impl From<JsParenthesizedExpression> for SyntaxElement {
    fn from(n: JsParenthesizedExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPostUpdateExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_POST_UPDATE_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_POST_UPDATE_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPostUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPostUpdateExpression")
            .field("operand", &support::DebugSyntaxResult(self.operand()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .finish()
    }
}
impl From<JsPostUpdateExpression> for SyntaxNode {
    fn from(n: JsPostUpdateExpression) -> SyntaxNode { n.syntax }
}
impl From<JsPostUpdateExpression> for SyntaxElement {
    fn from(n: JsPostUpdateExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPreUpdateExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PRE_UPDATE_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PRE_UPDATE_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPreUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPreUpdateExpression")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("operand", &support::DebugSyntaxResult(self.operand()))
            .finish()
    }
}
impl From<JsPreUpdateExpression> for SyntaxNode {
    fn from(n: JsPreUpdateExpression) -> SyntaxNode { n.syntax }
}
impl From<JsPreUpdateExpression> for SyntaxElement {
    fn from(n: JsPreUpdateExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPrivateClassMemberName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PRIVATE_CLASS_MEMBER_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PRIVATE_CLASS_MEMBER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPrivateClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPrivateClassMemberName")
            .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
            .field("id_token", &support::DebugSyntaxResult(self.id_token()))
            .finish()
    }
}
impl From<JsPrivateClassMemberName> for SyntaxNode {
    fn from(n: JsPrivateClassMemberName) -> SyntaxNode { n.syntax }
}
impl From<JsPrivateClassMemberName> for SyntaxElement {
    fn from(n: JsPrivateClassMemberName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPrivateName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PRIVATE_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PRIVATE_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPrivateName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPrivateName")
            .field("hash_token", &support::DebugSyntaxResult(self.hash_token()))
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsPrivateName> for SyntaxNode {
    fn from(n: JsPrivateName) -> SyntaxNode { n.syntax }
}
impl From<JsPrivateName> for SyntaxElement {
    fn from(n: JsPrivateName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPropertyClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PROPERTY_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PROPERTY_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPropertyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPropertyClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "property_annotation",
                &support::DebugOptionalElement(self.property_annotation()),
            )
            .field("value", &support::DebugOptionalElement(self.value()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsPropertyClassMember> for SyntaxNode {
    fn from(n: JsPropertyClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsPropertyClassMember> for SyntaxElement {
    fn from(n: JsPropertyClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsPropertyObjectMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PROPERTY_OBJECT_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PROPERTY_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsPropertyObjectMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsPropertyObjectMember> for SyntaxNode {
    fn from(n: JsPropertyObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsPropertyObjectMember> for SyntaxElement {
    fn from(n: JsPropertyObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsReferenceIdentifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_REFERENCE_IDENTIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_REFERENCE_IDENTIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsReferenceIdentifier")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsReferenceIdentifier> for SyntaxNode {
    fn from(n: JsReferenceIdentifier) -> SyntaxNode { n.syntax }
}
impl From<JsReferenceIdentifier> for SyntaxElement {
    fn from(n: JsReferenceIdentifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsRegexLiteralExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_REGEX_LITERAL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_REGEX_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsRegexLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsRegexLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsRegexLiteralExpression> for SyntaxNode {
    fn from(n: JsRegexLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsRegexLiteralExpression> for SyntaxElement {
    fn from(n: JsRegexLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsRestParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_REST_PARAMETER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_REST_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsRestParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsRestParameter")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<JsRestParameter> for SyntaxNode {
    fn from(n: JsRestParameter) -> SyntaxNode { n.syntax }
}
impl From<JsRestParameter> for SyntaxElement {
    fn from(n: JsRestParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsReturnStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_RETURN_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_RETURN_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsReturnStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsReturnStatement")
            .field(
                "return_token",
                &support::DebugSyntaxResult(self.return_token()),
            )
            .field("argument", &support::DebugOptionalElement(self.argument()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsReturnStatement> for SyntaxNode {
    fn from(n: JsReturnStatement) -> SyntaxNode { n.syntax }
}
impl From<JsReturnStatement> for SyntaxElement {
    fn from(n: JsReturnStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsScript {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SCRIPT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SCRIPT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsScript")
            .field(
                "interpreter_token",
                &support::DebugOptionalElement(self.interpreter_token()),
            )
            .field("directives", &self.directives())
            .field("statements", &self.statements())
            .field("eof_token", &support::DebugSyntaxResult(self.eof_token()))
            .finish()
    }
}
impl From<JsScript> for SyntaxNode {
    fn from(n: JsScript) -> SyntaxNode { n.syntax }
}
impl From<JsScript> for SyntaxElement {
    fn from(n: JsScript) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSequenceExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SEQUENCE_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SEQUENCE_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSequenceExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSequenceExpression")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field(
                "comma_token",
                &support::DebugSyntaxResult(self.comma_token()),
            )
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<JsSequenceExpression> for SyntaxNode {
    fn from(n: JsSequenceExpression) -> SyntaxNode { n.syntax }
}
impl From<JsSequenceExpression> for SyntaxElement {
    fn from(n: JsSequenceExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSetterClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SETTER_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SETTER_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSetterClassMember")
            .field("modifiers", &self.modifiers())
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsSetterClassMember> for SyntaxNode {
    fn from(n: JsSetterClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsSetterClassMember> for SyntaxElement {
    fn from(n: JsSetterClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSetterObjectMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SETTER_OBJECT_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SETTER_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSetterObjectMember")
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsSetterObjectMember> for SyntaxNode {
    fn from(n: JsSetterObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsSetterObjectMember> for SyntaxElement {
    fn from(n: JsSetterObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsShorthandNamedImportSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SHORTHAND_NAMED_IMPORT_SPECIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SHORTHAND_NAMED_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsShorthandNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsShorthandNamedImportSpecifier")
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("local_name", &support::DebugSyntaxResult(self.local_name()))
            .finish()
    }
}
impl From<JsShorthandNamedImportSpecifier> for SyntaxNode {
    fn from(n: JsShorthandNamedImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsShorthandNamedImportSpecifier> for SyntaxElement {
    fn from(n: JsShorthandNamedImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsShorthandPropertyObjectMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SHORTHAND_PROPERTY_OBJECT_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SHORTHAND_PROPERTY_OBJECT_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsShorthandPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsShorthandPropertyObjectMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsShorthandPropertyObjectMember> for SyntaxNode {
    fn from(n: JsShorthandPropertyObjectMember) -> SyntaxNode { n.syntax }
}
impl From<JsShorthandPropertyObjectMember> for SyntaxElement {
    fn from(n: JsShorthandPropertyObjectMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSpread {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SPREAD as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SPREAD }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSpread {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSpread")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsSpread> for SyntaxNode {
    fn from(n: JsSpread) -> SyntaxNode { n.syntax }
}
impl From<JsSpread> for SyntaxElement {
    fn from(n: JsSpread) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStaticInitializationBlockClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStaticInitializationBlockClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticInitializationBlockClassMember")
            .field(
                "static_token",
                &support::DebugSyntaxResult(self.static_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("statements", &self.statements())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsStaticInitializationBlockClassMember> for SyntaxNode {
    fn from(n: JsStaticInitializationBlockClassMember) -> SyntaxNode { n.syntax }
}
impl From<JsStaticInitializationBlockClassMember> for SyntaxElement {
    fn from(n: JsStaticInitializationBlockClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStaticMemberAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_STATIC_MEMBER_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATIC_MEMBER_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStaticMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticMemberAssignment")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsStaticMemberAssignment> for SyntaxNode {
    fn from(n: JsStaticMemberAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsStaticMemberAssignment> for SyntaxElement {
    fn from(n: JsStaticMemberAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStaticMemberExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_STATIC_MEMBER_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATIC_MEMBER_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStaticMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticMemberExpression")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsStaticMemberExpression> for SyntaxNode {
    fn from(n: JsStaticMemberExpression) -> SyntaxNode { n.syntax }
}
impl From<JsStaticMemberExpression> for SyntaxElement {
    fn from(n: JsStaticMemberExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStaticModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_STATIC_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATIC_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStaticModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStaticModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<JsStaticModifier> for SyntaxNode {
    fn from(n: JsStaticModifier) -> SyntaxNode { n.syntax }
}
impl From<JsStaticModifier> for SyntaxElement {
    fn from(n: JsStaticModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsStringLiteralExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_STRING_LITERAL_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STRING_LITERAL_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsStringLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsStringLiteralExpression")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsStringLiteralExpression> for SyntaxNode {
    fn from(n: JsStringLiteralExpression) -> SyntaxNode { n.syntax }
}
impl From<JsStringLiteralExpression> for SyntaxElement {
    fn from(n: JsStringLiteralExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSuperExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SUPER_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SUPER_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSuperExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSuperExpression")
            .field(
                "super_token",
                &support::DebugSyntaxResult(self.super_token()),
            )
            .finish()
    }
}
impl From<JsSuperExpression> for SyntaxNode {
    fn from(n: JsSuperExpression) -> SyntaxNode { n.syntax }
}
impl From<JsSuperExpression> for SyntaxElement {
    fn from(n: JsSuperExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsSwitchStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SWITCH_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SWITCH_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsSwitchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsSwitchStatement")
            .field(
                "switch_token",
                &support::DebugSyntaxResult(self.switch_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "discriminant",
                &support::DebugSyntaxResult(self.discriminant()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("cases", &self.cases())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsSwitchStatement> for SyntaxNode {
    fn from(n: JsSwitchStatement) -> SyntaxNode { n.syntax }
}
impl From<JsSwitchStatement> for SyntaxElement {
    fn from(n: JsSwitchStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTemplateChunkElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_TEMPLATE_CHUNK_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TEMPLATE_CHUNK_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplateChunkElement")
            .field(
                "template_chunk_token",
                &support::DebugSyntaxResult(self.template_chunk_token()),
            )
            .finish()
    }
}
impl From<JsTemplateChunkElement> for SyntaxNode {
    fn from(n: JsTemplateChunkElement) -> SyntaxNode { n.syntax }
}
impl From<JsTemplateChunkElement> for SyntaxElement {
    fn from(n: JsTemplateChunkElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTemplateElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_TEMPLATE_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TEMPLATE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplateElement")
            .field(
                "dollar_curly_token",
                &support::DebugSyntaxResult(self.dollar_curly_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsTemplateElement> for SyntaxNode {
    fn from(n: JsTemplateElement) -> SyntaxNode { n.syntax }
}
impl From<JsTemplateElement> for SyntaxElement {
    fn from(n: JsTemplateElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTemplateExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_TEMPLATE_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TEMPLATE_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTemplateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTemplateExpression")
            .field("tag", &support::DebugOptionalElement(self.tag()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field(
                "l_tick_token",
                &support::DebugSyntaxResult(self.l_tick_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_tick_token",
                &support::DebugSyntaxResult(self.r_tick_token()),
            )
            .finish()
    }
}
impl From<JsTemplateExpression> for SyntaxNode {
    fn from(n: JsTemplateExpression) -> SyntaxNode { n.syntax }
}
impl From<JsTemplateExpression> for SyntaxElement {
    fn from(n: JsTemplateExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsThisExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_THIS_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_THIS_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsThisExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsThisExpression")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .finish()
    }
}
impl From<JsThisExpression> for SyntaxNode {
    fn from(n: JsThisExpression) -> SyntaxNode { n.syntax }
}
impl From<JsThisExpression> for SyntaxElement {
    fn from(n: JsThisExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsThrowStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_THROW_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_THROW_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsThrowStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsThrowStatement")
            .field(
                "throw_token",
                &support::DebugSyntaxResult(self.throw_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsThrowStatement> for SyntaxNode {
    fn from(n: JsThrowStatement) -> SyntaxNode { n.syntax }
}
impl From<JsThrowStatement> for SyntaxElement {
    fn from(n: JsThrowStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTryFinallyStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_TRY_FINALLY_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TRY_FINALLY_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTryFinallyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTryFinallyStatement")
            .field("try_token", &support::DebugSyntaxResult(self.try_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "catch_clause",
                &support::DebugOptionalElement(self.catch_clause()),
            )
            .field(
                "finally_clause",
                &support::DebugSyntaxResult(self.finally_clause()),
            )
            .finish()
    }
}
impl From<JsTryFinallyStatement> for SyntaxNode {
    fn from(n: JsTryFinallyStatement) -> SyntaxNode { n.syntax }
}
impl From<JsTryFinallyStatement> for SyntaxElement {
    fn from(n: JsTryFinallyStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsTryStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_TRY_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TRY_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsTryStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsTryStatement")
            .field("try_token", &support::DebugSyntaxResult(self.try_token()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .field(
                "catch_clause",
                &support::DebugSyntaxResult(self.catch_clause()),
            )
            .finish()
    }
}
impl From<JsTryStatement> for SyntaxNode {
    fn from(n: JsTryStatement) -> SyntaxNode { n.syntax }
}
impl From<JsTryStatement> for SyntaxElement {
    fn from(n: JsTryStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsUnaryExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_UNARY_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_UNARY_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsUnaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsUnaryExpression")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .finish()
    }
}
impl From<JsUnaryExpression> for SyntaxNode {
    fn from(n: JsUnaryExpression) -> SyntaxNode { n.syntax }
}
impl From<JsUnaryExpression> for SyntaxElement {
    fn from(n: JsUnaryExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsVariableDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_VARIABLE_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclaration")
            .field("kind", &support::DebugSyntaxResult(self.kind()))
            .field("declarators", &self.declarators())
            .finish()
    }
}
impl From<JsVariableDeclaration> for SyntaxNode {
    fn from(n: JsVariableDeclaration) -> SyntaxNode { n.syntax }
}
impl From<JsVariableDeclaration> for SyntaxElement {
    fn from(n: JsVariableDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsVariableDeclarationClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_VARIABLE_DECLARATION_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_DECLARATION_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsVariableDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclarationClause")
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsVariableDeclarationClause> for SyntaxNode {
    fn from(n: JsVariableDeclarationClause) -> SyntaxNode { n.syntax }
}
impl From<JsVariableDeclarationClause> for SyntaxElement {
    fn from(n: JsVariableDeclarationClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsVariableDeclarator {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_VARIABLE_DECLARATOR as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_DECLARATOR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsVariableDeclarator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableDeclarator")
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "variable_annotation",
                &support::DebugOptionalElement(self.variable_annotation()),
            )
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsVariableDeclarator> for SyntaxNode {
    fn from(n: JsVariableDeclarator) -> SyntaxNode { n.syntax }
}
impl From<JsVariableDeclarator> for SyntaxElement {
    fn from(n: JsVariableDeclarator) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsVariableStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_VARIABLE_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsVariableStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsVariableStatement")
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<JsVariableStatement> for SyntaxNode {
    fn from(n: JsVariableStatement) -> SyntaxNode { n.syntax }
}
impl From<JsVariableStatement> for SyntaxElement {
    fn from(n: JsVariableStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsWhileStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_WHILE_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_WHILE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsWhileStatement")
            .field(
                "while_token",
                &support::DebugSyntaxResult(self.while_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("test", &support::DebugSyntaxResult(self.test()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsWhileStatement> for SyntaxNode {
    fn from(n: JsWhileStatement) -> SyntaxNode { n.syntax }
}
impl From<JsWhileStatement> for SyntaxElement {
    fn from(n: JsWhileStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsWithStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_WITH_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_WITH_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsWithStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsWithStatement")
            .field("with_token", &support::DebugSyntaxResult(self.with_token()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<JsWithStatement> for SyntaxNode {
    fn from(n: JsWithStatement) -> SyntaxNode { n.syntax }
}
impl From<JsWithStatement> for SyntaxElement {
    fn from(n: JsWithStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsYieldArgument {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_YIELD_ARGUMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_YIELD_ARGUMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsYieldArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsYieldArgument")
            .field(
                "star_token",
                &support::DebugOptionalElement(self.star_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<JsYieldArgument> for SyntaxNode {
    fn from(n: JsYieldArgument) -> SyntaxNode { n.syntax }
}
impl From<JsYieldArgument> for SyntaxElement {
    fn from(n: JsYieldArgument) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsYieldExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_YIELD_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_YIELD_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsYieldExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsYieldExpression")
            .field(
                "yield_token",
                &support::DebugSyntaxResult(self.yield_token()),
            )
            .field("argument", &support::DebugOptionalElement(self.argument()))
            .finish()
    }
}
impl From<JsYieldExpression> for SyntaxNode {
    fn from(n: JsYieldExpression) -> SyntaxNode { n.syntax }
}
impl From<JsYieldExpression> for SyntaxElement {
    fn from(n: JsYieldExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxAttribute {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_ATTRIBUTE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_ATTRIBUTE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxAttribute")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<JsxAttribute> for SyntaxNode {
    fn from(n: JsxAttribute) -> SyntaxNode { n.syntax }
}
impl From<JsxAttribute> for SyntaxElement {
    fn from(n: JsxAttribute) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxAttributeInitializerClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_ATTRIBUTE_INITIALIZER_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_ATTRIBUTE_INITIALIZER_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxAttributeInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxAttributeInitializerClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("value", &support::DebugSyntaxResult(self.value()))
            .finish()
    }
}
impl From<JsxAttributeInitializerClause> for SyntaxNode {
    fn from(n: JsxAttributeInitializerClause) -> SyntaxNode { n.syntax }
}
impl From<JsxAttributeInitializerClause> for SyntaxElement {
    fn from(n: JsxAttributeInitializerClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxClosingElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_CLOSING_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_CLOSING_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxClosingElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxClosingElement> for SyntaxNode {
    fn from(n: JsxClosingElement) -> SyntaxNode { n.syntax }
}
impl From<JsxClosingElement> for SyntaxElement {
    fn from(n: JsxClosingElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxClosingFragment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_CLOSING_FRAGMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_CLOSING_FRAGMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxClosingFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxClosingFragment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxClosingFragment> for SyntaxNode {
    fn from(n: JsxClosingFragment) -> SyntaxNode { n.syntax }
}
impl From<JsxClosingFragment> for SyntaxElement {
    fn from(n: JsxClosingFragment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxElement")
            .field(
                "opening_element",
                &support::DebugSyntaxResult(self.opening_element()),
            )
            .field("children", &self.children())
            .field(
                "closing_element",
                &support::DebugSyntaxResult(self.closing_element()),
            )
            .finish()
    }
}
impl From<JsxElement> for SyntaxNode {
    fn from(n: JsxElement) -> SyntaxNode { n.syntax }
}
impl From<JsxElement> for SyntaxElement {
    fn from(n: JsxElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxExpressionAttributeValue {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_EXPRESSION_ATTRIBUTE_VALUE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_EXPRESSION_ATTRIBUTE_VALUE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxExpressionAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxExpressionAttributeValue")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxExpressionAttributeValue> for SyntaxNode {
    fn from(n: JsxExpressionAttributeValue) -> SyntaxNode { n.syntax }
}
impl From<JsxExpressionAttributeValue> for SyntaxElement {
    fn from(n: JsxExpressionAttributeValue) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxExpressionChild {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_EXPRESSION_CHILD as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_EXPRESSION_CHILD }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxExpressionChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxExpressionChild")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "expression",
                &support::DebugOptionalElement(self.expression()),
            )
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxExpressionChild> for SyntaxNode {
    fn from(n: JsxExpressionChild) -> SyntaxNode { n.syntax }
}
impl From<JsxExpressionChild> for SyntaxElement {
    fn from(n: JsxExpressionChild) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxFragment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_FRAGMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_FRAGMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxFragment")
            .field(
                "opening_fragment",
                &support::DebugSyntaxResult(self.opening_fragment()),
            )
            .field("children", &self.children())
            .field(
                "closing_fragment",
                &support::DebugSyntaxResult(self.closing_fragment()),
            )
            .finish()
    }
}
impl From<JsxFragment> for SyntaxNode {
    fn from(n: JsxFragment) -> SyntaxNode { n.syntax }
}
impl From<JsxFragment> for SyntaxElement {
    fn from(n: JsxFragment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxMemberName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_MEMBER_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_MEMBER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxMemberName")
            .field("object", &support::DebugSyntaxResult(self.object()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("member", &support::DebugSyntaxResult(self.member()))
            .finish()
    }
}
impl From<JsxMemberName> for SyntaxNode {
    fn from(n: JsxMemberName) -> SyntaxNode { n.syntax }
}
impl From<JsxMemberName> for SyntaxElement {
    fn from(n: JsxMemberName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxName")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxName> for SyntaxNode {
    fn from(n: JsxName) -> SyntaxNode { n.syntax }
}
impl From<JsxName> for SyntaxElement {
    fn from(n: JsxName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxNamespaceName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_NAMESPACE_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_NAMESPACE_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxNamespaceName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxNamespaceName")
            .field("namespace", &support::DebugSyntaxResult(self.namespace()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .finish()
    }
}
impl From<JsxNamespaceName> for SyntaxNode {
    fn from(n: JsxNamespaceName) -> SyntaxNode { n.syntax }
}
impl From<JsxNamespaceName> for SyntaxElement {
    fn from(n: JsxNamespaceName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxOpeningElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_OPENING_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_OPENING_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxOpeningElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxOpeningElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("attributes", &self.attributes())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxOpeningElement> for SyntaxNode {
    fn from(n: JsxOpeningElement) -> SyntaxNode { n.syntax }
}
impl From<JsxOpeningElement> for SyntaxElement {
    fn from(n: JsxOpeningElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxOpeningFragment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_OPENING_FRAGMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_OPENING_FRAGMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxOpeningFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxOpeningFragment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxOpeningFragment> for SyntaxNode {
    fn from(n: JsxOpeningFragment) -> SyntaxNode { n.syntax }
}
impl From<JsxOpeningFragment> for SyntaxElement {
    fn from(n: JsxOpeningFragment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxReferenceIdentifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_REFERENCE_IDENTIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_REFERENCE_IDENTIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxReferenceIdentifier")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxReferenceIdentifier> for SyntaxNode {
    fn from(n: JsxReferenceIdentifier) -> SyntaxNode { n.syntax }
}
impl From<JsxReferenceIdentifier> for SyntaxElement {
    fn from(n: JsxReferenceIdentifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxSelfClosingElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_SELF_CLOSING_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_SELF_CLOSING_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxSelfClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSelfClosingElement")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .field("attributes", &self.attributes())
            .field(
                "slash_token",
                &support::DebugSyntaxResult(self.slash_token()),
            )
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<JsxSelfClosingElement> for SyntaxNode {
    fn from(n: JsxSelfClosingElement) -> SyntaxNode { n.syntax }
}
impl From<JsxSelfClosingElement> for SyntaxElement {
    fn from(n: JsxSelfClosingElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxSpreadAttribute {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_SPREAD_ATTRIBUTE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_SPREAD_ATTRIBUTE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxSpreadAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSpreadAttribute")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("argument", &support::DebugSyntaxResult(self.argument()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxSpreadAttribute> for SyntaxNode {
    fn from(n: JsxSpreadAttribute) -> SyntaxNode { n.syntax }
}
impl From<JsxSpreadAttribute> for SyntaxElement {
    fn from(n: JsxSpreadAttribute) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxSpreadChild {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_SPREAD_CHILD as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_SPREAD_CHILD }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxSpreadChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxSpreadChild")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<JsxSpreadChild> for SyntaxNode {
    fn from(n: JsxSpreadChild) -> SyntaxNode { n.syntax }
}
impl From<JsxSpreadChild> for SyntaxElement {
    fn from(n: JsxSpreadChild) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxString {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_STRING as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_STRING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxString")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxString> for SyntaxNode {
    fn from(n: JsxString) -> SyntaxNode { n.syntax }
}
impl From<JsxString> for SyntaxElement {
    fn from(n: JsxString) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxTagExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_TAG_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_TAG_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxTagExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxTagExpression")
            .field("tag", &support::DebugSyntaxResult(self.tag()))
            .finish()
    }
}
impl From<JsxTagExpression> for SyntaxNode {
    fn from(n: JsxTagExpression) -> SyntaxNode { n.syntax }
}
impl From<JsxTagExpression> for SyntaxElement {
    fn from(n: JsxTagExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for JsxText {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_TEXT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_TEXT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsxText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsxText")
            .field(
                "value_token",
                &support::DebugSyntaxResult(self.value_token()),
            )
            .finish()
    }
}
impl From<JsxText> for SyntaxNode {
    fn from(n: JsxText) -> SyntaxNode { n.syntax }
}
impl From<JsxText> for SyntaxElement {
    fn from(n: JsxText) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAbstractModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ABSTRACT_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ABSTRACT_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAbstractModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAbstractModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsAbstractModifier> for SyntaxNode {
    fn from(n: TsAbstractModifier) -> SyntaxNode { n.syntax }
}
impl From<TsAbstractModifier> for SyntaxElement {
    fn from(n: TsAbstractModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAccessibilityModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ACCESSIBILITY_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ACCESSIBILITY_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAccessibilityModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAccessibilityModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsAccessibilityModifier> for SyntaxNode {
    fn from(n: TsAccessibilityModifier) -> SyntaxNode { n.syntax }
}
impl From<TsAccessibilityModifier> for SyntaxElement {
    fn from(n: TsAccessibilityModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAnyType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ANY_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ANY_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAnyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAnyType")
            .field("any_token", &support::DebugSyntaxResult(self.any_token()))
            .finish()
    }
}
impl From<TsAnyType> for SyntaxNode {
    fn from(n: TsAnyType) -> SyntaxNode { n.syntax }
}
impl From<TsAnyType> for SyntaxElement {
    fn from(n: TsAnyType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsArrayType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ARRAY_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ARRAY_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsArrayType")
            .field(
                "element_type",
                &support::DebugSyntaxResult(self.element_type()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsArrayType> for SyntaxNode {
    fn from(n: TsArrayType) -> SyntaxNode { n.syntax }
}
impl From<TsArrayType> for SyntaxElement {
    fn from(n: TsArrayType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAsAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_AS_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_AS_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAsAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAsAssignment")
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAsAssignment> for SyntaxNode {
    fn from(n: TsAsAssignment) -> SyntaxNode { n.syntax }
}
impl From<TsAsAssignment> for SyntaxElement {
    fn from(n: TsAsAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAsExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_AS_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_AS_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAsExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAsExpression")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAsExpression> for SyntaxNode {
    fn from(n: TsAsExpression) -> SyntaxNode { n.syntax }
}
impl From<TsAsExpression> for SyntaxElement {
    fn from(n: TsAsExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAssertsCondition {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ASSERTS_CONDITION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ASSERTS_CONDITION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAssertsCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAssertsCondition")
            .field("is_token", &support::DebugSyntaxResult(self.is_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsAssertsCondition> for SyntaxNode {
    fn from(n: TsAssertsCondition) -> SyntaxNode { n.syntax }
}
impl From<TsAssertsCondition> for SyntaxElement {
    fn from(n: TsAssertsCondition) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsAssertsReturnType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ASSERTS_RETURN_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ASSERTS_RETURN_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsAssertsReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsAssertsReturnType")
            .field(
                "asserts_token",
                &support::DebugSyntaxResult(self.asserts_token()),
            )
            .field(
                "parameter_name",
                &support::DebugSyntaxResult(self.parameter_name()),
            )
            .field(
                "predicate",
                &support::DebugOptionalElement(self.predicate()),
            )
            .finish()
    }
}
impl From<TsAssertsReturnType> for SyntaxNode {
    fn from(n: TsAssertsReturnType) -> SyntaxNode { n.syntax }
}
impl From<TsAssertsReturnType> for SyntaxElement {
    fn from(n: TsAssertsReturnType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsBigintLiteralType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_BIGINT_LITERAL_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BIGINT_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBigintLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBigintLiteralType")
            .field(
                "minus_token",
                &support::DebugOptionalElement(self.minus_token()),
            )
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsBigintLiteralType> for SyntaxNode {
    fn from(n: TsBigintLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsBigintLiteralType> for SyntaxElement {
    fn from(n: TsBigintLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsBigintType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_BIGINT_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BIGINT_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBigintType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBigintType")
            .field(
                "bigint_token",
                &support::DebugSyntaxResult(self.bigint_token()),
            )
            .finish()
    }
}
impl From<TsBigintType> for SyntaxNode {
    fn from(n: TsBigintType) -> SyntaxNode { n.syntax }
}
impl From<TsBigintType> for SyntaxElement {
    fn from(n: TsBigintType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsBooleanLiteralType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_BOOLEAN_LITERAL_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BOOLEAN_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBooleanLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBooleanLiteralType")
            .field("literal", &support::DebugSyntaxResult(self.literal()))
            .finish()
    }
}
impl From<TsBooleanLiteralType> for SyntaxNode {
    fn from(n: TsBooleanLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsBooleanLiteralType> for SyntaxElement {
    fn from(n: TsBooleanLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsBooleanType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_BOOLEAN_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BOOLEAN_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBooleanType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBooleanType")
            .field(
                "boolean_token",
                &support::DebugSyntaxResult(self.boolean_token()),
            )
            .finish()
    }
}
impl From<TsBooleanType> for SyntaxNode {
    fn from(n: TsBooleanType) -> SyntaxNode { n.syntax }
}
impl From<TsBooleanType> for SyntaxElement {
    fn from(n: TsBooleanType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsCallSignatureTypeMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_CALL_SIGNATURE_TYPE_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CALL_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsCallSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsCallSignatureTypeMember")
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsCallSignatureTypeMember> for SyntaxNode {
    fn from(n: TsCallSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsCallSignatureTypeMember> for SyntaxElement {
    fn from(n: TsCallSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConditionalType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_CONDITIONAL_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONDITIONAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConditionalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConditionalType")
            .field("check_type", &support::DebugSyntaxResult(self.check_type()))
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field(
                "extends_type",
                &support::DebugSyntaxResult(self.extends_type()),
            )
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field("true_type", &support::DebugSyntaxResult(self.true_type()))
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("false_type", &support::DebugSyntaxResult(self.false_type()))
            .finish()
    }
}
impl From<TsConditionalType> for SyntaxNode {
    fn from(n: TsConditionalType) -> SyntaxNode { n.syntax }
}
impl From<TsConditionalType> for SyntaxElement {
    fn from(n: TsConditionalType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConstModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_CONST_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONST_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConstModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsConstModifier> for SyntaxNode {
    fn from(n: TsConstModifier) -> SyntaxNode { n.syntax }
}
impl From<TsConstModifier> for SyntaxElement {
    fn from(n: TsConstModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConstructSignatureTypeMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConstructSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructSignatureTypeMember")
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsConstructSignatureTypeMember> for SyntaxNode {
    fn from(n: TsConstructSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsConstructSignatureTypeMember> for SyntaxElement {
    fn from(n: TsConstructSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConstructorSignatureClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConstructorSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructorSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsConstructorSignatureClassMember> for SyntaxNode {
    fn from(n: TsConstructorSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsConstructorSignatureClassMember> for SyntaxElement {
    fn from(n: TsConstructorSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsConstructorType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_CONSTRUCTOR_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_CONSTRUCTOR_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsConstructorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsConstructorType")
            .field(
                "abstract_token",
                &support::DebugOptionalElement(self.abstract_token()),
            )
            .field("new_token", &support::DebugSyntaxResult(self.new_token()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field(
                "return_type",
                &support::DebugSyntaxResult(self.return_type()),
            )
            .finish()
    }
}
impl From<TsConstructorType> for SyntaxNode {
    fn from(n: TsConstructorType) -> SyntaxNode { n.syntax }
}
impl From<TsConstructorType> for SyntaxElement {
    fn from(n: TsConstructorType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDeclareFunctionDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_DECLARE_FUNCTION_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DECLARE_FUNCTION_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDeclareFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareFunctionDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsDeclareFunctionDeclaration> for SyntaxNode {
    fn from(n: TsDeclareFunctionDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsDeclareFunctionDeclaration> for SyntaxElement {
    fn from(n: TsDeclareFunctionDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDeclareFunctionExportDefaultDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        TS_DECLARE_FUNCTION_EXPORT_DEFAULT_DECLARATION as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DECLARE_FUNCTION_EXPORT_DEFAULT_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDeclareFunctionExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareFunctionExportDefaultDeclaration")
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field(
                "function_token",
                &support::DebugSyntaxResult(self.function_token()),
            )
            .field("id", &support::DebugOptionalElement(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsDeclareFunctionExportDefaultDeclaration> for SyntaxNode {
    fn from(n: TsDeclareFunctionExportDefaultDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsDeclareFunctionExportDefaultDeclaration> for SyntaxElement {
    fn from(n: TsDeclareFunctionExportDefaultDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDeclareModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_DECLARE_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DECLARE_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDeclareModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsDeclareModifier> for SyntaxNode {
    fn from(n: TsDeclareModifier) -> SyntaxNode { n.syntax }
}
impl From<TsDeclareModifier> for SyntaxElement {
    fn from(n: TsDeclareModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDeclareStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_DECLARE_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DECLARE_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDeclareStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDeclareStatement")
            .field(
                "declare_token",
                &support::DebugSyntaxResult(self.declare_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .finish()
    }
}
impl From<TsDeclareStatement> for SyntaxNode {
    fn from(n: TsDeclareStatement) -> SyntaxNode { n.syntax }
}
impl From<TsDeclareStatement> for SyntaxElement {
    fn from(n: TsDeclareStatement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDefaultTypeClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_DEFAULT_TYPE_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DEFAULT_TYPE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDefaultTypeClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefaultTypeClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsDefaultTypeClause> for SyntaxNode {
    fn from(n: TsDefaultTypeClause) -> SyntaxNode { n.syntax }
}
impl From<TsDefaultTypeClause> for SyntaxElement {
    fn from(n: TsDefaultTypeClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDefinitePropertyAnnotation {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_DEFINITE_PROPERTY_ANNOTATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DEFINITE_PROPERTY_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDefinitePropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefinitePropertyAnnotation")
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsDefinitePropertyAnnotation> for SyntaxNode {
    fn from(n: TsDefinitePropertyAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsDefinitePropertyAnnotation> for SyntaxElement {
    fn from(n: TsDefinitePropertyAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsDefiniteVariableAnnotation {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_DEFINITE_VARIABLE_ANNOTATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_DEFINITE_VARIABLE_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsDefiniteVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsDefiniteVariableAnnotation")
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsDefiniteVariableAnnotation> for SyntaxNode {
    fn from(n: TsDefiniteVariableAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsDefiniteVariableAnnotation> for SyntaxElement {
    fn from(n: TsDefiniteVariableAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsEmptyExternalModuleDeclarationBody {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsEmptyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEmptyExternalModuleDeclarationBody")
            .field(
                "semicolon_token",
                &support::DebugSyntaxResult(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsEmptyExternalModuleDeclarationBody> for SyntaxNode {
    fn from(n: TsEmptyExternalModuleDeclarationBody) -> SyntaxNode { n.syntax }
}
impl From<TsEmptyExternalModuleDeclarationBody> for SyntaxElement {
    fn from(n: TsEmptyExternalModuleDeclarationBody) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsEnumDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ENUM_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ENUM_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsEnumDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEnumDeclaration")
            .field(
                "const_token",
                &support::DebugOptionalElement(self.const_token()),
            )
            .field("enum_token", &support::DebugSyntaxResult(self.enum_token()))
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsEnumDeclaration> for SyntaxNode {
    fn from(n: TsEnumDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsEnumDeclaration> for SyntaxElement {
    fn from(n: TsEnumDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsEnumMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ENUM_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ENUM_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsEnumMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsEnumMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "initializer",
                &support::DebugOptionalElement(self.initializer()),
            )
            .finish()
    }
}
impl From<TsEnumMember> for SyntaxNode {
    fn from(n: TsEnumMember) -> SyntaxNode { n.syntax }
}
impl From<TsEnumMember> for SyntaxElement {
    fn from(n: TsEnumMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExportAsNamespaceClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_EXPORT_AS_NAMESPACE_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXPORT_AS_NAMESPACE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExportAsNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportAsNamespaceClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field(
                "namespace_token",
                &support::DebugSyntaxResult(self.namespace_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsExportAsNamespaceClause> for SyntaxNode {
    fn from(n: TsExportAsNamespaceClause) -> SyntaxNode { n.syntax }
}
impl From<TsExportAsNamespaceClause> for SyntaxElement {
    fn from(n: TsExportAsNamespaceClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExportAssignmentClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_EXPORT_ASSIGNMENT_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXPORT_ASSIGNMENT_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExportAssignmentClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportAssignmentClause")
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsExportAssignmentClause> for SyntaxNode {
    fn from(n: TsExportAssignmentClause) -> SyntaxNode { n.syntax }
}
impl From<TsExportAssignmentClause> for SyntaxElement {
    fn from(n: TsExportAssignmentClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExportDeclareClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_EXPORT_DECLARE_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXPORT_DECLARE_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExportDeclareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExportDeclareClause")
            .field(
                "declare_token",
                &support::DebugSyntaxResult(self.declare_token()),
            )
            .field(
                "declaration",
                &support::DebugSyntaxResult(self.declaration()),
            )
            .finish()
    }
}
impl From<TsExportDeclareClause> for SyntaxNode {
    fn from(n: TsExportDeclareClause) -> SyntaxNode { n.syntax }
}
impl From<TsExportDeclareClause> for SyntaxElement {
    fn from(n: TsExportDeclareClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExtendsClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_EXTENDS_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXTENDS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExtendsClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsExtendsClause> for SyntaxNode {
    fn from(n: TsExtendsClause) -> SyntaxNode { n.syntax }
}
impl From<TsExtendsClause> for SyntaxElement {
    fn from(n: TsExtendsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExternalModuleDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_EXTERNAL_MODULE_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXTERNAL_MODULE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExternalModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExternalModuleDeclaration")
            .field(
                "module_token",
                &support::DebugSyntaxResult(self.module_token()),
            )
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field("body", &support::DebugOptionalElement(self.body()))
            .finish()
    }
}
impl From<TsExternalModuleDeclaration> for SyntaxNode {
    fn from(n: TsExternalModuleDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsExternalModuleDeclaration> for SyntaxElement {
    fn from(n: TsExternalModuleDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsExternalModuleReference {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_EXTERNAL_MODULE_REFERENCE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_EXTERNAL_MODULE_REFERENCE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsExternalModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsExternalModuleReference")
            .field(
                "require_token",
                &support::DebugSyntaxResult(self.require_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("source", &support::DebugSyntaxResult(self.source()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<TsExternalModuleReference> for SyntaxNode {
    fn from(n: TsExternalModuleReference) -> SyntaxNode { n.syntax }
}
impl From<TsExternalModuleReference> for SyntaxElement {
    fn from(n: TsExternalModuleReference) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsFunctionType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_FUNCTION_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_FUNCTION_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsFunctionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsFunctionType")
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "fat_arrow_token",
                &support::DebugSyntaxResult(self.fat_arrow_token()),
            )
            .field(
                "return_type",
                &support::DebugSyntaxResult(self.return_type()),
            )
            .finish()
    }
}
impl From<TsFunctionType> for SyntaxNode {
    fn from(n: TsFunctionType) -> SyntaxNode { n.syntax }
}
impl From<TsFunctionType> for SyntaxElement {
    fn from(n: TsFunctionType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsGetterSignatureClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_GETTER_SIGNATURE_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_GETTER_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsGetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGetterSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "return_type",
                &support::DebugOptionalElement(self.return_type()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsGetterSignatureClassMember> for SyntaxNode {
    fn from(n: TsGetterSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsGetterSignatureClassMember> for SyntaxElement {
    fn from(n: TsGetterSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsGetterSignatureTypeMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_GETTER_SIGNATURE_TYPE_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_GETTER_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsGetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGetterSignatureTypeMember")
            .field("get_token", &support::DebugSyntaxResult(self.get_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsGetterSignatureTypeMember> for SyntaxNode {
    fn from(n: TsGetterSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsGetterSignatureTypeMember> for SyntaxElement {
    fn from(n: TsGetterSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsGlobalDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_GLOBAL_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_GLOBAL_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsGlobalDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsGlobalDeclaration")
            .field(
                "global_token",
                &support::DebugSyntaxResult(self.global_token()),
            )
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<TsGlobalDeclaration> for SyntaxNode {
    fn from(n: TsGlobalDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsGlobalDeclaration> for SyntaxElement {
    fn from(n: TsGlobalDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIdentifierBinding {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_IDENTIFIER_BINDING as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IDENTIFIER_BINDING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIdentifierBinding")
            .field("name_token", &support::DebugSyntaxResult(self.name_token()))
            .finish()
    }
}
impl From<TsIdentifierBinding> for SyntaxNode {
    fn from(n: TsIdentifierBinding) -> SyntaxNode { n.syntax }
}
impl From<TsIdentifierBinding> for SyntaxElement {
    fn from(n: TsIdentifierBinding) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsImplementsClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_IMPLEMENTS_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IMPLEMENTS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsImplementsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImplementsClause")
            .field(
                "implements_token",
                &support::DebugSyntaxResult(self.implements_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsImplementsClause> for SyntaxNode {
    fn from(n: TsImplementsClause) -> SyntaxNode { n.syntax }
}
impl From<TsImplementsClause> for SyntaxElement {
    fn from(n: TsImplementsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsImportEqualsDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_IMPORT_EQUALS_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IMPORT_EQUALS_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsImportEqualsDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportEqualsDeclaration")
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "type_token",
                &support::DebugOptionalElement(self.type_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field(
                "module_reference",
                &support::DebugSyntaxResult(self.module_reference()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsImportEqualsDeclaration> for SyntaxNode {
    fn from(n: TsImportEqualsDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsImportEqualsDeclaration> for SyntaxElement {
    fn from(n: TsImportEqualsDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsImportType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_IMPORT_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IMPORT_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsImportType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportType")
            .field(
                "typeof_token",
                &support::DebugOptionalElement(self.typeof_token()),
            )
            .field(
                "import_token",
                &support::DebugSyntaxResult(self.import_token()),
            )
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field(
                "argument_token",
                &support::DebugSyntaxResult(self.argument_token()),
            )
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "qualifier_clause",
                &support::DebugOptionalElement(self.qualifier_clause()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsImportType> for SyntaxNode {
    fn from(n: TsImportType) -> SyntaxNode { n.syntax }
}
impl From<TsImportType> for SyntaxElement {
    fn from(n: TsImportType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsImportTypeQualifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_IMPORT_TYPE_QUALIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IMPORT_TYPE_QUALIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsImportTypeQualifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsImportTypeQualifier")
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsImportTypeQualifier> for SyntaxNode {
    fn from(n: TsImportTypeQualifier) -> SyntaxNode { n.syntax }
}
impl From<TsImportTypeQualifier> for SyntaxElement {
    fn from(n: TsImportTypeQualifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsInModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_IN_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_IN_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsInModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsInModifier> for SyntaxNode {
    fn from(n: TsInModifier) -> SyntaxNode { n.syntax }
}
impl From<TsInModifier> for SyntaxElement {
    fn from(n: TsInModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIndexSignatureClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INDEX_SIGNATURE_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEX_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIndexSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureClassMember> for SyntaxNode {
    fn from(n: TsIndexSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsIndexSignatureClassMember> for SyntaxElement {
    fn from(n: TsIndexSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIndexSignatureParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INDEX_SIGNATURE_PARAMETER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEX_SIGNATURE_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIndexSignatureParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureParameter")
            .field("binding", &support::DebugSyntaxResult(self.binding()))
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureParameter> for SyntaxNode {
    fn from(n: TsIndexSignatureParameter) -> SyntaxNode { n.syntax }
}
impl From<TsIndexSignatureParameter> for SyntaxElement {
    fn from(n: TsIndexSignatureParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIndexSignatureTypeMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INDEX_SIGNATURE_TYPE_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEX_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIndexSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexSignatureTypeMember")
            .field(
                "readonly_token",
                &support::DebugOptionalElement(self.readonly_token()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "type_annotation",
                &support::DebugSyntaxResult(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsIndexSignatureTypeMember> for SyntaxNode {
    fn from(n: TsIndexSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsIndexSignatureTypeMember> for SyntaxElement {
    fn from(n: TsIndexSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIndexedAccessType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INDEXED_ACCESS_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEXED_ACCESS_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIndexedAccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIndexedAccessType")
            .field(
                "object_type",
                &support::DebugSyntaxResult(self.object_type()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("index_type", &support::DebugSyntaxResult(self.index_type()))
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsIndexedAccessType> for SyntaxNode {
    fn from(n: TsIndexedAccessType) -> SyntaxNode { n.syntax }
}
impl From<TsIndexedAccessType> for SyntaxElement {
    fn from(n: TsIndexedAccessType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsInferType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INFER_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INFER_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsInferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInferType")
            .field(
                "infer_token",
                &support::DebugSyntaxResult(self.infer_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "constraint",
                &support::DebugOptionalElement(self.constraint()),
            )
            .finish()
    }
}
impl From<TsInferType> for SyntaxNode {
    fn from(n: TsInferType) -> SyntaxNode { n.syntax }
}
impl From<TsInferType> for SyntaxElement {
    fn from(n: TsInferType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsInitializedPropertySignatureClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        TS_INITIALIZED_PROPERTY_SIGNATURE_CLASS_MEMBER as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INITIALIZED_PROPERTY_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsInitializedPropertySignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInitializedPropertySignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field("value", &support::DebugSyntaxResult(self.value()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsInitializedPropertySignatureClassMember> for SyntaxNode {
    fn from(n: TsInitializedPropertySignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsInitializedPropertySignatureClassMember> for SyntaxElement {
    fn from(n: TsInitializedPropertySignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsInstantiationExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INSTANTIATION_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INSTANTIATION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsInstantiationExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInstantiationExpression")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("arguments", &support::DebugSyntaxResult(self.arguments()))
            .finish()
    }
}
impl From<TsInstantiationExpression> for SyntaxNode {
    fn from(n: TsInstantiationExpression) -> SyntaxNode { n.syntax }
}
impl From<TsInstantiationExpression> for SyntaxElement {
    fn from(n: TsInstantiationExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsInterfaceDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INTERFACE_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INTERFACE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsInterfaceDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsInterfaceDeclaration")
            .field(
                "interface_token",
                &support::DebugSyntaxResult(self.interface_token()),
            )
            .field("id", &support::DebugSyntaxResult(self.id()))
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field(
                "extends_clause",
                &support::DebugOptionalElement(self.extends_clause()),
            )
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsInterfaceDeclaration> for SyntaxNode {
    fn from(n: TsInterfaceDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsInterfaceDeclaration> for SyntaxElement {
    fn from(n: TsInterfaceDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsIntersectionType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INTERSECTION_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INTERSECTION_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsIntersectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsIntersectionType")
            .field(
                "leading_separator_token",
                &support::DebugOptionalElement(self.leading_separator_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsIntersectionType> for SyntaxNode {
    fn from(n: TsIntersectionType) -> SyntaxNode { n.syntax }
}
impl From<TsIntersectionType> for SyntaxElement {
    fn from(n: TsIntersectionType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMappedType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_MAPPED_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MAPPED_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMappedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedType")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field(
                "readonly_modifier",
                &support::DebugOptionalElement(self.readonly_modifier()),
            )
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field(
                "property_name",
                &support::DebugSyntaxResult(self.property_name()),
            )
            .field("in_token", &support::DebugSyntaxResult(self.in_token()))
            .field("keys_type", &support::DebugSyntaxResult(self.keys_type()))
            .field(
                "as_clause",
                &support::DebugOptionalElement(self.as_clause()),
            )
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .field(
                "optional_modifier",
                &support::DebugOptionalElement(self.optional_modifier()),
            )
            .field(
                "mapped_type",
                &support::DebugOptionalElement(self.mapped_type()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsMappedType> for SyntaxNode {
    fn from(n: TsMappedType) -> SyntaxNode { n.syntax }
}
impl From<TsMappedType> for SyntaxElement {
    fn from(n: TsMappedType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMappedTypeAsClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_MAPPED_TYPE_AS_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MAPPED_TYPE_AS_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMappedTypeAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeAsClause")
            .field("as_token", &support::DebugSyntaxResult(self.as_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsMappedTypeAsClause> for SyntaxNode {
    fn from(n: TsMappedTypeAsClause) -> SyntaxNode { n.syntax }
}
impl From<TsMappedTypeAsClause> for SyntaxElement {
    fn from(n: TsMappedTypeAsClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMappedTypeOptionalModifierClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        TS_MAPPED_TYPE_OPTIONAL_MODIFIER_CLAUSE as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MAPPED_TYPE_OPTIONAL_MODIFIER_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMappedTypeOptionalModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeOptionalModifierClause")
            .field(
                "operator_token",
                &support::DebugOptionalElement(self.operator_token()),
            )
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .finish()
    }
}
impl From<TsMappedTypeOptionalModifierClause> for SyntaxNode {
    fn from(n: TsMappedTypeOptionalModifierClause) -> SyntaxNode { n.syntax }
}
impl From<TsMappedTypeOptionalModifierClause> for SyntaxElement {
    fn from(n: TsMappedTypeOptionalModifierClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMappedTypeReadonlyModifierClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        TS_MAPPED_TYPE_READONLY_MODIFIER_CLAUSE as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MAPPED_TYPE_READONLY_MODIFIER_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMappedTypeReadonlyModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMappedTypeReadonlyModifierClause")
            .field(
                "operator_token",
                &support::DebugOptionalElement(self.operator_token()),
            )
            .field(
                "readonly_token",
                &support::DebugSyntaxResult(self.readonly_token()),
            )
            .finish()
    }
}
impl From<TsMappedTypeReadonlyModifierClause> for SyntaxNode {
    fn from(n: TsMappedTypeReadonlyModifierClause) -> SyntaxNode { n.syntax }
}
impl From<TsMappedTypeReadonlyModifierClause> for SyntaxElement {
    fn from(n: TsMappedTypeReadonlyModifierClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMethodSignatureClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_METHOD_SIGNATURE_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_METHOD_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMethodSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMethodSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field(
                "async_token",
                &support::DebugOptionalElement(self.async_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsMethodSignatureClassMember> for SyntaxNode {
    fn from(n: TsMethodSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsMethodSignatureClassMember> for SyntaxElement {
    fn from(n: TsMethodSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsMethodSignatureTypeMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_METHOD_SIGNATURE_TYPE_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_METHOD_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsMethodSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsMethodSignatureTypeMember")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "optional_token",
                &support::DebugOptionalElement(self.optional_token()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("parameters", &support::DebugSyntaxResult(self.parameters()))
            .field(
                "return_type_annotation",
                &support::DebugOptionalElement(self.return_type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsMethodSignatureTypeMember> for SyntaxNode {
    fn from(n: TsMethodSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsMethodSignatureTypeMember> for SyntaxElement {
    fn from(n: TsMethodSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsModuleBlock {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_MODULE_BLOCK as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MODULE_BLOCK }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsModuleBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsModuleBlock")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("items", &self.items())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsModuleBlock> for SyntaxNode {
    fn from(n: TsModuleBlock) -> SyntaxNode { n.syntax }
}
impl From<TsModuleBlock> for SyntaxElement {
    fn from(n: TsModuleBlock) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsModuleDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_MODULE_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_MODULE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsModuleDeclaration")
            .field(
                "module_or_namespace",
                &support::DebugSyntaxResult(self.module_or_namespace()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field("body", &support::DebugSyntaxResult(self.body()))
            .finish()
    }
}
impl From<TsModuleDeclaration> for SyntaxNode {
    fn from(n: TsModuleDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsModuleDeclaration> for SyntaxElement {
    fn from(n: TsModuleDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNameWithTypeArguments {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NAME_WITH_TYPE_ARGUMENTS as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NAME_WITH_TYPE_ARGUMENTS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNameWithTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNameWithTypeArguments")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsNameWithTypeArguments> for SyntaxNode {
    fn from(n: TsNameWithTypeArguments) -> SyntaxNode { n.syntax }
}
impl From<TsNameWithTypeArguments> for SyntaxElement {
    fn from(n: TsNameWithTypeArguments) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNamedTupleTypeElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NAMED_TUPLE_TYPE_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NAMED_TUPLE_TYPE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNamedTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNamedTupleTypeElement")
            .field(
                "dotdotdot_token",
                &support::DebugOptionalElement(self.dotdotdot_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "question_mark_token",
                &support::DebugOptionalElement(self.question_mark_token()),
            )
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsNamedTupleTypeElement> for SyntaxNode {
    fn from(n: TsNamedTupleTypeElement) -> SyntaxNode { n.syntax }
}
impl From<TsNamedTupleTypeElement> for SyntaxElement {
    fn from(n: TsNamedTupleTypeElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNeverType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NEVER_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NEVER_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNeverType")
            .field(
                "never_token",
                &support::DebugSyntaxResult(self.never_token()),
            )
            .finish()
    }
}
impl From<TsNeverType> for SyntaxNode {
    fn from(n: TsNeverType) -> SyntaxNode { n.syntax }
}
impl From<TsNeverType> for SyntaxElement {
    fn from(n: TsNeverType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNonNullAssertionAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NON_NULL_ASSERTION_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NON_NULL_ASSERTION_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNonNullAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonNullAssertionAssignment")
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .finish()
    }
}
impl From<TsNonNullAssertionAssignment> for SyntaxNode {
    fn from(n: TsNonNullAssertionAssignment) -> SyntaxNode { n.syntax }
}
impl From<TsNonNullAssertionAssignment> for SyntaxElement {
    fn from(n: TsNonNullAssertionAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNonNullAssertionExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NON_NULL_ASSERTION_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NON_NULL_ASSERTION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNonNullAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonNullAssertionExpression")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field("excl_token", &support::DebugSyntaxResult(self.excl_token()))
            .finish()
    }
}
impl From<TsNonNullAssertionExpression> for SyntaxNode {
    fn from(n: TsNonNullAssertionExpression) -> SyntaxNode { n.syntax }
}
impl From<TsNonNullAssertionExpression> for SyntaxElement {
    fn from(n: TsNonNullAssertionExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNonPrimitiveType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NON_PRIMITIVE_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NON_PRIMITIVE_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNonPrimitiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNonPrimitiveType")
            .field(
                "object_token",
                &support::DebugSyntaxResult(self.object_token()),
            )
            .finish()
    }
}
impl From<TsNonPrimitiveType> for SyntaxNode {
    fn from(n: TsNonPrimitiveType) -> SyntaxNode { n.syntax }
}
impl From<TsNonPrimitiveType> for SyntaxElement {
    fn from(n: TsNonPrimitiveType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNullLiteralType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NULL_LITERAL_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NULL_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNullLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNullLiteralType")
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsNullLiteralType> for SyntaxNode {
    fn from(n: TsNullLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsNullLiteralType> for SyntaxElement {
    fn from(n: TsNullLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNumberLiteralType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NUMBER_LITERAL_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NUMBER_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNumberLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNumberLiteralType")
            .field(
                "minus_token",
                &support::DebugOptionalElement(self.minus_token()),
            )
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsNumberLiteralType> for SyntaxNode {
    fn from(n: TsNumberLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsNumberLiteralType> for SyntaxElement {
    fn from(n: TsNumberLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsNumberType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_NUMBER_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_NUMBER_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsNumberType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsNumberType")
            .field(
                "number_token",
                &support::DebugSyntaxResult(self.number_token()),
            )
            .finish()
    }
}
impl From<TsNumberType> for SyntaxNode {
    fn from(n: TsNumberType) -> SyntaxNode { n.syntax }
}
impl From<TsNumberType> for SyntaxElement {
    fn from(n: TsNumberType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsObjectType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_OBJECT_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OBJECT_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsObjectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsObjectType")
            .field(
                "l_curly_token",
                &support::DebugSyntaxResult(self.l_curly_token()),
            )
            .field("members", &self.members())
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsObjectType> for SyntaxNode {
    fn from(n: TsObjectType) -> SyntaxNode { n.syntax }
}
impl From<TsObjectType> for SyntaxElement {
    fn from(n: TsObjectType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsOptionalPropertyAnnotation {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_OPTIONAL_PROPERTY_ANNOTATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OPTIONAL_PROPERTY_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsOptionalPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOptionalPropertyAnnotation")
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsOptionalPropertyAnnotation> for SyntaxNode {
    fn from(n: TsOptionalPropertyAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsOptionalPropertyAnnotation> for SyntaxElement {
    fn from(n: TsOptionalPropertyAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsOptionalTupleTypeElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_OPTIONAL_TUPLE_TYPE_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OPTIONAL_TUPLE_TYPE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsOptionalTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOptionalTupleTypeElement")
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "question_mark_token",
                &support::DebugSyntaxResult(self.question_mark_token()),
            )
            .finish()
    }
}
impl From<TsOptionalTupleTypeElement> for SyntaxNode {
    fn from(n: TsOptionalTupleTypeElement) -> SyntaxNode { n.syntax }
}
impl From<TsOptionalTupleTypeElement> for SyntaxElement {
    fn from(n: TsOptionalTupleTypeElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsOutModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_OUT_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OUT_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsOutModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOutModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsOutModifier> for SyntaxNode {
    fn from(n: TsOutModifier) -> SyntaxNode { n.syntax }
}
impl From<TsOutModifier> for SyntaxElement {
    fn from(n: TsOutModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsOverrideModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_OVERRIDE_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_OVERRIDE_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsOverrideModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsOverrideModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsOverrideModifier> for SyntaxNode {
    fn from(n: TsOverrideModifier) -> SyntaxNode { n.syntax }
}
impl From<TsOverrideModifier> for SyntaxElement {
    fn from(n: TsOverrideModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsParenthesizedType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_PARENTHESIZED_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PARENTHESIZED_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsParenthesizedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsParenthesizedType")
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .finish()
    }
}
impl From<TsParenthesizedType> for SyntaxNode {
    fn from(n: TsParenthesizedType) -> SyntaxNode { n.syntax }
}
impl From<TsParenthesizedType> for SyntaxElement {
    fn from(n: TsParenthesizedType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsPredicateReturnType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_PREDICATE_RETURN_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PREDICATE_RETURN_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsPredicateReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPredicateReturnType")
            .field(
                "parameter_name",
                &support::DebugSyntaxResult(self.parameter_name()),
            )
            .field("is_token", &support::DebugSyntaxResult(self.is_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsPredicateReturnType> for SyntaxNode {
    fn from(n: TsPredicateReturnType) -> SyntaxNode { n.syntax }
}
impl From<TsPredicateReturnType> for SyntaxElement {
    fn from(n: TsPredicateReturnType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsPropertyParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_PROPERTY_PARAMETER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsPropertyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertyParameter")
            .field("modifiers", &self.modifiers())
            .field(
                "formal_parameter",
                &support::DebugSyntaxResult(self.formal_parameter()),
            )
            .finish()
    }
}
impl From<TsPropertyParameter> for SyntaxNode {
    fn from(n: TsPropertyParameter) -> SyntaxNode { n.syntax }
}
impl From<TsPropertyParameter> for SyntaxElement {
    fn from(n: TsPropertyParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsPropertySignatureClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_PROPERTY_SIGNATURE_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsPropertySignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertySignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "property_annotation",
                &support::DebugOptionalElement(self.property_annotation()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsPropertySignatureClassMember> for SyntaxNode {
    fn from(n: TsPropertySignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsPropertySignatureClassMember> for SyntaxElement {
    fn from(n: TsPropertySignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsPropertySignatureTypeMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_PROPERTY_SIGNATURE_TYPE_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsPropertySignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsPropertySignatureTypeMember")
            .field(
                "readonly_token",
                &support::DebugOptionalElement(self.readonly_token()),
            )
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "optional_token",
                &support::DebugOptionalElement(self.optional_token()),
            )
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsPropertySignatureTypeMember> for SyntaxNode {
    fn from(n: TsPropertySignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsPropertySignatureTypeMember> for SyntaxElement {
    fn from(n: TsPropertySignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsQualifiedModuleName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_QUALIFIED_MODULE_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_QUALIFIED_MODULE_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsQualifiedModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsQualifiedModuleName")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsQualifiedModuleName> for SyntaxNode {
    fn from(n: TsQualifiedModuleName) -> SyntaxNode { n.syntax }
}
impl From<TsQualifiedModuleName> for SyntaxElement {
    fn from(n: TsQualifiedModuleName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsQualifiedName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_QUALIFIED_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_QUALIFIED_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsQualifiedName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsQualifiedName")
            .field("left", &support::DebugSyntaxResult(self.left()))
            .field("dot_token", &support::DebugSyntaxResult(self.dot_token()))
            .field("right", &support::DebugSyntaxResult(self.right()))
            .finish()
    }
}
impl From<TsQualifiedName> for SyntaxNode {
    fn from(n: TsQualifiedName) -> SyntaxNode { n.syntax }
}
impl From<TsQualifiedName> for SyntaxElement {
    fn from(n: TsQualifiedName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsReadonlyModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_READONLY_MODIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_READONLY_MODIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsReadonlyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReadonlyModifier")
            .field(
                "modifier_token",
                &support::DebugSyntaxResult(self.modifier_token()),
            )
            .finish()
    }
}
impl From<TsReadonlyModifier> for SyntaxNode {
    fn from(n: TsReadonlyModifier) -> SyntaxNode { n.syntax }
}
impl From<TsReadonlyModifier> for SyntaxElement {
    fn from(n: TsReadonlyModifier) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsReferenceType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_REFERENCE_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_REFERENCE_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsReferenceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReferenceType")
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsReferenceType> for SyntaxNode {
    fn from(n: TsReferenceType) -> SyntaxNode { n.syntax }
}
impl From<TsReferenceType> for SyntaxElement {
    fn from(n: TsReferenceType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsRestTupleTypeElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_REST_TUPLE_TYPE_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_REST_TUPLE_TYPE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsRestTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsRestTupleTypeElement")
            .field(
                "dotdotdot_token",
                &support::DebugSyntaxResult(self.dotdotdot_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsRestTupleTypeElement> for SyntaxNode {
    fn from(n: TsRestTupleTypeElement) -> SyntaxNode { n.syntax }
}
impl From<TsRestTupleTypeElement> for SyntaxElement {
    fn from(n: TsRestTupleTypeElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsReturnTypeAnnotation {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_RETURN_TYPE_ANNOTATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_RETURN_TYPE_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsReturnTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsReturnTypeAnnotation")
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsReturnTypeAnnotation> for SyntaxNode {
    fn from(n: TsReturnTypeAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsReturnTypeAnnotation> for SyntaxElement {
    fn from(n: TsReturnTypeAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsSatisfiesAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_SATISFIES_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_SATISFIES_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsSatisfiesAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSatisfiesAssignment")
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .field(
                "satisfies_token",
                &support::DebugSyntaxResult(self.satisfies_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsSatisfiesAssignment> for SyntaxNode {
    fn from(n: TsSatisfiesAssignment) -> SyntaxNode { n.syntax }
}
impl From<TsSatisfiesAssignment> for SyntaxElement {
    fn from(n: TsSatisfiesAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsSatisfiesExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_SATISFIES_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_SATISFIES_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsSatisfiesExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSatisfiesExpression")
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .field(
                "satisfies_token",
                &support::DebugSyntaxResult(self.satisfies_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsSatisfiesExpression> for SyntaxNode {
    fn from(n: TsSatisfiesExpression) -> SyntaxNode { n.syntax }
}
impl From<TsSatisfiesExpression> for SyntaxElement {
    fn from(n: TsSatisfiesExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsSetterSignatureClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_SETTER_SIGNATURE_CLASS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_SETTER_SIGNATURE_CLASS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsSetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSetterSignatureClassMember")
            .field("modifiers", &self.modifiers())
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsSetterSignatureClassMember> for SyntaxNode {
    fn from(n: TsSetterSignatureClassMember) -> SyntaxNode { n.syntax }
}
impl From<TsSetterSignatureClassMember> for SyntaxElement {
    fn from(n: TsSetterSignatureClassMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsSetterSignatureTypeMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_SETTER_SIGNATURE_TYPE_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_SETTER_SIGNATURE_TYPE_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsSetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSetterSignatureTypeMember")
            .field("set_token", &support::DebugSyntaxResult(self.set_token()))
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "l_paren_token",
                &support::DebugSyntaxResult(self.l_paren_token()),
            )
            .field("parameter", &support::DebugSyntaxResult(self.parameter()))
            .field(
                "r_paren_token",
                &support::DebugSyntaxResult(self.r_paren_token()),
            )
            .field(
                "separator_token",
                &support::DebugOptionalElement(self.separator_token()),
            )
            .finish()
    }
}
impl From<TsSetterSignatureTypeMember> for SyntaxNode {
    fn from(n: TsSetterSignatureTypeMember) -> SyntaxNode { n.syntax }
}
impl From<TsSetterSignatureTypeMember> for SyntaxElement {
    fn from(n: TsSetterSignatureTypeMember) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsStringLiteralType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_STRING_LITERAL_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_STRING_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsStringLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsStringLiteralType")
            .field(
                "literal_token",
                &support::DebugSyntaxResult(self.literal_token()),
            )
            .finish()
    }
}
impl From<TsStringLiteralType> for SyntaxNode {
    fn from(n: TsStringLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsStringLiteralType> for SyntaxElement {
    fn from(n: TsStringLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsStringType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_STRING_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_STRING_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsStringType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsStringType")
            .field(
                "string_token",
                &support::DebugSyntaxResult(self.string_token()),
            )
            .finish()
    }
}
impl From<TsStringType> for SyntaxNode {
    fn from(n: TsStringType) -> SyntaxNode { n.syntax }
}
impl From<TsStringType> for SyntaxElement {
    fn from(n: TsStringType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsSymbolType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_SYMBOL_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_SYMBOL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsSymbolType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsSymbolType")
            .field(
                "symbol_token",
                &support::DebugSyntaxResult(self.symbol_token()),
            )
            .finish()
    }
}
impl From<TsSymbolType> for SyntaxNode {
    fn from(n: TsSymbolType) -> SyntaxNode { n.syntax }
}
impl From<TsSymbolType> for SyntaxElement {
    fn from(n: TsSymbolType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTemplateChunkElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TEMPLATE_CHUNK_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TEMPLATE_CHUNK_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateChunkElement")
            .field(
                "template_chunk_token",
                &support::DebugSyntaxResult(self.template_chunk_token()),
            )
            .finish()
    }
}
impl From<TsTemplateChunkElement> for SyntaxNode {
    fn from(n: TsTemplateChunkElement) -> SyntaxNode { n.syntax }
}
impl From<TsTemplateChunkElement> for SyntaxElement {
    fn from(n: TsTemplateChunkElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTemplateElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TEMPLATE_ELEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TEMPLATE_ELEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateElement")
            .field(
                "dollar_curly_token",
                &support::DebugSyntaxResult(self.dollar_curly_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_curly_token",
                &support::DebugSyntaxResult(self.r_curly_token()),
            )
            .finish()
    }
}
impl From<TsTemplateElement> for SyntaxNode {
    fn from(n: TsTemplateElement) -> SyntaxNode { n.syntax }
}
impl From<TsTemplateElement> for SyntaxElement {
    fn from(n: TsTemplateElement) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTemplateLiteralType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TEMPLATE_LITERAL_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TEMPLATE_LITERAL_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTemplateLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTemplateLiteralType")
            .field(
                "l_tick_token",
                &support::DebugSyntaxResult(self.l_tick_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_tick_token",
                &support::DebugSyntaxResult(self.r_tick_token()),
            )
            .finish()
    }
}
impl From<TsTemplateLiteralType> for SyntaxNode {
    fn from(n: TsTemplateLiteralType) -> SyntaxNode { n.syntax }
}
impl From<TsTemplateLiteralType> for SyntaxElement {
    fn from(n: TsTemplateLiteralType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsThisParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_THIS_PARAMETER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_THIS_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsThisParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsThisParameter")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .field(
                "type_annotation",
                &support::DebugOptionalElement(self.type_annotation()),
            )
            .finish()
    }
}
impl From<TsThisParameter> for SyntaxNode {
    fn from(n: TsThisParameter) -> SyntaxNode { n.syntax }
}
impl From<TsThisParameter> for SyntaxElement {
    fn from(n: TsThisParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsThisType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_THIS_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_THIS_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsThisType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsThisType")
            .field("this_token", &support::DebugSyntaxResult(self.this_token()))
            .finish()
    }
}
impl From<TsThisType> for SyntaxNode {
    fn from(n: TsThisType) -> SyntaxNode { n.syntax }
}
impl From<TsThisType> for SyntaxElement {
    fn from(n: TsThisType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTupleType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TUPLE_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TUPLE_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTupleType")
            .field(
                "l_brack_token",
                &support::DebugSyntaxResult(self.l_brack_token()),
            )
            .field("elements", &self.elements())
            .field(
                "r_brack_token",
                &support::DebugSyntaxResult(self.r_brack_token()),
            )
            .finish()
    }
}
impl From<TsTupleType> for SyntaxNode {
    fn from(n: TsTupleType) -> SyntaxNode { n.syntax }
}
impl From<TsTupleType> for SyntaxElement {
    fn from(n: TsTupleType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeAliasDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_ALIAS_DECLARATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ALIAS_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeAliasDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAliasDeclaration")
            .field("type_token", &support::DebugSyntaxResult(self.type_token()))
            .field(
                "binding_identifier",
                &support::DebugSyntaxResult(self.binding_identifier()),
            )
            .field(
                "type_parameters",
                &support::DebugOptionalElement(self.type_parameters()),
            )
            .field("eq_token", &support::DebugSyntaxResult(self.eq_token()))
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "semicolon_token",
                &support::DebugOptionalElement(self.semicolon_token()),
            )
            .finish()
    }
}
impl From<TsTypeAliasDeclaration> for SyntaxNode {
    fn from(n: TsTypeAliasDeclaration) -> SyntaxNode { n.syntax }
}
impl From<TsTypeAliasDeclaration> for SyntaxElement {
    fn from(n: TsTypeAliasDeclaration) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeAnnotation {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_ANNOTATION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ANNOTATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAnnotation")
            .field(
                "colon_token",
                &support::DebugSyntaxResult(self.colon_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeAnnotation> for SyntaxNode {
    fn from(n: TsTypeAnnotation) -> SyntaxNode { n.syntax }
}
impl From<TsTypeAnnotation> for SyntaxElement {
    fn from(n: TsTypeAnnotation) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeArguments {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_ARGUMENTS as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ARGUMENTS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeArguments")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ts_type_argument_list", &self.ts_type_argument_list())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<TsTypeArguments> for SyntaxNode {
    fn from(n: TsTypeArguments) -> SyntaxNode { n.syntax }
}
impl From<TsTypeArguments> for SyntaxElement {
    fn from(n: TsTypeArguments) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeAssertionAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_ASSERTION_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ASSERTION_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAssertionAssignment")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .field("assignment", &support::DebugSyntaxResult(self.assignment()))
            .finish()
    }
}
impl From<TsTypeAssertionAssignment> for SyntaxNode {
    fn from(n: TsTypeAssertionAssignment) -> SyntaxNode { n.syntax }
}
impl From<TsTypeAssertionAssignment> for SyntaxElement {
    fn from(n: TsTypeAssertionAssignment) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeAssertionExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_ASSERTION_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ASSERTION_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeAssertionExpression")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .field("expression", &support::DebugSyntaxResult(self.expression()))
            .finish()
    }
}
impl From<TsTypeAssertionExpression> for SyntaxNode {
    fn from(n: TsTypeAssertionExpression) -> SyntaxNode { n.syntax }
}
impl From<TsTypeAssertionExpression> for SyntaxElement {
    fn from(n: TsTypeAssertionExpression) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeConstraintClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_CONSTRAINT_CLAUSE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_CONSTRAINT_CLAUSE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeConstraintClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeConstraintClause")
            .field(
                "extends_token",
                &support::DebugSyntaxResult(self.extends_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeConstraintClause> for SyntaxNode {
    fn from(n: TsTypeConstraintClause) -> SyntaxNode { n.syntax }
}
impl From<TsTypeConstraintClause> for SyntaxElement {
    fn from(n: TsTypeConstraintClause) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeOperatorType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_OPERATOR_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_OPERATOR_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeOperatorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeOperatorType")
            .field(
                "operator_token",
                &support::DebugSyntaxResult(self.operator_token()),
            )
            .field("ty", &support::DebugSyntaxResult(self.ty()))
            .finish()
    }
}
impl From<TsTypeOperatorType> for SyntaxNode {
    fn from(n: TsTypeOperatorType) -> SyntaxNode { n.syntax }
}
impl From<TsTypeOperatorType> for SyntaxElement {
    fn from(n: TsTypeOperatorType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_PARAMETER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameter")
            .field("modifiers", &self.modifiers())
            .field("name", &support::DebugSyntaxResult(self.name()))
            .field(
                "constraint",
                &support::DebugOptionalElement(self.constraint()),
            )
            .field("default", &support::DebugOptionalElement(self.default()))
            .finish()
    }
}
impl From<TsTypeParameter> for SyntaxNode {
    fn from(n: TsTypeParameter) -> SyntaxNode { n.syntax }
}
impl From<TsTypeParameter> for SyntaxElement {
    fn from(n: TsTypeParameter) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeParameterName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_PARAMETER_NAME as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETER_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameterName")
            .field(
                "ident_token",
                &support::DebugSyntaxResult(self.ident_token()),
            )
            .finish()
    }
}
impl From<TsTypeParameterName> for SyntaxNode {
    fn from(n: TsTypeParameterName) -> SyntaxNode { n.syntax }
}
impl From<TsTypeParameterName> for SyntaxElement {
    fn from(n: TsTypeParameterName) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeParameters {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_PARAMETERS as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETERS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeParameters")
            .field(
                "l_angle_token",
                &support::DebugSyntaxResult(self.l_angle_token()),
            )
            .field("items", &self.items())
            .field(
                "r_angle_token",
                &support::DebugSyntaxResult(self.r_angle_token()),
            )
            .finish()
    }
}
impl From<TsTypeParameters> for SyntaxNode {
    fn from(n: TsTypeParameters) -> SyntaxNode { n.syntax }
}
impl From<TsTypeParameters> for SyntaxElement {
    fn from(n: TsTypeParameters) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsTypeofType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPEOF_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPEOF_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsTypeofType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsTypeofType")
            .field(
                "typeof_token",
                &support::DebugSyntaxResult(self.typeof_token()),
            )
            .field(
                "expression_name",
                &support::DebugSyntaxResult(self.expression_name()),
            )
            .field(
                "type_arguments",
                &support::DebugOptionalElement(self.type_arguments()),
            )
            .finish()
    }
}
impl From<TsTypeofType> for SyntaxNode {
    fn from(n: TsTypeofType) -> SyntaxNode { n.syntax }
}
impl From<TsTypeofType> for SyntaxElement {
    fn from(n: TsTypeofType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsUndefinedType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_UNDEFINED_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_UNDEFINED_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsUndefinedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUndefinedType")
            .field(
                "undefined_token",
                &support::DebugSyntaxResult(self.undefined_token()),
            )
            .finish()
    }
}
impl From<TsUndefinedType> for SyntaxNode {
    fn from(n: TsUndefinedType) -> SyntaxNode { n.syntax }
}
impl From<TsUndefinedType> for SyntaxElement {
    fn from(n: TsUndefinedType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsUnionType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_UNION_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_UNION_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsUnionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUnionType")
            .field(
                "leading_separator_token",
                &support::DebugOptionalElement(self.leading_separator_token()),
            )
            .field("types", &self.types())
            .finish()
    }
}
impl From<TsUnionType> for SyntaxNode {
    fn from(n: TsUnionType) -> SyntaxNode { n.syntax }
}
impl From<TsUnionType> for SyntaxElement {
    fn from(n: TsUnionType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsUnknownType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_UNKNOWN_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_UNKNOWN_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsUnknownType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsUnknownType")
            .field(
                "unknown_token",
                &support::DebugSyntaxResult(self.unknown_token()),
            )
            .finish()
    }
}
impl From<TsUnknownType> for SyntaxNode {
    fn from(n: TsUnknownType) -> SyntaxNode { n.syntax }
}
impl From<TsUnknownType> for SyntaxElement {
    fn from(n: TsUnknownType) -> SyntaxElement { n.syntax.into() }
}
impl AstNode for TsVoidType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_VOID_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_VOID_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsVoidType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsVoidType")
            .field("void_token", &support::DebugSyntaxResult(self.void_token()))
            .finish()
    }
}
impl From<TsVoidType> for SyntaxNode {
    fn from(n: TsVoidType) -> SyntaxNode { n.syntax }
}
impl From<TsVoidType> for SyntaxElement {
    fn from(n: TsVoidType) -> SyntaxElement { n.syntax.into() }
}
impl From<JsArrayAssignmentPatternRestElement> for AnyJsArrayAssignmentPatternElement {
    fn from(node: JsArrayAssignmentPatternRestElement) -> AnyJsArrayAssignmentPatternElement {
        AnyJsArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(node)
    }
}
impl From<JsArrayHole> for AnyJsArrayAssignmentPatternElement {
    fn from(node: JsArrayHole) -> AnyJsArrayAssignmentPatternElement {
        AnyJsArrayAssignmentPatternElement::JsArrayHole(node)
    }
}
impl From<JsAssignmentWithDefault> for AnyJsArrayAssignmentPatternElement {
    fn from(node: JsAssignmentWithDefault) -> AnyJsArrayAssignmentPatternElement {
        AnyJsArrayAssignmentPatternElement::JsAssignmentWithDefault(node)
    }
}
impl AstNode for AnyJsArrayAssignmentPatternElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsAssignmentPattern::KIND_SET
        .union(JsArrayAssignmentPatternRestElement::KIND_SET)
        .union(JsArrayHole::KIND_SET)
        .union(JsAssignmentWithDefault::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT
            | JS_ARRAY_HOLE
            | JS_ASSIGNMENT_WITH_DEFAULT => true,
            k if AnyJsAssignmentPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT => {
                AnyJsArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(
                    JsArrayAssignmentPatternRestElement { syntax },
                )
            }
            JS_ARRAY_HOLE => {
                AnyJsArrayAssignmentPatternElement::JsArrayHole(JsArrayHole { syntax })
            }
            JS_ASSIGNMENT_WITH_DEFAULT => {
                AnyJsArrayAssignmentPatternElement::JsAssignmentWithDefault(
                    JsAssignmentWithDefault { syntax },
                )
            }
            _ => {
                if let Some(any_js_assignment_pattern) = AnyJsAssignmentPattern::cast(syntax) {
                    return Some(AnyJsArrayAssignmentPatternElement::AnyJsAssignmentPattern(
                        any_js_assignment_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                &it.syntax
            }
            AnyJsArrayAssignmentPatternElement::JsArrayHole(it) => &it.syntax,
            AnyJsArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => &it.syntax,
            AnyJsArrayAssignmentPatternElement::AnyJsAssignmentPattern(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                it.syntax
            }
            AnyJsArrayAssignmentPatternElement::JsArrayHole(it) => it.syntax,
            AnyJsArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => it.syntax,
            AnyJsArrayAssignmentPatternElement::AnyJsAssignmentPattern(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsArrayAssignmentPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsArrayAssignmentPatternElement::AnyJsAssignmentPattern(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsArrayAssignmentPatternElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            AnyJsArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<AnyJsArrayAssignmentPatternElement> for SyntaxNode {
    fn from(n: AnyJsArrayAssignmentPatternElement) -> SyntaxNode {
        match n {
            AnyJsArrayAssignmentPatternElement::AnyJsAssignmentPattern(it) => it.into(),
            AnyJsArrayAssignmentPatternElement::JsArrayAssignmentPatternRestElement(it) => {
                it.into()
            }
            AnyJsArrayAssignmentPatternElement::JsArrayHole(it) => it.into(),
            AnyJsArrayAssignmentPatternElement::JsAssignmentWithDefault(it) => it.into(),
        }
    }
}
impl From<AnyJsArrayAssignmentPatternElement> for SyntaxElement {
    fn from(n: AnyJsArrayAssignmentPatternElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayBindingPatternRestElement> for AnyJsArrayBindingPatternElement {
    fn from(node: JsArrayBindingPatternRestElement) -> AnyJsArrayBindingPatternElement {
        AnyJsArrayBindingPatternElement::JsArrayBindingPatternRestElement(node)
    }
}
impl From<JsArrayHole> for AnyJsArrayBindingPatternElement {
    fn from(node: JsArrayHole) -> AnyJsArrayBindingPatternElement {
        AnyJsArrayBindingPatternElement::JsArrayHole(node)
    }
}
impl From<JsBindingPatternWithDefault> for AnyJsArrayBindingPatternElement {
    fn from(node: JsBindingPatternWithDefault) -> AnyJsArrayBindingPatternElement {
        AnyJsArrayBindingPatternElement::JsBindingPatternWithDefault(node)
    }
}
impl AstNode for AnyJsArrayBindingPatternElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsBindingPattern::KIND_SET
        .union(JsArrayBindingPatternRestElement::KIND_SET)
        .union(JsArrayHole::KIND_SET)
        .union(JsBindingPatternWithDefault::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_BINDING_PATTERN_REST_ELEMENT
            | JS_ARRAY_HOLE
            | JS_BINDING_PATTERN_WITH_DEFAULT => true,
            k if AnyJsBindingPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_BINDING_PATTERN_REST_ELEMENT => {
                AnyJsArrayBindingPatternElement::JsArrayBindingPatternRestElement(
                    JsArrayBindingPatternRestElement { syntax },
                )
            }
            JS_ARRAY_HOLE => AnyJsArrayBindingPatternElement::JsArrayHole(JsArrayHole { syntax }),
            JS_BINDING_PATTERN_WITH_DEFAULT => {
                AnyJsArrayBindingPatternElement::JsBindingPatternWithDefault(
                    JsBindingPatternWithDefault { syntax },
                )
            }
            _ => {
                if let Some(any_js_binding_pattern) = AnyJsBindingPattern::cast(syntax) {
                    return Some(AnyJsArrayBindingPatternElement::AnyJsBindingPattern(
                        any_js_binding_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => &it.syntax,
            AnyJsArrayBindingPatternElement::JsArrayHole(it) => &it.syntax,
            AnyJsArrayBindingPatternElement::JsBindingPatternWithDefault(it) => &it.syntax,
            AnyJsArrayBindingPatternElement::AnyJsBindingPattern(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => it.syntax,
            AnyJsArrayBindingPatternElement::JsArrayHole(it) => it.syntax,
            AnyJsArrayBindingPatternElement::JsBindingPatternWithDefault(it) => it.syntax,
            AnyJsArrayBindingPatternElement::AnyJsBindingPattern(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsArrayBindingPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsArrayBindingPatternElement::AnyJsBindingPattern(it) => std::fmt::Debug::fmt(it, f),
            AnyJsArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsArrayBindingPatternElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            AnyJsArrayBindingPatternElement::JsBindingPatternWithDefault(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<AnyJsArrayBindingPatternElement> for SyntaxNode {
    fn from(n: AnyJsArrayBindingPatternElement) -> SyntaxNode {
        match n {
            AnyJsArrayBindingPatternElement::AnyJsBindingPattern(it) => it.into(),
            AnyJsArrayBindingPatternElement::JsArrayBindingPatternRestElement(it) => it.into(),
            AnyJsArrayBindingPatternElement::JsArrayHole(it) => it.into(),
            AnyJsArrayBindingPatternElement::JsBindingPatternWithDefault(it) => it.into(),
        }
    }
}
impl From<AnyJsArrayBindingPatternElement> for SyntaxElement {
    fn from(n: AnyJsArrayBindingPatternElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayHole> for AnyJsArrayElement {
    fn from(node: JsArrayHole) -> AnyJsArrayElement { AnyJsArrayElement::JsArrayHole(node) }
}
impl From<JsSpread> for AnyJsArrayElement {
    fn from(node: JsSpread) -> AnyJsArrayElement { AnyJsArrayElement::JsSpread(node) }
}
impl AstNode for AnyJsArrayElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsExpression::KIND_SET
        .union(JsArrayHole::KIND_SET)
        .union(JsSpread::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_HOLE | JS_SPREAD => true,
            k if AnyJsExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_HOLE => AnyJsArrayElement::JsArrayHole(JsArrayHole { syntax }),
            JS_SPREAD => AnyJsArrayElement::JsSpread(JsSpread { syntax }),
            _ => {
                if let Some(any_js_expression) = AnyJsExpression::cast(syntax) {
                    return Some(AnyJsArrayElement::AnyJsExpression(any_js_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsArrayElement::JsArrayHole(it) => &it.syntax,
            AnyJsArrayElement::JsSpread(it) => &it.syntax,
            AnyJsArrayElement::AnyJsExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsArrayElement::JsArrayHole(it) => it.syntax,
            AnyJsArrayElement::JsSpread(it) => it.syntax,
            AnyJsArrayElement::AnyJsExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsArrayElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsArrayElement::AnyJsExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsArrayElement::JsArrayHole(it) => std::fmt::Debug::fmt(it, f),
            AnyJsArrayElement::JsSpread(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsArrayElement> for SyntaxNode {
    fn from(n: AnyJsArrayElement) -> SyntaxNode {
        match n {
            AnyJsArrayElement::AnyJsExpression(it) => it.into(),
            AnyJsArrayElement::JsArrayHole(it) => it.into(),
            AnyJsArrayElement::JsSpread(it) => it.into(),
        }
    }
}
impl From<AnyJsArrayElement> for SyntaxElement {
    fn from(n: AnyJsArrayElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsParameters> for AnyJsArrowFunctionParameters {
    fn from(node: JsParameters) -> AnyJsArrowFunctionParameters {
        AnyJsArrowFunctionParameters::JsParameters(node)
    }
}
impl AstNode for AnyJsArrowFunctionParameters {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsBinding::KIND_SET.union(JsParameters::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_PARAMETERS => true,
            k if AnyJsBinding::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_PARAMETERS => AnyJsArrowFunctionParameters::JsParameters(JsParameters { syntax }),
            _ => {
                if let Some(any_js_binding) = AnyJsBinding::cast(syntax) {
                    return Some(AnyJsArrowFunctionParameters::AnyJsBinding(any_js_binding));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsArrowFunctionParameters::JsParameters(it) => &it.syntax,
            AnyJsArrowFunctionParameters::AnyJsBinding(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsArrowFunctionParameters::JsParameters(it) => it.syntax,
            AnyJsArrowFunctionParameters::AnyJsBinding(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsArrowFunctionParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsArrowFunctionParameters::AnyJsBinding(it) => std::fmt::Debug::fmt(it, f),
            AnyJsArrowFunctionParameters::JsParameters(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsArrowFunctionParameters> for SyntaxNode {
    fn from(n: AnyJsArrowFunctionParameters) -> SyntaxNode {
        match n {
            AnyJsArrowFunctionParameters::AnyJsBinding(it) => it.into(),
            AnyJsArrowFunctionParameters::JsParameters(it) => it.into(),
        }
    }
}
impl From<AnyJsArrowFunctionParameters> for SyntaxElement {
    fn from(n: AnyJsArrowFunctionParameters) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusAssignment> for AnyJsAssignment {
    fn from(node: JsBogusAssignment) -> AnyJsAssignment { AnyJsAssignment::JsBogusAssignment(node) }
}
impl From<JsComputedMemberAssignment> for AnyJsAssignment {
    fn from(node: JsComputedMemberAssignment) -> AnyJsAssignment {
        AnyJsAssignment::JsComputedMemberAssignment(node)
    }
}
impl From<JsIdentifierAssignment> for AnyJsAssignment {
    fn from(node: JsIdentifierAssignment) -> AnyJsAssignment {
        AnyJsAssignment::JsIdentifierAssignment(node)
    }
}
impl From<JsParenthesizedAssignment> for AnyJsAssignment {
    fn from(node: JsParenthesizedAssignment) -> AnyJsAssignment {
        AnyJsAssignment::JsParenthesizedAssignment(node)
    }
}
impl From<JsStaticMemberAssignment> for AnyJsAssignment {
    fn from(node: JsStaticMemberAssignment) -> AnyJsAssignment {
        AnyJsAssignment::JsStaticMemberAssignment(node)
    }
}
impl From<TsAsAssignment> for AnyJsAssignment {
    fn from(node: TsAsAssignment) -> AnyJsAssignment { AnyJsAssignment::TsAsAssignment(node) }
}
impl From<TsNonNullAssertionAssignment> for AnyJsAssignment {
    fn from(node: TsNonNullAssertionAssignment) -> AnyJsAssignment {
        AnyJsAssignment::TsNonNullAssertionAssignment(node)
    }
}
impl From<TsSatisfiesAssignment> for AnyJsAssignment {
    fn from(node: TsSatisfiesAssignment) -> AnyJsAssignment {
        AnyJsAssignment::TsSatisfiesAssignment(node)
    }
}
impl From<TsTypeAssertionAssignment> for AnyJsAssignment {
    fn from(node: TsTypeAssertionAssignment) -> AnyJsAssignment {
        AnyJsAssignment::TsTypeAssertionAssignment(node)
    }
}
impl AstNode for AnyJsAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBogusAssignment::KIND_SET
        .union(JsComputedMemberAssignment::KIND_SET)
        .union(JsIdentifierAssignment::KIND_SET)
        .union(JsParenthesizedAssignment::KIND_SET)
        .union(JsStaticMemberAssignment::KIND_SET)
        .union(TsAsAssignment::KIND_SET)
        .union(TsNonNullAssertionAssignment::KIND_SET)
        .union(TsSatisfiesAssignment::KIND_SET)
        .union(TsTypeAssertionAssignment::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_ASSIGNMENT
                | JS_COMPUTED_MEMBER_ASSIGNMENT
                | JS_IDENTIFIER_ASSIGNMENT
                | JS_PARENTHESIZED_ASSIGNMENT
                | JS_STATIC_MEMBER_ASSIGNMENT
                | TS_AS_ASSIGNMENT
                | TS_NON_NULL_ASSERTION_ASSIGNMENT
                | TS_SATISFIES_ASSIGNMENT
                | TS_TYPE_ASSERTION_ASSIGNMENT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_ASSIGNMENT => AnyJsAssignment::JsBogusAssignment(JsBogusAssignment { syntax }),
            JS_COMPUTED_MEMBER_ASSIGNMENT => {
                AnyJsAssignment::JsComputedMemberAssignment(JsComputedMemberAssignment { syntax })
            }
            JS_IDENTIFIER_ASSIGNMENT => {
                AnyJsAssignment::JsIdentifierAssignment(JsIdentifierAssignment { syntax })
            }
            JS_PARENTHESIZED_ASSIGNMENT => {
                AnyJsAssignment::JsParenthesizedAssignment(JsParenthesizedAssignment { syntax })
            }
            JS_STATIC_MEMBER_ASSIGNMENT => {
                AnyJsAssignment::JsStaticMemberAssignment(JsStaticMemberAssignment { syntax })
            }
            TS_AS_ASSIGNMENT => AnyJsAssignment::TsAsAssignment(TsAsAssignment { syntax }),
            TS_NON_NULL_ASSERTION_ASSIGNMENT => {
                AnyJsAssignment::TsNonNullAssertionAssignment(TsNonNullAssertionAssignment {
                    syntax,
                })
            }
            TS_SATISFIES_ASSIGNMENT => {
                AnyJsAssignment::TsSatisfiesAssignment(TsSatisfiesAssignment { syntax })
            }
            TS_TYPE_ASSERTION_ASSIGNMENT => {
                AnyJsAssignment::TsTypeAssertionAssignment(TsTypeAssertionAssignment { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsAssignment::JsBogusAssignment(it) => &it.syntax,
            AnyJsAssignment::JsComputedMemberAssignment(it) => &it.syntax,
            AnyJsAssignment::JsIdentifierAssignment(it) => &it.syntax,
            AnyJsAssignment::JsParenthesizedAssignment(it) => &it.syntax,
            AnyJsAssignment::JsStaticMemberAssignment(it) => &it.syntax,
            AnyJsAssignment::TsAsAssignment(it) => &it.syntax,
            AnyJsAssignment::TsNonNullAssertionAssignment(it) => &it.syntax,
            AnyJsAssignment::TsSatisfiesAssignment(it) => &it.syntax,
            AnyJsAssignment::TsTypeAssertionAssignment(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsAssignment::JsBogusAssignment(it) => it.syntax,
            AnyJsAssignment::JsComputedMemberAssignment(it) => it.syntax,
            AnyJsAssignment::JsIdentifierAssignment(it) => it.syntax,
            AnyJsAssignment::JsParenthesizedAssignment(it) => it.syntax,
            AnyJsAssignment::JsStaticMemberAssignment(it) => it.syntax,
            AnyJsAssignment::TsAsAssignment(it) => it.syntax,
            AnyJsAssignment::TsNonNullAssertionAssignment(it) => it.syntax,
            AnyJsAssignment::TsSatisfiesAssignment(it) => it.syntax,
            AnyJsAssignment::TsTypeAssertionAssignment(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsAssignment::JsBogusAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignment::JsComputedMemberAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignment::JsIdentifierAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignment::JsParenthesizedAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignment::JsStaticMemberAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignment::TsAsAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignment::TsNonNullAssertionAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignment::TsSatisfiesAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignment::TsTypeAssertionAssignment(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsAssignment> for SyntaxNode {
    fn from(n: AnyJsAssignment) -> SyntaxNode {
        match n {
            AnyJsAssignment::JsBogusAssignment(it) => it.into(),
            AnyJsAssignment::JsComputedMemberAssignment(it) => it.into(),
            AnyJsAssignment::JsIdentifierAssignment(it) => it.into(),
            AnyJsAssignment::JsParenthesizedAssignment(it) => it.into(),
            AnyJsAssignment::JsStaticMemberAssignment(it) => it.into(),
            AnyJsAssignment::TsAsAssignment(it) => it.into(),
            AnyJsAssignment::TsNonNullAssertionAssignment(it) => it.into(),
            AnyJsAssignment::TsSatisfiesAssignment(it) => it.into(),
            AnyJsAssignment::TsTypeAssertionAssignment(it) => it.into(),
        }
    }
}
impl From<AnyJsAssignment> for SyntaxElement {
    fn from(n: AnyJsAssignment) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayAssignmentPattern> for AnyJsAssignmentPattern {
    fn from(node: JsArrayAssignmentPattern) -> AnyJsAssignmentPattern {
        AnyJsAssignmentPattern::JsArrayAssignmentPattern(node)
    }
}
impl From<JsObjectAssignmentPattern> for AnyJsAssignmentPattern {
    fn from(node: JsObjectAssignmentPattern) -> AnyJsAssignmentPattern {
        AnyJsAssignmentPattern::JsObjectAssignmentPattern(node)
    }
}
impl AstNode for AnyJsAssignmentPattern {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsAssignment::KIND_SET
        .union(JsArrayAssignmentPattern::KIND_SET)
        .union(JsObjectAssignmentPattern::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_ASSIGNMENT_PATTERN | JS_OBJECT_ASSIGNMENT_PATTERN => true,
            k if AnyJsAssignment::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_ASSIGNMENT_PATTERN => {
                AnyJsAssignmentPattern::JsArrayAssignmentPattern(JsArrayAssignmentPattern {
                    syntax,
                })
            }
            JS_OBJECT_ASSIGNMENT_PATTERN => {
                AnyJsAssignmentPattern::JsObjectAssignmentPattern(JsObjectAssignmentPattern {
                    syntax,
                })
            }
            _ => {
                if let Some(any_js_assignment) = AnyJsAssignment::cast(syntax) {
                    return Some(AnyJsAssignmentPattern::AnyJsAssignment(any_js_assignment));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsAssignmentPattern::JsArrayAssignmentPattern(it) => &it.syntax,
            AnyJsAssignmentPattern::JsObjectAssignmentPattern(it) => &it.syntax,
            AnyJsAssignmentPattern::AnyJsAssignment(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsAssignmentPattern::JsArrayAssignmentPattern(it) => it.syntax,
            AnyJsAssignmentPattern::JsObjectAssignmentPattern(it) => it.syntax,
            AnyJsAssignmentPattern::AnyJsAssignment(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsAssignmentPattern::AnyJsAssignment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignmentPattern::JsArrayAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
            AnyJsAssignmentPattern::JsObjectAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsAssignmentPattern> for SyntaxNode {
    fn from(n: AnyJsAssignmentPattern) -> SyntaxNode {
        match n {
            AnyJsAssignmentPattern::AnyJsAssignment(it) => it.into(),
            AnyJsAssignmentPattern::JsArrayAssignmentPattern(it) => it.into(),
            AnyJsAssignmentPattern::JsObjectAssignmentPattern(it) => it.into(),
        }
    }
}
impl From<AnyJsAssignmentPattern> for SyntaxElement {
    fn from(n: AnyJsAssignmentPattern) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusBinding> for AnyJsBinding {
    fn from(node: JsBogusBinding) -> AnyJsBinding { AnyJsBinding::JsBogusBinding(node) }
}
impl From<JsIdentifierBinding> for AnyJsBinding {
    fn from(node: JsIdentifierBinding) -> AnyJsBinding { AnyJsBinding::JsIdentifierBinding(node) }
}
impl AstNode for AnyJsBinding {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsBogusBinding::KIND_SET.union(JsIdentifierBinding::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_BOGUS_BINDING | JS_IDENTIFIER_BINDING)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_BINDING => AnyJsBinding::JsBogusBinding(JsBogusBinding { syntax }),
            JS_IDENTIFIER_BINDING => {
                AnyJsBinding::JsIdentifierBinding(JsIdentifierBinding { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsBinding::JsBogusBinding(it) => &it.syntax,
            AnyJsBinding::JsIdentifierBinding(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsBinding::JsBogusBinding(it) => it.syntax,
            AnyJsBinding::JsIdentifierBinding(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsBinding::JsBogusBinding(it) => std::fmt::Debug::fmt(it, f),
            AnyJsBinding::JsIdentifierBinding(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsBinding> for SyntaxNode {
    fn from(n: AnyJsBinding) -> SyntaxNode {
        match n {
            AnyJsBinding::JsBogusBinding(it) => it.into(),
            AnyJsBinding::JsIdentifierBinding(it) => it.into(),
        }
    }
}
impl From<AnyJsBinding> for SyntaxElement {
    fn from(n: AnyJsBinding) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayBindingPattern> for AnyJsBindingPattern {
    fn from(node: JsArrayBindingPattern) -> AnyJsBindingPattern {
        AnyJsBindingPattern::JsArrayBindingPattern(node)
    }
}
impl From<JsObjectBindingPattern> for AnyJsBindingPattern {
    fn from(node: JsObjectBindingPattern) -> AnyJsBindingPattern {
        AnyJsBindingPattern::JsObjectBindingPattern(node)
    }
}
impl AstNode for AnyJsBindingPattern {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsBinding::KIND_SET
        .union(JsArrayBindingPattern::KIND_SET)
        .union(JsObjectBindingPattern::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_BINDING_PATTERN | JS_OBJECT_BINDING_PATTERN => true,
            k if AnyJsBinding::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_BINDING_PATTERN => {
                AnyJsBindingPattern::JsArrayBindingPattern(JsArrayBindingPattern { syntax })
            }
            JS_OBJECT_BINDING_PATTERN => {
                AnyJsBindingPattern::JsObjectBindingPattern(JsObjectBindingPattern { syntax })
            }
            _ => {
                if let Some(any_js_binding) = AnyJsBinding::cast(syntax) {
                    return Some(AnyJsBindingPattern::AnyJsBinding(any_js_binding));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsBindingPattern::JsArrayBindingPattern(it) => &it.syntax,
            AnyJsBindingPattern::JsObjectBindingPattern(it) => &it.syntax,
            AnyJsBindingPattern::AnyJsBinding(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsBindingPattern::JsArrayBindingPattern(it) => it.syntax,
            AnyJsBindingPattern::JsObjectBindingPattern(it) => it.syntax,
            AnyJsBindingPattern::AnyJsBinding(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsBindingPattern::AnyJsBinding(it) => std::fmt::Debug::fmt(it, f),
            AnyJsBindingPattern::JsArrayBindingPattern(it) => std::fmt::Debug::fmt(it, f),
            AnyJsBindingPattern::JsObjectBindingPattern(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsBindingPattern> for SyntaxNode {
    fn from(n: AnyJsBindingPattern) -> SyntaxNode {
        match n {
            AnyJsBindingPattern::AnyJsBinding(it) => it.into(),
            AnyJsBindingPattern::JsArrayBindingPattern(it) => it.into(),
            AnyJsBindingPattern::JsObjectBindingPattern(it) => it.into(),
        }
    }
}
impl From<AnyJsBindingPattern> for SyntaxElement {
    fn from(n: AnyJsBindingPattern) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsSpread> for AnyJsCallArgument {
    fn from(node: JsSpread) -> AnyJsCallArgument { AnyJsCallArgument::JsSpread(node) }
}
impl AstNode for AnyJsCallArgument {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsExpression::KIND_SET.union(JsSpread::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_SPREAD => true,
            k if AnyJsExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_SPREAD => AnyJsCallArgument::JsSpread(JsSpread { syntax }),
            _ => {
                if let Some(any_js_expression) = AnyJsExpression::cast(syntax) {
                    return Some(AnyJsCallArgument::AnyJsExpression(any_js_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsCallArgument::JsSpread(it) => &it.syntax,
            AnyJsCallArgument::AnyJsExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsCallArgument::JsSpread(it) => it.syntax,
            AnyJsCallArgument::AnyJsExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsCallArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsCallArgument::AnyJsExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsCallArgument::JsSpread(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsCallArgument> for SyntaxNode {
    fn from(n: AnyJsCallArgument) -> SyntaxNode {
        match n {
            AnyJsCallArgument::AnyJsExpression(it) => it.into(),
            AnyJsCallArgument::JsSpread(it) => it.into(),
        }
    }
}
impl From<AnyJsCallArgument> for SyntaxElement {
    fn from(n: AnyJsCallArgument) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for AnyJsClass {
    fn from(node: JsClassDeclaration) -> AnyJsClass { AnyJsClass::JsClassDeclaration(node) }
}
impl From<JsClassExportDefaultDeclaration> for AnyJsClass {
    fn from(node: JsClassExportDefaultDeclaration) -> AnyJsClass {
        AnyJsClass::JsClassExportDefaultDeclaration(node)
    }
}
impl From<JsClassExpression> for AnyJsClass {
    fn from(node: JsClassExpression) -> AnyJsClass { AnyJsClass::JsClassExpression(node) }
}
impl AstNode for AnyJsClass {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsClassDeclaration::KIND_SET
        .union(JsClassExportDefaultDeclaration::KIND_SET)
        .union(JsClassExpression::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION | JS_CLASS_EXPORT_DEFAULT_DECLARATION | JS_CLASS_EXPRESSION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => AnyJsClass::JsClassDeclaration(JsClassDeclaration { syntax }),
            JS_CLASS_EXPORT_DEFAULT_DECLARATION => {
                AnyJsClass::JsClassExportDefaultDeclaration(JsClassExportDefaultDeclaration {
                    syntax,
                })
            }
            JS_CLASS_EXPRESSION => AnyJsClass::JsClassExpression(JsClassExpression { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsClass::JsClassDeclaration(it) => &it.syntax,
            AnyJsClass::JsClassExportDefaultDeclaration(it) => &it.syntax,
            AnyJsClass::JsClassExpression(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsClass::JsClassDeclaration(it) => it.syntax,
            AnyJsClass::JsClassExportDefaultDeclaration(it) => it.syntax,
            AnyJsClass::JsClassExpression(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsClass::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClass::JsClassExportDefaultDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClass::JsClassExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsClass> for SyntaxNode {
    fn from(n: AnyJsClass) -> SyntaxNode {
        match n {
            AnyJsClass::JsClassDeclaration(it) => it.into(),
            AnyJsClass::JsClassExportDefaultDeclaration(it) => it.into(),
            AnyJsClass::JsClassExpression(it) => it.into(),
        }
    }
}
impl From<AnyJsClass> for SyntaxElement {
    fn from(n: AnyJsClass) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusMember> for AnyJsClassMember {
    fn from(node: JsBogusMember) -> AnyJsClassMember { AnyJsClassMember::JsBogusMember(node) }
}
impl From<JsConstructorClassMember> for AnyJsClassMember {
    fn from(node: JsConstructorClassMember) -> AnyJsClassMember {
        AnyJsClassMember::JsConstructorClassMember(node)
    }
}
impl From<JsEmptyClassMember> for AnyJsClassMember {
    fn from(node: JsEmptyClassMember) -> AnyJsClassMember {
        AnyJsClassMember::JsEmptyClassMember(node)
    }
}
impl From<JsGetterClassMember> for AnyJsClassMember {
    fn from(node: JsGetterClassMember) -> AnyJsClassMember {
        AnyJsClassMember::JsGetterClassMember(node)
    }
}
impl From<JsMethodClassMember> for AnyJsClassMember {
    fn from(node: JsMethodClassMember) -> AnyJsClassMember {
        AnyJsClassMember::JsMethodClassMember(node)
    }
}
impl From<JsPropertyClassMember> for AnyJsClassMember {
    fn from(node: JsPropertyClassMember) -> AnyJsClassMember {
        AnyJsClassMember::JsPropertyClassMember(node)
    }
}
impl From<JsSetterClassMember> for AnyJsClassMember {
    fn from(node: JsSetterClassMember) -> AnyJsClassMember {
        AnyJsClassMember::JsSetterClassMember(node)
    }
}
impl From<JsStaticInitializationBlockClassMember> for AnyJsClassMember {
    fn from(node: JsStaticInitializationBlockClassMember) -> AnyJsClassMember {
        AnyJsClassMember::JsStaticInitializationBlockClassMember(node)
    }
}
impl From<TsConstructorSignatureClassMember> for AnyJsClassMember {
    fn from(node: TsConstructorSignatureClassMember) -> AnyJsClassMember {
        AnyJsClassMember::TsConstructorSignatureClassMember(node)
    }
}
impl From<TsGetterSignatureClassMember> for AnyJsClassMember {
    fn from(node: TsGetterSignatureClassMember) -> AnyJsClassMember {
        AnyJsClassMember::TsGetterSignatureClassMember(node)
    }
}
impl From<TsIndexSignatureClassMember> for AnyJsClassMember {
    fn from(node: TsIndexSignatureClassMember) -> AnyJsClassMember {
        AnyJsClassMember::TsIndexSignatureClassMember(node)
    }
}
impl From<TsInitializedPropertySignatureClassMember> for AnyJsClassMember {
    fn from(node: TsInitializedPropertySignatureClassMember) -> AnyJsClassMember {
        AnyJsClassMember::TsInitializedPropertySignatureClassMember(node)
    }
}
impl From<TsMethodSignatureClassMember> for AnyJsClassMember {
    fn from(node: TsMethodSignatureClassMember) -> AnyJsClassMember {
        AnyJsClassMember::TsMethodSignatureClassMember(node)
    }
}
impl From<TsPropertySignatureClassMember> for AnyJsClassMember {
    fn from(node: TsPropertySignatureClassMember) -> AnyJsClassMember {
        AnyJsClassMember::TsPropertySignatureClassMember(node)
    }
}
impl From<TsSetterSignatureClassMember> for AnyJsClassMember {
    fn from(node: TsSetterSignatureClassMember) -> AnyJsClassMember {
        AnyJsClassMember::TsSetterSignatureClassMember(node)
    }
}
impl AstNode for AnyJsClassMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBogusMember::KIND_SET
        .union(JsConstructorClassMember::KIND_SET)
        .union(JsEmptyClassMember::KIND_SET)
        .union(JsGetterClassMember::KIND_SET)
        .union(JsMethodClassMember::KIND_SET)
        .union(JsPropertyClassMember::KIND_SET)
        .union(JsSetterClassMember::KIND_SET)
        .union(JsStaticInitializationBlockClassMember::KIND_SET)
        .union(TsConstructorSignatureClassMember::KIND_SET)
        .union(TsGetterSignatureClassMember::KIND_SET)
        .union(TsIndexSignatureClassMember::KIND_SET)
        .union(TsInitializedPropertySignatureClassMember::KIND_SET)
        .union(TsMethodSignatureClassMember::KIND_SET)
        .union(TsPropertySignatureClassMember::KIND_SET)
        .union(TsSetterSignatureClassMember::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_MEMBER
                | JS_CONSTRUCTOR_CLASS_MEMBER
                | JS_EMPTY_CLASS_MEMBER
                | JS_GETTER_CLASS_MEMBER
                | JS_METHOD_CLASS_MEMBER
                | JS_PROPERTY_CLASS_MEMBER
                | JS_SETTER_CLASS_MEMBER
                | JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER
                | TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER
                | TS_GETTER_SIGNATURE_CLASS_MEMBER
                | TS_INDEX_SIGNATURE_CLASS_MEMBER
                | TS_INITIALIZED_PROPERTY_SIGNATURE_CLASS_MEMBER
                | TS_METHOD_SIGNATURE_CLASS_MEMBER
                | TS_PROPERTY_SIGNATURE_CLASS_MEMBER
                | TS_SETTER_SIGNATURE_CLASS_MEMBER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_MEMBER => AnyJsClassMember::JsBogusMember(JsBogusMember { syntax }),
            JS_CONSTRUCTOR_CLASS_MEMBER => {
                AnyJsClassMember::JsConstructorClassMember(JsConstructorClassMember { syntax })
            }
            JS_EMPTY_CLASS_MEMBER => {
                AnyJsClassMember::JsEmptyClassMember(JsEmptyClassMember { syntax })
            }
            JS_GETTER_CLASS_MEMBER => {
                AnyJsClassMember::JsGetterClassMember(JsGetterClassMember { syntax })
            }
            JS_METHOD_CLASS_MEMBER => {
                AnyJsClassMember::JsMethodClassMember(JsMethodClassMember { syntax })
            }
            JS_PROPERTY_CLASS_MEMBER => {
                AnyJsClassMember::JsPropertyClassMember(JsPropertyClassMember { syntax })
            }
            JS_SETTER_CLASS_MEMBER => {
                AnyJsClassMember::JsSetterClassMember(JsSetterClassMember { syntax })
            }
            JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER => {
                AnyJsClassMember::JsStaticInitializationBlockClassMember(
                    JsStaticInitializationBlockClassMember { syntax },
                )
            }
            TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER => {
                AnyJsClassMember::TsConstructorSignatureClassMember(
                    TsConstructorSignatureClassMember { syntax },
                )
            }
            TS_GETTER_SIGNATURE_CLASS_MEMBER => {
                AnyJsClassMember::TsGetterSignatureClassMember(TsGetterSignatureClassMember {
                    syntax,
                })
            }
            TS_INDEX_SIGNATURE_CLASS_MEMBER => {
                AnyJsClassMember::TsIndexSignatureClassMember(TsIndexSignatureClassMember {
                    syntax,
                })
            }
            TS_INITIALIZED_PROPERTY_SIGNATURE_CLASS_MEMBER => {
                AnyJsClassMember::TsInitializedPropertySignatureClassMember(
                    TsInitializedPropertySignatureClassMember { syntax },
                )
            }
            TS_METHOD_SIGNATURE_CLASS_MEMBER => {
                AnyJsClassMember::TsMethodSignatureClassMember(TsMethodSignatureClassMember {
                    syntax,
                })
            }
            TS_PROPERTY_SIGNATURE_CLASS_MEMBER => {
                AnyJsClassMember::TsPropertySignatureClassMember(TsPropertySignatureClassMember {
                    syntax,
                })
            }
            TS_SETTER_SIGNATURE_CLASS_MEMBER => {
                AnyJsClassMember::TsSetterSignatureClassMember(TsSetterSignatureClassMember {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsClassMember::JsBogusMember(it) => &it.syntax,
            AnyJsClassMember::JsConstructorClassMember(it) => &it.syntax,
            AnyJsClassMember::JsEmptyClassMember(it) => &it.syntax,
            AnyJsClassMember::JsGetterClassMember(it) => &it.syntax,
            AnyJsClassMember::JsMethodClassMember(it) => &it.syntax,
            AnyJsClassMember::JsPropertyClassMember(it) => &it.syntax,
            AnyJsClassMember::JsSetterClassMember(it) => &it.syntax,
            AnyJsClassMember::JsStaticInitializationBlockClassMember(it) => &it.syntax,
            AnyJsClassMember::TsConstructorSignatureClassMember(it) => &it.syntax,
            AnyJsClassMember::TsGetterSignatureClassMember(it) => &it.syntax,
            AnyJsClassMember::TsIndexSignatureClassMember(it) => &it.syntax,
            AnyJsClassMember::TsInitializedPropertySignatureClassMember(it) => &it.syntax,
            AnyJsClassMember::TsMethodSignatureClassMember(it) => &it.syntax,
            AnyJsClassMember::TsPropertySignatureClassMember(it) => &it.syntax,
            AnyJsClassMember::TsSetterSignatureClassMember(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsClassMember::JsBogusMember(it) => it.syntax,
            AnyJsClassMember::JsConstructorClassMember(it) => it.syntax,
            AnyJsClassMember::JsEmptyClassMember(it) => it.syntax,
            AnyJsClassMember::JsGetterClassMember(it) => it.syntax,
            AnyJsClassMember::JsMethodClassMember(it) => it.syntax,
            AnyJsClassMember::JsPropertyClassMember(it) => it.syntax,
            AnyJsClassMember::JsSetterClassMember(it) => it.syntax,
            AnyJsClassMember::JsStaticInitializationBlockClassMember(it) => it.syntax,
            AnyJsClassMember::TsConstructorSignatureClassMember(it) => it.syntax,
            AnyJsClassMember::TsGetterSignatureClassMember(it) => it.syntax,
            AnyJsClassMember::TsIndexSignatureClassMember(it) => it.syntax,
            AnyJsClassMember::TsInitializedPropertySignatureClassMember(it) => it.syntax,
            AnyJsClassMember::TsMethodSignatureClassMember(it) => it.syntax,
            AnyJsClassMember::TsPropertySignatureClassMember(it) => it.syntax,
            AnyJsClassMember::TsSetterSignatureClassMember(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsClassMember::JsBogusMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::JsConstructorClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::JsEmptyClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::JsGetterClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::JsMethodClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::JsPropertyClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::JsSetterClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::JsStaticInitializationBlockClassMember(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsClassMember::TsConstructorSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::TsGetterSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::TsIndexSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::TsInitializedPropertySignatureClassMember(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsClassMember::TsMethodSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::TsPropertySignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMember::TsSetterSignatureClassMember(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsClassMember> for SyntaxNode {
    fn from(n: AnyJsClassMember) -> SyntaxNode {
        match n {
            AnyJsClassMember::JsBogusMember(it) => it.into(),
            AnyJsClassMember::JsConstructorClassMember(it) => it.into(),
            AnyJsClassMember::JsEmptyClassMember(it) => it.into(),
            AnyJsClassMember::JsGetterClassMember(it) => it.into(),
            AnyJsClassMember::JsMethodClassMember(it) => it.into(),
            AnyJsClassMember::JsPropertyClassMember(it) => it.into(),
            AnyJsClassMember::JsSetterClassMember(it) => it.into(),
            AnyJsClassMember::JsStaticInitializationBlockClassMember(it) => it.into(),
            AnyJsClassMember::TsConstructorSignatureClassMember(it) => it.into(),
            AnyJsClassMember::TsGetterSignatureClassMember(it) => it.into(),
            AnyJsClassMember::TsIndexSignatureClassMember(it) => it.into(),
            AnyJsClassMember::TsInitializedPropertySignatureClassMember(it) => it.into(),
            AnyJsClassMember::TsMethodSignatureClassMember(it) => it.into(),
            AnyJsClassMember::TsPropertySignatureClassMember(it) => it.into(),
            AnyJsClassMember::TsSetterSignatureClassMember(it) => it.into(),
        }
    }
}
impl From<AnyJsClassMember> for SyntaxElement {
    fn from(n: AnyJsClassMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsComputedMemberName> for AnyJsClassMemberName {
    fn from(node: JsComputedMemberName) -> AnyJsClassMemberName {
        AnyJsClassMemberName::JsComputedMemberName(node)
    }
}
impl From<JsLiteralMemberName> for AnyJsClassMemberName {
    fn from(node: JsLiteralMemberName) -> AnyJsClassMemberName {
        AnyJsClassMemberName::JsLiteralMemberName(node)
    }
}
impl From<JsPrivateClassMemberName> for AnyJsClassMemberName {
    fn from(node: JsPrivateClassMemberName) -> AnyJsClassMemberName {
        AnyJsClassMemberName::JsPrivateClassMemberName(node)
    }
}
impl AstNode for AnyJsClassMemberName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsComputedMemberName::KIND_SET
        .union(JsLiteralMemberName::KIND_SET)
        .union(JsPrivateClassMemberName::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_COMPUTED_MEMBER_NAME | JS_LITERAL_MEMBER_NAME | JS_PRIVATE_CLASS_MEMBER_NAME
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_COMPUTED_MEMBER_NAME => {
                AnyJsClassMemberName::JsComputedMemberName(JsComputedMemberName { syntax })
            }
            JS_LITERAL_MEMBER_NAME => {
                AnyJsClassMemberName::JsLiteralMemberName(JsLiteralMemberName { syntax })
            }
            JS_PRIVATE_CLASS_MEMBER_NAME => {
                AnyJsClassMemberName::JsPrivateClassMemberName(JsPrivateClassMemberName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsClassMemberName::JsComputedMemberName(it) => &it.syntax,
            AnyJsClassMemberName::JsLiteralMemberName(it) => &it.syntax,
            AnyJsClassMemberName::JsPrivateClassMemberName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsClassMemberName::JsComputedMemberName(it) => it.syntax,
            AnyJsClassMemberName::JsLiteralMemberName(it) => it.syntax,
            AnyJsClassMemberName::JsPrivateClassMemberName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsClassMemberName::JsComputedMemberName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMemberName::JsLiteralMemberName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsClassMemberName::JsPrivateClassMemberName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsClassMemberName> for SyntaxNode {
    fn from(n: AnyJsClassMemberName) -> SyntaxNode {
        match n {
            AnyJsClassMemberName::JsComputedMemberName(it) => it.into(),
            AnyJsClassMemberName::JsLiteralMemberName(it) => it.into(),
            AnyJsClassMemberName::JsPrivateClassMemberName(it) => it.into(),
        }
    }
}
impl From<AnyJsClassMemberName> for SyntaxElement {
    fn from(n: AnyJsClassMemberName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsRestParameter> for AnyJsConstructorParameter {
    fn from(node: JsRestParameter) -> AnyJsConstructorParameter {
        AnyJsConstructorParameter::JsRestParameter(node)
    }
}
impl From<TsPropertyParameter> for AnyJsConstructorParameter {
    fn from(node: TsPropertyParameter) -> AnyJsConstructorParameter {
        AnyJsConstructorParameter::TsPropertyParameter(node)
    }
}
impl AstNode for AnyJsConstructorParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsFormalParameter::KIND_SET
        .union(JsRestParameter::KIND_SET)
        .union(TsPropertyParameter::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_REST_PARAMETER | TS_PROPERTY_PARAMETER => true,
            k if AnyJsFormalParameter::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REST_PARAMETER => {
                AnyJsConstructorParameter::JsRestParameter(JsRestParameter { syntax })
            }
            TS_PROPERTY_PARAMETER => {
                AnyJsConstructorParameter::TsPropertyParameter(TsPropertyParameter { syntax })
            }
            _ => {
                if let Some(any_js_formal_parameter) = AnyJsFormalParameter::cast(syntax) {
                    return Some(AnyJsConstructorParameter::AnyJsFormalParameter(
                        any_js_formal_parameter,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsConstructorParameter::JsRestParameter(it) => &it.syntax,
            AnyJsConstructorParameter::TsPropertyParameter(it) => &it.syntax,
            AnyJsConstructorParameter::AnyJsFormalParameter(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsConstructorParameter::JsRestParameter(it) => it.syntax,
            AnyJsConstructorParameter::TsPropertyParameter(it) => it.syntax,
            AnyJsConstructorParameter::AnyJsFormalParameter(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsConstructorParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsConstructorParameter::AnyJsFormalParameter(it) => std::fmt::Debug::fmt(it, f),
            AnyJsConstructorParameter::JsRestParameter(it) => std::fmt::Debug::fmt(it, f),
            AnyJsConstructorParameter::TsPropertyParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsConstructorParameter> for SyntaxNode {
    fn from(n: AnyJsConstructorParameter) -> SyntaxNode {
        match n {
            AnyJsConstructorParameter::AnyJsFormalParameter(it) => it.into(),
            AnyJsConstructorParameter::JsRestParameter(it) => it.into(),
            AnyJsConstructorParameter::TsPropertyParameter(it) => it.into(),
        }
    }
}
impl From<AnyJsConstructorParameter> for SyntaxElement {
    fn from(n: AnyJsConstructorParameter) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for AnyJsDeclaration {
    fn from(node: JsClassDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::JsClassDeclaration(node)
    }
}
impl From<JsFunctionDeclaration> for AnyJsDeclaration {
    fn from(node: JsFunctionDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::JsFunctionDeclaration(node)
    }
}
impl From<JsVariableDeclaration> for AnyJsDeclaration {
    fn from(node: JsVariableDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::JsVariableDeclaration(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for AnyJsDeclaration {
    fn from(node: TsDeclareFunctionDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsEnumDeclaration> for AnyJsDeclaration {
    fn from(node: TsEnumDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::TsEnumDeclaration(node)
    }
}
impl From<TsExternalModuleDeclaration> for AnyJsDeclaration {
    fn from(node: TsExternalModuleDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for AnyJsDeclaration {
    fn from(node: TsGlobalDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for AnyJsDeclaration {
    fn from(node: TsImportEqualsDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for AnyJsDeclaration {
    fn from(node: TsInterfaceDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for AnyJsDeclaration {
    fn from(node: TsModuleDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for AnyJsDeclaration {
    fn from(node: TsTypeAliasDeclaration) -> AnyJsDeclaration {
        AnyJsDeclaration::TsTypeAliasDeclaration(node)
    }
}
impl AstNode for AnyJsDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsClassDeclaration::KIND_SET
        .union(JsFunctionDeclaration::KIND_SET)
        .union(JsVariableDeclaration::KIND_SET)
        .union(TsDeclareFunctionDeclaration::KIND_SET)
        .union(TsEnumDeclaration::KIND_SET)
        .union(TsExternalModuleDeclaration::KIND_SET)
        .union(TsGlobalDeclaration::KIND_SET)
        .union(TsImportEqualsDeclaration::KIND_SET)
        .union(TsInterfaceDeclaration::KIND_SET)
        .union(TsModuleDeclaration::KIND_SET)
        .union(TsTypeAliasDeclaration::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION
                | JS_FUNCTION_DECLARATION
                | JS_VARIABLE_DECLARATION
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => {
                AnyJsDeclaration::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                AnyJsDeclaration::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_VARIABLE_DECLARATION => {
                AnyJsDeclaration::JsVariableDeclaration(JsVariableDeclaration { syntax })
            }
            TS_DECLARE_FUNCTION_DECLARATION => {
                AnyJsDeclaration::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_ENUM_DECLARATION => {
                AnyJsDeclaration::TsEnumDeclaration(TsEnumDeclaration { syntax })
            }
            TS_EXTERNAL_MODULE_DECLARATION => {
                AnyJsDeclaration::TsExternalModuleDeclaration(TsExternalModuleDeclaration {
                    syntax,
                })
            }
            TS_GLOBAL_DECLARATION => {
                AnyJsDeclaration::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                AnyJsDeclaration::TsImportEqualsDeclaration(TsImportEqualsDeclaration { syntax })
            }
            TS_INTERFACE_DECLARATION => {
                AnyJsDeclaration::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                AnyJsDeclaration::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                AnyJsDeclaration::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsDeclaration::JsClassDeclaration(it) => &it.syntax,
            AnyJsDeclaration::JsFunctionDeclaration(it) => &it.syntax,
            AnyJsDeclaration::JsVariableDeclaration(it) => &it.syntax,
            AnyJsDeclaration::TsDeclareFunctionDeclaration(it) => &it.syntax,
            AnyJsDeclaration::TsEnumDeclaration(it) => &it.syntax,
            AnyJsDeclaration::TsExternalModuleDeclaration(it) => &it.syntax,
            AnyJsDeclaration::TsGlobalDeclaration(it) => &it.syntax,
            AnyJsDeclaration::TsImportEqualsDeclaration(it) => &it.syntax,
            AnyJsDeclaration::TsInterfaceDeclaration(it) => &it.syntax,
            AnyJsDeclaration::TsModuleDeclaration(it) => &it.syntax,
            AnyJsDeclaration::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsDeclaration::JsClassDeclaration(it) => it.syntax,
            AnyJsDeclaration::JsFunctionDeclaration(it) => it.syntax,
            AnyJsDeclaration::JsVariableDeclaration(it) => it.syntax,
            AnyJsDeclaration::TsDeclareFunctionDeclaration(it) => it.syntax,
            AnyJsDeclaration::TsEnumDeclaration(it) => it.syntax,
            AnyJsDeclaration::TsExternalModuleDeclaration(it) => it.syntax,
            AnyJsDeclaration::TsGlobalDeclaration(it) => it.syntax,
            AnyJsDeclaration::TsImportEqualsDeclaration(it) => it.syntax,
            AnyJsDeclaration::TsInterfaceDeclaration(it) => it.syntax,
            AnyJsDeclaration::TsModuleDeclaration(it) => it.syntax,
            AnyJsDeclaration::TsTypeAliasDeclaration(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsDeclaration::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::JsVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclaration::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsDeclaration> for SyntaxNode {
    fn from(n: AnyJsDeclaration) -> SyntaxNode {
        match n {
            AnyJsDeclaration::JsClassDeclaration(it) => it.into(),
            AnyJsDeclaration::JsFunctionDeclaration(it) => it.into(),
            AnyJsDeclaration::JsVariableDeclaration(it) => it.into(),
            AnyJsDeclaration::TsDeclareFunctionDeclaration(it) => it.into(),
            AnyJsDeclaration::TsEnumDeclaration(it) => it.into(),
            AnyJsDeclaration::TsExternalModuleDeclaration(it) => it.into(),
            AnyJsDeclaration::TsGlobalDeclaration(it) => it.into(),
            AnyJsDeclaration::TsImportEqualsDeclaration(it) => it.into(),
            AnyJsDeclaration::TsInterfaceDeclaration(it) => it.into(),
            AnyJsDeclaration::TsModuleDeclaration(it) => it.into(),
            AnyJsDeclaration::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<AnyJsDeclaration> for SyntaxElement {
    fn from(n: AnyJsDeclaration) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassDeclaration> for AnyJsDeclarationClause {
    fn from(node: JsClassDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::JsClassDeclaration(node)
    }
}
impl From<JsFunctionDeclaration> for AnyJsDeclarationClause {
    fn from(node: JsFunctionDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::JsFunctionDeclaration(node)
    }
}
impl From<JsVariableDeclarationClause> for AnyJsDeclarationClause {
    fn from(node: JsVariableDeclarationClause) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::JsVariableDeclarationClause(node)
    }
}
impl From<TsDeclareFunctionDeclaration> for AnyJsDeclarationClause {
    fn from(node: TsDeclareFunctionDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsEnumDeclaration> for AnyJsDeclarationClause {
    fn from(node: TsEnumDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::TsEnumDeclaration(node)
    }
}
impl From<TsExternalModuleDeclaration> for AnyJsDeclarationClause {
    fn from(node: TsExternalModuleDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for AnyJsDeclarationClause {
    fn from(node: TsGlobalDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for AnyJsDeclarationClause {
    fn from(node: TsImportEqualsDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for AnyJsDeclarationClause {
    fn from(node: TsInterfaceDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for AnyJsDeclarationClause {
    fn from(node: TsModuleDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for AnyJsDeclarationClause {
    fn from(node: TsTypeAliasDeclaration) -> AnyJsDeclarationClause {
        AnyJsDeclarationClause::TsTypeAliasDeclaration(node)
    }
}
impl AstNode for AnyJsDeclarationClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsClassDeclaration::KIND_SET
        .union(JsFunctionDeclaration::KIND_SET)
        .union(JsVariableDeclarationClause::KIND_SET)
        .union(TsDeclareFunctionDeclaration::KIND_SET)
        .union(TsEnumDeclaration::KIND_SET)
        .union(TsExternalModuleDeclaration::KIND_SET)
        .union(TsGlobalDeclaration::KIND_SET)
        .union(TsImportEqualsDeclaration::KIND_SET)
        .union(TsInterfaceDeclaration::KIND_SET)
        .union(TsModuleDeclaration::KIND_SET)
        .union(TsTypeAliasDeclaration::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_DECLARATION
                | JS_FUNCTION_DECLARATION
                | JS_VARIABLE_DECLARATION_CLAUSE
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_DECLARATION => {
                AnyJsDeclarationClause::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                AnyJsDeclarationClause::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_VARIABLE_DECLARATION_CLAUSE => {
                AnyJsDeclarationClause::JsVariableDeclarationClause(JsVariableDeclarationClause {
                    syntax,
                })
            }
            TS_DECLARE_FUNCTION_DECLARATION => {
                AnyJsDeclarationClause::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_ENUM_DECLARATION => {
                AnyJsDeclarationClause::TsEnumDeclaration(TsEnumDeclaration { syntax })
            }
            TS_EXTERNAL_MODULE_DECLARATION => {
                AnyJsDeclarationClause::TsExternalModuleDeclaration(TsExternalModuleDeclaration {
                    syntax,
                })
            }
            TS_GLOBAL_DECLARATION => {
                AnyJsDeclarationClause::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                AnyJsDeclarationClause::TsImportEqualsDeclaration(TsImportEqualsDeclaration {
                    syntax,
                })
            }
            TS_INTERFACE_DECLARATION => {
                AnyJsDeclarationClause::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                AnyJsDeclarationClause::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                AnyJsDeclarationClause::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsDeclarationClause::JsClassDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::JsFunctionDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::JsVariableDeclarationClause(it) => &it.syntax,
            AnyJsDeclarationClause::TsDeclareFunctionDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::TsEnumDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::TsExternalModuleDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::TsGlobalDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::TsImportEqualsDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::TsInterfaceDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::TsModuleDeclaration(it) => &it.syntax,
            AnyJsDeclarationClause::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsDeclarationClause::JsClassDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::JsFunctionDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::JsVariableDeclarationClause(it) => it.syntax,
            AnyJsDeclarationClause::TsDeclareFunctionDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::TsEnumDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::TsExternalModuleDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::TsGlobalDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::TsImportEqualsDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::TsInterfaceDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::TsModuleDeclaration(it) => it.syntax,
            AnyJsDeclarationClause::TsTypeAliasDeclaration(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsDeclarationClause::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::JsVariableDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDeclarationClause::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsDeclarationClause> for SyntaxNode {
    fn from(n: AnyJsDeclarationClause) -> SyntaxNode {
        match n {
            AnyJsDeclarationClause::JsClassDeclaration(it) => it.into(),
            AnyJsDeclarationClause::JsFunctionDeclaration(it) => it.into(),
            AnyJsDeclarationClause::JsVariableDeclarationClause(it) => it.into(),
            AnyJsDeclarationClause::TsDeclareFunctionDeclaration(it) => it.into(),
            AnyJsDeclarationClause::TsEnumDeclaration(it) => it.into(),
            AnyJsDeclarationClause::TsExternalModuleDeclaration(it) => it.into(),
            AnyJsDeclarationClause::TsGlobalDeclaration(it) => it.into(),
            AnyJsDeclarationClause::TsImportEqualsDeclaration(it) => it.into(),
            AnyJsDeclarationClause::TsInterfaceDeclaration(it) => it.into(),
            AnyJsDeclarationClause::TsModuleDeclaration(it) => it.into(),
            AnyJsDeclarationClause::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<AnyJsDeclarationClause> for SyntaxElement {
    fn from(n: AnyJsDeclarationClause) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusExpression> for AnyJsDecorator {
    fn from(node: JsBogusExpression) -> AnyJsDecorator { AnyJsDecorator::JsBogusExpression(node) }
}
impl From<JsCallExpression> for AnyJsDecorator {
    fn from(node: JsCallExpression) -> AnyJsDecorator { AnyJsDecorator::JsCallExpression(node) }
}
impl From<JsIdentifierExpression> for AnyJsDecorator {
    fn from(node: JsIdentifierExpression) -> AnyJsDecorator {
        AnyJsDecorator::JsIdentifierExpression(node)
    }
}
impl From<JsParenthesizedExpression> for AnyJsDecorator {
    fn from(node: JsParenthesizedExpression) -> AnyJsDecorator {
        AnyJsDecorator::JsParenthesizedExpression(node)
    }
}
impl From<JsStaticMemberExpression> for AnyJsDecorator {
    fn from(node: JsStaticMemberExpression) -> AnyJsDecorator {
        AnyJsDecorator::JsStaticMemberExpression(node)
    }
}
impl AstNode for AnyJsDecorator {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBogusExpression::KIND_SET
        .union(JsCallExpression::KIND_SET)
        .union(JsIdentifierExpression::KIND_SET)
        .union(JsParenthesizedExpression::KIND_SET)
        .union(JsStaticMemberExpression::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_EXPRESSION
                | JS_CALL_EXPRESSION
                | JS_IDENTIFIER_EXPRESSION
                | JS_PARENTHESIZED_EXPRESSION
                | JS_STATIC_MEMBER_EXPRESSION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_EXPRESSION => AnyJsDecorator::JsBogusExpression(JsBogusExpression { syntax }),
            JS_CALL_EXPRESSION => AnyJsDecorator::JsCallExpression(JsCallExpression { syntax }),
            JS_IDENTIFIER_EXPRESSION => {
                AnyJsDecorator::JsIdentifierExpression(JsIdentifierExpression { syntax })
            }
            JS_PARENTHESIZED_EXPRESSION => {
                AnyJsDecorator::JsParenthesizedExpression(JsParenthesizedExpression { syntax })
            }
            JS_STATIC_MEMBER_EXPRESSION => {
                AnyJsDecorator::JsStaticMemberExpression(JsStaticMemberExpression { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsDecorator::JsBogusExpression(it) => &it.syntax,
            AnyJsDecorator::JsCallExpression(it) => &it.syntax,
            AnyJsDecorator::JsIdentifierExpression(it) => &it.syntax,
            AnyJsDecorator::JsParenthesizedExpression(it) => &it.syntax,
            AnyJsDecorator::JsStaticMemberExpression(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsDecorator::JsBogusExpression(it) => it.syntax,
            AnyJsDecorator::JsCallExpression(it) => it.syntax,
            AnyJsDecorator::JsIdentifierExpression(it) => it.syntax,
            AnyJsDecorator::JsParenthesizedExpression(it) => it.syntax,
            AnyJsDecorator::JsStaticMemberExpression(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsDecorator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsDecorator::JsBogusExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDecorator::JsCallExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDecorator::JsIdentifierExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDecorator::JsParenthesizedExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsDecorator::JsStaticMemberExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsDecorator> for SyntaxNode {
    fn from(n: AnyJsDecorator) -> SyntaxNode {
        match n {
            AnyJsDecorator::JsBogusExpression(it) => it.into(),
            AnyJsDecorator::JsCallExpression(it) => it.into(),
            AnyJsDecorator::JsIdentifierExpression(it) => it.into(),
            AnyJsDecorator::JsParenthesizedExpression(it) => it.into(),
            AnyJsDecorator::JsStaticMemberExpression(it) => it.into(),
        }
    }
}
impl From<AnyJsDecorator> for SyntaxElement {
    fn from(n: AnyJsDecorator) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExportDefaultDeclarationClause> for AnyJsExportClause {
    fn from(node: JsExportDefaultDeclarationClause) -> AnyJsExportClause {
        AnyJsExportClause::JsExportDefaultDeclarationClause(node)
    }
}
impl From<JsExportDefaultExpressionClause> for AnyJsExportClause {
    fn from(node: JsExportDefaultExpressionClause) -> AnyJsExportClause {
        AnyJsExportClause::JsExportDefaultExpressionClause(node)
    }
}
impl From<JsExportFromClause> for AnyJsExportClause {
    fn from(node: JsExportFromClause) -> AnyJsExportClause {
        AnyJsExportClause::JsExportFromClause(node)
    }
}
impl From<JsExportNamedClause> for AnyJsExportClause {
    fn from(node: JsExportNamedClause) -> AnyJsExportClause {
        AnyJsExportClause::JsExportNamedClause(node)
    }
}
impl From<JsExportNamedFromClause> for AnyJsExportClause {
    fn from(node: JsExportNamedFromClause) -> AnyJsExportClause {
        AnyJsExportClause::JsExportNamedFromClause(node)
    }
}
impl From<TsExportAsNamespaceClause> for AnyJsExportClause {
    fn from(node: TsExportAsNamespaceClause) -> AnyJsExportClause {
        AnyJsExportClause::TsExportAsNamespaceClause(node)
    }
}
impl From<TsExportAssignmentClause> for AnyJsExportClause {
    fn from(node: TsExportAssignmentClause) -> AnyJsExportClause {
        AnyJsExportClause::TsExportAssignmentClause(node)
    }
}
impl From<TsExportDeclareClause> for AnyJsExportClause {
    fn from(node: TsExportDeclareClause) -> AnyJsExportClause {
        AnyJsExportClause::TsExportDeclareClause(node)
    }
}
impl AstNode for AnyJsExportClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsDeclarationClause::KIND_SET
        .union(JsExportDefaultDeclarationClause::KIND_SET)
        .union(JsExportDefaultExpressionClause::KIND_SET)
        .union(JsExportFromClause::KIND_SET)
        .union(JsExportNamedClause::KIND_SET)
        .union(JsExportNamedFromClause::KIND_SET)
        .union(TsExportAsNamespaceClause::KIND_SET)
        .union(TsExportAssignmentClause::KIND_SET)
        .union(TsExportDeclareClause::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_EXPORT_DEFAULT_DECLARATION_CLAUSE
            | JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE
            | JS_EXPORT_FROM_CLAUSE
            | JS_EXPORT_NAMED_CLAUSE
            | JS_EXPORT_NAMED_FROM_CLAUSE
            | TS_EXPORT_AS_NAMESPACE_CLAUSE
            | TS_EXPORT_ASSIGNMENT_CLAUSE
            | TS_EXPORT_DECLARE_CLAUSE => true,
            k if AnyJsDeclarationClause::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT_DEFAULT_DECLARATION_CLAUSE => {
                AnyJsExportClause::JsExportDefaultDeclarationClause(
                    JsExportDefaultDeclarationClause { syntax },
                )
            }
            JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE => {
                AnyJsExportClause::JsExportDefaultExpressionClause(
                    JsExportDefaultExpressionClause { syntax },
                )
            }
            JS_EXPORT_FROM_CLAUSE => {
                AnyJsExportClause::JsExportFromClause(JsExportFromClause { syntax })
            }
            JS_EXPORT_NAMED_CLAUSE => {
                AnyJsExportClause::JsExportNamedClause(JsExportNamedClause { syntax })
            }
            JS_EXPORT_NAMED_FROM_CLAUSE => {
                AnyJsExportClause::JsExportNamedFromClause(JsExportNamedFromClause { syntax })
            }
            TS_EXPORT_AS_NAMESPACE_CLAUSE => {
                AnyJsExportClause::TsExportAsNamespaceClause(TsExportAsNamespaceClause { syntax })
            }
            TS_EXPORT_ASSIGNMENT_CLAUSE => {
                AnyJsExportClause::TsExportAssignmentClause(TsExportAssignmentClause { syntax })
            }
            TS_EXPORT_DECLARE_CLAUSE => {
                AnyJsExportClause::TsExportDeclareClause(TsExportDeclareClause { syntax })
            }
            _ => {
                if let Some(any_js_declaration_clause) = AnyJsDeclarationClause::cast(syntax) {
                    return Some(AnyJsExportClause::AnyJsDeclarationClause(
                        any_js_declaration_clause,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsExportClause::JsExportDefaultDeclarationClause(it) => &it.syntax,
            AnyJsExportClause::JsExportDefaultExpressionClause(it) => &it.syntax,
            AnyJsExportClause::JsExportFromClause(it) => &it.syntax,
            AnyJsExportClause::JsExportNamedClause(it) => &it.syntax,
            AnyJsExportClause::JsExportNamedFromClause(it) => &it.syntax,
            AnyJsExportClause::TsExportAsNamespaceClause(it) => &it.syntax,
            AnyJsExportClause::TsExportAssignmentClause(it) => &it.syntax,
            AnyJsExportClause::TsExportDeclareClause(it) => &it.syntax,
            AnyJsExportClause::AnyJsDeclarationClause(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsExportClause::JsExportDefaultDeclarationClause(it) => it.syntax,
            AnyJsExportClause::JsExportDefaultExpressionClause(it) => it.syntax,
            AnyJsExportClause::JsExportFromClause(it) => it.syntax,
            AnyJsExportClause::JsExportNamedClause(it) => it.syntax,
            AnyJsExportClause::JsExportNamedFromClause(it) => it.syntax,
            AnyJsExportClause::TsExportAsNamespaceClause(it) => it.syntax,
            AnyJsExportClause::TsExportAssignmentClause(it) => it.syntax,
            AnyJsExportClause::TsExportDeclareClause(it) => it.syntax,
            AnyJsExportClause::AnyJsDeclarationClause(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsExportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsExportClause::AnyJsDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExportClause::JsExportDefaultDeclarationClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExportClause::JsExportDefaultExpressionClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExportClause::JsExportFromClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExportClause::JsExportNamedClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExportClause::JsExportNamedFromClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExportClause::TsExportAsNamespaceClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExportClause::TsExportAssignmentClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExportClause::TsExportDeclareClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsExportClause> for SyntaxNode {
    fn from(n: AnyJsExportClause) -> SyntaxNode {
        match n {
            AnyJsExportClause::AnyJsDeclarationClause(it) => it.into(),
            AnyJsExportClause::JsExportDefaultDeclarationClause(it) => it.into(),
            AnyJsExportClause::JsExportDefaultExpressionClause(it) => it.into(),
            AnyJsExportClause::JsExportFromClause(it) => it.into(),
            AnyJsExportClause::JsExportNamedClause(it) => it.into(),
            AnyJsExportClause::JsExportNamedFromClause(it) => it.into(),
            AnyJsExportClause::TsExportAsNamespaceClause(it) => it.into(),
            AnyJsExportClause::TsExportAssignmentClause(it) => it.into(),
            AnyJsExportClause::TsExportDeclareClause(it) => it.into(),
        }
    }
}
impl From<AnyJsExportClause> for SyntaxElement {
    fn from(n: AnyJsExportClause) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsClassExportDefaultDeclaration> for AnyJsExportDefaultDeclaration {
    fn from(node: JsClassExportDefaultDeclaration) -> AnyJsExportDefaultDeclaration {
        AnyJsExportDefaultDeclaration::JsClassExportDefaultDeclaration(node)
    }
}
impl From<JsFunctionExportDefaultDeclaration> for AnyJsExportDefaultDeclaration {
    fn from(node: JsFunctionExportDefaultDeclaration) -> AnyJsExportDefaultDeclaration {
        AnyJsExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(node)
    }
}
impl From<TsDeclareFunctionExportDefaultDeclaration> for AnyJsExportDefaultDeclaration {
    fn from(node: TsDeclareFunctionExportDefaultDeclaration) -> AnyJsExportDefaultDeclaration {
        AnyJsExportDefaultDeclaration::TsDeclareFunctionExportDefaultDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for AnyJsExportDefaultDeclaration {
    fn from(node: TsInterfaceDeclaration) -> AnyJsExportDefaultDeclaration {
        AnyJsExportDefaultDeclaration::TsInterfaceDeclaration(node)
    }
}
impl AstNode for AnyJsExportDefaultDeclaration {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsClassExportDefaultDeclaration::KIND_SET
        .union(JsFunctionExportDefaultDeclaration::KIND_SET)
        .union(TsDeclareFunctionExportDefaultDeclaration::KIND_SET)
        .union(TsInterfaceDeclaration::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_CLASS_EXPORT_DEFAULT_DECLARATION
                | JS_FUNCTION_EXPORT_DEFAULT_DECLARATION
                | TS_DECLARE_FUNCTION_EXPORT_DEFAULT_DECLARATION
                | TS_INTERFACE_DECLARATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CLASS_EXPORT_DEFAULT_DECLARATION => {
                AnyJsExportDefaultDeclaration::JsClassExportDefaultDeclaration(
                    JsClassExportDefaultDeclaration { syntax },
                )
            }
            JS_FUNCTION_EXPORT_DEFAULT_DECLARATION => {
                AnyJsExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(
                    JsFunctionExportDefaultDeclaration { syntax },
                )
            }
            TS_DECLARE_FUNCTION_EXPORT_DEFAULT_DECLARATION => {
                AnyJsExportDefaultDeclaration::TsDeclareFunctionExportDefaultDeclaration(
                    TsDeclareFunctionExportDefaultDeclaration { syntax },
                )
            }
            TS_INTERFACE_DECLARATION => {
                AnyJsExportDefaultDeclaration::TsInterfaceDeclaration(TsInterfaceDeclaration {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => &it.syntax,
            AnyJsExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => &it.syntax,
            AnyJsExportDefaultDeclaration::TsDeclareFunctionExportDefaultDeclaration(it) => {
                &it.syntax
            }
            AnyJsExportDefaultDeclaration::TsInterfaceDeclaration(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => it.syntax,
            AnyJsExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => it.syntax,
            AnyJsExportDefaultDeclaration::TsDeclareFunctionExportDefaultDeclaration(it) => {
                it.syntax
            }
            AnyJsExportDefaultDeclaration::TsInterfaceDeclaration(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsExportDefaultDeclaration::TsDeclareFunctionExportDefaultDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsExportDefaultDeclaration::TsInterfaceDeclaration(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<AnyJsExportDefaultDeclaration> for SyntaxNode {
    fn from(n: AnyJsExportDefaultDeclaration) -> SyntaxNode {
        match n {
            AnyJsExportDefaultDeclaration::JsClassExportDefaultDeclaration(it) => it.into(),
            AnyJsExportDefaultDeclaration::JsFunctionExportDefaultDeclaration(it) => it.into(),
            AnyJsExportDefaultDeclaration::TsDeclareFunctionExportDefaultDeclaration(it) => {
                it.into()
            }
            AnyJsExportDefaultDeclaration::TsInterfaceDeclaration(it) => it.into(),
        }
    }
}
impl From<AnyJsExportDefaultDeclaration> for SyntaxElement {
    fn from(n: AnyJsExportDefaultDeclaration) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExportNamedShorthandSpecifier> for AnyJsExportNamedSpecifier {
    fn from(node: JsExportNamedShorthandSpecifier) -> AnyJsExportNamedSpecifier {
        AnyJsExportNamedSpecifier::JsExportNamedShorthandSpecifier(node)
    }
}
impl From<JsExportNamedSpecifier> for AnyJsExportNamedSpecifier {
    fn from(node: JsExportNamedSpecifier) -> AnyJsExportNamedSpecifier {
        AnyJsExportNamedSpecifier::JsExportNamedSpecifier(node)
    }
}
impl AstNode for AnyJsExportNamedSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsExportNamedShorthandSpecifier::KIND_SET.union(JsExportNamedSpecifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_EXPORT_NAMED_SHORTHAND_SPECIFIER | JS_EXPORT_NAMED_SPECIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT_NAMED_SHORTHAND_SPECIFIER => {
                AnyJsExportNamedSpecifier::JsExportNamedShorthandSpecifier(
                    JsExportNamedShorthandSpecifier { syntax },
                )
            }
            JS_EXPORT_NAMED_SPECIFIER => {
                AnyJsExportNamedSpecifier::JsExportNamedSpecifier(JsExportNamedSpecifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => &it.syntax,
            AnyJsExportNamedSpecifier::JsExportNamedSpecifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => it.syntax,
            AnyJsExportNamedSpecifier::JsExportNamedSpecifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsExportNamedSpecifier::JsExportNamedSpecifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsExportNamedSpecifier> for SyntaxNode {
    fn from(n: AnyJsExportNamedSpecifier) -> SyntaxNode {
        match n {
            AnyJsExportNamedSpecifier::JsExportNamedShorthandSpecifier(it) => it.into(),
            AnyJsExportNamedSpecifier::JsExportNamedSpecifier(it) => it.into(),
        }
    }
}
impl From<AnyJsExportNamedSpecifier> for SyntaxElement {
    fn from(n: AnyJsExportNamedSpecifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrayExpression> for AnyJsExpression {
    fn from(node: JsArrayExpression) -> AnyJsExpression { AnyJsExpression::JsArrayExpression(node) }
}
impl From<JsArrowFunctionExpression> for AnyJsExpression {
    fn from(node: JsArrowFunctionExpression) -> AnyJsExpression {
        AnyJsExpression::JsArrowFunctionExpression(node)
    }
}
impl From<JsAssignmentExpression> for AnyJsExpression {
    fn from(node: JsAssignmentExpression) -> AnyJsExpression {
        AnyJsExpression::JsAssignmentExpression(node)
    }
}
impl From<JsAwaitExpression> for AnyJsExpression {
    fn from(node: JsAwaitExpression) -> AnyJsExpression { AnyJsExpression::JsAwaitExpression(node) }
}
impl From<JsBinaryExpression> for AnyJsExpression {
    fn from(node: JsBinaryExpression) -> AnyJsExpression {
        AnyJsExpression::JsBinaryExpression(node)
    }
}
impl From<JsBogusExpression> for AnyJsExpression {
    fn from(node: JsBogusExpression) -> AnyJsExpression { AnyJsExpression::JsBogusExpression(node) }
}
impl From<JsCallExpression> for AnyJsExpression {
    fn from(node: JsCallExpression) -> AnyJsExpression { AnyJsExpression::JsCallExpression(node) }
}
impl From<JsClassExpression> for AnyJsExpression {
    fn from(node: JsClassExpression) -> AnyJsExpression { AnyJsExpression::JsClassExpression(node) }
}
impl From<JsComputedMemberExpression> for AnyJsExpression {
    fn from(node: JsComputedMemberExpression) -> AnyJsExpression {
        AnyJsExpression::JsComputedMemberExpression(node)
    }
}
impl From<JsConditionalExpression> for AnyJsExpression {
    fn from(node: JsConditionalExpression) -> AnyJsExpression {
        AnyJsExpression::JsConditionalExpression(node)
    }
}
impl From<JsFunctionExpression> for AnyJsExpression {
    fn from(node: JsFunctionExpression) -> AnyJsExpression {
        AnyJsExpression::JsFunctionExpression(node)
    }
}
impl From<JsIdentifierExpression> for AnyJsExpression {
    fn from(node: JsIdentifierExpression) -> AnyJsExpression {
        AnyJsExpression::JsIdentifierExpression(node)
    }
}
impl From<JsImportCallExpression> for AnyJsExpression {
    fn from(node: JsImportCallExpression) -> AnyJsExpression {
        AnyJsExpression::JsImportCallExpression(node)
    }
}
impl From<JsImportMetaExpression> for AnyJsExpression {
    fn from(node: JsImportMetaExpression) -> AnyJsExpression {
        AnyJsExpression::JsImportMetaExpression(node)
    }
}
impl From<JsInExpression> for AnyJsExpression {
    fn from(node: JsInExpression) -> AnyJsExpression { AnyJsExpression::JsInExpression(node) }
}
impl From<JsInstanceofExpression> for AnyJsExpression {
    fn from(node: JsInstanceofExpression) -> AnyJsExpression {
        AnyJsExpression::JsInstanceofExpression(node)
    }
}
impl From<JsLogicalExpression> for AnyJsExpression {
    fn from(node: JsLogicalExpression) -> AnyJsExpression {
        AnyJsExpression::JsLogicalExpression(node)
    }
}
impl From<JsNewExpression> for AnyJsExpression {
    fn from(node: JsNewExpression) -> AnyJsExpression { AnyJsExpression::JsNewExpression(node) }
}
impl From<JsNewTargetExpression> for AnyJsExpression {
    fn from(node: JsNewTargetExpression) -> AnyJsExpression {
        AnyJsExpression::JsNewTargetExpression(node)
    }
}
impl From<JsObjectExpression> for AnyJsExpression {
    fn from(node: JsObjectExpression) -> AnyJsExpression {
        AnyJsExpression::JsObjectExpression(node)
    }
}
impl From<JsParenthesizedExpression> for AnyJsExpression {
    fn from(node: JsParenthesizedExpression) -> AnyJsExpression {
        AnyJsExpression::JsParenthesizedExpression(node)
    }
}
impl From<JsPostUpdateExpression> for AnyJsExpression {
    fn from(node: JsPostUpdateExpression) -> AnyJsExpression {
        AnyJsExpression::JsPostUpdateExpression(node)
    }
}
impl From<JsPreUpdateExpression> for AnyJsExpression {
    fn from(node: JsPreUpdateExpression) -> AnyJsExpression {
        AnyJsExpression::JsPreUpdateExpression(node)
    }
}
impl From<JsSequenceExpression> for AnyJsExpression {
    fn from(node: JsSequenceExpression) -> AnyJsExpression {
        AnyJsExpression::JsSequenceExpression(node)
    }
}
impl From<JsStaticMemberExpression> for AnyJsExpression {
    fn from(node: JsStaticMemberExpression) -> AnyJsExpression {
        AnyJsExpression::JsStaticMemberExpression(node)
    }
}
impl From<JsSuperExpression> for AnyJsExpression {
    fn from(node: JsSuperExpression) -> AnyJsExpression { AnyJsExpression::JsSuperExpression(node) }
}
impl From<JsTemplateExpression> for AnyJsExpression {
    fn from(node: JsTemplateExpression) -> AnyJsExpression {
        AnyJsExpression::JsTemplateExpression(node)
    }
}
impl From<JsThisExpression> for AnyJsExpression {
    fn from(node: JsThisExpression) -> AnyJsExpression { AnyJsExpression::JsThisExpression(node) }
}
impl From<JsUnaryExpression> for AnyJsExpression {
    fn from(node: JsUnaryExpression) -> AnyJsExpression { AnyJsExpression::JsUnaryExpression(node) }
}
impl From<JsYieldExpression> for AnyJsExpression {
    fn from(node: JsYieldExpression) -> AnyJsExpression { AnyJsExpression::JsYieldExpression(node) }
}
impl From<JsxTagExpression> for AnyJsExpression {
    fn from(node: JsxTagExpression) -> AnyJsExpression { AnyJsExpression::JsxTagExpression(node) }
}
impl From<TsAsExpression> for AnyJsExpression {
    fn from(node: TsAsExpression) -> AnyJsExpression { AnyJsExpression::TsAsExpression(node) }
}
impl From<TsInstantiationExpression> for AnyJsExpression {
    fn from(node: TsInstantiationExpression) -> AnyJsExpression {
        AnyJsExpression::TsInstantiationExpression(node)
    }
}
impl From<TsNonNullAssertionExpression> for AnyJsExpression {
    fn from(node: TsNonNullAssertionExpression) -> AnyJsExpression {
        AnyJsExpression::TsNonNullAssertionExpression(node)
    }
}
impl From<TsSatisfiesExpression> for AnyJsExpression {
    fn from(node: TsSatisfiesExpression) -> AnyJsExpression {
        AnyJsExpression::TsSatisfiesExpression(node)
    }
}
impl From<TsTypeAssertionExpression> for AnyJsExpression {
    fn from(node: TsTypeAssertionExpression) -> AnyJsExpression {
        AnyJsExpression::TsTypeAssertionExpression(node)
    }
}
impl AstNode for AnyJsExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsLiteralExpression::KIND_SET
        .union(JsArrayExpression::KIND_SET)
        .union(JsArrowFunctionExpression::KIND_SET)
        .union(JsAssignmentExpression::KIND_SET)
        .union(JsAwaitExpression::KIND_SET)
        .union(JsBinaryExpression::KIND_SET)
        .union(JsBogusExpression::KIND_SET)
        .union(JsCallExpression::KIND_SET)
        .union(JsClassExpression::KIND_SET)
        .union(JsComputedMemberExpression::KIND_SET)
        .union(JsConditionalExpression::KIND_SET)
        .union(JsFunctionExpression::KIND_SET)
        .union(JsIdentifierExpression::KIND_SET)
        .union(JsImportCallExpression::KIND_SET)
        .union(JsImportMetaExpression::KIND_SET)
        .union(JsInExpression::KIND_SET)
        .union(JsInstanceofExpression::KIND_SET)
        .union(JsLogicalExpression::KIND_SET)
        .union(JsNewExpression::KIND_SET)
        .union(JsNewTargetExpression::KIND_SET)
        .union(JsObjectExpression::KIND_SET)
        .union(JsParenthesizedExpression::KIND_SET)
        .union(JsPostUpdateExpression::KIND_SET)
        .union(JsPreUpdateExpression::KIND_SET)
        .union(JsSequenceExpression::KIND_SET)
        .union(JsStaticMemberExpression::KIND_SET)
        .union(JsSuperExpression::KIND_SET)
        .union(JsTemplateExpression::KIND_SET)
        .union(JsThisExpression::KIND_SET)
        .union(JsUnaryExpression::KIND_SET)
        .union(JsYieldExpression::KIND_SET)
        .union(JsxTagExpression::KIND_SET)
        .union(TsAsExpression::KIND_SET)
        .union(TsInstantiationExpression::KIND_SET)
        .union(TsNonNullAssertionExpression::KIND_SET)
        .union(TsSatisfiesExpression::KIND_SET)
        .union(TsTypeAssertionExpression::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_ARRAY_EXPRESSION
            | JS_ARROW_FUNCTION_EXPRESSION
            | JS_ASSIGNMENT_EXPRESSION
            | JS_AWAIT_EXPRESSION
            | JS_BINARY_EXPRESSION
            | JS_BOGUS_EXPRESSION
            | JS_CALL_EXPRESSION
            | JS_CLASS_EXPRESSION
            | JS_COMPUTED_MEMBER_EXPRESSION
            | JS_CONDITIONAL_EXPRESSION
            | JS_FUNCTION_EXPRESSION
            | JS_IDENTIFIER_EXPRESSION
            | JS_IMPORT_CALL_EXPRESSION
            | JS_IMPORT_META_EXPRESSION
            | JS_IN_EXPRESSION
            | JS_INSTANCEOF_EXPRESSION
            | JS_LOGICAL_EXPRESSION
            | JS_NEW_EXPRESSION
            | JS_NEW_TARGET_EXPRESSION
            | JS_OBJECT_EXPRESSION
            | JS_PARENTHESIZED_EXPRESSION
            | JS_POST_UPDATE_EXPRESSION
            | JS_PRE_UPDATE_EXPRESSION
            | JS_SEQUENCE_EXPRESSION
            | JS_STATIC_MEMBER_EXPRESSION
            | JS_SUPER_EXPRESSION
            | JS_TEMPLATE_EXPRESSION
            | JS_THIS_EXPRESSION
            | JS_UNARY_EXPRESSION
            | JS_YIELD_EXPRESSION
            | JSX_TAG_EXPRESSION
            | TS_AS_EXPRESSION
            | TS_INSTANTIATION_EXPRESSION
            | TS_NON_NULL_ASSERTION_EXPRESSION
            | TS_SATISFIES_EXPRESSION
            | TS_TYPE_ASSERTION_EXPRESSION => true,
            k if AnyJsLiteralExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARRAY_EXPRESSION => AnyJsExpression::JsArrayExpression(JsArrayExpression { syntax }),
            JS_ARROW_FUNCTION_EXPRESSION => {
                AnyJsExpression::JsArrowFunctionExpression(JsArrowFunctionExpression { syntax })
            }
            JS_ASSIGNMENT_EXPRESSION => {
                AnyJsExpression::JsAssignmentExpression(JsAssignmentExpression { syntax })
            }
            JS_AWAIT_EXPRESSION => AnyJsExpression::JsAwaitExpression(JsAwaitExpression { syntax }),
            JS_BINARY_EXPRESSION => {
                AnyJsExpression::JsBinaryExpression(JsBinaryExpression { syntax })
            }
            JS_BOGUS_EXPRESSION => AnyJsExpression::JsBogusExpression(JsBogusExpression { syntax }),
            JS_CALL_EXPRESSION => AnyJsExpression::JsCallExpression(JsCallExpression { syntax }),
            JS_CLASS_EXPRESSION => AnyJsExpression::JsClassExpression(JsClassExpression { syntax }),
            JS_COMPUTED_MEMBER_EXPRESSION => {
                AnyJsExpression::JsComputedMemberExpression(JsComputedMemberExpression { syntax })
            }
            JS_CONDITIONAL_EXPRESSION => {
                AnyJsExpression::JsConditionalExpression(JsConditionalExpression { syntax })
            }
            JS_FUNCTION_EXPRESSION => {
                AnyJsExpression::JsFunctionExpression(JsFunctionExpression { syntax })
            }
            JS_IDENTIFIER_EXPRESSION => {
                AnyJsExpression::JsIdentifierExpression(JsIdentifierExpression { syntax })
            }
            JS_IMPORT_CALL_EXPRESSION => {
                AnyJsExpression::JsImportCallExpression(JsImportCallExpression { syntax })
            }
            JS_IMPORT_META_EXPRESSION => {
                AnyJsExpression::JsImportMetaExpression(JsImportMetaExpression { syntax })
            }
            JS_IN_EXPRESSION => AnyJsExpression::JsInExpression(JsInExpression { syntax }),
            JS_INSTANCEOF_EXPRESSION => {
                AnyJsExpression::JsInstanceofExpression(JsInstanceofExpression { syntax })
            }
            JS_LOGICAL_EXPRESSION => {
                AnyJsExpression::JsLogicalExpression(JsLogicalExpression { syntax })
            }
            JS_NEW_EXPRESSION => AnyJsExpression::JsNewExpression(JsNewExpression { syntax }),
            JS_NEW_TARGET_EXPRESSION => {
                AnyJsExpression::JsNewTargetExpression(JsNewTargetExpression { syntax })
            }
            JS_OBJECT_EXPRESSION => {
                AnyJsExpression::JsObjectExpression(JsObjectExpression { syntax })
            }
            JS_PARENTHESIZED_EXPRESSION => {
                AnyJsExpression::JsParenthesizedExpression(JsParenthesizedExpression { syntax })
            }
            JS_POST_UPDATE_EXPRESSION => {
                AnyJsExpression::JsPostUpdateExpression(JsPostUpdateExpression { syntax })
            }
            JS_PRE_UPDATE_EXPRESSION => {
                AnyJsExpression::JsPreUpdateExpression(JsPreUpdateExpression { syntax })
            }
            JS_SEQUENCE_EXPRESSION => {
                AnyJsExpression::JsSequenceExpression(JsSequenceExpression { syntax })
            }
            JS_STATIC_MEMBER_EXPRESSION => {
                AnyJsExpression::JsStaticMemberExpression(JsStaticMemberExpression { syntax })
            }
            JS_SUPER_EXPRESSION => AnyJsExpression::JsSuperExpression(JsSuperExpression { syntax }),
            JS_TEMPLATE_EXPRESSION => {
                AnyJsExpression::JsTemplateExpression(JsTemplateExpression { syntax })
            }
            JS_THIS_EXPRESSION => AnyJsExpression::JsThisExpression(JsThisExpression { syntax }),
            JS_UNARY_EXPRESSION => AnyJsExpression::JsUnaryExpression(JsUnaryExpression { syntax }),
            JS_YIELD_EXPRESSION => AnyJsExpression::JsYieldExpression(JsYieldExpression { syntax }),
            JSX_TAG_EXPRESSION => AnyJsExpression::JsxTagExpression(JsxTagExpression { syntax }),
            TS_AS_EXPRESSION => AnyJsExpression::TsAsExpression(TsAsExpression { syntax }),
            TS_INSTANTIATION_EXPRESSION => {
                AnyJsExpression::TsInstantiationExpression(TsInstantiationExpression { syntax })
            }
            TS_NON_NULL_ASSERTION_EXPRESSION => {
                AnyJsExpression::TsNonNullAssertionExpression(TsNonNullAssertionExpression {
                    syntax,
                })
            }
            TS_SATISFIES_EXPRESSION => {
                AnyJsExpression::TsSatisfiesExpression(TsSatisfiesExpression { syntax })
            }
            TS_TYPE_ASSERTION_EXPRESSION => {
                AnyJsExpression::TsTypeAssertionExpression(TsTypeAssertionExpression { syntax })
            }
            _ => {
                if let Some(any_js_literal_expression) = AnyJsLiteralExpression::cast(syntax) {
                    return Some(AnyJsExpression::AnyJsLiteralExpression(
                        any_js_literal_expression,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsExpression::JsArrayExpression(it) => &it.syntax,
            AnyJsExpression::JsArrowFunctionExpression(it) => &it.syntax,
            AnyJsExpression::JsAssignmentExpression(it) => &it.syntax,
            AnyJsExpression::JsAwaitExpression(it) => &it.syntax,
            AnyJsExpression::JsBinaryExpression(it) => &it.syntax,
            AnyJsExpression::JsBogusExpression(it) => &it.syntax,
            AnyJsExpression::JsCallExpression(it) => &it.syntax,
            AnyJsExpression::JsClassExpression(it) => &it.syntax,
            AnyJsExpression::JsComputedMemberExpression(it) => &it.syntax,
            AnyJsExpression::JsConditionalExpression(it) => &it.syntax,
            AnyJsExpression::JsFunctionExpression(it) => &it.syntax,
            AnyJsExpression::JsIdentifierExpression(it) => &it.syntax,
            AnyJsExpression::JsImportCallExpression(it) => &it.syntax,
            AnyJsExpression::JsImportMetaExpression(it) => &it.syntax,
            AnyJsExpression::JsInExpression(it) => &it.syntax,
            AnyJsExpression::JsInstanceofExpression(it) => &it.syntax,
            AnyJsExpression::JsLogicalExpression(it) => &it.syntax,
            AnyJsExpression::JsNewExpression(it) => &it.syntax,
            AnyJsExpression::JsNewTargetExpression(it) => &it.syntax,
            AnyJsExpression::JsObjectExpression(it) => &it.syntax,
            AnyJsExpression::JsParenthesizedExpression(it) => &it.syntax,
            AnyJsExpression::JsPostUpdateExpression(it) => &it.syntax,
            AnyJsExpression::JsPreUpdateExpression(it) => &it.syntax,
            AnyJsExpression::JsSequenceExpression(it) => &it.syntax,
            AnyJsExpression::JsStaticMemberExpression(it) => &it.syntax,
            AnyJsExpression::JsSuperExpression(it) => &it.syntax,
            AnyJsExpression::JsTemplateExpression(it) => &it.syntax,
            AnyJsExpression::JsThisExpression(it) => &it.syntax,
            AnyJsExpression::JsUnaryExpression(it) => &it.syntax,
            AnyJsExpression::JsYieldExpression(it) => &it.syntax,
            AnyJsExpression::JsxTagExpression(it) => &it.syntax,
            AnyJsExpression::TsAsExpression(it) => &it.syntax,
            AnyJsExpression::TsInstantiationExpression(it) => &it.syntax,
            AnyJsExpression::TsNonNullAssertionExpression(it) => &it.syntax,
            AnyJsExpression::TsSatisfiesExpression(it) => &it.syntax,
            AnyJsExpression::TsTypeAssertionExpression(it) => &it.syntax,
            AnyJsExpression::AnyJsLiteralExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsExpression::JsArrayExpression(it) => it.syntax,
            AnyJsExpression::JsArrowFunctionExpression(it) => it.syntax,
            AnyJsExpression::JsAssignmentExpression(it) => it.syntax,
            AnyJsExpression::JsAwaitExpression(it) => it.syntax,
            AnyJsExpression::JsBinaryExpression(it) => it.syntax,
            AnyJsExpression::JsBogusExpression(it) => it.syntax,
            AnyJsExpression::JsCallExpression(it) => it.syntax,
            AnyJsExpression::JsClassExpression(it) => it.syntax,
            AnyJsExpression::JsComputedMemberExpression(it) => it.syntax,
            AnyJsExpression::JsConditionalExpression(it) => it.syntax,
            AnyJsExpression::JsFunctionExpression(it) => it.syntax,
            AnyJsExpression::JsIdentifierExpression(it) => it.syntax,
            AnyJsExpression::JsImportCallExpression(it) => it.syntax,
            AnyJsExpression::JsImportMetaExpression(it) => it.syntax,
            AnyJsExpression::JsInExpression(it) => it.syntax,
            AnyJsExpression::JsInstanceofExpression(it) => it.syntax,
            AnyJsExpression::JsLogicalExpression(it) => it.syntax,
            AnyJsExpression::JsNewExpression(it) => it.syntax,
            AnyJsExpression::JsNewTargetExpression(it) => it.syntax,
            AnyJsExpression::JsObjectExpression(it) => it.syntax,
            AnyJsExpression::JsParenthesizedExpression(it) => it.syntax,
            AnyJsExpression::JsPostUpdateExpression(it) => it.syntax,
            AnyJsExpression::JsPreUpdateExpression(it) => it.syntax,
            AnyJsExpression::JsSequenceExpression(it) => it.syntax,
            AnyJsExpression::JsStaticMemberExpression(it) => it.syntax,
            AnyJsExpression::JsSuperExpression(it) => it.syntax,
            AnyJsExpression::JsTemplateExpression(it) => it.syntax,
            AnyJsExpression::JsThisExpression(it) => it.syntax,
            AnyJsExpression::JsUnaryExpression(it) => it.syntax,
            AnyJsExpression::JsYieldExpression(it) => it.syntax,
            AnyJsExpression::JsxTagExpression(it) => it.syntax,
            AnyJsExpression::TsAsExpression(it) => it.syntax,
            AnyJsExpression::TsInstantiationExpression(it) => it.syntax,
            AnyJsExpression::TsNonNullAssertionExpression(it) => it.syntax,
            AnyJsExpression::TsSatisfiesExpression(it) => it.syntax,
            AnyJsExpression::TsTypeAssertionExpression(it) => it.syntax,
            AnyJsExpression::AnyJsLiteralExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsExpression::AnyJsLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsArrayExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsArrowFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsAssignmentExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsAwaitExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsBinaryExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsBogusExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsCallExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsClassExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsComputedMemberExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsConditionalExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsIdentifierExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsImportCallExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsImportMetaExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsInExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsInstanceofExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsLogicalExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsNewExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsNewTargetExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsObjectExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsParenthesizedExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsPostUpdateExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsPreUpdateExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsSequenceExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsStaticMemberExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsSuperExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsTemplateExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsThisExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsUnaryExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsYieldExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::JsxTagExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::TsAsExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::TsInstantiationExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::TsNonNullAssertionExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::TsSatisfiesExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsExpression::TsTypeAssertionExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsExpression> for SyntaxNode {
    fn from(n: AnyJsExpression) -> SyntaxNode {
        match n {
            AnyJsExpression::AnyJsLiteralExpression(it) => it.into(),
            AnyJsExpression::JsArrayExpression(it) => it.into(),
            AnyJsExpression::JsArrowFunctionExpression(it) => it.into(),
            AnyJsExpression::JsAssignmentExpression(it) => it.into(),
            AnyJsExpression::JsAwaitExpression(it) => it.into(),
            AnyJsExpression::JsBinaryExpression(it) => it.into(),
            AnyJsExpression::JsBogusExpression(it) => it.into(),
            AnyJsExpression::JsCallExpression(it) => it.into(),
            AnyJsExpression::JsClassExpression(it) => it.into(),
            AnyJsExpression::JsComputedMemberExpression(it) => it.into(),
            AnyJsExpression::JsConditionalExpression(it) => it.into(),
            AnyJsExpression::JsFunctionExpression(it) => it.into(),
            AnyJsExpression::JsIdentifierExpression(it) => it.into(),
            AnyJsExpression::JsImportCallExpression(it) => it.into(),
            AnyJsExpression::JsImportMetaExpression(it) => it.into(),
            AnyJsExpression::JsInExpression(it) => it.into(),
            AnyJsExpression::JsInstanceofExpression(it) => it.into(),
            AnyJsExpression::JsLogicalExpression(it) => it.into(),
            AnyJsExpression::JsNewExpression(it) => it.into(),
            AnyJsExpression::JsNewTargetExpression(it) => it.into(),
            AnyJsExpression::JsObjectExpression(it) => it.into(),
            AnyJsExpression::JsParenthesizedExpression(it) => it.into(),
            AnyJsExpression::JsPostUpdateExpression(it) => it.into(),
            AnyJsExpression::JsPreUpdateExpression(it) => it.into(),
            AnyJsExpression::JsSequenceExpression(it) => it.into(),
            AnyJsExpression::JsStaticMemberExpression(it) => it.into(),
            AnyJsExpression::JsSuperExpression(it) => it.into(),
            AnyJsExpression::JsTemplateExpression(it) => it.into(),
            AnyJsExpression::JsThisExpression(it) => it.into(),
            AnyJsExpression::JsUnaryExpression(it) => it.into(),
            AnyJsExpression::JsYieldExpression(it) => it.into(),
            AnyJsExpression::JsxTagExpression(it) => it.into(),
            AnyJsExpression::TsAsExpression(it) => it.into(),
            AnyJsExpression::TsInstantiationExpression(it) => it.into(),
            AnyJsExpression::TsNonNullAssertionExpression(it) => it.into(),
            AnyJsExpression::TsSatisfiesExpression(it) => it.into(),
            AnyJsExpression::TsTypeAssertionExpression(it) => it.into(),
        }
    }
}
impl From<AnyJsExpression> for SyntaxElement {
    fn from(n: AnyJsExpression) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsForVariableDeclaration> for AnyJsForInOrOfInitializer {
    fn from(node: JsForVariableDeclaration) -> AnyJsForInOrOfInitializer {
        AnyJsForInOrOfInitializer::JsForVariableDeclaration(node)
    }
}
impl AstNode for AnyJsForInOrOfInitializer {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        AnyJsAssignmentPattern::KIND_SET.union(JsForVariableDeclaration::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_FOR_VARIABLE_DECLARATION => true,
            k if AnyJsAssignmentPattern::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_FOR_VARIABLE_DECLARATION => {
                AnyJsForInOrOfInitializer::JsForVariableDeclaration(JsForVariableDeclaration {
                    syntax,
                })
            }
            _ => {
                if let Some(any_js_assignment_pattern) = AnyJsAssignmentPattern::cast(syntax) {
                    return Some(AnyJsForInOrOfInitializer::AnyJsAssignmentPattern(
                        any_js_assignment_pattern,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsForInOrOfInitializer::JsForVariableDeclaration(it) => &it.syntax,
            AnyJsForInOrOfInitializer::AnyJsAssignmentPattern(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsForInOrOfInitializer::JsForVariableDeclaration(it) => it.syntax,
            AnyJsForInOrOfInitializer::AnyJsAssignmentPattern(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsForInOrOfInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsForInOrOfInitializer::AnyJsAssignmentPattern(it) => std::fmt::Debug::fmt(it, f),
            AnyJsForInOrOfInitializer::JsForVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsForInOrOfInitializer> for SyntaxNode {
    fn from(n: AnyJsForInOrOfInitializer) -> SyntaxNode {
        match n {
            AnyJsForInOrOfInitializer::AnyJsAssignmentPattern(it) => it.into(),
            AnyJsForInOrOfInitializer::JsForVariableDeclaration(it) => it.into(),
        }
    }
}
impl From<AnyJsForInOrOfInitializer> for SyntaxElement {
    fn from(n: AnyJsForInOrOfInitializer) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsVariableDeclaration> for AnyJsForInitializer {
    fn from(node: JsVariableDeclaration) -> AnyJsForInitializer {
        AnyJsForInitializer::JsVariableDeclaration(node)
    }
}
impl AstNode for AnyJsForInitializer {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        AnyJsExpression::KIND_SET.union(JsVariableDeclaration::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_VARIABLE_DECLARATION => true,
            k if AnyJsExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_VARIABLE_DECLARATION => {
                AnyJsForInitializer::JsVariableDeclaration(JsVariableDeclaration { syntax })
            }
            _ => {
                if let Some(any_js_expression) = AnyJsExpression::cast(syntax) {
                    return Some(AnyJsForInitializer::AnyJsExpression(any_js_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsForInitializer::JsVariableDeclaration(it) => &it.syntax,
            AnyJsForInitializer::AnyJsExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsForInitializer::JsVariableDeclaration(it) => it.syntax,
            AnyJsForInitializer::AnyJsExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsForInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsForInitializer::AnyJsExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsForInitializer::JsVariableDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsForInitializer> for SyntaxNode {
    fn from(n: AnyJsForInitializer) -> SyntaxNode {
        match n {
            AnyJsForInitializer::AnyJsExpression(it) => it.into(),
            AnyJsForInitializer::JsVariableDeclaration(it) => it.into(),
        }
    }
}
impl From<AnyJsForInitializer> for SyntaxElement {
    fn from(n: AnyJsForInitializer) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusParameter> for AnyJsFormalParameter {
    fn from(node: JsBogusParameter) -> AnyJsFormalParameter {
        AnyJsFormalParameter::JsBogusParameter(node)
    }
}
impl From<JsFormalParameter> for AnyJsFormalParameter {
    fn from(node: JsFormalParameter) -> AnyJsFormalParameter {
        AnyJsFormalParameter::JsFormalParameter(node)
    }
}
impl AstNode for AnyJsFormalParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsBogusParameter::KIND_SET.union(JsFormalParameter::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_BOGUS_PARAMETER | JS_FORMAL_PARAMETER)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_PARAMETER => {
                AnyJsFormalParameter::JsBogusParameter(JsBogusParameter { syntax })
            }
            JS_FORMAL_PARAMETER => {
                AnyJsFormalParameter::JsFormalParameter(JsFormalParameter { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsFormalParameter::JsBogusParameter(it) => &it.syntax,
            AnyJsFormalParameter::JsFormalParameter(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsFormalParameter::JsBogusParameter(it) => it.syntax,
            AnyJsFormalParameter::JsFormalParameter(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsFormalParameter::JsBogusParameter(it) => std::fmt::Debug::fmt(it, f),
            AnyJsFormalParameter::JsFormalParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsFormalParameter> for SyntaxNode {
    fn from(n: AnyJsFormalParameter) -> SyntaxNode {
        match n {
            AnyJsFormalParameter::JsBogusParameter(it) => it.into(),
            AnyJsFormalParameter::JsFormalParameter(it) => it.into(),
        }
    }
}
impl From<AnyJsFormalParameter> for SyntaxElement {
    fn from(n: AnyJsFormalParameter) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsArrowFunctionExpression> for AnyJsFunction {
    fn from(node: JsArrowFunctionExpression) -> AnyJsFunction {
        AnyJsFunction::JsArrowFunctionExpression(node)
    }
}
impl From<JsFunctionDeclaration> for AnyJsFunction {
    fn from(node: JsFunctionDeclaration) -> AnyJsFunction {
        AnyJsFunction::JsFunctionDeclaration(node)
    }
}
impl From<JsFunctionExportDefaultDeclaration> for AnyJsFunction {
    fn from(node: JsFunctionExportDefaultDeclaration) -> AnyJsFunction {
        AnyJsFunction::JsFunctionExportDefaultDeclaration(node)
    }
}
impl From<JsFunctionExpression> for AnyJsFunction {
    fn from(node: JsFunctionExpression) -> AnyJsFunction {
        AnyJsFunction::JsFunctionExpression(node)
    }
}
impl AstNode for AnyJsFunction {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsArrowFunctionExpression::KIND_SET
        .union(JsFunctionDeclaration::KIND_SET)
        .union(JsFunctionExportDefaultDeclaration::KIND_SET)
        .union(JsFunctionExpression::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_ARROW_FUNCTION_EXPRESSION
                | JS_FUNCTION_DECLARATION
                | JS_FUNCTION_EXPORT_DEFAULT_DECLARATION
                | JS_FUNCTION_EXPRESSION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ARROW_FUNCTION_EXPRESSION => {
                AnyJsFunction::JsArrowFunctionExpression(JsArrowFunctionExpression { syntax })
            }
            JS_FUNCTION_DECLARATION => {
                AnyJsFunction::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_FUNCTION_EXPORT_DEFAULT_DECLARATION => {
                AnyJsFunction::JsFunctionExportDefaultDeclaration(
                    JsFunctionExportDefaultDeclaration { syntax },
                )
            }
            JS_FUNCTION_EXPRESSION => {
                AnyJsFunction::JsFunctionExpression(JsFunctionExpression { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsFunction::JsArrowFunctionExpression(it) => &it.syntax,
            AnyJsFunction::JsFunctionDeclaration(it) => &it.syntax,
            AnyJsFunction::JsFunctionExportDefaultDeclaration(it) => &it.syntax,
            AnyJsFunction::JsFunctionExpression(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsFunction::JsArrowFunctionExpression(it) => it.syntax,
            AnyJsFunction::JsFunctionDeclaration(it) => it.syntax,
            AnyJsFunction::JsFunctionExportDefaultDeclaration(it) => it.syntax,
            AnyJsFunction::JsFunctionExpression(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsFunction::JsArrowFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsFunction::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsFunction::JsFunctionExportDefaultDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsFunction::JsFunctionExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsFunction> for SyntaxNode {
    fn from(n: AnyJsFunction) -> SyntaxNode {
        match n {
            AnyJsFunction::JsArrowFunctionExpression(it) => it.into(),
            AnyJsFunction::JsFunctionDeclaration(it) => it.into(),
            AnyJsFunction::JsFunctionExportDefaultDeclaration(it) => it.into(),
            AnyJsFunction::JsFunctionExpression(it) => it.into(),
        }
    }
}
impl From<AnyJsFunction> for SyntaxElement {
    fn from(n: AnyJsFunction) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsFunctionBody> for AnyJsFunctionBody {
    fn from(node: JsFunctionBody) -> AnyJsFunctionBody { AnyJsFunctionBody::JsFunctionBody(node) }
}
impl AstNode for AnyJsFunctionBody {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        AnyJsExpression::KIND_SET.union(JsFunctionBody::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_FUNCTION_BODY => true,
            k if AnyJsExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_FUNCTION_BODY => AnyJsFunctionBody::JsFunctionBody(JsFunctionBody { syntax }),
            _ => {
                if let Some(any_js_expression) = AnyJsExpression::cast(syntax) {
                    return Some(AnyJsFunctionBody::AnyJsExpression(any_js_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsFunctionBody::JsFunctionBody(it) => &it.syntax,
            AnyJsFunctionBody::AnyJsExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsFunctionBody::JsFunctionBody(it) => it.syntax,
            AnyJsFunctionBody::AnyJsExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsFunctionBody::AnyJsExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsFunctionBody::JsFunctionBody(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsFunctionBody> for SyntaxNode {
    fn from(n: AnyJsFunctionBody) -> SyntaxNode {
        match n {
            AnyJsFunctionBody::AnyJsExpression(it) => it.into(),
            AnyJsFunctionBody::JsFunctionBody(it) => it.into(),
        }
    }
}
impl From<AnyJsFunctionBody> for SyntaxElement {
    fn from(n: AnyJsFunctionBody) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusImportAttributeEntry> for AnyJsImportAttributeEntry {
    fn from(node: JsBogusImportAttributeEntry) -> AnyJsImportAttributeEntry {
        AnyJsImportAttributeEntry::JsBogusImportAttributeEntry(node)
    }
}
impl From<JsImportAttributeEntry> for AnyJsImportAttributeEntry {
    fn from(node: JsImportAttributeEntry) -> AnyJsImportAttributeEntry {
        AnyJsImportAttributeEntry::JsImportAttributeEntry(node)
    }
}
impl AstNode for AnyJsImportAttributeEntry {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsBogusImportAttributeEntry::KIND_SET.union(JsImportAttributeEntry::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_IMPORT_ATTRIBUTE_ENTRY | JS_IMPORT_ATTRIBUTE_ENTRY
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_IMPORT_ATTRIBUTE_ENTRY => {
                AnyJsImportAttributeEntry::JsBogusImportAttributeEntry(
                    JsBogusImportAttributeEntry { syntax },
                )
            }
            JS_IMPORT_ATTRIBUTE_ENTRY => {
                AnyJsImportAttributeEntry::JsImportAttributeEntry(JsImportAttributeEntry { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsImportAttributeEntry::JsBogusImportAttributeEntry(it) => &it.syntax,
            AnyJsImportAttributeEntry::JsImportAttributeEntry(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsImportAttributeEntry::JsBogusImportAttributeEntry(it) => it.syntax,
            AnyJsImportAttributeEntry::JsImportAttributeEntry(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsImportAttributeEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsImportAttributeEntry::JsBogusImportAttributeEntry(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsImportAttributeEntry::JsImportAttributeEntry(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsImportAttributeEntry> for SyntaxNode {
    fn from(n: AnyJsImportAttributeEntry) -> SyntaxNode {
        match n {
            AnyJsImportAttributeEntry::JsBogusImportAttributeEntry(it) => it.into(),
            AnyJsImportAttributeEntry::JsImportAttributeEntry(it) => it.into(),
        }
    }
}
impl From<AnyJsImportAttributeEntry> for SyntaxElement {
    fn from(n: AnyJsImportAttributeEntry) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsImportBareClause> for AnyJsImportClause {
    fn from(node: JsImportBareClause) -> AnyJsImportClause {
        AnyJsImportClause::JsImportBareClause(node)
    }
}
impl From<JsImportDefaultClause> for AnyJsImportClause {
    fn from(node: JsImportDefaultClause) -> AnyJsImportClause {
        AnyJsImportClause::JsImportDefaultClause(node)
    }
}
impl From<JsImportNamedClause> for AnyJsImportClause {
    fn from(node: JsImportNamedClause) -> AnyJsImportClause {
        AnyJsImportClause::JsImportNamedClause(node)
    }
}
impl From<JsImportNamespaceClause> for AnyJsImportClause {
    fn from(node: JsImportNamespaceClause) -> AnyJsImportClause {
        AnyJsImportClause::JsImportNamespaceClause(node)
    }
}
impl AstNode for AnyJsImportClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsImportBareClause::KIND_SET
        .union(JsImportDefaultClause::KIND_SET)
        .union(JsImportNamedClause::KIND_SET)
        .union(JsImportNamespaceClause::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_IMPORT_BARE_CLAUSE
                | JS_IMPORT_DEFAULT_CLAUSE
                | JS_IMPORT_NAMED_CLAUSE
                | JS_IMPORT_NAMESPACE_CLAUSE
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_IMPORT_BARE_CLAUSE => {
                AnyJsImportClause::JsImportBareClause(JsImportBareClause { syntax })
            }
            JS_IMPORT_DEFAULT_CLAUSE => {
                AnyJsImportClause::JsImportDefaultClause(JsImportDefaultClause { syntax })
            }
            JS_IMPORT_NAMED_CLAUSE => {
                AnyJsImportClause::JsImportNamedClause(JsImportNamedClause { syntax })
            }
            JS_IMPORT_NAMESPACE_CLAUSE => {
                AnyJsImportClause::JsImportNamespaceClause(JsImportNamespaceClause { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsImportClause::JsImportBareClause(it) => &it.syntax,
            AnyJsImportClause::JsImportDefaultClause(it) => &it.syntax,
            AnyJsImportClause::JsImportNamedClause(it) => &it.syntax,
            AnyJsImportClause::JsImportNamespaceClause(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsImportClause::JsImportBareClause(it) => it.syntax,
            AnyJsImportClause::JsImportDefaultClause(it) => it.syntax,
            AnyJsImportClause::JsImportNamedClause(it) => it.syntax,
            AnyJsImportClause::JsImportNamespaceClause(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsImportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsImportClause::JsImportBareClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsImportClause::JsImportDefaultClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsImportClause::JsImportNamedClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsImportClause::JsImportNamespaceClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsImportClause> for SyntaxNode {
    fn from(n: AnyJsImportClause) -> SyntaxNode {
        match n {
            AnyJsImportClause::JsImportBareClause(it) => it.into(),
            AnyJsImportClause::JsImportDefaultClause(it) => it.into(),
            AnyJsImportClause::JsImportNamedClause(it) => it.into(),
            AnyJsImportClause::JsImportNamespaceClause(it) => it.into(),
        }
    }
}
impl From<AnyJsImportClause> for SyntaxElement {
    fn from(n: AnyJsImportClause) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsPrivateName> for AnyJsInProperty {
    fn from(node: JsPrivateName) -> AnyJsInProperty { AnyJsInProperty::JsPrivateName(node) }
}
impl AstNode for AnyJsInProperty {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        AnyJsExpression::KIND_SET.union(JsPrivateName::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_PRIVATE_NAME => true,
            k if AnyJsExpression::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_PRIVATE_NAME => AnyJsInProperty::JsPrivateName(JsPrivateName { syntax }),
            _ => {
                if let Some(any_js_expression) = AnyJsExpression::cast(syntax) {
                    return Some(AnyJsInProperty::AnyJsExpression(any_js_expression));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsInProperty::JsPrivateName(it) => &it.syntax,
            AnyJsInProperty::AnyJsExpression(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsInProperty::JsPrivateName(it) => it.syntax,
            AnyJsInProperty::AnyJsExpression(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsInProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsInProperty::AnyJsExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsInProperty::JsPrivateName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsInProperty> for SyntaxNode {
    fn from(n: AnyJsInProperty) -> SyntaxNode {
        match n {
            AnyJsInProperty::AnyJsExpression(it) => it.into(),
            AnyJsInProperty::JsPrivateName(it) => it.into(),
        }
    }
}
impl From<AnyJsInProperty> for SyntaxElement {
    fn from(n: AnyJsInProperty) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBigintLiteralExpression> for AnyJsLiteralExpression {
    fn from(node: JsBigintLiteralExpression) -> AnyJsLiteralExpression {
        AnyJsLiteralExpression::JsBigintLiteralExpression(node)
    }
}
impl From<JsBooleanLiteralExpression> for AnyJsLiteralExpression {
    fn from(node: JsBooleanLiteralExpression) -> AnyJsLiteralExpression {
        AnyJsLiteralExpression::JsBooleanLiteralExpression(node)
    }
}
impl From<JsNullLiteralExpression> for AnyJsLiteralExpression {
    fn from(node: JsNullLiteralExpression) -> AnyJsLiteralExpression {
        AnyJsLiteralExpression::JsNullLiteralExpression(node)
    }
}
impl From<JsNumberLiteralExpression> for AnyJsLiteralExpression {
    fn from(node: JsNumberLiteralExpression) -> AnyJsLiteralExpression {
        AnyJsLiteralExpression::JsNumberLiteralExpression(node)
    }
}
impl From<JsRegexLiteralExpression> for AnyJsLiteralExpression {
    fn from(node: JsRegexLiteralExpression) -> AnyJsLiteralExpression {
        AnyJsLiteralExpression::JsRegexLiteralExpression(node)
    }
}
impl From<JsStringLiteralExpression> for AnyJsLiteralExpression {
    fn from(node: JsStringLiteralExpression) -> AnyJsLiteralExpression {
        AnyJsLiteralExpression::JsStringLiteralExpression(node)
    }
}
impl AstNode for AnyJsLiteralExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBigintLiteralExpression::KIND_SET
        .union(JsBooleanLiteralExpression::KIND_SET)
        .union(JsNullLiteralExpression::KIND_SET)
        .union(JsNumberLiteralExpression::KIND_SET)
        .union(JsRegexLiteralExpression::KIND_SET)
        .union(JsStringLiteralExpression::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BIGINT_LITERAL_EXPRESSION
                | JS_BOOLEAN_LITERAL_EXPRESSION
                | JS_NULL_LITERAL_EXPRESSION
                | JS_NUMBER_LITERAL_EXPRESSION
                | JS_REGEX_LITERAL_EXPRESSION
                | JS_STRING_LITERAL_EXPRESSION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BIGINT_LITERAL_EXPRESSION => {
                AnyJsLiteralExpression::JsBigintLiteralExpression(JsBigintLiteralExpression {
                    syntax,
                })
            }
            JS_BOOLEAN_LITERAL_EXPRESSION => {
                AnyJsLiteralExpression::JsBooleanLiteralExpression(JsBooleanLiteralExpression {
                    syntax,
                })
            }
            JS_NULL_LITERAL_EXPRESSION => {
                AnyJsLiteralExpression::JsNullLiteralExpression(JsNullLiteralExpression { syntax })
            }
            JS_NUMBER_LITERAL_EXPRESSION => {
                AnyJsLiteralExpression::JsNumberLiteralExpression(JsNumberLiteralExpression {
                    syntax,
                })
            }
            JS_REGEX_LITERAL_EXPRESSION => {
                AnyJsLiteralExpression::JsRegexLiteralExpression(JsRegexLiteralExpression {
                    syntax,
                })
            }
            JS_STRING_LITERAL_EXPRESSION => {
                AnyJsLiteralExpression::JsStringLiteralExpression(JsStringLiteralExpression {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsLiteralExpression::JsBigintLiteralExpression(it) => &it.syntax,
            AnyJsLiteralExpression::JsBooleanLiteralExpression(it) => &it.syntax,
            AnyJsLiteralExpression::JsNullLiteralExpression(it) => &it.syntax,
            AnyJsLiteralExpression::JsNumberLiteralExpression(it) => &it.syntax,
            AnyJsLiteralExpression::JsRegexLiteralExpression(it) => &it.syntax,
            AnyJsLiteralExpression::JsStringLiteralExpression(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsLiteralExpression::JsBigintLiteralExpression(it) => it.syntax,
            AnyJsLiteralExpression::JsBooleanLiteralExpression(it) => it.syntax,
            AnyJsLiteralExpression::JsNullLiteralExpression(it) => it.syntax,
            AnyJsLiteralExpression::JsNumberLiteralExpression(it) => it.syntax,
            AnyJsLiteralExpression::JsRegexLiteralExpression(it) => it.syntax,
            AnyJsLiteralExpression::JsStringLiteralExpression(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsLiteralExpression::JsBigintLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsLiteralExpression::JsBooleanLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsLiteralExpression::JsNullLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsLiteralExpression::JsNumberLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsLiteralExpression::JsRegexLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
            AnyJsLiteralExpression::JsStringLiteralExpression(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsLiteralExpression> for SyntaxNode {
    fn from(n: AnyJsLiteralExpression) -> SyntaxNode {
        match n {
            AnyJsLiteralExpression::JsBigintLiteralExpression(it) => it.into(),
            AnyJsLiteralExpression::JsBooleanLiteralExpression(it) => it.into(),
            AnyJsLiteralExpression::JsNullLiteralExpression(it) => it.into(),
            AnyJsLiteralExpression::JsNumberLiteralExpression(it) => it.into(),
            AnyJsLiteralExpression::JsRegexLiteralExpression(it) => it.into(),
            AnyJsLiteralExpression::JsStringLiteralExpression(it) => it.into(),
        }
    }
}
impl From<AnyJsLiteralExpression> for SyntaxElement {
    fn from(n: AnyJsLiteralExpression) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for AnyJsMethodModifier {
    fn from(node: JsStaticModifier) -> AnyJsMethodModifier {
        AnyJsMethodModifier::JsStaticModifier(node)
    }
}
impl From<TsAccessibilityModifier> for AnyJsMethodModifier {
    fn from(node: TsAccessibilityModifier) -> AnyJsMethodModifier {
        AnyJsMethodModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for AnyJsMethodModifier {
    fn from(node: TsOverrideModifier) -> AnyJsMethodModifier {
        AnyJsMethodModifier::TsOverrideModifier(node)
    }
}
impl AstNode for AnyJsMethodModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsStaticModifier::KIND_SET
        .union(TsAccessibilityModifier::KIND_SET)
        .union(TsOverrideModifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER | TS_ACCESSIBILITY_MODIFIER | TS_OVERRIDE_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                AnyJsMethodModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                AnyJsMethodModifier::TsAccessibilityModifier(TsAccessibilityModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                AnyJsMethodModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsMethodModifier::JsStaticModifier(it) => &it.syntax,
            AnyJsMethodModifier::TsAccessibilityModifier(it) => &it.syntax,
            AnyJsMethodModifier::TsOverrideModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsMethodModifier::JsStaticModifier(it) => it.syntax,
            AnyJsMethodModifier::TsAccessibilityModifier(it) => it.syntax,
            AnyJsMethodModifier::TsOverrideModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsMethodModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsMethodModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyJsMethodModifier::TsAccessibilityModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyJsMethodModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsMethodModifier> for SyntaxNode {
    fn from(n: AnyJsMethodModifier) -> SyntaxNode {
        match n {
            AnyJsMethodModifier::JsStaticModifier(it) => it.into(),
            AnyJsMethodModifier::TsAccessibilityModifier(it) => it.into(),
            AnyJsMethodModifier::TsOverrideModifier(it) => it.into(),
        }
    }
}
impl From<AnyJsMethodModifier> for SyntaxElement {
    fn from(n: AnyJsMethodModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExport> for AnyJsModuleItem {
    fn from(node: JsExport) -> AnyJsModuleItem { AnyJsModuleItem::JsExport(node) }
}
impl From<JsImport> for AnyJsModuleItem {
    fn from(node: JsImport) -> AnyJsModuleItem { AnyJsModuleItem::JsImport(node) }
}
impl AstNode for AnyJsModuleItem {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsStatement::KIND_SET
        .union(JsExport::KIND_SET)
        .union(JsImport::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_EXPORT | JS_IMPORT => true,
            k if AnyJsStatement::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPORT => AnyJsModuleItem::JsExport(JsExport { syntax }),
            JS_IMPORT => AnyJsModuleItem::JsImport(JsImport { syntax }),
            _ => {
                if let Some(any_js_statement) = AnyJsStatement::cast(syntax) {
                    return Some(AnyJsModuleItem::AnyJsStatement(any_js_statement));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsModuleItem::JsExport(it) => &it.syntax,
            AnyJsModuleItem::JsImport(it) => &it.syntax,
            AnyJsModuleItem::AnyJsStatement(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsModuleItem::JsExport(it) => it.syntax,
            AnyJsModuleItem::JsImport(it) => it.syntax,
            AnyJsModuleItem::AnyJsStatement(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsModuleItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsModuleItem::AnyJsStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsModuleItem::JsExport(it) => std::fmt::Debug::fmt(it, f),
            AnyJsModuleItem::JsImport(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsModuleItem> for SyntaxNode {
    fn from(n: AnyJsModuleItem) -> SyntaxNode {
        match n {
            AnyJsModuleItem::AnyJsStatement(it) => it.into(),
            AnyJsModuleItem::JsExport(it) => it.into(),
            AnyJsModuleItem::JsImport(it) => it.into(),
        }
    }
}
impl From<AnyJsModuleItem> for SyntaxElement {
    fn from(n: AnyJsModuleItem) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsName> for AnyJsName {
    fn from(node: JsName) -> AnyJsName { AnyJsName::JsName(node) }
}
impl From<JsPrivateName> for AnyJsName {
    fn from(node: JsPrivateName) -> AnyJsName { AnyJsName::JsPrivateName(node) }
}
impl AstNode for AnyJsName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsName::KIND_SET.union(JsPrivateName::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JS_NAME | JS_PRIVATE_NAME) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_NAME => AnyJsName::JsName(JsName { syntax }),
            JS_PRIVATE_NAME => AnyJsName::JsPrivateName(JsPrivateName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsName::JsName(it) => &it.syntax,
            AnyJsName::JsPrivateName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsName::JsName(it) => it.syntax,
            AnyJsName::JsPrivateName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsName::JsName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsName::JsPrivateName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsName> for SyntaxNode {
    fn from(n: AnyJsName) -> SyntaxNode {
        match n {
            AnyJsName::JsName(it) => it.into(),
            AnyJsName::JsPrivateName(it) => it.into(),
        }
    }
}
impl From<AnyJsName> for SyntaxElement {
    fn from(n: AnyJsName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsNamedImportSpecifiers> for AnyJsNamedImport {
    fn from(node: JsNamedImportSpecifiers) -> AnyJsNamedImport {
        AnyJsNamedImport::JsNamedImportSpecifiers(node)
    }
}
impl From<JsNamespaceImportSpecifier> for AnyJsNamedImport {
    fn from(node: JsNamespaceImportSpecifier) -> AnyJsNamedImport {
        AnyJsNamedImport::JsNamespaceImportSpecifier(node)
    }
}
impl AstNode for AnyJsNamedImport {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsNamedImportSpecifiers::KIND_SET.union(JsNamespaceImportSpecifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_NAMED_IMPORT_SPECIFIERS | JS_NAMESPACE_IMPORT_SPECIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_NAMED_IMPORT_SPECIFIERS => {
                AnyJsNamedImport::JsNamedImportSpecifiers(JsNamedImportSpecifiers { syntax })
            }
            JS_NAMESPACE_IMPORT_SPECIFIER => {
                AnyJsNamedImport::JsNamespaceImportSpecifier(JsNamespaceImportSpecifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsNamedImport::JsNamedImportSpecifiers(it) => &it.syntax,
            AnyJsNamedImport::JsNamespaceImportSpecifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsNamedImport::JsNamedImportSpecifiers(it) => it.syntax,
            AnyJsNamedImport::JsNamespaceImportSpecifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsNamedImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsNamedImport::JsNamedImportSpecifiers(it) => std::fmt::Debug::fmt(it, f),
            AnyJsNamedImport::JsNamespaceImportSpecifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsNamedImport> for SyntaxNode {
    fn from(n: AnyJsNamedImport) -> SyntaxNode {
        match n {
            AnyJsNamedImport::JsNamedImportSpecifiers(it) => it.into(),
            AnyJsNamedImport::JsNamespaceImportSpecifier(it) => it.into(),
        }
    }
}
impl From<AnyJsNamedImport> for SyntaxElement {
    fn from(n: AnyJsNamedImport) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusNamedImportSpecifier> for AnyJsNamedImportSpecifier {
    fn from(node: JsBogusNamedImportSpecifier) -> AnyJsNamedImportSpecifier {
        AnyJsNamedImportSpecifier::JsBogusNamedImportSpecifier(node)
    }
}
impl From<JsNamedImportSpecifier> for AnyJsNamedImportSpecifier {
    fn from(node: JsNamedImportSpecifier) -> AnyJsNamedImportSpecifier {
        AnyJsNamedImportSpecifier::JsNamedImportSpecifier(node)
    }
}
impl From<JsShorthandNamedImportSpecifier> for AnyJsNamedImportSpecifier {
    fn from(node: JsShorthandNamedImportSpecifier) -> AnyJsNamedImportSpecifier {
        AnyJsNamedImportSpecifier::JsShorthandNamedImportSpecifier(node)
    }
}
impl AstNode for AnyJsNamedImportSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBogusNamedImportSpecifier::KIND_SET
        .union(JsNamedImportSpecifier::KIND_SET)
        .union(JsShorthandNamedImportSpecifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_NAMED_IMPORT_SPECIFIER
                | JS_NAMED_IMPORT_SPECIFIER
                | JS_SHORTHAND_NAMED_IMPORT_SPECIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_NAMED_IMPORT_SPECIFIER => {
                AnyJsNamedImportSpecifier::JsBogusNamedImportSpecifier(
                    JsBogusNamedImportSpecifier { syntax },
                )
            }
            JS_NAMED_IMPORT_SPECIFIER => {
                AnyJsNamedImportSpecifier::JsNamedImportSpecifier(JsNamedImportSpecifier { syntax })
            }
            JS_SHORTHAND_NAMED_IMPORT_SPECIFIER => {
                AnyJsNamedImportSpecifier::JsShorthandNamedImportSpecifier(
                    JsShorthandNamedImportSpecifier { syntax },
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsNamedImportSpecifier::JsBogusNamedImportSpecifier(it) => &it.syntax,
            AnyJsNamedImportSpecifier::JsNamedImportSpecifier(it) => &it.syntax,
            AnyJsNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsNamedImportSpecifier::JsBogusNamedImportSpecifier(it) => it.syntax,
            AnyJsNamedImportSpecifier::JsNamedImportSpecifier(it) => it.syntax,
            AnyJsNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsNamedImportSpecifier::JsBogusNamedImportSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsNamedImportSpecifier::JsNamedImportSpecifier(it) => std::fmt::Debug::fmt(it, f),
            AnyJsNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<AnyJsNamedImportSpecifier> for SyntaxNode {
    fn from(n: AnyJsNamedImportSpecifier) -> SyntaxNode {
        match n {
            AnyJsNamedImportSpecifier::JsBogusNamedImportSpecifier(it) => it.into(),
            AnyJsNamedImportSpecifier::JsNamedImportSpecifier(it) => it.into(),
            AnyJsNamedImportSpecifier::JsShorthandNamedImportSpecifier(it) => it.into(),
        }
    }
}
impl From<AnyJsNamedImportSpecifier> for SyntaxElement {
    fn from(n: AnyJsNamedImportSpecifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusAssignment> for AnyJsObjectAssignmentPatternMember {
    fn from(node: JsBogusAssignment) -> AnyJsObjectAssignmentPatternMember {
        AnyJsObjectAssignmentPatternMember::JsBogusAssignment(node)
    }
}
impl From<JsObjectAssignmentPatternProperty> for AnyJsObjectAssignmentPatternMember {
    fn from(node: JsObjectAssignmentPatternProperty) -> AnyJsObjectAssignmentPatternMember {
        AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(node)
    }
}
impl From<JsObjectAssignmentPatternRest> for AnyJsObjectAssignmentPatternMember {
    fn from(node: JsObjectAssignmentPatternRest) -> AnyJsObjectAssignmentPatternMember {
        AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(node)
    }
}
impl From<JsObjectAssignmentPatternShorthandProperty> for AnyJsObjectAssignmentPatternMember {
    fn from(
        node: JsObjectAssignmentPatternShorthandProperty,
    ) -> AnyJsObjectAssignmentPatternMember {
        AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(node)
    }
}
impl AstNode for AnyJsObjectAssignmentPatternMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBogusAssignment::KIND_SET
        .union(JsObjectAssignmentPatternProperty::KIND_SET)
        .union(JsObjectAssignmentPatternRest::KIND_SET)
        .union(JsObjectAssignmentPatternShorthandProperty::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_ASSIGNMENT
                | JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY
                | JS_OBJECT_ASSIGNMENT_PATTERN_REST
                | JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_ASSIGNMENT => {
                AnyJsObjectAssignmentPatternMember::JsBogusAssignment(JsBogusAssignment { syntax })
            }
            JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY => {
                AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(
                    JsObjectAssignmentPatternProperty { syntax },
                )
            }
            JS_OBJECT_ASSIGNMENT_PATTERN_REST => {
                AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(
                    JsObjectAssignmentPatternRest { syntax },
                )
            }
            JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY => {
                AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(
                    JsObjectAssignmentPatternShorthandProperty { syntax },
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsObjectAssignmentPatternMember::JsBogusAssignment(it) => &it.syntax,
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => &it.syntax,
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => &it.syntax,
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                &it.syntax
            }
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsObjectAssignmentPatternMember::JsBogusAssignment(it) => it.syntax,
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => it.syntax,
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => it.syntax,
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                it.syntax
            }
        }
    }
}
impl std::fmt::Debug for AnyJsObjectAssignmentPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsObjectAssignmentPatternMember::JsBogusAssignment(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<AnyJsObjectAssignmentPatternMember> for SyntaxNode {
    fn from(n: AnyJsObjectAssignmentPatternMember) -> SyntaxNode {
        match n {
            AnyJsObjectAssignmentPatternMember::JsBogusAssignment(it) => it.into(),
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternProperty(it) => it.into(),
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternRest(it) => it.into(),
            AnyJsObjectAssignmentPatternMember::JsObjectAssignmentPatternShorthandProperty(it) => {
                it.into()
            }
        }
    }
}
impl From<AnyJsObjectAssignmentPatternMember> for SyntaxElement {
    fn from(n: AnyJsObjectAssignmentPatternMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusBinding> for AnyJsObjectBindingPatternMember {
    fn from(node: JsBogusBinding) -> AnyJsObjectBindingPatternMember {
        AnyJsObjectBindingPatternMember::JsBogusBinding(node)
    }
}
impl From<JsObjectBindingPatternProperty> for AnyJsObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternProperty) -> AnyJsObjectBindingPatternMember {
        AnyJsObjectBindingPatternMember::JsObjectBindingPatternProperty(node)
    }
}
impl From<JsObjectBindingPatternRest> for AnyJsObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternRest) -> AnyJsObjectBindingPatternMember {
        AnyJsObjectBindingPatternMember::JsObjectBindingPatternRest(node)
    }
}
impl From<JsObjectBindingPatternShorthandProperty> for AnyJsObjectBindingPatternMember {
    fn from(node: JsObjectBindingPatternShorthandProperty) -> AnyJsObjectBindingPatternMember {
        AnyJsObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(node)
    }
}
impl AstNode for AnyJsObjectBindingPatternMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBogusBinding::KIND_SET
        .union(JsObjectBindingPatternProperty::KIND_SET)
        .union(JsObjectBindingPatternRest::KIND_SET)
        .union(JsObjectBindingPatternShorthandProperty::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_BINDING
                | JS_OBJECT_BINDING_PATTERN_PROPERTY
                | JS_OBJECT_BINDING_PATTERN_REST
                | JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_BINDING => {
                AnyJsObjectBindingPatternMember::JsBogusBinding(JsBogusBinding { syntax })
            }
            JS_OBJECT_BINDING_PATTERN_PROPERTY => {
                AnyJsObjectBindingPatternMember::JsObjectBindingPatternProperty(
                    JsObjectBindingPatternProperty { syntax },
                )
            }
            JS_OBJECT_BINDING_PATTERN_REST => {
                AnyJsObjectBindingPatternMember::JsObjectBindingPatternRest(
                    JsObjectBindingPatternRest { syntax },
                )
            }
            JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY => {
                AnyJsObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(
                    JsObjectBindingPatternShorthandProperty { syntax },
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsObjectBindingPatternMember::JsBogusBinding(it) => &it.syntax,
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => &it.syntax,
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternRest(it) => &it.syntax,
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                &it.syntax
            }
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsObjectBindingPatternMember::JsBogusBinding(it) => it.syntax,
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => it.syntax,
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternRest(it) => it.syntax,
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                it.syntax
            }
        }
    }
}
impl std::fmt::Debug for AnyJsObjectBindingPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsObjectBindingPatternMember::JsBogusBinding(it) => std::fmt::Debug::fmt(it, f),
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternRest(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                std::fmt::Debug::fmt(it, f)
            }
        }
    }
}
impl From<AnyJsObjectBindingPatternMember> for SyntaxNode {
    fn from(n: AnyJsObjectBindingPatternMember) -> SyntaxNode {
        match n {
            AnyJsObjectBindingPatternMember::JsBogusBinding(it) => it.into(),
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternProperty(it) => it.into(),
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternRest(it) => it.into(),
            AnyJsObjectBindingPatternMember::JsObjectBindingPatternShorthandProperty(it) => {
                it.into()
            }
        }
    }
}
impl From<AnyJsObjectBindingPatternMember> for SyntaxElement {
    fn from(n: AnyJsObjectBindingPatternMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusMember> for AnyJsObjectMember {
    fn from(node: JsBogusMember) -> AnyJsObjectMember { AnyJsObjectMember::JsBogusMember(node) }
}
impl From<JsGetterObjectMember> for AnyJsObjectMember {
    fn from(node: JsGetterObjectMember) -> AnyJsObjectMember {
        AnyJsObjectMember::JsGetterObjectMember(node)
    }
}
impl From<JsMethodObjectMember> for AnyJsObjectMember {
    fn from(node: JsMethodObjectMember) -> AnyJsObjectMember {
        AnyJsObjectMember::JsMethodObjectMember(node)
    }
}
impl From<JsPropertyObjectMember> for AnyJsObjectMember {
    fn from(node: JsPropertyObjectMember) -> AnyJsObjectMember {
        AnyJsObjectMember::JsPropertyObjectMember(node)
    }
}
impl From<JsSetterObjectMember> for AnyJsObjectMember {
    fn from(node: JsSetterObjectMember) -> AnyJsObjectMember {
        AnyJsObjectMember::JsSetterObjectMember(node)
    }
}
impl From<JsShorthandPropertyObjectMember> for AnyJsObjectMember {
    fn from(node: JsShorthandPropertyObjectMember) -> AnyJsObjectMember {
        AnyJsObjectMember::JsShorthandPropertyObjectMember(node)
    }
}
impl From<JsSpread> for AnyJsObjectMember {
    fn from(node: JsSpread) -> AnyJsObjectMember { AnyJsObjectMember::JsSpread(node) }
}
impl AstNode for AnyJsObjectMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBogusMember::KIND_SET
        .union(JsGetterObjectMember::KIND_SET)
        .union(JsMethodObjectMember::KIND_SET)
        .union(JsPropertyObjectMember::KIND_SET)
        .union(JsSetterObjectMember::KIND_SET)
        .union(JsShorthandPropertyObjectMember::KIND_SET)
        .union(JsSpread::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_MEMBER
                | JS_GETTER_OBJECT_MEMBER
                | JS_METHOD_OBJECT_MEMBER
                | JS_PROPERTY_OBJECT_MEMBER
                | JS_SETTER_OBJECT_MEMBER
                | JS_SHORTHAND_PROPERTY_OBJECT_MEMBER
                | JS_SPREAD
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_MEMBER => AnyJsObjectMember::JsBogusMember(JsBogusMember { syntax }),
            JS_GETTER_OBJECT_MEMBER => {
                AnyJsObjectMember::JsGetterObjectMember(JsGetterObjectMember { syntax })
            }
            JS_METHOD_OBJECT_MEMBER => {
                AnyJsObjectMember::JsMethodObjectMember(JsMethodObjectMember { syntax })
            }
            JS_PROPERTY_OBJECT_MEMBER => {
                AnyJsObjectMember::JsPropertyObjectMember(JsPropertyObjectMember { syntax })
            }
            JS_SETTER_OBJECT_MEMBER => {
                AnyJsObjectMember::JsSetterObjectMember(JsSetterObjectMember { syntax })
            }
            JS_SHORTHAND_PROPERTY_OBJECT_MEMBER => {
                AnyJsObjectMember::JsShorthandPropertyObjectMember(
                    JsShorthandPropertyObjectMember { syntax },
                )
            }
            JS_SPREAD => AnyJsObjectMember::JsSpread(JsSpread { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsObjectMember::JsBogusMember(it) => &it.syntax,
            AnyJsObjectMember::JsGetterObjectMember(it) => &it.syntax,
            AnyJsObjectMember::JsMethodObjectMember(it) => &it.syntax,
            AnyJsObjectMember::JsPropertyObjectMember(it) => &it.syntax,
            AnyJsObjectMember::JsSetterObjectMember(it) => &it.syntax,
            AnyJsObjectMember::JsShorthandPropertyObjectMember(it) => &it.syntax,
            AnyJsObjectMember::JsSpread(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsObjectMember::JsBogusMember(it) => it.syntax,
            AnyJsObjectMember::JsGetterObjectMember(it) => it.syntax,
            AnyJsObjectMember::JsMethodObjectMember(it) => it.syntax,
            AnyJsObjectMember::JsPropertyObjectMember(it) => it.syntax,
            AnyJsObjectMember::JsSetterObjectMember(it) => it.syntax,
            AnyJsObjectMember::JsShorthandPropertyObjectMember(it) => it.syntax,
            AnyJsObjectMember::JsSpread(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsObjectMember::JsBogusMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsObjectMember::JsGetterObjectMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsObjectMember::JsMethodObjectMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsObjectMember::JsPropertyObjectMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsObjectMember::JsSetterObjectMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsObjectMember::JsShorthandPropertyObjectMember(it) => std::fmt::Debug::fmt(it, f),
            AnyJsObjectMember::JsSpread(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsObjectMember> for SyntaxNode {
    fn from(n: AnyJsObjectMember) -> SyntaxNode {
        match n {
            AnyJsObjectMember::JsBogusMember(it) => it.into(),
            AnyJsObjectMember::JsGetterObjectMember(it) => it.into(),
            AnyJsObjectMember::JsMethodObjectMember(it) => it.into(),
            AnyJsObjectMember::JsPropertyObjectMember(it) => it.into(),
            AnyJsObjectMember::JsSetterObjectMember(it) => it.into(),
            AnyJsObjectMember::JsShorthandPropertyObjectMember(it) => it.into(),
            AnyJsObjectMember::JsSpread(it) => it.into(),
        }
    }
}
impl From<AnyJsObjectMember> for SyntaxElement {
    fn from(n: AnyJsObjectMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsComputedMemberName> for AnyJsObjectMemberName {
    fn from(node: JsComputedMemberName) -> AnyJsObjectMemberName {
        AnyJsObjectMemberName::JsComputedMemberName(node)
    }
}
impl From<JsLiteralMemberName> for AnyJsObjectMemberName {
    fn from(node: JsLiteralMemberName) -> AnyJsObjectMemberName {
        AnyJsObjectMemberName::JsLiteralMemberName(node)
    }
}
impl AstNode for AnyJsObjectMemberName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsComputedMemberName::KIND_SET.union(JsLiteralMemberName::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_COMPUTED_MEMBER_NAME | JS_LITERAL_MEMBER_NAME)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_COMPUTED_MEMBER_NAME => {
                AnyJsObjectMemberName::JsComputedMemberName(JsComputedMemberName { syntax })
            }
            JS_LITERAL_MEMBER_NAME => {
                AnyJsObjectMemberName::JsLiteralMemberName(JsLiteralMemberName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsObjectMemberName::JsComputedMemberName(it) => &it.syntax,
            AnyJsObjectMemberName::JsLiteralMemberName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsObjectMemberName::JsComputedMemberName(it) => it.syntax,
            AnyJsObjectMemberName::JsLiteralMemberName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsObjectMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsObjectMemberName::JsComputedMemberName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsObjectMemberName::JsLiteralMemberName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsObjectMemberName> for SyntaxNode {
    fn from(n: AnyJsObjectMemberName) -> SyntaxNode {
        match n {
            AnyJsObjectMemberName::JsComputedMemberName(it) => it.into(),
            AnyJsObjectMemberName::JsLiteralMemberName(it) => it.into(),
        }
    }
}
impl From<AnyJsObjectMemberName> for SyntaxElement {
    fn from(n: AnyJsObjectMemberName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsRestParameter> for AnyJsParameter {
    fn from(node: JsRestParameter) -> AnyJsParameter { AnyJsParameter::JsRestParameter(node) }
}
impl From<TsThisParameter> for AnyJsParameter {
    fn from(node: TsThisParameter) -> AnyJsParameter { AnyJsParameter::TsThisParameter(node) }
}
impl AstNode for AnyJsParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsFormalParameter::KIND_SET
        .union(JsRestParameter::KIND_SET)
        .union(TsThisParameter::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JS_REST_PARAMETER | TS_THIS_PARAMETER => true,
            k if AnyJsFormalParameter::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REST_PARAMETER => AnyJsParameter::JsRestParameter(JsRestParameter { syntax }),
            TS_THIS_PARAMETER => AnyJsParameter::TsThisParameter(TsThisParameter { syntax }),
            _ => {
                if let Some(any_js_formal_parameter) = AnyJsFormalParameter::cast(syntax) {
                    return Some(AnyJsParameter::AnyJsFormalParameter(
                        any_js_formal_parameter,
                    ));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsParameter::JsRestParameter(it) => &it.syntax,
            AnyJsParameter::TsThisParameter(it) => &it.syntax,
            AnyJsParameter::AnyJsFormalParameter(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsParameter::JsRestParameter(it) => it.syntax,
            AnyJsParameter::TsThisParameter(it) => it.syntax,
            AnyJsParameter::AnyJsFormalParameter(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsParameter::AnyJsFormalParameter(it) => std::fmt::Debug::fmt(it, f),
            AnyJsParameter::JsRestParameter(it) => std::fmt::Debug::fmt(it, f),
            AnyJsParameter::TsThisParameter(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsParameter> for SyntaxNode {
    fn from(n: AnyJsParameter) -> SyntaxNode {
        match n {
            AnyJsParameter::AnyJsFormalParameter(it) => it.into(),
            AnyJsParameter::JsRestParameter(it) => it.into(),
            AnyJsParameter::TsThisParameter(it) => it.into(),
        }
    }
}
impl From<AnyJsParameter> for SyntaxElement {
    fn from(n: AnyJsParameter) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsAccessorModifier> for AnyJsPropertyModifier {
    fn from(node: JsAccessorModifier) -> AnyJsPropertyModifier {
        AnyJsPropertyModifier::JsAccessorModifier(node)
    }
}
impl From<JsStaticModifier> for AnyJsPropertyModifier {
    fn from(node: JsStaticModifier) -> AnyJsPropertyModifier {
        AnyJsPropertyModifier::JsStaticModifier(node)
    }
}
impl From<TsAccessibilityModifier> for AnyJsPropertyModifier {
    fn from(node: TsAccessibilityModifier) -> AnyJsPropertyModifier {
        AnyJsPropertyModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for AnyJsPropertyModifier {
    fn from(node: TsOverrideModifier) -> AnyJsPropertyModifier {
        AnyJsPropertyModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for AnyJsPropertyModifier {
    fn from(node: TsReadonlyModifier) -> AnyJsPropertyModifier {
        AnyJsPropertyModifier::TsReadonlyModifier(node)
    }
}
impl AstNode for AnyJsPropertyModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsAccessorModifier::KIND_SET
        .union(JsStaticModifier::KIND_SET)
        .union(TsAccessibilityModifier::KIND_SET)
        .union(TsOverrideModifier::KIND_SET)
        .union(TsReadonlyModifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_ACCESSOR_MODIFIER
                | JS_STATIC_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_OVERRIDE_MODIFIER
                | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ACCESSOR_MODIFIER => {
                AnyJsPropertyModifier::JsAccessorModifier(JsAccessorModifier { syntax })
            }
            JS_STATIC_MODIFIER => {
                AnyJsPropertyModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                AnyJsPropertyModifier::TsAccessibilityModifier(TsAccessibilityModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                AnyJsPropertyModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                AnyJsPropertyModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsPropertyModifier::JsAccessorModifier(it) => &it.syntax,
            AnyJsPropertyModifier::JsStaticModifier(it) => &it.syntax,
            AnyJsPropertyModifier::TsAccessibilityModifier(it) => &it.syntax,
            AnyJsPropertyModifier::TsOverrideModifier(it) => &it.syntax,
            AnyJsPropertyModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsPropertyModifier::JsAccessorModifier(it) => it.syntax,
            AnyJsPropertyModifier::JsStaticModifier(it) => it.syntax,
            AnyJsPropertyModifier::TsAccessibilityModifier(it) => it.syntax,
            AnyJsPropertyModifier::TsOverrideModifier(it) => it.syntax,
            AnyJsPropertyModifier::TsReadonlyModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsPropertyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsPropertyModifier::JsAccessorModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyJsPropertyModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyJsPropertyModifier::TsAccessibilityModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyJsPropertyModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyJsPropertyModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsPropertyModifier> for SyntaxNode {
    fn from(n: AnyJsPropertyModifier) -> SyntaxNode {
        match n {
            AnyJsPropertyModifier::JsAccessorModifier(it) => it.into(),
            AnyJsPropertyModifier::JsStaticModifier(it) => it.into(),
            AnyJsPropertyModifier::TsAccessibilityModifier(it) => it.into(),
            AnyJsPropertyModifier::TsOverrideModifier(it) => it.into(),
            AnyJsPropertyModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<AnyJsPropertyModifier> for SyntaxElement {
    fn from(n: AnyJsPropertyModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsExpressionSnipped> for AnyJsRoot {
    fn from(node: JsExpressionSnipped) -> AnyJsRoot { AnyJsRoot::JsExpressionSnipped(node) }
}
impl From<JsModule> for AnyJsRoot {
    fn from(node: JsModule) -> AnyJsRoot { AnyJsRoot::JsModule(node) }
}
impl From<JsScript> for AnyJsRoot {
    fn from(node: JsScript) -> AnyJsRoot { AnyJsRoot::JsScript(node) }
}
impl AstNode for AnyJsRoot {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsExpressionSnipped::KIND_SET
        .union(JsModule::KIND_SET)
        .union(JsScript::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_EXPRESSION_SNIPPED | JS_MODULE | JS_SCRIPT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_EXPRESSION_SNIPPED => AnyJsRoot::JsExpressionSnipped(JsExpressionSnipped { syntax }),
            JS_MODULE => AnyJsRoot::JsModule(JsModule { syntax }),
            JS_SCRIPT => AnyJsRoot::JsScript(JsScript { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsRoot::JsExpressionSnipped(it) => &it.syntax,
            AnyJsRoot::JsModule(it) => &it.syntax,
            AnyJsRoot::JsScript(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsRoot::JsExpressionSnipped(it) => it.syntax,
            AnyJsRoot::JsModule(it) => it.syntax,
            AnyJsRoot::JsScript(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsRoot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsRoot::JsExpressionSnipped(it) => std::fmt::Debug::fmt(it, f),
            AnyJsRoot::JsModule(it) => std::fmt::Debug::fmt(it, f),
            AnyJsRoot::JsScript(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsRoot> for SyntaxNode {
    fn from(n: AnyJsRoot) -> SyntaxNode {
        match n {
            AnyJsRoot::JsExpressionSnipped(it) => it.into(),
            AnyJsRoot::JsModule(it) => it.into(),
            AnyJsRoot::JsScript(it) => it.into(),
        }
    }
}
impl From<AnyJsRoot> for SyntaxElement {
    fn from(n: AnyJsRoot) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBlockStatement> for AnyJsStatement {
    fn from(node: JsBlockStatement) -> AnyJsStatement { AnyJsStatement::JsBlockStatement(node) }
}
impl From<JsBogusStatement> for AnyJsStatement {
    fn from(node: JsBogusStatement) -> AnyJsStatement { AnyJsStatement::JsBogusStatement(node) }
}
impl From<JsBreakStatement> for AnyJsStatement {
    fn from(node: JsBreakStatement) -> AnyJsStatement { AnyJsStatement::JsBreakStatement(node) }
}
impl From<JsClassDeclaration> for AnyJsStatement {
    fn from(node: JsClassDeclaration) -> AnyJsStatement { AnyJsStatement::JsClassDeclaration(node) }
}
impl From<JsContinueStatement> for AnyJsStatement {
    fn from(node: JsContinueStatement) -> AnyJsStatement {
        AnyJsStatement::JsContinueStatement(node)
    }
}
impl From<JsDebuggerStatement> for AnyJsStatement {
    fn from(node: JsDebuggerStatement) -> AnyJsStatement {
        AnyJsStatement::JsDebuggerStatement(node)
    }
}
impl From<JsDoWhileStatement> for AnyJsStatement {
    fn from(node: JsDoWhileStatement) -> AnyJsStatement { AnyJsStatement::JsDoWhileStatement(node) }
}
impl From<JsEmptyStatement> for AnyJsStatement {
    fn from(node: JsEmptyStatement) -> AnyJsStatement { AnyJsStatement::JsEmptyStatement(node) }
}
impl From<JsExpressionStatement> for AnyJsStatement {
    fn from(node: JsExpressionStatement) -> AnyJsStatement {
        AnyJsStatement::JsExpressionStatement(node)
    }
}
impl From<JsForInStatement> for AnyJsStatement {
    fn from(node: JsForInStatement) -> AnyJsStatement { AnyJsStatement::JsForInStatement(node) }
}
impl From<JsForOfStatement> for AnyJsStatement {
    fn from(node: JsForOfStatement) -> AnyJsStatement { AnyJsStatement::JsForOfStatement(node) }
}
impl From<JsForStatement> for AnyJsStatement {
    fn from(node: JsForStatement) -> AnyJsStatement { AnyJsStatement::JsForStatement(node) }
}
impl From<JsFunctionDeclaration> for AnyJsStatement {
    fn from(node: JsFunctionDeclaration) -> AnyJsStatement {
        AnyJsStatement::JsFunctionDeclaration(node)
    }
}
impl From<JsIfStatement> for AnyJsStatement {
    fn from(node: JsIfStatement) -> AnyJsStatement { AnyJsStatement::JsIfStatement(node) }
}
impl From<JsLabeledStatement> for AnyJsStatement {
    fn from(node: JsLabeledStatement) -> AnyJsStatement { AnyJsStatement::JsLabeledStatement(node) }
}
impl From<JsReturnStatement> for AnyJsStatement {
    fn from(node: JsReturnStatement) -> AnyJsStatement { AnyJsStatement::JsReturnStatement(node) }
}
impl From<JsSwitchStatement> for AnyJsStatement {
    fn from(node: JsSwitchStatement) -> AnyJsStatement { AnyJsStatement::JsSwitchStatement(node) }
}
impl From<JsThrowStatement> for AnyJsStatement {
    fn from(node: JsThrowStatement) -> AnyJsStatement { AnyJsStatement::JsThrowStatement(node) }
}
impl From<JsTryFinallyStatement> for AnyJsStatement {
    fn from(node: JsTryFinallyStatement) -> AnyJsStatement {
        AnyJsStatement::JsTryFinallyStatement(node)
    }
}
impl From<JsTryStatement> for AnyJsStatement {
    fn from(node: JsTryStatement) -> AnyJsStatement { AnyJsStatement::JsTryStatement(node) }
}
impl From<JsVariableStatement> for AnyJsStatement {
    fn from(node: JsVariableStatement) -> AnyJsStatement {
        AnyJsStatement::JsVariableStatement(node)
    }
}
impl From<JsWhileStatement> for AnyJsStatement {
    fn from(node: JsWhileStatement) -> AnyJsStatement { AnyJsStatement::JsWhileStatement(node) }
}
impl From<JsWithStatement> for AnyJsStatement {
    fn from(node: JsWithStatement) -> AnyJsStatement { AnyJsStatement::JsWithStatement(node) }
}
impl From<TsDeclareFunctionDeclaration> for AnyJsStatement {
    fn from(node: TsDeclareFunctionDeclaration) -> AnyJsStatement {
        AnyJsStatement::TsDeclareFunctionDeclaration(node)
    }
}
impl From<TsDeclareStatement> for AnyJsStatement {
    fn from(node: TsDeclareStatement) -> AnyJsStatement { AnyJsStatement::TsDeclareStatement(node) }
}
impl From<TsEnumDeclaration> for AnyJsStatement {
    fn from(node: TsEnumDeclaration) -> AnyJsStatement { AnyJsStatement::TsEnumDeclaration(node) }
}
impl From<TsExternalModuleDeclaration> for AnyJsStatement {
    fn from(node: TsExternalModuleDeclaration) -> AnyJsStatement {
        AnyJsStatement::TsExternalModuleDeclaration(node)
    }
}
impl From<TsGlobalDeclaration> for AnyJsStatement {
    fn from(node: TsGlobalDeclaration) -> AnyJsStatement {
        AnyJsStatement::TsGlobalDeclaration(node)
    }
}
impl From<TsImportEqualsDeclaration> for AnyJsStatement {
    fn from(node: TsImportEqualsDeclaration) -> AnyJsStatement {
        AnyJsStatement::TsImportEqualsDeclaration(node)
    }
}
impl From<TsInterfaceDeclaration> for AnyJsStatement {
    fn from(node: TsInterfaceDeclaration) -> AnyJsStatement {
        AnyJsStatement::TsInterfaceDeclaration(node)
    }
}
impl From<TsModuleDeclaration> for AnyJsStatement {
    fn from(node: TsModuleDeclaration) -> AnyJsStatement {
        AnyJsStatement::TsModuleDeclaration(node)
    }
}
impl From<TsTypeAliasDeclaration> for AnyJsStatement {
    fn from(node: TsTypeAliasDeclaration) -> AnyJsStatement {
        AnyJsStatement::TsTypeAliasDeclaration(node)
    }
}
impl AstNode for AnyJsStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBlockStatement::KIND_SET
        .union(JsBogusStatement::KIND_SET)
        .union(JsBreakStatement::KIND_SET)
        .union(JsClassDeclaration::KIND_SET)
        .union(JsContinueStatement::KIND_SET)
        .union(JsDebuggerStatement::KIND_SET)
        .union(JsDoWhileStatement::KIND_SET)
        .union(JsEmptyStatement::KIND_SET)
        .union(JsExpressionStatement::KIND_SET)
        .union(JsForInStatement::KIND_SET)
        .union(JsForOfStatement::KIND_SET)
        .union(JsForStatement::KIND_SET)
        .union(JsFunctionDeclaration::KIND_SET)
        .union(JsIfStatement::KIND_SET)
        .union(JsLabeledStatement::KIND_SET)
        .union(JsReturnStatement::KIND_SET)
        .union(JsSwitchStatement::KIND_SET)
        .union(JsThrowStatement::KIND_SET)
        .union(JsTryFinallyStatement::KIND_SET)
        .union(JsTryStatement::KIND_SET)
        .union(JsVariableStatement::KIND_SET)
        .union(JsWhileStatement::KIND_SET)
        .union(JsWithStatement::KIND_SET)
        .union(TsDeclareFunctionDeclaration::KIND_SET)
        .union(TsDeclareStatement::KIND_SET)
        .union(TsEnumDeclaration::KIND_SET)
        .union(TsExternalModuleDeclaration::KIND_SET)
        .union(TsGlobalDeclaration::KIND_SET)
        .union(TsImportEqualsDeclaration::KIND_SET)
        .union(TsInterfaceDeclaration::KIND_SET)
        .union(TsModuleDeclaration::KIND_SET)
        .union(TsTypeAliasDeclaration::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BLOCK_STATEMENT
                | JS_BOGUS_STATEMENT
                | JS_BREAK_STATEMENT
                | JS_CLASS_DECLARATION
                | JS_CONTINUE_STATEMENT
                | JS_DEBUGGER_STATEMENT
                | JS_DO_WHILE_STATEMENT
                | JS_EMPTY_STATEMENT
                | JS_EXPRESSION_STATEMENT
                | JS_FOR_IN_STATEMENT
                | JS_FOR_OF_STATEMENT
                | JS_FOR_STATEMENT
                | JS_FUNCTION_DECLARATION
                | JS_IF_STATEMENT
                | JS_LABELED_STATEMENT
                | JS_RETURN_STATEMENT
                | JS_SWITCH_STATEMENT
                | JS_THROW_STATEMENT
                | JS_TRY_FINALLY_STATEMENT
                | JS_TRY_STATEMENT
                | JS_VARIABLE_STATEMENT
                | JS_WHILE_STATEMENT
                | JS_WITH_STATEMENT
                | TS_DECLARE_FUNCTION_DECLARATION
                | TS_DECLARE_STATEMENT
                | TS_ENUM_DECLARATION
                | TS_EXTERNAL_MODULE_DECLARATION
                | TS_GLOBAL_DECLARATION
                | TS_IMPORT_EQUALS_DECLARATION
                | TS_INTERFACE_DECLARATION
                | TS_MODULE_DECLARATION
                | TS_TYPE_ALIAS_DECLARATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BLOCK_STATEMENT => AnyJsStatement::JsBlockStatement(JsBlockStatement { syntax }),
            JS_BOGUS_STATEMENT => AnyJsStatement::JsBogusStatement(JsBogusStatement { syntax }),
            JS_BREAK_STATEMENT => AnyJsStatement::JsBreakStatement(JsBreakStatement { syntax }),
            JS_CLASS_DECLARATION => {
                AnyJsStatement::JsClassDeclaration(JsClassDeclaration { syntax })
            }
            JS_CONTINUE_STATEMENT => {
                AnyJsStatement::JsContinueStatement(JsContinueStatement { syntax })
            }
            JS_DEBUGGER_STATEMENT => {
                AnyJsStatement::JsDebuggerStatement(JsDebuggerStatement { syntax })
            }
            JS_DO_WHILE_STATEMENT => {
                AnyJsStatement::JsDoWhileStatement(JsDoWhileStatement { syntax })
            }
            JS_EMPTY_STATEMENT => AnyJsStatement::JsEmptyStatement(JsEmptyStatement { syntax }),
            JS_EXPRESSION_STATEMENT => {
                AnyJsStatement::JsExpressionStatement(JsExpressionStatement { syntax })
            }
            JS_FOR_IN_STATEMENT => AnyJsStatement::JsForInStatement(JsForInStatement { syntax }),
            JS_FOR_OF_STATEMENT => AnyJsStatement::JsForOfStatement(JsForOfStatement { syntax }),
            JS_FOR_STATEMENT => AnyJsStatement::JsForStatement(JsForStatement { syntax }),
            JS_FUNCTION_DECLARATION => {
                AnyJsStatement::JsFunctionDeclaration(JsFunctionDeclaration { syntax })
            }
            JS_IF_STATEMENT => AnyJsStatement::JsIfStatement(JsIfStatement { syntax }),
            JS_LABELED_STATEMENT => {
                AnyJsStatement::JsLabeledStatement(JsLabeledStatement { syntax })
            }
            JS_RETURN_STATEMENT => AnyJsStatement::JsReturnStatement(JsReturnStatement { syntax }),
            JS_SWITCH_STATEMENT => AnyJsStatement::JsSwitchStatement(JsSwitchStatement { syntax }),
            JS_THROW_STATEMENT => AnyJsStatement::JsThrowStatement(JsThrowStatement { syntax }),
            JS_TRY_FINALLY_STATEMENT => {
                AnyJsStatement::JsTryFinallyStatement(JsTryFinallyStatement { syntax })
            }
            JS_TRY_STATEMENT => AnyJsStatement::JsTryStatement(JsTryStatement { syntax }),
            JS_VARIABLE_STATEMENT => {
                AnyJsStatement::JsVariableStatement(JsVariableStatement { syntax })
            }
            JS_WHILE_STATEMENT => AnyJsStatement::JsWhileStatement(JsWhileStatement { syntax }),
            JS_WITH_STATEMENT => AnyJsStatement::JsWithStatement(JsWithStatement { syntax }),
            TS_DECLARE_FUNCTION_DECLARATION => {
                AnyJsStatement::TsDeclareFunctionDeclaration(TsDeclareFunctionDeclaration {
                    syntax,
                })
            }
            TS_DECLARE_STATEMENT => {
                AnyJsStatement::TsDeclareStatement(TsDeclareStatement { syntax })
            }
            TS_ENUM_DECLARATION => AnyJsStatement::TsEnumDeclaration(TsEnumDeclaration { syntax }),
            TS_EXTERNAL_MODULE_DECLARATION => {
                AnyJsStatement::TsExternalModuleDeclaration(TsExternalModuleDeclaration { syntax })
            }
            TS_GLOBAL_DECLARATION => {
                AnyJsStatement::TsGlobalDeclaration(TsGlobalDeclaration { syntax })
            }
            TS_IMPORT_EQUALS_DECLARATION => {
                AnyJsStatement::TsImportEqualsDeclaration(TsImportEqualsDeclaration { syntax })
            }
            TS_INTERFACE_DECLARATION => {
                AnyJsStatement::TsInterfaceDeclaration(TsInterfaceDeclaration { syntax })
            }
            TS_MODULE_DECLARATION => {
                AnyJsStatement::TsModuleDeclaration(TsModuleDeclaration { syntax })
            }
            TS_TYPE_ALIAS_DECLARATION => {
                AnyJsStatement::TsTypeAliasDeclaration(TsTypeAliasDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsStatement::JsBlockStatement(it) => &it.syntax,
            AnyJsStatement::JsBogusStatement(it) => &it.syntax,
            AnyJsStatement::JsBreakStatement(it) => &it.syntax,
            AnyJsStatement::JsClassDeclaration(it) => &it.syntax,
            AnyJsStatement::JsContinueStatement(it) => &it.syntax,
            AnyJsStatement::JsDebuggerStatement(it) => &it.syntax,
            AnyJsStatement::JsDoWhileStatement(it) => &it.syntax,
            AnyJsStatement::JsEmptyStatement(it) => &it.syntax,
            AnyJsStatement::JsExpressionStatement(it) => &it.syntax,
            AnyJsStatement::JsForInStatement(it) => &it.syntax,
            AnyJsStatement::JsForOfStatement(it) => &it.syntax,
            AnyJsStatement::JsForStatement(it) => &it.syntax,
            AnyJsStatement::JsFunctionDeclaration(it) => &it.syntax,
            AnyJsStatement::JsIfStatement(it) => &it.syntax,
            AnyJsStatement::JsLabeledStatement(it) => &it.syntax,
            AnyJsStatement::JsReturnStatement(it) => &it.syntax,
            AnyJsStatement::JsSwitchStatement(it) => &it.syntax,
            AnyJsStatement::JsThrowStatement(it) => &it.syntax,
            AnyJsStatement::JsTryFinallyStatement(it) => &it.syntax,
            AnyJsStatement::JsTryStatement(it) => &it.syntax,
            AnyJsStatement::JsVariableStatement(it) => &it.syntax,
            AnyJsStatement::JsWhileStatement(it) => &it.syntax,
            AnyJsStatement::JsWithStatement(it) => &it.syntax,
            AnyJsStatement::TsDeclareFunctionDeclaration(it) => &it.syntax,
            AnyJsStatement::TsDeclareStatement(it) => &it.syntax,
            AnyJsStatement::TsEnumDeclaration(it) => &it.syntax,
            AnyJsStatement::TsExternalModuleDeclaration(it) => &it.syntax,
            AnyJsStatement::TsGlobalDeclaration(it) => &it.syntax,
            AnyJsStatement::TsImportEqualsDeclaration(it) => &it.syntax,
            AnyJsStatement::TsInterfaceDeclaration(it) => &it.syntax,
            AnyJsStatement::TsModuleDeclaration(it) => &it.syntax,
            AnyJsStatement::TsTypeAliasDeclaration(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsStatement::JsBlockStatement(it) => it.syntax,
            AnyJsStatement::JsBogusStatement(it) => it.syntax,
            AnyJsStatement::JsBreakStatement(it) => it.syntax,
            AnyJsStatement::JsClassDeclaration(it) => it.syntax,
            AnyJsStatement::JsContinueStatement(it) => it.syntax,
            AnyJsStatement::JsDebuggerStatement(it) => it.syntax,
            AnyJsStatement::JsDoWhileStatement(it) => it.syntax,
            AnyJsStatement::JsEmptyStatement(it) => it.syntax,
            AnyJsStatement::JsExpressionStatement(it) => it.syntax,
            AnyJsStatement::JsForInStatement(it) => it.syntax,
            AnyJsStatement::JsForOfStatement(it) => it.syntax,
            AnyJsStatement::JsForStatement(it) => it.syntax,
            AnyJsStatement::JsFunctionDeclaration(it) => it.syntax,
            AnyJsStatement::JsIfStatement(it) => it.syntax,
            AnyJsStatement::JsLabeledStatement(it) => it.syntax,
            AnyJsStatement::JsReturnStatement(it) => it.syntax,
            AnyJsStatement::JsSwitchStatement(it) => it.syntax,
            AnyJsStatement::JsThrowStatement(it) => it.syntax,
            AnyJsStatement::JsTryFinallyStatement(it) => it.syntax,
            AnyJsStatement::JsTryStatement(it) => it.syntax,
            AnyJsStatement::JsVariableStatement(it) => it.syntax,
            AnyJsStatement::JsWhileStatement(it) => it.syntax,
            AnyJsStatement::JsWithStatement(it) => it.syntax,
            AnyJsStatement::TsDeclareFunctionDeclaration(it) => it.syntax,
            AnyJsStatement::TsDeclareStatement(it) => it.syntax,
            AnyJsStatement::TsEnumDeclaration(it) => it.syntax,
            AnyJsStatement::TsExternalModuleDeclaration(it) => it.syntax,
            AnyJsStatement::TsGlobalDeclaration(it) => it.syntax,
            AnyJsStatement::TsImportEqualsDeclaration(it) => it.syntax,
            AnyJsStatement::TsInterfaceDeclaration(it) => it.syntax,
            AnyJsStatement::TsModuleDeclaration(it) => it.syntax,
            AnyJsStatement::TsTypeAliasDeclaration(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsStatement::JsBlockStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsBogusStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsBreakStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsClassDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsContinueStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsDebuggerStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsDoWhileStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsEmptyStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsExpressionStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsForInStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsForOfStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsForStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsIfStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsLabeledStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsReturnStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsSwitchStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsThrowStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsTryFinallyStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsTryStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsVariableStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsWhileStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::JsWithStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsDeclareFunctionDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsDeclareStatement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsEnumDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsExternalModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsGlobalDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsImportEqualsDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsInterfaceDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsModuleDeclaration(it) => std::fmt::Debug::fmt(it, f),
            AnyJsStatement::TsTypeAliasDeclaration(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsStatement> for SyntaxNode {
    fn from(n: AnyJsStatement) -> SyntaxNode {
        match n {
            AnyJsStatement::JsBlockStatement(it) => it.into(),
            AnyJsStatement::JsBogusStatement(it) => it.into(),
            AnyJsStatement::JsBreakStatement(it) => it.into(),
            AnyJsStatement::JsClassDeclaration(it) => it.into(),
            AnyJsStatement::JsContinueStatement(it) => it.into(),
            AnyJsStatement::JsDebuggerStatement(it) => it.into(),
            AnyJsStatement::JsDoWhileStatement(it) => it.into(),
            AnyJsStatement::JsEmptyStatement(it) => it.into(),
            AnyJsStatement::JsExpressionStatement(it) => it.into(),
            AnyJsStatement::JsForInStatement(it) => it.into(),
            AnyJsStatement::JsForOfStatement(it) => it.into(),
            AnyJsStatement::JsForStatement(it) => it.into(),
            AnyJsStatement::JsFunctionDeclaration(it) => it.into(),
            AnyJsStatement::JsIfStatement(it) => it.into(),
            AnyJsStatement::JsLabeledStatement(it) => it.into(),
            AnyJsStatement::JsReturnStatement(it) => it.into(),
            AnyJsStatement::JsSwitchStatement(it) => it.into(),
            AnyJsStatement::JsThrowStatement(it) => it.into(),
            AnyJsStatement::JsTryFinallyStatement(it) => it.into(),
            AnyJsStatement::JsTryStatement(it) => it.into(),
            AnyJsStatement::JsVariableStatement(it) => it.into(),
            AnyJsStatement::JsWhileStatement(it) => it.into(),
            AnyJsStatement::JsWithStatement(it) => it.into(),
            AnyJsStatement::TsDeclareFunctionDeclaration(it) => it.into(),
            AnyJsStatement::TsDeclareStatement(it) => it.into(),
            AnyJsStatement::TsEnumDeclaration(it) => it.into(),
            AnyJsStatement::TsExternalModuleDeclaration(it) => it.into(),
            AnyJsStatement::TsGlobalDeclaration(it) => it.into(),
            AnyJsStatement::TsImportEqualsDeclaration(it) => it.into(),
            AnyJsStatement::TsInterfaceDeclaration(it) => it.into(),
            AnyJsStatement::TsModuleDeclaration(it) => it.into(),
            AnyJsStatement::TsTypeAliasDeclaration(it) => it.into(),
        }
    }
}
impl From<AnyJsStatement> for SyntaxElement {
    fn from(n: AnyJsStatement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsCaseClause> for AnyJsSwitchClause {
    fn from(node: JsCaseClause) -> AnyJsSwitchClause { AnyJsSwitchClause::JsCaseClause(node) }
}
impl From<JsDefaultClause> for AnyJsSwitchClause {
    fn from(node: JsDefaultClause) -> AnyJsSwitchClause { AnyJsSwitchClause::JsDefaultClause(node) }
}
impl AstNode for AnyJsSwitchClause {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsCaseClause::KIND_SET.union(JsDefaultClause::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JS_CASE_CLAUSE | JS_DEFAULT_CLAUSE) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_CASE_CLAUSE => AnyJsSwitchClause::JsCaseClause(JsCaseClause { syntax }),
            JS_DEFAULT_CLAUSE => AnyJsSwitchClause::JsDefaultClause(JsDefaultClause { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsSwitchClause::JsCaseClause(it) => &it.syntax,
            AnyJsSwitchClause::JsDefaultClause(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsSwitchClause::JsCaseClause(it) => it.syntax,
            AnyJsSwitchClause::JsDefaultClause(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsSwitchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsSwitchClause::JsCaseClause(it) => std::fmt::Debug::fmt(it, f),
            AnyJsSwitchClause::JsDefaultClause(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsSwitchClause> for SyntaxNode {
    fn from(n: AnyJsSwitchClause) -> SyntaxNode {
        match n {
            AnyJsSwitchClause::JsCaseClause(it) => it.into(),
            AnyJsSwitchClause::JsDefaultClause(it) => it.into(),
        }
    }
}
impl From<AnyJsSwitchClause> for SyntaxElement {
    fn from(n: AnyJsSwitchClause) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsTemplateChunkElement> for AnyJsTemplateElement {
    fn from(node: JsTemplateChunkElement) -> AnyJsTemplateElement {
        AnyJsTemplateElement::JsTemplateChunkElement(node)
    }
}
impl From<JsTemplateElement> for AnyJsTemplateElement {
    fn from(node: JsTemplateElement) -> AnyJsTemplateElement {
        AnyJsTemplateElement::JsTemplateElement(node)
    }
}
impl AstNode for AnyJsTemplateElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsTemplateChunkElement::KIND_SET.union(JsTemplateElement::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_TEMPLATE_CHUNK_ELEMENT | JS_TEMPLATE_ELEMENT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_TEMPLATE_CHUNK_ELEMENT => {
                AnyJsTemplateElement::JsTemplateChunkElement(JsTemplateChunkElement { syntax })
            }
            JS_TEMPLATE_ELEMENT => {
                AnyJsTemplateElement::JsTemplateElement(JsTemplateElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsTemplateElement::JsTemplateChunkElement(it) => &it.syntax,
            AnyJsTemplateElement::JsTemplateElement(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsTemplateElement::JsTemplateChunkElement(it) => it.syntax,
            AnyJsTemplateElement::JsTemplateElement(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsTemplateElement::JsTemplateChunkElement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsTemplateElement::JsTemplateElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsTemplateElement> for SyntaxNode {
    fn from(n: AnyJsTemplateElement) -> SyntaxNode {
        match n {
            AnyJsTemplateElement::JsTemplateChunkElement(it) => it.into(),
            AnyJsTemplateElement::JsTemplateElement(it) => it.into(),
        }
    }
}
impl From<AnyJsTemplateElement> for SyntaxElement {
    fn from(n: AnyJsTemplateElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxAttribute> for AnyJsxAttribute {
    fn from(node: JsxAttribute) -> AnyJsxAttribute { AnyJsxAttribute::JsxAttribute(node) }
}
impl From<JsxSpreadAttribute> for AnyJsxAttribute {
    fn from(node: JsxSpreadAttribute) -> AnyJsxAttribute {
        AnyJsxAttribute::JsxSpreadAttribute(node)
    }
}
impl AstNode for AnyJsxAttribute {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsxAttribute::KIND_SET.union(JsxSpreadAttribute::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JSX_ATTRIBUTE | JSX_SPREAD_ATTRIBUTE) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ATTRIBUTE => AnyJsxAttribute::JsxAttribute(JsxAttribute { syntax }),
            JSX_SPREAD_ATTRIBUTE => {
                AnyJsxAttribute::JsxSpreadAttribute(JsxSpreadAttribute { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsxAttribute::JsxAttribute(it) => &it.syntax,
            AnyJsxAttribute::JsxSpreadAttribute(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsxAttribute::JsxAttribute(it) => it.syntax,
            AnyJsxAttribute::JsxSpreadAttribute(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsxAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsxAttribute::JsxAttribute(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxAttribute::JsxSpreadAttribute(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsxAttribute> for SyntaxNode {
    fn from(n: AnyJsxAttribute) -> SyntaxNode {
        match n {
            AnyJsxAttribute::JsxAttribute(it) => it.into(),
            AnyJsxAttribute::JsxSpreadAttribute(it) => it.into(),
        }
    }
}
impl From<AnyJsxAttribute> for SyntaxElement {
    fn from(n: AnyJsxAttribute) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxName> for AnyJsxAttributeName {
    fn from(node: JsxName) -> AnyJsxAttributeName { AnyJsxAttributeName::JsxName(node) }
}
impl From<JsxNamespaceName> for AnyJsxAttributeName {
    fn from(node: JsxNamespaceName) -> AnyJsxAttributeName {
        AnyJsxAttributeName::JsxNamespaceName(node)
    }
}
impl AstNode for AnyJsxAttributeName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsxName::KIND_SET.union(JsxNamespaceName::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JSX_NAME | JSX_NAMESPACE_NAME) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_NAME => AnyJsxAttributeName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => {
                AnyJsxAttributeName::JsxNamespaceName(JsxNamespaceName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsxAttributeName::JsxName(it) => &it.syntax,
            AnyJsxAttributeName::JsxNamespaceName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsxAttributeName::JsxName(it) => it.syntax,
            AnyJsxAttributeName::JsxNamespaceName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsxAttributeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsxAttributeName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxAttributeName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsxAttributeName> for SyntaxNode {
    fn from(n: AnyJsxAttributeName) -> SyntaxNode {
        match n {
            AnyJsxAttributeName::JsxName(it) => it.into(),
            AnyJsxAttributeName::JsxNamespaceName(it) => it.into(),
        }
    }
}
impl From<AnyJsxAttributeName> for SyntaxElement {
    fn from(n: AnyJsxAttributeName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxExpressionAttributeValue> for AnyJsxAttributeValue {
    fn from(node: JsxExpressionAttributeValue) -> AnyJsxAttributeValue {
        AnyJsxAttributeValue::JsxExpressionAttributeValue(node)
    }
}
impl From<JsxString> for AnyJsxAttributeValue {
    fn from(node: JsxString) -> AnyJsxAttributeValue { AnyJsxAttributeValue::JsxString(node) }
}
impl AstNode for AnyJsxAttributeValue {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyJsxTag::KIND_SET
        .union(JsxExpressionAttributeValue::KIND_SET)
        .union(JsxString::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            JSX_EXPRESSION_ATTRIBUTE_VALUE | JSX_STRING => true,
            k if AnyJsxTag::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_EXPRESSION_ATTRIBUTE_VALUE => {
                AnyJsxAttributeValue::JsxExpressionAttributeValue(JsxExpressionAttributeValue {
                    syntax,
                })
            }
            JSX_STRING => AnyJsxAttributeValue::JsxString(JsxString { syntax }),
            _ => {
                if let Some(any_jsx_tag) = AnyJsxTag::cast(syntax) {
                    return Some(AnyJsxAttributeValue::AnyJsxTag(any_jsx_tag));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsxAttributeValue::JsxExpressionAttributeValue(it) => &it.syntax,
            AnyJsxAttributeValue::JsxString(it) => &it.syntax,
            AnyJsxAttributeValue::AnyJsxTag(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsxAttributeValue::JsxExpressionAttributeValue(it) => it.syntax,
            AnyJsxAttributeValue::JsxString(it) => it.syntax,
            AnyJsxAttributeValue::AnyJsxTag(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyJsxAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsxAttributeValue::AnyJsxTag(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxAttributeValue::JsxExpressionAttributeValue(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxAttributeValue::JsxString(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsxAttributeValue> for SyntaxNode {
    fn from(n: AnyJsxAttributeValue) -> SyntaxNode {
        match n {
            AnyJsxAttributeValue::AnyJsxTag(it) => it.into(),
            AnyJsxAttributeValue::JsxExpressionAttributeValue(it) => it.into(),
            AnyJsxAttributeValue::JsxString(it) => it.into(),
        }
    }
}
impl From<AnyJsxAttributeValue> for SyntaxElement {
    fn from(n: AnyJsxAttributeValue) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxElement> for AnyJsxChild {
    fn from(node: JsxElement) -> AnyJsxChild { AnyJsxChild::JsxElement(node) }
}
impl From<JsxExpressionChild> for AnyJsxChild {
    fn from(node: JsxExpressionChild) -> AnyJsxChild { AnyJsxChild::JsxExpressionChild(node) }
}
impl From<JsxFragment> for AnyJsxChild {
    fn from(node: JsxFragment) -> AnyJsxChild { AnyJsxChild::JsxFragment(node) }
}
impl From<JsxSelfClosingElement> for AnyJsxChild {
    fn from(node: JsxSelfClosingElement) -> AnyJsxChild { AnyJsxChild::JsxSelfClosingElement(node) }
}
impl From<JsxSpreadChild> for AnyJsxChild {
    fn from(node: JsxSpreadChild) -> AnyJsxChild { AnyJsxChild::JsxSpreadChild(node) }
}
impl From<JsxText> for AnyJsxChild {
    fn from(node: JsxText) -> AnyJsxChild { AnyJsxChild::JsxText(node) }
}
impl AstNode for AnyJsxChild {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsxElement::KIND_SET
        .union(JsxExpressionChild::KIND_SET)
        .union(JsxFragment::KIND_SET)
        .union(JsxSelfClosingElement::KIND_SET)
        .union(JsxSpreadChild::KIND_SET)
        .union(JsxText::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JSX_ELEMENT
                | JSX_EXPRESSION_CHILD
                | JSX_FRAGMENT
                | JSX_SELF_CLOSING_ELEMENT
                | JSX_SPREAD_CHILD
                | JSX_TEXT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ELEMENT => AnyJsxChild::JsxElement(JsxElement { syntax }),
            JSX_EXPRESSION_CHILD => AnyJsxChild::JsxExpressionChild(JsxExpressionChild { syntax }),
            JSX_FRAGMENT => AnyJsxChild::JsxFragment(JsxFragment { syntax }),
            JSX_SELF_CLOSING_ELEMENT => {
                AnyJsxChild::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
            }
            JSX_SPREAD_CHILD => AnyJsxChild::JsxSpreadChild(JsxSpreadChild { syntax }),
            JSX_TEXT => AnyJsxChild::JsxText(JsxText { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsxChild::JsxElement(it) => &it.syntax,
            AnyJsxChild::JsxExpressionChild(it) => &it.syntax,
            AnyJsxChild::JsxFragment(it) => &it.syntax,
            AnyJsxChild::JsxSelfClosingElement(it) => &it.syntax,
            AnyJsxChild::JsxSpreadChild(it) => &it.syntax,
            AnyJsxChild::JsxText(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsxChild::JsxElement(it) => it.syntax,
            AnyJsxChild::JsxExpressionChild(it) => it.syntax,
            AnyJsxChild::JsxFragment(it) => it.syntax,
            AnyJsxChild::JsxSelfClosingElement(it) => it.syntax,
            AnyJsxChild::JsxSpreadChild(it) => it.syntax,
            AnyJsxChild::JsxText(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsxChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsxChild::JsxElement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxChild::JsxExpressionChild(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxChild::JsxFragment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxChild::JsxSelfClosingElement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxChild::JsxSpreadChild(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxChild::JsxText(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsxChild> for SyntaxNode {
    fn from(n: AnyJsxChild) -> SyntaxNode {
        match n {
            AnyJsxChild::JsxElement(it) => it.into(),
            AnyJsxChild::JsxExpressionChild(it) => it.into(),
            AnyJsxChild::JsxFragment(it) => it.into(),
            AnyJsxChild::JsxSelfClosingElement(it) => it.into(),
            AnyJsxChild::JsxSpreadChild(it) => it.into(),
            AnyJsxChild::JsxText(it) => it.into(),
        }
    }
}
impl From<AnyJsxChild> for SyntaxElement {
    fn from(n: AnyJsxChild) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxMemberName> for AnyJsxElementName {
    fn from(node: JsxMemberName) -> AnyJsxElementName { AnyJsxElementName::JsxMemberName(node) }
}
impl From<JsxName> for AnyJsxElementName {
    fn from(node: JsxName) -> AnyJsxElementName { AnyJsxElementName::JsxName(node) }
}
impl From<JsxNamespaceName> for AnyJsxElementName {
    fn from(node: JsxNamespaceName) -> AnyJsxElementName {
        AnyJsxElementName::JsxNamespaceName(node)
    }
}
impl From<JsxReferenceIdentifier> for AnyJsxElementName {
    fn from(node: JsxReferenceIdentifier) -> AnyJsxElementName {
        AnyJsxElementName::JsxReferenceIdentifier(node)
    }
}
impl AstNode for AnyJsxElementName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsxMemberName::KIND_SET
        .union(JsxName::KIND_SET)
        .union(JsxNamespaceName::KIND_SET)
        .union(JsxReferenceIdentifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JSX_MEMBER_NAME | JSX_NAME | JSX_NAMESPACE_NAME | JSX_REFERENCE_IDENTIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_MEMBER_NAME => AnyJsxElementName::JsxMemberName(JsxMemberName { syntax }),
            JSX_NAME => AnyJsxElementName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => AnyJsxElementName::JsxNamespaceName(JsxNamespaceName { syntax }),
            JSX_REFERENCE_IDENTIFIER => {
                AnyJsxElementName::JsxReferenceIdentifier(JsxReferenceIdentifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsxElementName::JsxMemberName(it) => &it.syntax,
            AnyJsxElementName::JsxName(it) => &it.syntax,
            AnyJsxElementName::JsxNamespaceName(it) => &it.syntax,
            AnyJsxElementName::JsxReferenceIdentifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsxElementName::JsxMemberName(it) => it.syntax,
            AnyJsxElementName::JsxName(it) => it.syntax,
            AnyJsxElementName::JsxNamespaceName(it) => it.syntax,
            AnyJsxElementName::JsxReferenceIdentifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsxElementName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsxElementName::JsxMemberName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxElementName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxElementName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxElementName::JsxReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsxElementName> for SyntaxNode {
    fn from(n: AnyJsxElementName) -> SyntaxNode {
        match n {
            AnyJsxElementName::JsxMemberName(it) => it.into(),
            AnyJsxElementName::JsxName(it) => it.into(),
            AnyJsxElementName::JsxNamespaceName(it) => it.into(),
            AnyJsxElementName::JsxReferenceIdentifier(it) => it.into(),
        }
    }
}
impl From<AnyJsxElementName> for SyntaxElement {
    fn from(n: AnyJsxElementName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxName> for AnyJsxName {
    fn from(node: JsxName) -> AnyJsxName { AnyJsxName::JsxName(node) }
}
impl From<JsxNamespaceName> for AnyJsxName {
    fn from(node: JsxNamespaceName) -> AnyJsxName { AnyJsxName::JsxNamespaceName(node) }
}
impl AstNode for AnyJsxName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsxName::KIND_SET.union(JsxNamespaceName::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JSX_NAME | JSX_NAMESPACE_NAME) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_NAME => AnyJsxName::JsxName(JsxName { syntax }),
            JSX_NAMESPACE_NAME => AnyJsxName::JsxNamespaceName(JsxNamespaceName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsxName::JsxName(it) => &it.syntax,
            AnyJsxName::JsxNamespaceName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsxName::JsxName(it) => it.syntax,
            AnyJsxName::JsxNamespaceName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsxName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsxName::JsxName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsxName> for SyntaxNode {
    fn from(n: AnyJsxName) -> SyntaxNode {
        match n {
            AnyJsxName::JsxName(it) => it.into(),
            AnyJsxName::JsxNamespaceName(it) => it.into(),
        }
    }
}
impl From<AnyJsxName> for SyntaxElement {
    fn from(n: AnyJsxName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxMemberName> for AnyJsxObjectName {
    fn from(node: JsxMemberName) -> AnyJsxObjectName { AnyJsxObjectName::JsxMemberName(node) }
}
impl From<JsxNamespaceName> for AnyJsxObjectName {
    fn from(node: JsxNamespaceName) -> AnyJsxObjectName { AnyJsxObjectName::JsxNamespaceName(node) }
}
impl From<JsxReferenceIdentifier> for AnyJsxObjectName {
    fn from(node: JsxReferenceIdentifier) -> AnyJsxObjectName {
        AnyJsxObjectName::JsxReferenceIdentifier(node)
    }
}
impl AstNode for AnyJsxObjectName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsxMemberName::KIND_SET
        .union(JsxNamespaceName::KIND_SET)
        .union(JsxReferenceIdentifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JSX_MEMBER_NAME | JSX_NAMESPACE_NAME | JSX_REFERENCE_IDENTIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_MEMBER_NAME => AnyJsxObjectName::JsxMemberName(JsxMemberName { syntax }),
            JSX_NAMESPACE_NAME => AnyJsxObjectName::JsxNamespaceName(JsxNamespaceName { syntax }),
            JSX_REFERENCE_IDENTIFIER => {
                AnyJsxObjectName::JsxReferenceIdentifier(JsxReferenceIdentifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsxObjectName::JsxMemberName(it) => &it.syntax,
            AnyJsxObjectName::JsxNamespaceName(it) => &it.syntax,
            AnyJsxObjectName::JsxReferenceIdentifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsxObjectName::JsxMemberName(it) => it.syntax,
            AnyJsxObjectName::JsxNamespaceName(it) => it.syntax,
            AnyJsxObjectName::JsxReferenceIdentifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsxObjectName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsxObjectName::JsxMemberName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxObjectName::JsxNamespaceName(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxObjectName::JsxReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsxObjectName> for SyntaxNode {
    fn from(n: AnyJsxObjectName) -> SyntaxNode {
        match n {
            AnyJsxObjectName::JsxMemberName(it) => it.into(),
            AnyJsxObjectName::JsxNamespaceName(it) => it.into(),
            AnyJsxObjectName::JsxReferenceIdentifier(it) => it.into(),
        }
    }
}
impl From<AnyJsxObjectName> for SyntaxElement {
    fn from(n: AnyJsxObjectName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsxElement> for AnyJsxTag {
    fn from(node: JsxElement) -> AnyJsxTag { AnyJsxTag::JsxElement(node) }
}
impl From<JsxFragment> for AnyJsxTag {
    fn from(node: JsxFragment) -> AnyJsxTag { AnyJsxTag::JsxFragment(node) }
}
impl From<JsxSelfClosingElement> for AnyJsxTag {
    fn from(node: JsxSelfClosingElement) -> AnyJsxTag { AnyJsxTag::JsxSelfClosingElement(node) }
}
impl AstNode for AnyJsxTag {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsxElement::KIND_SET
        .union(JsxFragment::KIND_SET)
        .union(JsxSelfClosingElement::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JSX_ELEMENT | JSX_FRAGMENT | JSX_SELF_CLOSING_ELEMENT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JSX_ELEMENT => AnyJsxTag::JsxElement(JsxElement { syntax }),
            JSX_FRAGMENT => AnyJsxTag::JsxFragment(JsxFragment { syntax }),
            JSX_SELF_CLOSING_ELEMENT => {
                AnyJsxTag::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyJsxTag::JsxElement(it) => &it.syntax,
            AnyJsxTag::JsxFragment(it) => &it.syntax,
            AnyJsxTag::JsxSelfClosingElement(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyJsxTag::JsxElement(it) => it.syntax,
            AnyJsxTag::JsxFragment(it) => it.syntax,
            AnyJsxTag::JsxSelfClosingElement(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyJsxTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyJsxTag::JsxElement(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxTag::JsxFragment(it) => std::fmt::Debug::fmt(it, f),
            AnyJsxTag::JsxSelfClosingElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyJsxTag> for SyntaxNode {
    fn from(n: AnyJsxTag) -> SyntaxNode {
        match n {
            AnyJsxTag::JsxElement(it) => it.into(),
            AnyJsxTag::JsxFragment(it) => it.into(),
            AnyJsxTag::JsxSelfClosingElement(it) => it.into(),
        }
    }
}
impl From<AnyJsxTag> for SyntaxElement {
    fn from(n: AnyJsxTag) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsEmptyExternalModuleDeclarationBody> for AnyTsExternalModuleDeclarationBody {
    fn from(node: TsEmptyExternalModuleDeclarationBody) -> AnyTsExternalModuleDeclarationBody {
        AnyTsExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(node)
    }
}
impl From<TsModuleBlock> for AnyTsExternalModuleDeclarationBody {
    fn from(node: TsModuleBlock) -> AnyTsExternalModuleDeclarationBody {
        AnyTsExternalModuleDeclarationBody::TsModuleBlock(node)
    }
}
impl AstNode for AnyTsExternalModuleDeclarationBody {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        TsEmptyExternalModuleDeclarationBody::KIND_SET.union(TsModuleBlock::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY | TS_MODULE_BLOCK
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY => {
                AnyTsExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(
                    TsEmptyExternalModuleDeclarationBody { syntax },
                )
            }
            TS_MODULE_BLOCK => {
                AnyTsExternalModuleDeclarationBody::TsModuleBlock(TsModuleBlock { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                &it.syntax
            }
            AnyTsExternalModuleDeclarationBody::TsModuleBlock(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                it.syntax
            }
            AnyTsExternalModuleDeclarationBody::TsModuleBlock(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsExternalModuleDeclarationBody::TsModuleBlock(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsExternalModuleDeclarationBody> for SyntaxNode {
    fn from(n: AnyTsExternalModuleDeclarationBody) -> SyntaxNode {
        match n {
            AnyTsExternalModuleDeclarationBody::TsEmptyExternalModuleDeclarationBody(it) => {
                it.into()
            }
            AnyTsExternalModuleDeclarationBody::TsModuleBlock(it) => it.into(),
        }
    }
}
impl From<AnyTsExternalModuleDeclarationBody> for SyntaxElement {
    fn from(n: AnyTsExternalModuleDeclarationBody) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for AnyTsIndexSignatureModifier {
    fn from(node: JsStaticModifier) -> AnyTsIndexSignatureModifier {
        AnyTsIndexSignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsReadonlyModifier> for AnyTsIndexSignatureModifier {
    fn from(node: TsReadonlyModifier) -> AnyTsIndexSignatureModifier {
        AnyTsIndexSignatureModifier::TsReadonlyModifier(node)
    }
}
impl AstNode for AnyTsIndexSignatureModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsStaticModifier::KIND_SET.union(TsReadonlyModifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_STATIC_MODIFIER | TS_READONLY_MODIFIER)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                AnyTsIndexSignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                AnyTsIndexSignatureModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsIndexSignatureModifier::JsStaticModifier(it) => &it.syntax,
            AnyTsIndexSignatureModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsIndexSignatureModifier::JsStaticModifier(it) => it.syntax,
            AnyTsIndexSignatureModifier::TsReadonlyModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsIndexSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsIndexSignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsIndexSignatureModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsIndexSignatureModifier> for SyntaxNode {
    fn from(n: AnyTsIndexSignatureModifier) -> SyntaxNode {
        match n {
            AnyTsIndexSignatureModifier::JsStaticModifier(it) => it.into(),
            AnyTsIndexSignatureModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<AnyTsIndexSignatureModifier> for SyntaxElement {
    fn from(n: AnyTsIndexSignatureModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsStaticModifier> for AnyTsMethodSignatureModifier {
    fn from(node: JsStaticModifier) -> AnyTsMethodSignatureModifier {
        AnyTsMethodSignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsAbstractModifier> for AnyTsMethodSignatureModifier {
    fn from(node: TsAbstractModifier) -> AnyTsMethodSignatureModifier {
        AnyTsMethodSignatureModifier::TsAbstractModifier(node)
    }
}
impl From<TsAccessibilityModifier> for AnyTsMethodSignatureModifier {
    fn from(node: TsAccessibilityModifier) -> AnyTsMethodSignatureModifier {
        AnyTsMethodSignatureModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for AnyTsMethodSignatureModifier {
    fn from(node: TsOverrideModifier) -> AnyTsMethodSignatureModifier {
        AnyTsMethodSignatureModifier::TsOverrideModifier(node)
    }
}
impl AstNode for AnyTsMethodSignatureModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsStaticModifier::KIND_SET
        .union(TsAbstractModifier::KIND_SET)
        .union(TsAccessibilityModifier::KIND_SET)
        .union(TsOverrideModifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_STATIC_MODIFIER
                | TS_ABSTRACT_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_OVERRIDE_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_STATIC_MODIFIER => {
                AnyTsMethodSignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ABSTRACT_MODIFIER => {
                AnyTsMethodSignatureModifier::TsAbstractModifier(TsAbstractModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                AnyTsMethodSignatureModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_OVERRIDE_MODIFIER => {
                AnyTsMethodSignatureModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsMethodSignatureModifier::JsStaticModifier(it) => &it.syntax,
            AnyTsMethodSignatureModifier::TsAbstractModifier(it) => &it.syntax,
            AnyTsMethodSignatureModifier::TsAccessibilityModifier(it) => &it.syntax,
            AnyTsMethodSignatureModifier::TsOverrideModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsMethodSignatureModifier::JsStaticModifier(it) => it.syntax,
            AnyTsMethodSignatureModifier::TsAbstractModifier(it) => it.syntax,
            AnyTsMethodSignatureModifier::TsAccessibilityModifier(it) => it.syntax,
            AnyTsMethodSignatureModifier::TsOverrideModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsMethodSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsMethodSignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsMethodSignatureModifier::TsAbstractModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsMethodSignatureModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsMethodSignatureModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsMethodSignatureModifier> for SyntaxNode {
    fn from(n: AnyTsMethodSignatureModifier) -> SyntaxNode {
        match n {
            AnyTsMethodSignatureModifier::JsStaticModifier(it) => it.into(),
            AnyTsMethodSignatureModifier::TsAbstractModifier(it) => it.into(),
            AnyTsMethodSignatureModifier::TsAccessibilityModifier(it) => it.into(),
            AnyTsMethodSignatureModifier::TsOverrideModifier(it) => it.into(),
        }
    }
}
impl From<AnyTsMethodSignatureModifier> for SyntaxElement {
    fn from(n: AnyTsMethodSignatureModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsIdentifierBinding> for AnyTsModuleName {
    fn from(node: TsIdentifierBinding) -> AnyTsModuleName {
        AnyTsModuleName::TsIdentifierBinding(node)
    }
}
impl From<TsQualifiedModuleName> for AnyTsModuleName {
    fn from(node: TsQualifiedModuleName) -> AnyTsModuleName {
        AnyTsModuleName::TsQualifiedModuleName(node)
    }
}
impl AstNode for AnyTsModuleName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        TsIdentifierBinding::KIND_SET.union(TsQualifiedModuleName::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_IDENTIFIER_BINDING | TS_QUALIFIED_MODULE_NAME)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_IDENTIFIER_BINDING => {
                AnyTsModuleName::TsIdentifierBinding(TsIdentifierBinding { syntax })
            }
            TS_QUALIFIED_MODULE_NAME => {
                AnyTsModuleName::TsQualifiedModuleName(TsQualifiedModuleName { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsModuleName::TsIdentifierBinding(it) => &it.syntax,
            AnyTsModuleName::TsQualifiedModuleName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsModuleName::TsIdentifierBinding(it) => it.syntax,
            AnyTsModuleName::TsQualifiedModuleName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsModuleName::TsIdentifierBinding(it) => std::fmt::Debug::fmt(it, f),
            AnyTsModuleName::TsQualifiedModuleName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsModuleName> for SyntaxNode {
    fn from(n: AnyTsModuleName) -> SyntaxNode {
        match n {
            AnyTsModuleName::TsIdentifierBinding(it) => it.into(),
            AnyTsModuleName::TsQualifiedModuleName(it) => it.into(),
        }
    }
}
impl From<AnyTsModuleName> for SyntaxElement {
    fn from(n: AnyTsModuleName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsExternalModuleReference> for AnyTsModuleReference {
    fn from(node: TsExternalModuleReference) -> AnyTsModuleReference {
        AnyTsModuleReference::TsExternalModuleReference(node)
    }
}
impl AstNode for AnyTsModuleReference {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        AnyTsName::KIND_SET.union(TsExternalModuleReference::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TS_EXTERNAL_MODULE_REFERENCE => true,
            k if AnyTsName::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_EXTERNAL_MODULE_REFERENCE => {
                AnyTsModuleReference::TsExternalModuleReference(TsExternalModuleReference {
                    syntax,
                })
            }
            _ => {
                if let Some(any_ts_name) = AnyTsName::cast(syntax) {
                    return Some(AnyTsModuleReference::AnyTsName(any_ts_name));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsModuleReference::TsExternalModuleReference(it) => &it.syntax,
            AnyTsModuleReference::AnyTsName(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsModuleReference::TsExternalModuleReference(it) => it.syntax,
            AnyTsModuleReference::AnyTsName(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyTsModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsModuleReference::AnyTsName(it) => std::fmt::Debug::fmt(it, f),
            AnyTsModuleReference::TsExternalModuleReference(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsModuleReference> for SyntaxNode {
    fn from(n: AnyTsModuleReference) -> SyntaxNode {
        match n {
            AnyTsModuleReference::AnyTsName(it) => it.into(),
            AnyTsModuleReference::TsExternalModuleReference(it) => it.into(),
        }
    }
}
impl From<AnyTsModuleReference> for SyntaxElement {
    fn from(n: AnyTsModuleReference) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsReferenceIdentifier> for AnyTsName {
    fn from(node: JsReferenceIdentifier) -> AnyTsName { AnyTsName::JsReferenceIdentifier(node) }
}
impl From<TsQualifiedName> for AnyTsName {
    fn from(node: TsQualifiedName) -> AnyTsName { AnyTsName::TsQualifiedName(node) }
}
impl AstNode for AnyTsName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsReferenceIdentifier::KIND_SET.union(TsQualifiedName::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, JS_REFERENCE_IDENTIFIER | TS_QUALIFIED_NAME)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REFERENCE_IDENTIFIER => {
                AnyTsName::JsReferenceIdentifier(JsReferenceIdentifier { syntax })
            }
            TS_QUALIFIED_NAME => AnyTsName::TsQualifiedName(TsQualifiedName { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsName::JsReferenceIdentifier(it) => &it.syntax,
            AnyTsName::TsQualifiedName(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsName::JsReferenceIdentifier(it) => it.syntax,
            AnyTsName::TsQualifiedName(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsName::JsReferenceIdentifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsName::TsQualifiedName(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsName> for SyntaxNode {
    fn from(n: AnyTsName) -> SyntaxNode {
        match n {
            AnyTsName::JsReferenceIdentifier(it) => it.into(),
            AnyTsName::TsQualifiedName(it) => it.into(),
        }
    }
}
impl From<AnyTsName> for SyntaxElement {
    fn from(n: AnyTsName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsDefinitePropertyAnnotation> for AnyTsPropertyAnnotation {
    fn from(node: TsDefinitePropertyAnnotation) -> AnyTsPropertyAnnotation {
        AnyTsPropertyAnnotation::TsDefinitePropertyAnnotation(node)
    }
}
impl From<TsOptionalPropertyAnnotation> for AnyTsPropertyAnnotation {
    fn from(node: TsOptionalPropertyAnnotation) -> AnyTsPropertyAnnotation {
        AnyTsPropertyAnnotation::TsOptionalPropertyAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for AnyTsPropertyAnnotation {
    fn from(node: TsTypeAnnotation) -> AnyTsPropertyAnnotation {
        AnyTsPropertyAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode for AnyTsPropertyAnnotation {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = TsDefinitePropertyAnnotation::KIND_SET
        .union(TsOptionalPropertyAnnotation::KIND_SET)
        .union(TsTypeAnnotation::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TS_DEFINITE_PROPERTY_ANNOTATION | TS_OPTIONAL_PROPERTY_ANNOTATION | TS_TYPE_ANNOTATION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_DEFINITE_PROPERTY_ANNOTATION => {
                AnyTsPropertyAnnotation::TsDefinitePropertyAnnotation(
                    TsDefinitePropertyAnnotation { syntax },
                )
            }
            TS_OPTIONAL_PROPERTY_ANNOTATION => {
                AnyTsPropertyAnnotation::TsOptionalPropertyAnnotation(
                    TsOptionalPropertyAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                AnyTsPropertyAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsPropertyAnnotation::TsDefinitePropertyAnnotation(it) => &it.syntax,
            AnyTsPropertyAnnotation::TsOptionalPropertyAnnotation(it) => &it.syntax,
            AnyTsPropertyAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsPropertyAnnotation::TsDefinitePropertyAnnotation(it) => it.syntax,
            AnyTsPropertyAnnotation::TsOptionalPropertyAnnotation(it) => it.syntax,
            AnyTsPropertyAnnotation::TsTypeAnnotation(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsPropertyAnnotation::TsDefinitePropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsPropertyAnnotation::TsOptionalPropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsPropertyAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsPropertyAnnotation> for SyntaxNode {
    fn from(n: AnyTsPropertyAnnotation) -> SyntaxNode {
        match n {
            AnyTsPropertyAnnotation::TsDefinitePropertyAnnotation(it) => it.into(),
            AnyTsPropertyAnnotation::TsOptionalPropertyAnnotation(it) => it.into(),
            AnyTsPropertyAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<AnyTsPropertyAnnotation> for SyntaxElement {
    fn from(n: AnyTsPropertyAnnotation) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAccessibilityModifier> for AnyTsPropertyParameterModifier {
    fn from(node: TsAccessibilityModifier) -> AnyTsPropertyParameterModifier {
        AnyTsPropertyParameterModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsOverrideModifier> for AnyTsPropertyParameterModifier {
    fn from(node: TsOverrideModifier) -> AnyTsPropertyParameterModifier {
        AnyTsPropertyParameterModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for AnyTsPropertyParameterModifier {
    fn from(node: TsReadonlyModifier) -> AnyTsPropertyParameterModifier {
        AnyTsPropertyParameterModifier::TsReadonlyModifier(node)
    }
}
impl AstNode for AnyTsPropertyParameterModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = TsAccessibilityModifier::KIND_SET
        .union(TsOverrideModifier::KIND_SET)
        .union(TsReadonlyModifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TS_ACCESSIBILITY_MODIFIER | TS_OVERRIDE_MODIFIER | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ACCESSIBILITY_MODIFIER => {
                AnyTsPropertyParameterModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_OVERRIDE_MODIFIER => {
                AnyTsPropertyParameterModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                AnyTsPropertyParameterModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsPropertyParameterModifier::TsAccessibilityModifier(it) => &it.syntax,
            AnyTsPropertyParameterModifier::TsOverrideModifier(it) => &it.syntax,
            AnyTsPropertyParameterModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsPropertyParameterModifier::TsAccessibilityModifier(it) => it.syntax,
            AnyTsPropertyParameterModifier::TsOverrideModifier(it) => it.syntax,
            AnyTsPropertyParameterModifier::TsReadonlyModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsPropertyParameterModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsPropertyParameterModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsPropertyParameterModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsPropertyParameterModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsPropertyParameterModifier> for SyntaxNode {
    fn from(n: AnyTsPropertyParameterModifier) -> SyntaxNode {
        match n {
            AnyTsPropertyParameterModifier::TsAccessibilityModifier(it) => it.into(),
            AnyTsPropertyParameterModifier::TsOverrideModifier(it) => it.into(),
            AnyTsPropertyParameterModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<AnyTsPropertyParameterModifier> for SyntaxElement {
    fn from(n: AnyTsPropertyParameterModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsOptionalPropertyAnnotation> for AnyTsPropertySignatureAnnotation {
    fn from(node: TsOptionalPropertyAnnotation) -> AnyTsPropertySignatureAnnotation {
        AnyTsPropertySignatureAnnotation::TsOptionalPropertyAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for AnyTsPropertySignatureAnnotation {
    fn from(node: TsTypeAnnotation) -> AnyTsPropertySignatureAnnotation {
        AnyTsPropertySignatureAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode for AnyTsPropertySignatureAnnotation {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        TsOptionalPropertyAnnotation::KIND_SET.union(TsTypeAnnotation::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_OPTIONAL_PROPERTY_ANNOTATION | TS_TYPE_ANNOTATION)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_OPTIONAL_PROPERTY_ANNOTATION => {
                AnyTsPropertySignatureAnnotation::TsOptionalPropertyAnnotation(
                    TsOptionalPropertyAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                AnyTsPropertySignatureAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => &it.syntax,
            AnyTsPropertySignatureAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => it.syntax,
            AnyTsPropertySignatureAnnotation::TsTypeAnnotation(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsPropertySignatureAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsPropertySignatureAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsPropertySignatureAnnotation> for SyntaxNode {
    fn from(n: AnyTsPropertySignatureAnnotation) -> SyntaxNode {
        match n {
            AnyTsPropertySignatureAnnotation::TsOptionalPropertyAnnotation(it) => it.into(),
            AnyTsPropertySignatureAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<AnyTsPropertySignatureAnnotation> for SyntaxElement {
    fn from(n: AnyTsPropertySignatureAnnotation) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsAccessorModifier> for AnyTsPropertySignatureModifier {
    fn from(node: JsAccessorModifier) -> AnyTsPropertySignatureModifier {
        AnyTsPropertySignatureModifier::JsAccessorModifier(node)
    }
}
impl From<JsStaticModifier> for AnyTsPropertySignatureModifier {
    fn from(node: JsStaticModifier) -> AnyTsPropertySignatureModifier {
        AnyTsPropertySignatureModifier::JsStaticModifier(node)
    }
}
impl From<TsAbstractModifier> for AnyTsPropertySignatureModifier {
    fn from(node: TsAbstractModifier) -> AnyTsPropertySignatureModifier {
        AnyTsPropertySignatureModifier::TsAbstractModifier(node)
    }
}
impl From<TsAccessibilityModifier> for AnyTsPropertySignatureModifier {
    fn from(node: TsAccessibilityModifier) -> AnyTsPropertySignatureModifier {
        AnyTsPropertySignatureModifier::TsAccessibilityModifier(node)
    }
}
impl From<TsDeclareModifier> for AnyTsPropertySignatureModifier {
    fn from(node: TsDeclareModifier) -> AnyTsPropertySignatureModifier {
        AnyTsPropertySignatureModifier::TsDeclareModifier(node)
    }
}
impl From<TsOverrideModifier> for AnyTsPropertySignatureModifier {
    fn from(node: TsOverrideModifier) -> AnyTsPropertySignatureModifier {
        AnyTsPropertySignatureModifier::TsOverrideModifier(node)
    }
}
impl From<TsReadonlyModifier> for AnyTsPropertySignatureModifier {
    fn from(node: TsReadonlyModifier) -> AnyTsPropertySignatureModifier {
        AnyTsPropertySignatureModifier::TsReadonlyModifier(node)
    }
}
impl AstNode for AnyTsPropertySignatureModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsAccessorModifier::KIND_SET
        .union(JsStaticModifier::KIND_SET)
        .union(TsAbstractModifier::KIND_SET)
        .union(TsAccessibilityModifier::KIND_SET)
        .union(TsDeclareModifier::KIND_SET)
        .union(TsOverrideModifier::KIND_SET)
        .union(TsReadonlyModifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_ACCESSOR_MODIFIER
                | JS_STATIC_MODIFIER
                | TS_ABSTRACT_MODIFIER
                | TS_ACCESSIBILITY_MODIFIER
                | TS_DECLARE_MODIFIER
                | TS_OVERRIDE_MODIFIER
                | TS_READONLY_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_ACCESSOR_MODIFIER => {
                AnyTsPropertySignatureModifier::JsAccessorModifier(JsAccessorModifier { syntax })
            }
            JS_STATIC_MODIFIER => {
                AnyTsPropertySignatureModifier::JsStaticModifier(JsStaticModifier { syntax })
            }
            TS_ABSTRACT_MODIFIER => {
                AnyTsPropertySignatureModifier::TsAbstractModifier(TsAbstractModifier { syntax })
            }
            TS_ACCESSIBILITY_MODIFIER => {
                AnyTsPropertySignatureModifier::TsAccessibilityModifier(TsAccessibilityModifier {
                    syntax,
                })
            }
            TS_DECLARE_MODIFIER => {
                AnyTsPropertySignatureModifier::TsDeclareModifier(TsDeclareModifier { syntax })
            }
            TS_OVERRIDE_MODIFIER => {
                AnyTsPropertySignatureModifier::TsOverrideModifier(TsOverrideModifier { syntax })
            }
            TS_READONLY_MODIFIER => {
                AnyTsPropertySignatureModifier::TsReadonlyModifier(TsReadonlyModifier { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsPropertySignatureModifier::JsAccessorModifier(it) => &it.syntax,
            AnyTsPropertySignatureModifier::JsStaticModifier(it) => &it.syntax,
            AnyTsPropertySignatureModifier::TsAbstractModifier(it) => &it.syntax,
            AnyTsPropertySignatureModifier::TsAccessibilityModifier(it) => &it.syntax,
            AnyTsPropertySignatureModifier::TsDeclareModifier(it) => &it.syntax,
            AnyTsPropertySignatureModifier::TsOverrideModifier(it) => &it.syntax,
            AnyTsPropertySignatureModifier::TsReadonlyModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsPropertySignatureModifier::JsAccessorModifier(it) => it.syntax,
            AnyTsPropertySignatureModifier::JsStaticModifier(it) => it.syntax,
            AnyTsPropertySignatureModifier::TsAbstractModifier(it) => it.syntax,
            AnyTsPropertySignatureModifier::TsAccessibilityModifier(it) => it.syntax,
            AnyTsPropertySignatureModifier::TsDeclareModifier(it) => it.syntax,
            AnyTsPropertySignatureModifier::TsOverrideModifier(it) => it.syntax,
            AnyTsPropertySignatureModifier::TsReadonlyModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsPropertySignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsPropertySignatureModifier::JsAccessorModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsPropertySignatureModifier::JsStaticModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsPropertySignatureModifier::TsAbstractModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsPropertySignatureModifier::TsAccessibilityModifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsPropertySignatureModifier::TsDeclareModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsPropertySignatureModifier::TsOverrideModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsPropertySignatureModifier::TsReadonlyModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsPropertySignatureModifier> for SyntaxNode {
    fn from(n: AnyTsPropertySignatureModifier) -> SyntaxNode {
        match n {
            AnyTsPropertySignatureModifier::JsAccessorModifier(it) => it.into(),
            AnyTsPropertySignatureModifier::JsStaticModifier(it) => it.into(),
            AnyTsPropertySignatureModifier::TsAbstractModifier(it) => it.into(),
            AnyTsPropertySignatureModifier::TsAccessibilityModifier(it) => it.into(),
            AnyTsPropertySignatureModifier::TsDeclareModifier(it) => it.into(),
            AnyTsPropertySignatureModifier::TsOverrideModifier(it) => it.into(),
            AnyTsPropertySignatureModifier::TsReadonlyModifier(it) => it.into(),
        }
    }
}
impl From<AnyTsPropertySignatureModifier> for SyntaxElement {
    fn from(n: AnyTsPropertySignatureModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAssertsReturnType> for AnyTsReturnType {
    fn from(node: TsAssertsReturnType) -> AnyTsReturnType {
        AnyTsReturnType::TsAssertsReturnType(node)
    }
}
impl From<TsPredicateReturnType> for AnyTsReturnType {
    fn from(node: TsPredicateReturnType) -> AnyTsReturnType {
        AnyTsReturnType::TsPredicateReturnType(node)
    }
}
impl AstNode for AnyTsReturnType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyTsType::KIND_SET
        .union(TsAssertsReturnType::KIND_SET)
        .union(TsPredicateReturnType::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TS_ASSERTS_RETURN_TYPE | TS_PREDICATE_RETURN_TYPE => true,
            k if AnyTsType::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ASSERTS_RETURN_TYPE => {
                AnyTsReturnType::TsAssertsReturnType(TsAssertsReturnType { syntax })
            }
            TS_PREDICATE_RETURN_TYPE => {
                AnyTsReturnType::TsPredicateReturnType(TsPredicateReturnType { syntax })
            }
            _ => {
                if let Some(any_ts_type) = AnyTsType::cast(syntax) {
                    return Some(AnyTsReturnType::AnyTsType(any_ts_type));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsReturnType::TsAssertsReturnType(it) => &it.syntax,
            AnyTsReturnType::TsPredicateReturnType(it) => &it.syntax,
            AnyTsReturnType::AnyTsType(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsReturnType::TsAssertsReturnType(it) => it.syntax,
            AnyTsReturnType::TsPredicateReturnType(it) => it.syntax,
            AnyTsReturnType::AnyTsType(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyTsReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsReturnType::AnyTsType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsReturnType::TsAssertsReturnType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsReturnType::TsPredicateReturnType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsReturnType> for SyntaxNode {
    fn from(n: AnyTsReturnType) -> SyntaxNode {
        match n {
            AnyTsReturnType::AnyTsType(it) => it.into(),
            AnyTsReturnType::TsAssertsReturnType(it) => it.into(),
            AnyTsReturnType::TsPredicateReturnType(it) => it.into(),
        }
    }
}
impl From<AnyTsReturnType> for SyntaxElement {
    fn from(n: AnyTsReturnType) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsTemplateChunkElement> for AnyTsTemplateElement {
    fn from(node: TsTemplateChunkElement) -> AnyTsTemplateElement {
        AnyTsTemplateElement::TsTemplateChunkElement(node)
    }
}
impl From<TsTemplateElement> for AnyTsTemplateElement {
    fn from(node: TsTemplateElement) -> AnyTsTemplateElement {
        AnyTsTemplateElement::TsTemplateElement(node)
    }
}
impl AstNode for AnyTsTemplateElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        TsTemplateChunkElement::KIND_SET.union(TsTemplateElement::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_TEMPLATE_CHUNK_ELEMENT | TS_TEMPLATE_ELEMENT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_TEMPLATE_CHUNK_ELEMENT => {
                AnyTsTemplateElement::TsTemplateChunkElement(TsTemplateChunkElement { syntax })
            }
            TS_TEMPLATE_ELEMENT => {
                AnyTsTemplateElement::TsTemplateElement(TsTemplateElement { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsTemplateElement::TsTemplateChunkElement(it) => &it.syntax,
            AnyTsTemplateElement::TsTemplateElement(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsTemplateElement::TsTemplateChunkElement(it) => it.syntax,
            AnyTsTemplateElement::TsTemplateElement(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsTemplateElement::TsTemplateChunkElement(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTemplateElement::TsTemplateElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsTemplateElement> for SyntaxNode {
    fn from(n: AnyTsTemplateElement) -> SyntaxNode {
        match n {
            AnyTsTemplateElement::TsTemplateChunkElement(it) => it.into(),
            AnyTsTemplateElement::TsTemplateElement(it) => it.into(),
        }
    }
}
impl From<AnyTsTemplateElement> for SyntaxElement {
    fn from(n: AnyTsTemplateElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsNamedTupleTypeElement> for AnyTsTupleTypeElement {
    fn from(node: TsNamedTupleTypeElement) -> AnyTsTupleTypeElement {
        AnyTsTupleTypeElement::TsNamedTupleTypeElement(node)
    }
}
impl From<TsOptionalTupleTypeElement> for AnyTsTupleTypeElement {
    fn from(node: TsOptionalTupleTypeElement) -> AnyTsTupleTypeElement {
        AnyTsTupleTypeElement::TsOptionalTupleTypeElement(node)
    }
}
impl From<TsRestTupleTypeElement> for AnyTsTupleTypeElement {
    fn from(node: TsRestTupleTypeElement) -> AnyTsTupleTypeElement {
        AnyTsTupleTypeElement::TsRestTupleTypeElement(node)
    }
}
impl AstNode for AnyTsTupleTypeElement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = AnyTsType::KIND_SET
        .union(TsNamedTupleTypeElement::KIND_SET)
        .union(TsOptionalTupleTypeElement::KIND_SET)
        .union(TsRestTupleTypeElement::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TS_NAMED_TUPLE_TYPE_ELEMENT
            | TS_OPTIONAL_TUPLE_TYPE_ELEMENT
            | TS_REST_TUPLE_TYPE_ELEMENT => true,
            k if AnyTsType::can_cast(k) => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_NAMED_TUPLE_TYPE_ELEMENT => {
                AnyTsTupleTypeElement::TsNamedTupleTypeElement(TsNamedTupleTypeElement { syntax })
            }
            TS_OPTIONAL_TUPLE_TYPE_ELEMENT => {
                AnyTsTupleTypeElement::TsOptionalTupleTypeElement(TsOptionalTupleTypeElement {
                    syntax,
                })
            }
            TS_REST_TUPLE_TYPE_ELEMENT => {
                AnyTsTupleTypeElement::TsRestTupleTypeElement(TsRestTupleTypeElement { syntax })
            }
            _ => {
                if let Some(any_ts_type) = AnyTsType::cast(syntax) {
                    return Some(AnyTsTupleTypeElement::AnyTsType(any_ts_type));
                }
                return None;
            }
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsTupleTypeElement::TsNamedTupleTypeElement(it) => &it.syntax,
            AnyTsTupleTypeElement::TsOptionalTupleTypeElement(it) => &it.syntax,
            AnyTsTupleTypeElement::TsRestTupleTypeElement(it) => &it.syntax,
            AnyTsTupleTypeElement::AnyTsType(it) => it.syntax(),
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsTupleTypeElement::TsNamedTupleTypeElement(it) => it.syntax,
            AnyTsTupleTypeElement::TsOptionalTupleTypeElement(it) => it.syntax,
            AnyTsTupleTypeElement::TsRestTupleTypeElement(it) => it.syntax,
            AnyTsTupleTypeElement::AnyTsType(it) => it.into_syntax(),
        }
    }
}
impl std::fmt::Debug for AnyTsTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsTupleTypeElement::AnyTsType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTupleTypeElement::TsNamedTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTupleTypeElement::TsOptionalTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTupleTypeElement::TsRestTupleTypeElement(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsTupleTypeElement> for SyntaxNode {
    fn from(n: AnyTsTupleTypeElement) -> SyntaxNode {
        match n {
            AnyTsTupleTypeElement::AnyTsType(it) => it.into(),
            AnyTsTupleTypeElement::TsNamedTupleTypeElement(it) => it.into(),
            AnyTsTupleTypeElement::TsOptionalTupleTypeElement(it) => it.into(),
            AnyTsTupleTypeElement::TsRestTupleTypeElement(it) => it.into(),
        }
    }
}
impl From<AnyTsTupleTypeElement> for SyntaxElement {
    fn from(n: AnyTsTupleTypeElement) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsAnyType> for AnyTsType {
    fn from(node: TsAnyType) -> AnyTsType { AnyTsType::TsAnyType(node) }
}
impl From<TsArrayType> for AnyTsType {
    fn from(node: TsArrayType) -> AnyTsType { AnyTsType::TsArrayType(node) }
}
impl From<TsBigintLiteralType> for AnyTsType {
    fn from(node: TsBigintLiteralType) -> AnyTsType { AnyTsType::TsBigintLiteralType(node) }
}
impl From<TsBigintType> for AnyTsType {
    fn from(node: TsBigintType) -> AnyTsType { AnyTsType::TsBigintType(node) }
}
impl From<TsBogusType> for AnyTsType {
    fn from(node: TsBogusType) -> AnyTsType { AnyTsType::TsBogusType(node) }
}
impl From<TsBooleanLiteralType> for AnyTsType {
    fn from(node: TsBooleanLiteralType) -> AnyTsType { AnyTsType::TsBooleanLiteralType(node) }
}
impl From<TsBooleanType> for AnyTsType {
    fn from(node: TsBooleanType) -> AnyTsType { AnyTsType::TsBooleanType(node) }
}
impl From<TsConditionalType> for AnyTsType {
    fn from(node: TsConditionalType) -> AnyTsType { AnyTsType::TsConditionalType(node) }
}
impl From<TsConstructorType> for AnyTsType {
    fn from(node: TsConstructorType) -> AnyTsType { AnyTsType::TsConstructorType(node) }
}
impl From<TsFunctionType> for AnyTsType {
    fn from(node: TsFunctionType) -> AnyTsType { AnyTsType::TsFunctionType(node) }
}
impl From<TsImportType> for AnyTsType {
    fn from(node: TsImportType) -> AnyTsType { AnyTsType::TsImportType(node) }
}
impl From<TsIndexedAccessType> for AnyTsType {
    fn from(node: TsIndexedAccessType) -> AnyTsType { AnyTsType::TsIndexedAccessType(node) }
}
impl From<TsInferType> for AnyTsType {
    fn from(node: TsInferType) -> AnyTsType { AnyTsType::TsInferType(node) }
}
impl From<TsIntersectionType> for AnyTsType {
    fn from(node: TsIntersectionType) -> AnyTsType { AnyTsType::TsIntersectionType(node) }
}
impl From<TsMappedType> for AnyTsType {
    fn from(node: TsMappedType) -> AnyTsType { AnyTsType::TsMappedType(node) }
}
impl From<TsNeverType> for AnyTsType {
    fn from(node: TsNeverType) -> AnyTsType { AnyTsType::TsNeverType(node) }
}
impl From<TsNonPrimitiveType> for AnyTsType {
    fn from(node: TsNonPrimitiveType) -> AnyTsType { AnyTsType::TsNonPrimitiveType(node) }
}
impl From<TsNullLiteralType> for AnyTsType {
    fn from(node: TsNullLiteralType) -> AnyTsType { AnyTsType::TsNullLiteralType(node) }
}
impl From<TsNumberLiteralType> for AnyTsType {
    fn from(node: TsNumberLiteralType) -> AnyTsType { AnyTsType::TsNumberLiteralType(node) }
}
impl From<TsNumberType> for AnyTsType {
    fn from(node: TsNumberType) -> AnyTsType { AnyTsType::TsNumberType(node) }
}
impl From<TsObjectType> for AnyTsType {
    fn from(node: TsObjectType) -> AnyTsType { AnyTsType::TsObjectType(node) }
}
impl From<TsParenthesizedType> for AnyTsType {
    fn from(node: TsParenthesizedType) -> AnyTsType { AnyTsType::TsParenthesizedType(node) }
}
impl From<TsReferenceType> for AnyTsType {
    fn from(node: TsReferenceType) -> AnyTsType { AnyTsType::TsReferenceType(node) }
}
impl From<TsStringLiteralType> for AnyTsType {
    fn from(node: TsStringLiteralType) -> AnyTsType { AnyTsType::TsStringLiteralType(node) }
}
impl From<TsStringType> for AnyTsType {
    fn from(node: TsStringType) -> AnyTsType { AnyTsType::TsStringType(node) }
}
impl From<TsSymbolType> for AnyTsType {
    fn from(node: TsSymbolType) -> AnyTsType { AnyTsType::TsSymbolType(node) }
}
impl From<TsTemplateLiteralType> for AnyTsType {
    fn from(node: TsTemplateLiteralType) -> AnyTsType { AnyTsType::TsTemplateLiteralType(node) }
}
impl From<TsThisType> for AnyTsType {
    fn from(node: TsThisType) -> AnyTsType { AnyTsType::TsThisType(node) }
}
impl From<TsTupleType> for AnyTsType {
    fn from(node: TsTupleType) -> AnyTsType { AnyTsType::TsTupleType(node) }
}
impl From<TsTypeOperatorType> for AnyTsType {
    fn from(node: TsTypeOperatorType) -> AnyTsType { AnyTsType::TsTypeOperatorType(node) }
}
impl From<TsTypeofType> for AnyTsType {
    fn from(node: TsTypeofType) -> AnyTsType { AnyTsType::TsTypeofType(node) }
}
impl From<TsUndefinedType> for AnyTsType {
    fn from(node: TsUndefinedType) -> AnyTsType { AnyTsType::TsUndefinedType(node) }
}
impl From<TsUnionType> for AnyTsType {
    fn from(node: TsUnionType) -> AnyTsType { AnyTsType::TsUnionType(node) }
}
impl From<TsUnknownType> for AnyTsType {
    fn from(node: TsUnknownType) -> AnyTsType { AnyTsType::TsUnknownType(node) }
}
impl From<TsVoidType> for AnyTsType {
    fn from(node: TsVoidType) -> AnyTsType { AnyTsType::TsVoidType(node) }
}
impl AstNode for AnyTsType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = TsAnyType::KIND_SET
        .union(TsArrayType::KIND_SET)
        .union(TsBigintLiteralType::KIND_SET)
        .union(TsBigintType::KIND_SET)
        .union(TsBogusType::KIND_SET)
        .union(TsBooleanLiteralType::KIND_SET)
        .union(TsBooleanType::KIND_SET)
        .union(TsConditionalType::KIND_SET)
        .union(TsConstructorType::KIND_SET)
        .union(TsFunctionType::KIND_SET)
        .union(TsImportType::KIND_SET)
        .union(TsIndexedAccessType::KIND_SET)
        .union(TsInferType::KIND_SET)
        .union(TsIntersectionType::KIND_SET)
        .union(TsMappedType::KIND_SET)
        .union(TsNeverType::KIND_SET)
        .union(TsNonPrimitiveType::KIND_SET)
        .union(TsNullLiteralType::KIND_SET)
        .union(TsNumberLiteralType::KIND_SET)
        .union(TsNumberType::KIND_SET)
        .union(TsObjectType::KIND_SET)
        .union(TsParenthesizedType::KIND_SET)
        .union(TsReferenceType::KIND_SET)
        .union(TsStringLiteralType::KIND_SET)
        .union(TsStringType::KIND_SET)
        .union(TsSymbolType::KIND_SET)
        .union(TsTemplateLiteralType::KIND_SET)
        .union(TsThisType::KIND_SET)
        .union(TsTupleType::KIND_SET)
        .union(TsTypeOperatorType::KIND_SET)
        .union(TsTypeofType::KIND_SET)
        .union(TsUndefinedType::KIND_SET)
        .union(TsUnionType::KIND_SET)
        .union(TsUnknownType::KIND_SET)
        .union(TsVoidType::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            TS_ANY_TYPE
                | TS_ARRAY_TYPE
                | TS_BIGINT_LITERAL_TYPE
                | TS_BIGINT_TYPE
                | TS_BOGUS_TYPE
                | TS_BOOLEAN_LITERAL_TYPE
                | TS_BOOLEAN_TYPE
                | TS_CONDITIONAL_TYPE
                | TS_CONSTRUCTOR_TYPE
                | TS_FUNCTION_TYPE
                | TS_IMPORT_TYPE
                | TS_INDEXED_ACCESS_TYPE
                | TS_INFER_TYPE
                | TS_INTERSECTION_TYPE
                | TS_MAPPED_TYPE
                | TS_NEVER_TYPE
                | TS_NON_PRIMITIVE_TYPE
                | TS_NULL_LITERAL_TYPE
                | TS_NUMBER_LITERAL_TYPE
                | TS_NUMBER_TYPE
                | TS_OBJECT_TYPE
                | TS_PARENTHESIZED_TYPE
                | TS_REFERENCE_TYPE
                | TS_STRING_LITERAL_TYPE
                | TS_STRING_TYPE
                | TS_SYMBOL_TYPE
                | TS_TEMPLATE_LITERAL_TYPE
                | TS_THIS_TYPE
                | TS_TUPLE_TYPE
                | TS_TYPE_OPERATOR_TYPE
                | TS_TYPEOF_TYPE
                | TS_UNDEFINED_TYPE
                | TS_UNION_TYPE
                | TS_UNKNOWN_TYPE
                | TS_VOID_TYPE
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_ANY_TYPE => AnyTsType::TsAnyType(TsAnyType { syntax }),
            TS_ARRAY_TYPE => AnyTsType::TsArrayType(TsArrayType { syntax }),
            TS_BIGINT_LITERAL_TYPE => {
                AnyTsType::TsBigintLiteralType(TsBigintLiteralType { syntax })
            }
            TS_BIGINT_TYPE => AnyTsType::TsBigintType(TsBigintType { syntax }),
            TS_BOGUS_TYPE => AnyTsType::TsBogusType(TsBogusType { syntax }),
            TS_BOOLEAN_LITERAL_TYPE => {
                AnyTsType::TsBooleanLiteralType(TsBooleanLiteralType { syntax })
            }
            TS_BOOLEAN_TYPE => AnyTsType::TsBooleanType(TsBooleanType { syntax }),
            TS_CONDITIONAL_TYPE => AnyTsType::TsConditionalType(TsConditionalType { syntax }),
            TS_CONSTRUCTOR_TYPE => AnyTsType::TsConstructorType(TsConstructorType { syntax }),
            TS_FUNCTION_TYPE => AnyTsType::TsFunctionType(TsFunctionType { syntax }),
            TS_IMPORT_TYPE => AnyTsType::TsImportType(TsImportType { syntax }),
            TS_INDEXED_ACCESS_TYPE => {
                AnyTsType::TsIndexedAccessType(TsIndexedAccessType { syntax })
            }
            TS_INFER_TYPE => AnyTsType::TsInferType(TsInferType { syntax }),
            TS_INTERSECTION_TYPE => AnyTsType::TsIntersectionType(TsIntersectionType { syntax }),
            TS_MAPPED_TYPE => AnyTsType::TsMappedType(TsMappedType { syntax }),
            TS_NEVER_TYPE => AnyTsType::TsNeverType(TsNeverType { syntax }),
            TS_NON_PRIMITIVE_TYPE => AnyTsType::TsNonPrimitiveType(TsNonPrimitiveType { syntax }),
            TS_NULL_LITERAL_TYPE => AnyTsType::TsNullLiteralType(TsNullLiteralType { syntax }),
            TS_NUMBER_LITERAL_TYPE => {
                AnyTsType::TsNumberLiteralType(TsNumberLiteralType { syntax })
            }
            TS_NUMBER_TYPE => AnyTsType::TsNumberType(TsNumberType { syntax }),
            TS_OBJECT_TYPE => AnyTsType::TsObjectType(TsObjectType { syntax }),
            TS_PARENTHESIZED_TYPE => AnyTsType::TsParenthesizedType(TsParenthesizedType { syntax }),
            TS_REFERENCE_TYPE => AnyTsType::TsReferenceType(TsReferenceType { syntax }),
            TS_STRING_LITERAL_TYPE => {
                AnyTsType::TsStringLiteralType(TsStringLiteralType { syntax })
            }
            TS_STRING_TYPE => AnyTsType::TsStringType(TsStringType { syntax }),
            TS_SYMBOL_TYPE => AnyTsType::TsSymbolType(TsSymbolType { syntax }),
            TS_TEMPLATE_LITERAL_TYPE => {
                AnyTsType::TsTemplateLiteralType(TsTemplateLiteralType { syntax })
            }
            TS_THIS_TYPE => AnyTsType::TsThisType(TsThisType { syntax }),
            TS_TUPLE_TYPE => AnyTsType::TsTupleType(TsTupleType { syntax }),
            TS_TYPE_OPERATOR_TYPE => AnyTsType::TsTypeOperatorType(TsTypeOperatorType { syntax }),
            TS_TYPEOF_TYPE => AnyTsType::TsTypeofType(TsTypeofType { syntax }),
            TS_UNDEFINED_TYPE => AnyTsType::TsUndefinedType(TsUndefinedType { syntax }),
            TS_UNION_TYPE => AnyTsType::TsUnionType(TsUnionType { syntax }),
            TS_UNKNOWN_TYPE => AnyTsType::TsUnknownType(TsUnknownType { syntax }),
            TS_VOID_TYPE => AnyTsType::TsVoidType(TsVoidType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsType::TsAnyType(it) => &it.syntax,
            AnyTsType::TsArrayType(it) => &it.syntax,
            AnyTsType::TsBigintLiteralType(it) => &it.syntax,
            AnyTsType::TsBigintType(it) => &it.syntax,
            AnyTsType::TsBogusType(it) => &it.syntax,
            AnyTsType::TsBooleanLiteralType(it) => &it.syntax,
            AnyTsType::TsBooleanType(it) => &it.syntax,
            AnyTsType::TsConditionalType(it) => &it.syntax,
            AnyTsType::TsConstructorType(it) => &it.syntax,
            AnyTsType::TsFunctionType(it) => &it.syntax,
            AnyTsType::TsImportType(it) => &it.syntax,
            AnyTsType::TsIndexedAccessType(it) => &it.syntax,
            AnyTsType::TsInferType(it) => &it.syntax,
            AnyTsType::TsIntersectionType(it) => &it.syntax,
            AnyTsType::TsMappedType(it) => &it.syntax,
            AnyTsType::TsNeverType(it) => &it.syntax,
            AnyTsType::TsNonPrimitiveType(it) => &it.syntax,
            AnyTsType::TsNullLiteralType(it) => &it.syntax,
            AnyTsType::TsNumberLiteralType(it) => &it.syntax,
            AnyTsType::TsNumberType(it) => &it.syntax,
            AnyTsType::TsObjectType(it) => &it.syntax,
            AnyTsType::TsParenthesizedType(it) => &it.syntax,
            AnyTsType::TsReferenceType(it) => &it.syntax,
            AnyTsType::TsStringLiteralType(it) => &it.syntax,
            AnyTsType::TsStringType(it) => &it.syntax,
            AnyTsType::TsSymbolType(it) => &it.syntax,
            AnyTsType::TsTemplateLiteralType(it) => &it.syntax,
            AnyTsType::TsThisType(it) => &it.syntax,
            AnyTsType::TsTupleType(it) => &it.syntax,
            AnyTsType::TsTypeOperatorType(it) => &it.syntax,
            AnyTsType::TsTypeofType(it) => &it.syntax,
            AnyTsType::TsUndefinedType(it) => &it.syntax,
            AnyTsType::TsUnionType(it) => &it.syntax,
            AnyTsType::TsUnknownType(it) => &it.syntax,
            AnyTsType::TsVoidType(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsType::TsAnyType(it) => it.syntax,
            AnyTsType::TsArrayType(it) => it.syntax,
            AnyTsType::TsBigintLiteralType(it) => it.syntax,
            AnyTsType::TsBigintType(it) => it.syntax,
            AnyTsType::TsBogusType(it) => it.syntax,
            AnyTsType::TsBooleanLiteralType(it) => it.syntax,
            AnyTsType::TsBooleanType(it) => it.syntax,
            AnyTsType::TsConditionalType(it) => it.syntax,
            AnyTsType::TsConstructorType(it) => it.syntax,
            AnyTsType::TsFunctionType(it) => it.syntax,
            AnyTsType::TsImportType(it) => it.syntax,
            AnyTsType::TsIndexedAccessType(it) => it.syntax,
            AnyTsType::TsInferType(it) => it.syntax,
            AnyTsType::TsIntersectionType(it) => it.syntax,
            AnyTsType::TsMappedType(it) => it.syntax,
            AnyTsType::TsNeverType(it) => it.syntax,
            AnyTsType::TsNonPrimitiveType(it) => it.syntax,
            AnyTsType::TsNullLiteralType(it) => it.syntax,
            AnyTsType::TsNumberLiteralType(it) => it.syntax,
            AnyTsType::TsNumberType(it) => it.syntax,
            AnyTsType::TsObjectType(it) => it.syntax,
            AnyTsType::TsParenthesizedType(it) => it.syntax,
            AnyTsType::TsReferenceType(it) => it.syntax,
            AnyTsType::TsStringLiteralType(it) => it.syntax,
            AnyTsType::TsStringType(it) => it.syntax,
            AnyTsType::TsSymbolType(it) => it.syntax,
            AnyTsType::TsTemplateLiteralType(it) => it.syntax,
            AnyTsType::TsThisType(it) => it.syntax,
            AnyTsType::TsTupleType(it) => it.syntax,
            AnyTsType::TsTypeOperatorType(it) => it.syntax,
            AnyTsType::TsTypeofType(it) => it.syntax,
            AnyTsType::TsUndefinedType(it) => it.syntax,
            AnyTsType::TsUnionType(it) => it.syntax,
            AnyTsType::TsUnknownType(it) => it.syntax,
            AnyTsType::TsVoidType(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsType::TsAnyType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsArrayType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsBigintLiteralType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsBigintType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsBogusType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsBooleanLiteralType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsBooleanType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsConditionalType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsConstructorType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsFunctionType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsImportType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsIndexedAccessType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsInferType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsIntersectionType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsMappedType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsNeverType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsNonPrimitiveType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsNullLiteralType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsNumberLiteralType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsNumberType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsObjectType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsParenthesizedType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsReferenceType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsStringLiteralType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsStringType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsSymbolType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsTemplateLiteralType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsThisType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsTupleType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsTypeOperatorType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsTypeofType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsUndefinedType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsUnionType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsUnknownType(it) => std::fmt::Debug::fmt(it, f),
            AnyTsType::TsVoidType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsType> for SyntaxNode {
    fn from(n: AnyTsType) -> SyntaxNode {
        match n {
            AnyTsType::TsAnyType(it) => it.into(),
            AnyTsType::TsArrayType(it) => it.into(),
            AnyTsType::TsBigintLiteralType(it) => it.into(),
            AnyTsType::TsBigintType(it) => it.into(),
            AnyTsType::TsBogusType(it) => it.into(),
            AnyTsType::TsBooleanLiteralType(it) => it.into(),
            AnyTsType::TsBooleanType(it) => it.into(),
            AnyTsType::TsConditionalType(it) => it.into(),
            AnyTsType::TsConstructorType(it) => it.into(),
            AnyTsType::TsFunctionType(it) => it.into(),
            AnyTsType::TsImportType(it) => it.into(),
            AnyTsType::TsIndexedAccessType(it) => it.into(),
            AnyTsType::TsInferType(it) => it.into(),
            AnyTsType::TsIntersectionType(it) => it.into(),
            AnyTsType::TsMappedType(it) => it.into(),
            AnyTsType::TsNeverType(it) => it.into(),
            AnyTsType::TsNonPrimitiveType(it) => it.into(),
            AnyTsType::TsNullLiteralType(it) => it.into(),
            AnyTsType::TsNumberLiteralType(it) => it.into(),
            AnyTsType::TsNumberType(it) => it.into(),
            AnyTsType::TsObjectType(it) => it.into(),
            AnyTsType::TsParenthesizedType(it) => it.into(),
            AnyTsType::TsReferenceType(it) => it.into(),
            AnyTsType::TsStringLiteralType(it) => it.into(),
            AnyTsType::TsStringType(it) => it.into(),
            AnyTsType::TsSymbolType(it) => it.into(),
            AnyTsType::TsTemplateLiteralType(it) => it.into(),
            AnyTsType::TsThisType(it) => it.into(),
            AnyTsType::TsTupleType(it) => it.into(),
            AnyTsType::TsTypeOperatorType(it) => it.into(),
            AnyTsType::TsTypeofType(it) => it.into(),
            AnyTsType::TsUndefinedType(it) => it.into(),
            AnyTsType::TsUnionType(it) => it.into(),
            AnyTsType::TsUnknownType(it) => it.into(),
            AnyTsType::TsVoidType(it) => it.into(),
        }
    }
}
impl From<AnyTsType> for SyntaxElement {
    fn from(n: AnyTsType) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsBogusMember> for AnyTsTypeMember {
    fn from(node: JsBogusMember) -> AnyTsTypeMember { AnyTsTypeMember::JsBogusMember(node) }
}
impl From<TsCallSignatureTypeMember> for AnyTsTypeMember {
    fn from(node: TsCallSignatureTypeMember) -> AnyTsTypeMember {
        AnyTsTypeMember::TsCallSignatureTypeMember(node)
    }
}
impl From<TsConstructSignatureTypeMember> for AnyTsTypeMember {
    fn from(node: TsConstructSignatureTypeMember) -> AnyTsTypeMember {
        AnyTsTypeMember::TsConstructSignatureTypeMember(node)
    }
}
impl From<TsGetterSignatureTypeMember> for AnyTsTypeMember {
    fn from(node: TsGetterSignatureTypeMember) -> AnyTsTypeMember {
        AnyTsTypeMember::TsGetterSignatureTypeMember(node)
    }
}
impl From<TsIndexSignatureTypeMember> for AnyTsTypeMember {
    fn from(node: TsIndexSignatureTypeMember) -> AnyTsTypeMember {
        AnyTsTypeMember::TsIndexSignatureTypeMember(node)
    }
}
impl From<TsMethodSignatureTypeMember> for AnyTsTypeMember {
    fn from(node: TsMethodSignatureTypeMember) -> AnyTsTypeMember {
        AnyTsTypeMember::TsMethodSignatureTypeMember(node)
    }
}
impl From<TsPropertySignatureTypeMember> for AnyTsTypeMember {
    fn from(node: TsPropertySignatureTypeMember) -> AnyTsTypeMember {
        AnyTsTypeMember::TsPropertySignatureTypeMember(node)
    }
}
impl From<TsSetterSignatureTypeMember> for AnyTsTypeMember {
    fn from(node: TsSetterSignatureTypeMember) -> AnyTsTypeMember {
        AnyTsTypeMember::TsSetterSignatureTypeMember(node)
    }
}
impl AstNode for AnyTsTypeMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = JsBogusMember::KIND_SET
        .union(TsCallSignatureTypeMember::KIND_SET)
        .union(TsConstructSignatureTypeMember::KIND_SET)
        .union(TsGetterSignatureTypeMember::KIND_SET)
        .union(TsIndexSignatureTypeMember::KIND_SET)
        .union(TsMethodSignatureTypeMember::KIND_SET)
        .union(TsPropertySignatureTypeMember::KIND_SET)
        .union(TsSetterSignatureTypeMember::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            JS_BOGUS_MEMBER
                | TS_CALL_SIGNATURE_TYPE_MEMBER
                | TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER
                | TS_GETTER_SIGNATURE_TYPE_MEMBER
                | TS_INDEX_SIGNATURE_TYPE_MEMBER
                | TS_METHOD_SIGNATURE_TYPE_MEMBER
                | TS_PROPERTY_SIGNATURE_TYPE_MEMBER
                | TS_SETTER_SIGNATURE_TYPE_MEMBER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_BOGUS_MEMBER => AnyTsTypeMember::JsBogusMember(JsBogusMember { syntax }),
            TS_CALL_SIGNATURE_TYPE_MEMBER => {
                AnyTsTypeMember::TsCallSignatureTypeMember(TsCallSignatureTypeMember { syntax })
            }
            TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER => {
                AnyTsTypeMember::TsConstructSignatureTypeMember(TsConstructSignatureTypeMember {
                    syntax,
                })
            }
            TS_GETTER_SIGNATURE_TYPE_MEMBER => {
                AnyTsTypeMember::TsGetterSignatureTypeMember(TsGetterSignatureTypeMember { syntax })
            }
            TS_INDEX_SIGNATURE_TYPE_MEMBER => {
                AnyTsTypeMember::TsIndexSignatureTypeMember(TsIndexSignatureTypeMember { syntax })
            }
            TS_METHOD_SIGNATURE_TYPE_MEMBER => {
                AnyTsTypeMember::TsMethodSignatureTypeMember(TsMethodSignatureTypeMember { syntax })
            }
            TS_PROPERTY_SIGNATURE_TYPE_MEMBER => {
                AnyTsTypeMember::TsPropertySignatureTypeMember(TsPropertySignatureTypeMember {
                    syntax,
                })
            }
            TS_SETTER_SIGNATURE_TYPE_MEMBER => {
                AnyTsTypeMember::TsSetterSignatureTypeMember(TsSetterSignatureTypeMember { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsTypeMember::JsBogusMember(it) => &it.syntax,
            AnyTsTypeMember::TsCallSignatureTypeMember(it) => &it.syntax,
            AnyTsTypeMember::TsConstructSignatureTypeMember(it) => &it.syntax,
            AnyTsTypeMember::TsGetterSignatureTypeMember(it) => &it.syntax,
            AnyTsTypeMember::TsIndexSignatureTypeMember(it) => &it.syntax,
            AnyTsTypeMember::TsMethodSignatureTypeMember(it) => &it.syntax,
            AnyTsTypeMember::TsPropertySignatureTypeMember(it) => &it.syntax,
            AnyTsTypeMember::TsSetterSignatureTypeMember(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsTypeMember::JsBogusMember(it) => it.syntax,
            AnyTsTypeMember::TsCallSignatureTypeMember(it) => it.syntax,
            AnyTsTypeMember::TsConstructSignatureTypeMember(it) => it.syntax,
            AnyTsTypeMember::TsGetterSignatureTypeMember(it) => it.syntax,
            AnyTsTypeMember::TsIndexSignatureTypeMember(it) => it.syntax,
            AnyTsTypeMember::TsMethodSignatureTypeMember(it) => it.syntax,
            AnyTsTypeMember::TsPropertySignatureTypeMember(it) => it.syntax,
            AnyTsTypeMember::TsSetterSignatureTypeMember(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsTypeMember::JsBogusMember(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeMember::TsCallSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeMember::TsConstructSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeMember::TsGetterSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeMember::TsIndexSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeMember::TsMethodSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeMember::TsPropertySignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeMember::TsSetterSignatureTypeMember(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsTypeMember> for SyntaxNode {
    fn from(n: AnyTsTypeMember) -> SyntaxNode {
        match n {
            AnyTsTypeMember::JsBogusMember(it) => it.into(),
            AnyTsTypeMember::TsCallSignatureTypeMember(it) => it.into(),
            AnyTsTypeMember::TsConstructSignatureTypeMember(it) => it.into(),
            AnyTsTypeMember::TsGetterSignatureTypeMember(it) => it.into(),
            AnyTsTypeMember::TsIndexSignatureTypeMember(it) => it.into(),
            AnyTsTypeMember::TsMethodSignatureTypeMember(it) => it.into(),
            AnyTsTypeMember::TsPropertySignatureTypeMember(it) => it.into(),
            AnyTsTypeMember::TsSetterSignatureTypeMember(it) => it.into(),
        }
    }
}
impl From<AnyTsTypeMember> for SyntaxElement {
    fn from(n: AnyTsTypeMember) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsConstModifier> for AnyTsTypeParameterModifier {
    fn from(node: TsConstModifier) -> AnyTsTypeParameterModifier {
        AnyTsTypeParameterModifier::TsConstModifier(node)
    }
}
impl From<TsInModifier> for AnyTsTypeParameterModifier {
    fn from(node: TsInModifier) -> AnyTsTypeParameterModifier {
        AnyTsTypeParameterModifier::TsInModifier(node)
    }
}
impl From<TsOutModifier> for AnyTsTypeParameterModifier {
    fn from(node: TsOutModifier) -> AnyTsTypeParameterModifier {
        AnyTsTypeParameterModifier::TsOutModifier(node)
    }
}
impl AstNode for AnyTsTypeParameterModifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = TsConstModifier::KIND_SET
        .union(TsInModifier::KIND_SET)
        .union(TsOutModifier::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_CONST_MODIFIER | TS_IN_MODIFIER | TS_OUT_MODIFIER)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_CONST_MODIFIER => {
                AnyTsTypeParameterModifier::TsConstModifier(TsConstModifier { syntax })
            }
            TS_IN_MODIFIER => AnyTsTypeParameterModifier::TsInModifier(TsInModifier { syntax }),
            TS_OUT_MODIFIER => AnyTsTypeParameterModifier::TsOutModifier(TsOutModifier { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsTypeParameterModifier::TsConstModifier(it) => &it.syntax,
            AnyTsTypeParameterModifier::TsInModifier(it) => &it.syntax,
            AnyTsTypeParameterModifier::TsOutModifier(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsTypeParameterModifier::TsConstModifier(it) => it.syntax,
            AnyTsTypeParameterModifier::TsInModifier(it) => it.syntax,
            AnyTsTypeParameterModifier::TsOutModifier(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsTypeParameterModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsTypeParameterModifier::TsConstModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeParameterModifier::TsInModifier(it) => std::fmt::Debug::fmt(it, f),
            AnyTsTypeParameterModifier::TsOutModifier(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsTypeParameterModifier> for SyntaxNode {
    fn from(n: AnyTsTypeParameterModifier) -> SyntaxNode {
        match n {
            AnyTsTypeParameterModifier::TsConstModifier(it) => it.into(),
            AnyTsTypeParameterModifier::TsInModifier(it) => it.into(),
            AnyTsTypeParameterModifier::TsOutModifier(it) => it.into(),
        }
    }
}
impl From<AnyTsTypeParameterModifier> for SyntaxElement {
    fn from(n: AnyTsTypeParameterModifier) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<JsReferenceIdentifier> for AnyTsTypePredicateParameterName {
    fn from(node: JsReferenceIdentifier) -> AnyTsTypePredicateParameterName {
        AnyTsTypePredicateParameterName::JsReferenceIdentifier(node)
    }
}
impl From<TsThisType> for AnyTsTypePredicateParameterName {
    fn from(node: TsThisType) -> AnyTsTypePredicateParameterName {
        AnyTsTypePredicateParameterName::TsThisType(node)
    }
}
impl AstNode for AnyTsTypePredicateParameterName {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        JsReferenceIdentifier::KIND_SET.union(TsThisType::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, JS_REFERENCE_IDENTIFIER | TS_THIS_TYPE) }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            JS_REFERENCE_IDENTIFIER => {
                AnyTsTypePredicateParameterName::JsReferenceIdentifier(JsReferenceIdentifier {
                    syntax,
                })
            }
            TS_THIS_TYPE => AnyTsTypePredicateParameterName::TsThisType(TsThisType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsTypePredicateParameterName::JsReferenceIdentifier(it) => &it.syntax,
            AnyTsTypePredicateParameterName::TsThisType(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsTypePredicateParameterName::JsReferenceIdentifier(it) => it.syntax,
            AnyTsTypePredicateParameterName::TsThisType(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsTypePredicateParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsTypePredicateParameterName::JsReferenceIdentifier(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsTypePredicateParameterName::TsThisType(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsTypePredicateParameterName> for SyntaxNode {
    fn from(n: AnyTsTypePredicateParameterName) -> SyntaxNode {
        match n {
            AnyTsTypePredicateParameterName::JsReferenceIdentifier(it) => it.into(),
            AnyTsTypePredicateParameterName::TsThisType(it) => it.into(),
        }
    }
}
impl From<AnyTsTypePredicateParameterName> for SyntaxElement {
    fn from(n: AnyTsTypePredicateParameterName) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl From<TsDefiniteVariableAnnotation> for AnyTsVariableAnnotation {
    fn from(node: TsDefiniteVariableAnnotation) -> AnyTsVariableAnnotation {
        AnyTsVariableAnnotation::TsDefiniteVariableAnnotation(node)
    }
}
impl From<TsTypeAnnotation> for AnyTsVariableAnnotation {
    fn from(node: TsTypeAnnotation) -> AnyTsVariableAnnotation {
        AnyTsVariableAnnotation::TsTypeAnnotation(node)
    }
}
impl AstNode for AnyTsVariableAnnotation {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        TsDefiniteVariableAnnotation::KIND_SET.union(TsTypeAnnotation::KIND_SET);
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TS_DEFINITE_VARIABLE_ANNOTATION | TS_TYPE_ANNOTATION)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TS_DEFINITE_VARIABLE_ANNOTATION => {
                AnyTsVariableAnnotation::TsDefiniteVariableAnnotation(
                    TsDefiniteVariableAnnotation { syntax },
                )
            }
            TS_TYPE_ANNOTATION => {
                AnyTsVariableAnnotation::TsTypeAnnotation(TsTypeAnnotation { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyTsVariableAnnotation::TsDefiniteVariableAnnotation(it) => &it.syntax,
            AnyTsVariableAnnotation::TsTypeAnnotation(it) => &it.syntax,
        }
    }
    fn into_syntax(self) -> SyntaxNode {
        match self {
            AnyTsVariableAnnotation::TsDefiniteVariableAnnotation(it) => it.syntax,
            AnyTsVariableAnnotation::TsTypeAnnotation(it) => it.syntax,
        }
    }
}
impl std::fmt::Debug for AnyTsVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnyTsVariableAnnotation::TsDefiniteVariableAnnotation(it) => {
                std::fmt::Debug::fmt(it, f)
            }
            AnyTsVariableAnnotation::TsTypeAnnotation(it) => std::fmt::Debug::fmt(it, f),
        }
    }
}
impl From<AnyTsVariableAnnotation> for SyntaxNode {
    fn from(n: AnyTsVariableAnnotation) -> SyntaxNode {
        match n {
            AnyTsVariableAnnotation::TsDefiniteVariableAnnotation(it) => it.into(),
            AnyTsVariableAnnotation::TsTypeAnnotation(it) => it.into(),
        }
    }
}
impl From<AnyTsVariableAnnotation> for SyntaxElement {
    fn from(n: AnyTsVariableAnnotation) -> SyntaxElement {
        let node: SyntaxNode = n.into();
        node.into()
    }
}
impl std::fmt::Display for AnyJsArrayAssignmentPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsArrayBindingPatternElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsArrayElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsArrowFunctionParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsCallArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsConstructorParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsDecorator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsExportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsForInOrOfInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsForInitializer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsImportAttributeEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsImportClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsInProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsMethodModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsModuleItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsNamedImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsObjectAssignmentPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsObjectBindingPatternMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsObjectMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsPropertyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsRoot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsSwitchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsxAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsxAttributeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsxAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsxChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsxElementName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsxName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsxObjectName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyJsxTag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsIndexSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsMethodSignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsPropertyParameterModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsPropertySignatureAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsPropertySignatureModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsTypeParameterModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsTypePredicateParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyTsVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAccessorModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayAssignmentPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayBindingPatternRestElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrayHole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsArrowFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAssignmentExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAssignmentWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsAwaitExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBigintLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBinaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBindingPatternWithDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBlockStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBooleanLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsBreakStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCallArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCaseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsCatchDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsClassExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsComputedMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConditionalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConstructorClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsConstructorParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsContinueStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDebuggerStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDecorator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDefaultImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDirective {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsDoWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsElseClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsEmptyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsEmptyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportDefaultDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportDefaultExpressionClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedFromClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedFromSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedShorthandSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExportNamedSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExpressionSnipped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExpressionStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFinallyClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForInStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForOfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsForVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFormalParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsFunctionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsGetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsGetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIdentifierExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsIfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportAttributeEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportBareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportCallExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportDefaultClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportMetaExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportNamedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsImportNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsInstanceofExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLabeledStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLiteralExportName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLiteralMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsLogicalExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsMethodClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsMethodObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsModule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsModuleSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamedImportSpecifiers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNamespaceImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNewExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNewTargetExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNullLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsNumberLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectAssignmentPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectBindingPatternShorthandProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsObjectExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParenthesizedAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsParenthesizedExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPostUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPreUpdateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPrivateClassMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPrivateName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPropertyClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsRegexLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsRestParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsReturnStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSequenceExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSetterClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSetterObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsShorthandNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsShorthandPropertyObjectMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSpread {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticInitializationBlockClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticMemberAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticMemberExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStaticModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsStringLiteralExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSuperExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsSwitchStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTemplateExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsThisExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsThrowStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTryFinallyStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsTryStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsUnaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclarationClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableDeclarator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsVariableStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsWhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsWithStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsYieldArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsYieldExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxAttributeInitializerClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxClosingFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxExpressionAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxExpressionChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxMemberName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxNamespaceName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxOpeningElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxOpeningFragment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxReferenceIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSelfClosingElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSpreadAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxSpreadChild {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxTagExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for JsxText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAbstractModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAccessibilityModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAnyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAsAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAsExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAssertsCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsAssertsReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBigintLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBigintType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBooleanLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsBooleanType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsCallSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConditionalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructorSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsConstructorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareFunctionDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareFunctionExportDefaultDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDeclareStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefaultTypeClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefinitePropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsDefiniteVariableAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEmptyExternalModuleDeclarationBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEnumDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsEnumMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportAsNamespaceClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportAssignmentClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExportDeclareClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExtendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExternalModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsExternalModuleReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsFunctionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsGlobalDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIdentifierBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImplementsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportEqualsDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsImportTypeQualifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIndexedAccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInitializedPropertySignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInstantiationExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsInterfaceDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsIntersectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeAsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeOptionalModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMappedTypeReadonlyModifierClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMethodSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsMethodSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsModuleBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsModuleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNameWithTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNamedTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonNullAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonNullAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNonPrimitiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNullLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNumberLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsNumberType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsObjectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOptionalPropertyAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOptionalTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOutModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsOverrideModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsParenthesizedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPredicateReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertyParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertySignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsPropertySignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsQualifiedModuleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsQualifiedName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReadonlyModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReferenceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsRestTupleTypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsReturnTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSatisfiesAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSatisfiesExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSetterSignatureClassMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSetterSignatureTypeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsStringLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsStringType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsSymbolType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateChunkElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTemplateLiteralType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsThisParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsThisType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAliasDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAssertionAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeAssertionExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeConstraintClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeOperatorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameterName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsTypeofType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUndefinedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUnionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsUnknownType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TsVoidType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogus {
    syntax: SyntaxNode,
}
impl JsBogus {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogus {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogus")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogus> for SyntaxNode {
    fn from(n: JsBogus) -> SyntaxNode { n.syntax }
}
impl From<JsBogus> for SyntaxElement {
    fn from(n: JsBogus) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogusAssignment {
    syntax: SyntaxNode,
}
impl JsBogusAssignment {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogusAssignment {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS_ASSIGNMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS_ASSIGNMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogusAssignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogusAssignment")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogusAssignment> for SyntaxNode {
    fn from(n: JsBogusAssignment) -> SyntaxNode { n.syntax }
}
impl From<JsBogusAssignment> for SyntaxElement {
    fn from(n: JsBogusAssignment) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogusBinding {
    syntax: SyntaxNode,
}
impl JsBogusBinding {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogusBinding {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS_BINDING as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS_BINDING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogusBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogusBinding")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogusBinding> for SyntaxNode {
    fn from(n: JsBogusBinding) -> SyntaxNode { n.syntax }
}
impl From<JsBogusBinding> for SyntaxElement {
    fn from(n: JsBogusBinding) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogusExpression {
    syntax: SyntaxNode,
}
impl JsBogusExpression {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogusExpression {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS_EXPRESSION as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogusExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogusExpression")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogusExpression> for SyntaxNode {
    fn from(n: JsBogusExpression) -> SyntaxNode { n.syntax }
}
impl From<JsBogusExpression> for SyntaxElement {
    fn from(n: JsBogusExpression) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogusImportAttributeEntry {
    syntax: SyntaxNode,
}
impl JsBogusImportAttributeEntry {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogusImportAttributeEntry {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS_IMPORT_ATTRIBUTE_ENTRY as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS_IMPORT_ATTRIBUTE_ENTRY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogusImportAttributeEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogusImportAttributeEntry")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogusImportAttributeEntry> for SyntaxNode {
    fn from(n: JsBogusImportAttributeEntry) -> SyntaxNode { n.syntax }
}
impl From<JsBogusImportAttributeEntry> for SyntaxElement {
    fn from(n: JsBogusImportAttributeEntry) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogusMember {
    syntax: SyntaxNode,
}
impl JsBogusMember {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogusMember {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS_MEMBER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS_MEMBER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogusMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogusMember")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogusMember> for SyntaxNode {
    fn from(n: JsBogusMember) -> SyntaxNode { n.syntax }
}
impl From<JsBogusMember> for SyntaxElement {
    fn from(n: JsBogusMember) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogusNamedImportSpecifier {
    syntax: SyntaxNode,
}
impl JsBogusNamedImportSpecifier {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogusNamedImportSpecifier {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS_NAMED_IMPORT_SPECIFIER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS_NAMED_IMPORT_SPECIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogusNamedImportSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogusNamedImportSpecifier")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogusNamedImportSpecifier> for SyntaxNode {
    fn from(n: JsBogusNamedImportSpecifier) -> SyntaxNode { n.syntax }
}
impl From<JsBogusNamedImportSpecifier> for SyntaxElement {
    fn from(n: JsBogusNamedImportSpecifier) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogusParameter {
    syntax: SyntaxNode,
}
impl JsBogusParameter {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogusParameter {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS_PARAMETER as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS_PARAMETER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogusParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogusParameter")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogusParameter> for SyntaxNode {
    fn from(n: JsBogusParameter) -> SyntaxNode { n.syntax }
}
impl From<JsBogusParameter> for SyntaxElement {
    fn from(n: JsBogusParameter) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct JsBogusStatement {
    syntax: SyntaxNode,
}
impl JsBogusStatement {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for JsBogusStatement {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_BOGUS_STATEMENT as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_BOGUS_STATEMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for JsBogusStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("JsBogusStatement")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<JsBogusStatement> for SyntaxNode {
    fn from(n: JsBogusStatement) -> SyntaxNode { n.syntax }
}
impl From<JsBogusStatement> for SyntaxElement {
    fn from(n: JsBogusStatement) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct TsBogusType {
    syntax: SyntaxNode,
}
impl TsBogusType {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub const unsafe fn new_unchecked(syntax: SyntaxNode) -> Self { Self { syntax } }
    pub fn items(&self) -> SyntaxElementChildren { support::elements(&self.syntax) }
}
impl AstNode for TsBogusType {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_BOGUS_TYPE as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_BOGUS_TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
    fn into_syntax(self) -> SyntaxNode { self.syntax }
}
impl std::fmt::Debug for TsBogusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TsBogusType")
            .field("items", &DebugSyntaxElementChildren(self.items()))
            .finish()
    }
}
impl From<TsBogusType> for SyntaxNode {
    fn from(n: TsBogusType) -> SyntaxNode { n.syntax }
}
impl From<TsBogusType> for SyntaxElement {
    fn from(n: TsBogusType) -> SyntaxElement { n.syntax.into() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayAssignmentPatternElementList {
    syntax_list: SyntaxList,
}
impl JsArrayAssignmentPatternElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsArrayAssignmentPatternElementList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        JS_ARRAY_ASSIGNMENT_PATTERN_ELEMENT_LIST as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_ASSIGNMENT_PATTERN_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsArrayAssignmentPatternElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayAssignmentPatternElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayAssignmentPatternElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsArrayAssignmentPatternElementList {
    type Language = Language;
    type Node = AnyJsArrayAssignmentPatternElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsArrayAssignmentPatternElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayAssignmentPatternElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayAssignmentPatternElementList {
    type Item = SyntaxResult<AnyJsArrayAssignmentPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsArrayAssignmentPatternElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsArrayAssignmentPatternElementList {
    type Item = SyntaxResult<AnyJsArrayAssignmentPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsArrayAssignmentPatternElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayBindingPatternElementList {
    syntax_list: SyntaxList,
}
impl JsArrayBindingPatternElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsArrayBindingPatternElementList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ARRAY_BINDING_PATTERN_ELEMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_BINDING_PATTERN_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsArrayBindingPatternElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayBindingPatternElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayBindingPatternElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsArrayBindingPatternElementList {
    type Language = Language;
    type Node = AnyJsArrayBindingPatternElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsArrayBindingPatternElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayBindingPatternElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayBindingPatternElementList {
    type Item = SyntaxResult<AnyJsArrayBindingPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsArrayBindingPatternElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsArrayBindingPatternElementList {
    type Item = SyntaxResult<AnyJsArrayBindingPatternElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsArrayBindingPatternElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsArrayElementList {
    syntax_list: SyntaxList,
}
impl JsArrayElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsArrayElementList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_ARRAY_ELEMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_ARRAY_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsArrayElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsArrayElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsArrayElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsArrayElementList {
    type Language = Language;
    type Node = AnyJsArrayElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsArrayElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsArrayElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsArrayElementList {
    type Item = SyntaxResult<AnyJsArrayElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsArrayElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsArrayElementList {
    type Item = SyntaxResult<AnyJsArrayElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsArrayElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsCallArgumentList {
    syntax_list: SyntaxList,
}
impl JsCallArgumentList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsCallArgumentList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CALL_ARGUMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CALL_ARGUMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsCallArgumentList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsCallArgumentList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsCallArgumentList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsCallArgumentList {
    type Language = Language;
    type Node = AnyJsCallArgument;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsCallArgumentList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsCallArgumentList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsCallArgumentList {
    type Item = SyntaxResult<AnyJsCallArgument>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsCallArgument>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsCallArgumentList {
    type Item = SyntaxResult<AnyJsCallArgument>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsCallArgument>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsClassMemberList {
    syntax_list: SyntaxList,
}
impl JsClassMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsClassMemberList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CLASS_MEMBER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CLASS_MEMBER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsClassMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsClassMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsClassMemberList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsClassMemberList {
    type Language = Language;
    type Node = AnyJsClassMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsClassMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsClassMemberList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsClassMemberList {
    type Item = AnyJsClassMember;
    type IntoIter = AstNodeListIterator<Language, AnyJsClassMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsClassMemberList {
    type Item = AnyJsClassMember;
    type IntoIter = AstNodeListIterator<Language, AnyJsClassMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsConstructorModifierList {
    syntax_list: SyntaxList,
}
impl JsConstructorModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsConstructorModifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CONSTRUCTOR_MODIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONSTRUCTOR_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsConstructorModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsConstructorModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsConstructorModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsConstructorModifierList {
    type Language = Language;
    type Node = TsAccessibilityModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsConstructorModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsConstructorModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsConstructorModifierList {
    type Item = TsAccessibilityModifier;
    type IntoIter = AstNodeListIterator<Language, TsAccessibilityModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsConstructorModifierList {
    type Item = TsAccessibilityModifier;
    type IntoIter = AstNodeListIterator<Language, TsAccessibilityModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsConstructorParameterList {
    syntax_list: SyntaxList,
}
impl JsConstructorParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsConstructorParameterList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_CONSTRUCTOR_PARAMETER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_CONSTRUCTOR_PARAMETER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsConstructorParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsConstructorParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsConstructorParameterList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsConstructorParameterList {
    type Language = Language;
    type Node = AnyJsConstructorParameter;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsConstructorParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsConstructorParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsConstructorParameterList {
    type Item = SyntaxResult<AnyJsConstructorParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsConstructorParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsConstructorParameterList {
    type Item = SyntaxResult<AnyJsConstructorParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsConstructorParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsDecoratorList {
    syntax_list: SyntaxList,
}
impl JsDecoratorList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsDecoratorList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_DECORATOR_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DECORATOR_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsDecoratorList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsDecoratorList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsDecoratorList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsDecoratorList {
    type Language = Language;
    type Node = JsDecorator;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsDecoratorList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsDecoratorList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsDecoratorList {
    type Item = JsDecorator;
    type IntoIter = AstNodeListIterator<Language, JsDecorator>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsDecoratorList {
    type Item = JsDecorator;
    type IntoIter = AstNodeListIterator<Language, JsDecorator>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsDirectiveList {
    syntax_list: SyntaxList,
}
impl JsDirectiveList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsDirectiveList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_DIRECTIVE_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_DIRECTIVE_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsDirectiveList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsDirectiveList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsDirectiveList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsDirectiveList {
    type Language = Language;
    type Node = JsDirective;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsDirectiveList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsDirectiveList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsDirectiveList {
    type Item = JsDirective;
    type IntoIter = AstNodeListIterator<Language, JsDirective>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsDirectiveList {
    type Item = JsDirective;
    type IntoIter = AstNodeListIterator<Language, JsDirective>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsExportNamedFromSpecifierList {
    syntax_list: SyntaxList,
}
impl JsExportNamedFromSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsExportNamedFromSpecifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_NAMED_FROM_SPECIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_FROM_SPECIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsExportNamedFromSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsExportNamedFromSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedFromSpecifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsExportNamedFromSpecifierList {
    type Language = Language;
    type Node = JsExportNamedFromSpecifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsExportNamedFromSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsExportNamedFromSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsExportNamedFromSpecifierList {
    type Item = SyntaxResult<JsExportNamedFromSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsExportNamedFromSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsExportNamedFromSpecifierList {
    type Item = SyntaxResult<JsExportNamedFromSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsExportNamedFromSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsExportNamedSpecifierList {
    syntax_list: SyntaxList,
}
impl JsExportNamedSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsExportNamedSpecifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_EXPORT_NAMED_SPECIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_EXPORT_NAMED_SPECIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsExportNamedSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsExportNamedSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsExportNamedSpecifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsExportNamedSpecifierList {
    type Language = Language;
    type Node = AnyJsExportNamedSpecifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsExportNamedSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsExportNamedSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsExportNamedSpecifierList {
    type Item = SyntaxResult<AnyJsExportNamedSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsExportNamedSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsExportNamedSpecifierList {
    type Item = SyntaxResult<AnyJsExportNamedSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsExportNamedSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsImportAttributeEntryList {
    syntax_list: SyntaxList,
}
impl JsImportAttributeEntryList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsImportAttributeEntryList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_IMPORT_ATTRIBUTE_ENTRY_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_IMPORT_ATTRIBUTE_ENTRY_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsImportAttributeEntryList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsImportAttributeEntryList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsImportAttributeEntryList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsImportAttributeEntryList {
    type Language = Language;
    type Node = AnyJsImportAttributeEntry;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsImportAttributeEntryList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsImportAttributeEntryList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsImportAttributeEntryList {
    type Item = SyntaxResult<AnyJsImportAttributeEntry>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsImportAttributeEntry>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsImportAttributeEntryList {
    type Item = SyntaxResult<AnyJsImportAttributeEntry>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsImportAttributeEntry>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsMethodModifierList {
    syntax_list: SyntaxList,
}
impl JsMethodModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsMethodModifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_METHOD_MODIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_METHOD_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsMethodModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsMethodModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsMethodModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsMethodModifierList {
    type Language = Language;
    type Node = AnyJsMethodModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsMethodModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsMethodModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsMethodModifierList {
    type Item = AnyJsMethodModifier;
    type IntoIter = AstNodeListIterator<Language, AnyJsMethodModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsMethodModifierList {
    type Item = AnyJsMethodModifier;
    type IntoIter = AstNodeListIterator<Language, AnyJsMethodModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsModuleItemList {
    syntax_list: SyntaxList,
}
impl JsModuleItemList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsModuleItemList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_MODULE_ITEM_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_MODULE_ITEM_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsModuleItemList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsModuleItemList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsModuleItemList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsModuleItemList {
    type Language = Language;
    type Node = AnyJsModuleItem;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsModuleItemList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsModuleItemList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsModuleItemList {
    type Item = AnyJsModuleItem;
    type IntoIter = AstNodeListIterator<Language, AnyJsModuleItem>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsModuleItemList {
    type Item = AnyJsModuleItem;
    type IntoIter = AstNodeListIterator<Language, AnyJsModuleItem>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsNamedImportSpecifierList {
    syntax_list: SyntaxList,
}
impl JsNamedImportSpecifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsNamedImportSpecifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_NAMED_IMPORT_SPECIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_NAMED_IMPORT_SPECIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsNamedImportSpecifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsNamedImportSpecifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsNamedImportSpecifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsNamedImportSpecifierList {
    type Language = Language;
    type Node = AnyJsNamedImportSpecifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsNamedImportSpecifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsNamedImportSpecifierList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsNamedImportSpecifierList {
    type Item = SyntaxResult<AnyJsNamedImportSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsNamedImportSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsNamedImportSpecifierList {
    type Item = SyntaxResult<AnyJsNamedImportSpecifier>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsNamedImportSpecifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectAssignmentPatternPropertyList {
    syntax_list: SyntaxList,
}
impl JsObjectAssignmentPatternPropertyList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsObjectAssignmentPatternPropertyList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY_LIST as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsObjectAssignmentPatternPropertyList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectAssignmentPatternPropertyList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectAssignmentPatternPropertyList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsObjectAssignmentPatternPropertyList {
    type Language = Language;
    type Node = AnyJsObjectAssignmentPatternMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsObjectAssignmentPatternPropertyList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectAssignmentPatternPropertyList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectAssignmentPatternPropertyList {
    type Item = SyntaxResult<AnyJsObjectAssignmentPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsObjectAssignmentPatternMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsObjectAssignmentPatternPropertyList {
    type Item = SyntaxResult<AnyJsObjectAssignmentPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsObjectAssignmentPatternMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectBindingPatternPropertyList {
    syntax_list: SyntaxList,
}
impl JsObjectBindingPatternPropertyList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsObjectBindingPatternPropertyList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> = SyntaxKindSet::from_raw(RawSyntaxKind(
        JS_OBJECT_BINDING_PATTERN_PROPERTY_LIST as u16,
    ));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_BINDING_PATTERN_PROPERTY_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsObjectBindingPatternPropertyList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectBindingPatternPropertyList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectBindingPatternPropertyList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsObjectBindingPatternPropertyList {
    type Language = Language;
    type Node = AnyJsObjectBindingPatternMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsObjectBindingPatternPropertyList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectBindingPatternPropertyList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectBindingPatternPropertyList {
    type Item = SyntaxResult<AnyJsObjectBindingPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsObjectBindingPatternMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsObjectBindingPatternPropertyList {
    type Item = SyntaxResult<AnyJsObjectBindingPatternMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsObjectBindingPatternMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsObjectMemberList {
    syntax_list: SyntaxList,
}
impl JsObjectMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsObjectMemberList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_OBJECT_MEMBER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_OBJECT_MEMBER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsObjectMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsObjectMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsObjectMemberList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsObjectMemberList {
    type Language = Language;
    type Node = AnyJsObjectMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsObjectMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsObjectMemberList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsObjectMemberList {
    type Item = SyntaxResult<AnyJsObjectMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsObjectMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsObjectMemberList {
    type Item = SyntaxResult<AnyJsObjectMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsObjectMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsParameterList {
    syntax_list: SyntaxList,
}
impl JsParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsParameterList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PARAMETER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PARAMETER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsParameterList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsParameterList {
    type Language = Language;
    type Node = AnyJsParameter;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsParameterList {
    type Item = SyntaxResult<AnyJsParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsParameterList {
    type Item = SyntaxResult<AnyJsParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyJsParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsPropertyModifierList {
    syntax_list: SyntaxList,
}
impl JsPropertyModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsPropertyModifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_PROPERTY_MODIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_PROPERTY_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsPropertyModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsPropertyModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsPropertyModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsPropertyModifierList {
    type Language = Language;
    type Node = AnyJsPropertyModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsPropertyModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsPropertyModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsPropertyModifierList {
    type Item = AnyJsPropertyModifier;
    type IntoIter = AstNodeListIterator<Language, AnyJsPropertyModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsPropertyModifierList {
    type Item = AnyJsPropertyModifier;
    type IntoIter = AstNodeListIterator<Language, AnyJsPropertyModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsStatementList {
    syntax_list: SyntaxList,
}
impl JsStatementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsStatementList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_STATEMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_STATEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsStatementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsStatementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsStatementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsStatementList {
    type Language = Language;
    type Node = AnyJsStatement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsStatementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsStatementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsStatementList {
    type Item = AnyJsStatement;
    type IntoIter = AstNodeListIterator<Language, AnyJsStatement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsStatementList {
    type Item = AnyJsStatement;
    type IntoIter = AstNodeListIterator<Language, AnyJsStatement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsSwitchCaseList {
    syntax_list: SyntaxList,
}
impl JsSwitchCaseList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsSwitchCaseList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_SWITCH_CASE_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_SWITCH_CASE_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsSwitchCaseList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsSwitchCaseList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsSwitchCaseList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsSwitchCaseList {
    type Language = Language;
    type Node = AnyJsSwitchClause;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsSwitchCaseList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsSwitchCaseList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsSwitchCaseList {
    type Item = AnyJsSwitchClause;
    type IntoIter = AstNodeListIterator<Language, AnyJsSwitchClause>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsSwitchCaseList {
    type Item = AnyJsSwitchClause;
    type IntoIter = AstNodeListIterator<Language, AnyJsSwitchClause>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsTemplateElementList {
    syntax_list: SyntaxList,
}
impl JsTemplateElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsTemplateElementList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_TEMPLATE_ELEMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_TEMPLATE_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsTemplateElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsTemplateElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsTemplateElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsTemplateElementList {
    type Language = Language;
    type Node = AnyJsTemplateElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsTemplateElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsTemplateElementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsTemplateElementList {
    type Item = AnyJsTemplateElement;
    type IntoIter = AstNodeListIterator<Language, AnyJsTemplateElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsTemplateElementList {
    type Item = AnyJsTemplateElement;
    type IntoIter = AstNodeListIterator<Language, AnyJsTemplateElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsVariableDeclaratorList {
    syntax_list: SyntaxList,
}
impl JsVariableDeclaratorList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsVariableDeclaratorList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JS_VARIABLE_DECLARATOR_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JS_VARIABLE_DECLARATOR_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsVariableDeclaratorList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsVariableDeclaratorList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsVariableDeclaratorList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for JsVariableDeclaratorList {
    type Language = Language;
    type Node = JsVariableDeclarator;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsVariableDeclaratorList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsVariableDeclaratorList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for JsVariableDeclaratorList {
    type Item = SyntaxResult<JsVariableDeclarator>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsVariableDeclarator>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &JsVariableDeclaratorList {
    type Item = SyntaxResult<JsVariableDeclarator>;
    type IntoIter = AstSeparatedListNodesIterator<Language, JsVariableDeclarator>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsxAttributeList {
    syntax_list: SyntaxList,
}
impl JsxAttributeList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsxAttributeList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_ATTRIBUTE_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_ATTRIBUTE_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsxAttributeList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsxAttributeList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsxAttributeList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsxAttributeList {
    type Language = Language;
    type Node = AnyJsxAttribute;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsxAttributeList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsxAttributeList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsxAttributeList {
    type Item = AnyJsxAttribute;
    type IntoIter = AstNodeListIterator<Language, AnyJsxAttribute>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsxAttributeList {
    type Item = AnyJsxAttribute;
    type IntoIter = AstNodeListIterator<Language, AnyJsxAttribute>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct JsxChildList {
    syntax_list: SyntaxList,
}
impl JsxChildList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for JsxChildList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(JSX_CHILD_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == JSX_CHILD_LIST }
    fn cast(syntax: SyntaxNode) -> Option<JsxChildList> {
        if Self::can_cast(syntax.kind()) {
            Some(JsxChildList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for JsxChildList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for JsxChildList {
    type Language = Language;
    type Node = AnyJsxChild;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for JsxChildList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("JsxChildList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &JsxChildList {
    type Item = AnyJsxChild;
    type IntoIter = AstNodeListIterator<Language, AnyJsxChild>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for JsxChildList {
    type Item = AnyJsxChild;
    type IntoIter = AstNodeListIterator<Language, AnyJsxChild>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsEnumMemberList {
    syntax_list: SyntaxList,
}
impl TsEnumMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsEnumMemberList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_ENUM_MEMBER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_ENUM_MEMBER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsEnumMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsEnumMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsEnumMemberList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsEnumMemberList {
    type Language = Language;
    type Node = TsEnumMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsEnumMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsEnumMemberList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsEnumMemberList {
    type Item = SyntaxResult<TsEnumMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsEnumMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsEnumMemberList {
    type Item = SyntaxResult<TsEnumMember>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsEnumMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsIndexSignatureModifierList {
    syntax_list: SyntaxList,
}
impl TsIndexSignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsIndexSignatureModifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INDEX_SIGNATURE_MODIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INDEX_SIGNATURE_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsIndexSignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsIndexSignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsIndexSignatureModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsIndexSignatureModifierList {
    type Language = Language;
    type Node = AnyTsIndexSignatureModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsIndexSignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsIndexSignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsIndexSignatureModifierList {
    type Item = AnyTsIndexSignatureModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsIndexSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsIndexSignatureModifierList {
    type Item = AnyTsIndexSignatureModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsIndexSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsIntersectionTypeElementList {
    syntax_list: SyntaxList,
}
impl TsIntersectionTypeElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsIntersectionTypeElementList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_INTERSECTION_TYPE_ELEMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_INTERSECTION_TYPE_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsIntersectionTypeElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsIntersectionTypeElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsIntersectionTypeElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsIntersectionTypeElementList {
    type Language = Language;
    type Node = AnyTsType;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsIntersectionTypeElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsIntersectionTypeElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsIntersectionTypeElementList {
    type Item = SyntaxResult<AnyTsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyTsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsIntersectionTypeElementList {
    type Item = SyntaxResult<AnyTsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyTsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsMethodSignatureModifierList {
    syntax_list: SyntaxList,
}
impl TsMethodSignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsMethodSignatureModifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_METHOD_SIGNATURE_MODIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_METHOD_SIGNATURE_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsMethodSignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsMethodSignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsMethodSignatureModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsMethodSignatureModifierList {
    type Language = Language;
    type Node = AnyTsMethodSignatureModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsMethodSignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsMethodSignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsMethodSignatureModifierList {
    type Item = AnyTsMethodSignatureModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsMethodSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsMethodSignatureModifierList {
    type Item = AnyTsMethodSignatureModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsMethodSignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsPropertyParameterModifierList {
    syntax_list: SyntaxList,
}
impl TsPropertyParameterModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsPropertyParameterModifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_PROPERTY_PARAMETER_MODIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_PARAMETER_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsPropertyParameterModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsPropertyParameterModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertyParameterModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsPropertyParameterModifierList {
    type Language = Language;
    type Node = AnyTsPropertyParameterModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsPropertyParameterModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsPropertyParameterModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsPropertyParameterModifierList {
    type Item = AnyTsPropertyParameterModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsPropertyParameterModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsPropertyParameterModifierList {
    type Item = AnyTsPropertyParameterModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsPropertyParameterModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsPropertySignatureModifierList {
    syntax_list: SyntaxList,
}
impl TsPropertySignatureModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsPropertySignatureModifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_PROPERTY_SIGNATURE_MODIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_PROPERTY_SIGNATURE_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsPropertySignatureModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsPropertySignatureModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsPropertySignatureModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsPropertySignatureModifierList {
    type Language = Language;
    type Node = AnyTsPropertySignatureModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsPropertySignatureModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsPropertySignatureModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsPropertySignatureModifierList {
    type Item = AnyTsPropertySignatureModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsPropertySignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsPropertySignatureModifierList {
    type Item = AnyTsPropertySignatureModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsPropertySignatureModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTemplateElementList {
    syntax_list: SyntaxList,
}
impl TsTemplateElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTemplateElementList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TEMPLATE_ELEMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TEMPLATE_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTemplateElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTemplateElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTemplateElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsTemplateElementList {
    type Language = Language;
    type Node = AnyTsTemplateElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsTemplateElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTemplateElementList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsTemplateElementList {
    type Item = AnyTsTemplateElement;
    type IntoIter = AstNodeListIterator<Language, AnyTsTemplateElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsTemplateElementList {
    type Item = AnyTsTemplateElement;
    type IntoIter = AstNodeListIterator<Language, AnyTsTemplateElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTupleTypeElementList {
    syntax_list: SyntaxList,
}
impl TsTupleTypeElementList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTupleTypeElementList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TUPLE_TYPE_ELEMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TUPLE_TYPE_ELEMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTupleTypeElementList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTupleTypeElementList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTupleTypeElementList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsTupleTypeElementList {
    type Language = Language;
    type Node = AnyTsTupleTypeElement;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsTupleTypeElementList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTupleTypeElementList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTupleTypeElementList {
    type Item = SyntaxResult<AnyTsTupleTypeElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyTsTupleTypeElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsTupleTypeElementList {
    type Item = SyntaxResult<AnyTsTupleTypeElement>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyTsTupleTypeElement>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeArgumentList {
    syntax_list: SyntaxList,
}
impl TsTypeArgumentList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeArgumentList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_ARGUMENT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_ARGUMENT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeArgumentList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeArgumentList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeArgumentList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsTypeArgumentList {
    type Language = Language;
    type Node = AnyTsType;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsTypeArgumentList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeArgumentList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeArgumentList {
    type Item = SyntaxResult<AnyTsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyTsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsTypeArgumentList {
    type Item = SyntaxResult<AnyTsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyTsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeList {
    syntax_list: SyntaxList,
}
impl TsTypeList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsTypeList {
    type Language = Language;
    type Node = TsNameWithTypeArguments;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsTypeList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeList {
    type Item = SyntaxResult<TsNameWithTypeArguments>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsNameWithTypeArguments>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsTypeList {
    type Item = SyntaxResult<TsNameWithTypeArguments>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsNameWithTypeArguments>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeMemberList {
    syntax_list: SyntaxList,
}
impl TsTypeMemberList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeMemberList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_MEMBER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_MEMBER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeMemberList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeMemberList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeMemberList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsTypeMemberList {
    type Language = Language;
    type Node = AnyTsTypeMember;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsTypeMemberList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeMemberList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsTypeMemberList {
    type Item = AnyTsTypeMember;
    type IntoIter = AstNodeListIterator<Language, AnyTsTypeMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsTypeMemberList {
    type Item = AnyTsTypeMember;
    type IntoIter = AstNodeListIterator<Language, AnyTsTypeMember>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeParameterList {
    syntax_list: SyntaxList,
}
impl TsTypeParameterList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeParameterList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_PARAMETER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeParameterList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeParameterList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameterList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsTypeParameterList {
    type Language = Language;
    type Node = TsTypeParameter;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsTypeParameterList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeParameterList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsTypeParameterList {
    type Item = SyntaxResult<TsTypeParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsTypeParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsTypeParameterList {
    type Item = SyntaxResult<TsTypeParameter>;
    type IntoIter = AstSeparatedListNodesIterator<Language, TsTypeParameter>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsTypeParameterModifierList {
    syntax_list: SyntaxList,
}
impl TsTypeParameterModifierList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsTypeParameterModifierList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_TYPE_PARAMETER_MODIFIER_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_TYPE_PARAMETER_MODIFIER_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsTypeParameterModifierList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsTypeParameterModifierList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsTypeParameterModifierList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstNodeList for TsTypeParameterModifierList {
    type Language = Language;
    type Node = AnyTsTypeParameterModifier;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsTypeParameterModifierList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsTypeParameterModifierList ")?;
        f.debug_list().entries(self.iter()).finish()
    }
}
impl IntoIterator for &TsTypeParameterModifierList {
    type Item = AnyTsTypeParameterModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsTypeParameterModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for TsTypeParameterModifierList {
    type Item = AnyTsTypeParameterModifier;
    type IntoIter = AstNodeListIterator<Language, AnyTsTypeParameterModifier>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct TsUnionTypeVariantList {
    syntax_list: SyntaxList,
}
impl TsUnionTypeVariantList {
    #[doc = r" Create an AstNode from a SyntaxNode without checking its kind"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r" This function must be guarded with a call to [AstNode::can_cast]"]
    #[doc = r" or a match on [SyntaxNode::kind]"]
    #[inline]
    pub unsafe fn new_unchecked(syntax: SyntaxNode) -> Self {
        Self {
            syntax_list: syntax.into_list(),
        }
    }
}
impl AstNode for TsUnionTypeVariantList {
    type Language = Language;
    const KIND_SET: SyntaxKindSet<Language> =
        SyntaxKindSet::from_raw(RawSyntaxKind(TS_UNION_TYPE_VARIANT_LIST as u16));
    fn can_cast(kind: SyntaxKind) -> bool { kind == TS_UNION_TYPE_VARIANT_LIST }
    fn cast(syntax: SyntaxNode) -> Option<TsUnionTypeVariantList> {
        if Self::can_cast(syntax.kind()) {
            Some(TsUnionTypeVariantList {
                syntax_list: syntax.into_list(),
            })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { self.syntax_list.node() }
    fn into_syntax(self) -> SyntaxNode { self.syntax_list.into_node() }
}
#[cfg(feature = "serde")]
impl Serialize for TsUnionTypeVariantList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for e in self.iter() {
            seq.serialize_element(&e)?;
        }
        seq.end()
    }
}
impl AstSeparatedList for TsUnionTypeVariantList {
    type Language = Language;
    type Node = AnyTsType;
    fn syntax_list(&self) -> &SyntaxList { &self.syntax_list }
    fn into_syntax_list(self) -> SyntaxList { self.syntax_list }
}
impl Debug for TsUnionTypeVariantList {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("TsUnionTypeVariantList ")?;
        f.debug_list().entries(self.elements()).finish()
    }
}
impl IntoIterator for TsUnionTypeVariantList {
    type Item = SyntaxResult<AnyTsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyTsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
impl IntoIterator for &TsUnionTypeVariantList {
    type Item = SyntaxResult<AnyTsType>;
    type IntoIter = AstSeparatedListNodesIterator<Language, AnyTsType>;
    fn into_iter(self) -> Self::IntoIter { self.iter() }
}
#[derive(Clone)]
pub struct DebugSyntaxElementChildren(pub SyntaxElementChildren);
impl Debug for DebugSyntaxElementChildren {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_list()
            .entries(self.clone().0.map(DebugSyntaxElement))
            .finish()
    }
}
struct DebugSyntaxElement(SyntaxElement);
impl Debug for DebugSyntaxElement {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match &self.0 {
            SyntaxElement::Node(node) => {
                map_syntax_node ! (node . clone () , node => std :: fmt :: Debug :: fmt (& node , f))
            }
            SyntaxElement::Token(token) => Debug::fmt(token, f),
        }
    }
}
