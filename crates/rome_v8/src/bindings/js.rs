//! Generated file, do not edit by hand, see `xtask/codegen`

use super::TemplateRegistry;
use crate::convert::{FromV8, ToV8};
use rome_rowan::{AstNode as _, AstNodeList as _, AstSeparatedList as _};
pub(super) fn register_interfaces(
    scope: &mut v8::HandleScope<'_, ()>,
    global: v8::Local<'_, v8::ObjectTemplate>,
    registry: &mut TemplateRegistry,
) {
    registry
        .build_enum::<rome_js_syntax::JsSyntaxKind>(scope, global, "JsSyntaxKind")
        .variant("EOF", rome_js_syntax::JsSyntaxKind::EOF)
        .variant("SEMICOLON", rome_js_syntax::JsSyntaxKind::SEMICOLON)
        .variant("COMMA", rome_js_syntax::JsSyntaxKind::COMMA)
        .variant("L_PAREN", rome_js_syntax::JsSyntaxKind::L_PAREN)
        .variant("R_PAREN", rome_js_syntax::JsSyntaxKind::R_PAREN)
        .variant("L_CURLY", rome_js_syntax::JsSyntaxKind::L_CURLY)
        .variant("R_CURLY", rome_js_syntax::JsSyntaxKind::R_CURLY)
        .variant("L_BRACK", rome_js_syntax::JsSyntaxKind::L_BRACK)
        .variant("R_BRACK", rome_js_syntax::JsSyntaxKind::R_BRACK)
        .variant("L_ANGLE", rome_js_syntax::JsSyntaxKind::L_ANGLE)
        .variant("R_ANGLE", rome_js_syntax::JsSyntaxKind::R_ANGLE)
        .variant("TILDE", rome_js_syntax::JsSyntaxKind::TILDE)
        .variant("QUESTION", rome_js_syntax::JsSyntaxKind::QUESTION)
        .variant("QUESTION2", rome_js_syntax::JsSyntaxKind::QUESTION2)
        .variant("QUESTIONDOT", rome_js_syntax::JsSyntaxKind::QUESTIONDOT)
        .variant("AMP", rome_js_syntax::JsSyntaxKind::AMP)
        .variant("PIPE", rome_js_syntax::JsSyntaxKind::PIPE)
        .variant("PLUS", rome_js_syntax::JsSyntaxKind::PLUS)
        .variant("PLUS2", rome_js_syntax::JsSyntaxKind::PLUS2)
        .variant("STAR", rome_js_syntax::JsSyntaxKind::STAR)
        .variant("STAR2", rome_js_syntax::JsSyntaxKind::STAR2)
        .variant("SLASH", rome_js_syntax::JsSyntaxKind::SLASH)
        .variant("CARET", rome_js_syntax::JsSyntaxKind::CARET)
        .variant("PERCENT", rome_js_syntax::JsSyntaxKind::PERCENT)
        .variant("DOT", rome_js_syntax::JsSyntaxKind::DOT)
        .variant("DOT3", rome_js_syntax::JsSyntaxKind::DOT3)
        .variant("COLON", rome_js_syntax::JsSyntaxKind::COLON)
        .variant("EQ", rome_js_syntax::JsSyntaxKind::EQ)
        .variant("EQ2", rome_js_syntax::JsSyntaxKind::EQ2)
        .variant("EQ3", rome_js_syntax::JsSyntaxKind::EQ3)
        .variant("FAT_ARROW", rome_js_syntax::JsSyntaxKind::FAT_ARROW)
        .variant("BANG", rome_js_syntax::JsSyntaxKind::BANG)
        .variant("NEQ", rome_js_syntax::JsSyntaxKind::NEQ)
        .variant("NEQ2", rome_js_syntax::JsSyntaxKind::NEQ2)
        .variant("MINUS", rome_js_syntax::JsSyntaxKind::MINUS)
        .variant("MINUS2", rome_js_syntax::JsSyntaxKind::MINUS2)
        .variant("LTEQ", rome_js_syntax::JsSyntaxKind::LTEQ)
        .variant("GTEQ", rome_js_syntax::JsSyntaxKind::GTEQ)
        .variant("PLUSEQ", rome_js_syntax::JsSyntaxKind::PLUSEQ)
        .variant("MINUSEQ", rome_js_syntax::JsSyntaxKind::MINUSEQ)
        .variant("PIPEEQ", rome_js_syntax::JsSyntaxKind::PIPEEQ)
        .variant("AMPEQ", rome_js_syntax::JsSyntaxKind::AMPEQ)
        .variant("CARETEQ", rome_js_syntax::JsSyntaxKind::CARETEQ)
        .variant("SLASHEQ", rome_js_syntax::JsSyntaxKind::SLASHEQ)
        .variant("STAREQ", rome_js_syntax::JsSyntaxKind::STAREQ)
        .variant("PERCENTEQ", rome_js_syntax::JsSyntaxKind::PERCENTEQ)
        .variant("AMP2", rome_js_syntax::JsSyntaxKind::AMP2)
        .variant("PIPE2", rome_js_syntax::JsSyntaxKind::PIPE2)
        .variant("SHL", rome_js_syntax::JsSyntaxKind::SHL)
        .variant("SHR", rome_js_syntax::JsSyntaxKind::SHR)
        .variant("USHR", rome_js_syntax::JsSyntaxKind::USHR)
        .variant("SHLEQ", rome_js_syntax::JsSyntaxKind::SHLEQ)
        .variant("SHREQ", rome_js_syntax::JsSyntaxKind::SHREQ)
        .variant("USHREQ", rome_js_syntax::JsSyntaxKind::USHREQ)
        .variant("AMP2EQ", rome_js_syntax::JsSyntaxKind::AMP2EQ)
        .variant("PIPE2EQ", rome_js_syntax::JsSyntaxKind::PIPE2EQ)
        .variant("STAR2EQ", rome_js_syntax::JsSyntaxKind::STAR2EQ)
        .variant("QUESTION2EQ", rome_js_syntax::JsSyntaxKind::QUESTION2EQ)
        .variant("AT", rome_js_syntax::JsSyntaxKind::AT)
        .variant("BACKTICK", rome_js_syntax::JsSyntaxKind::BACKTICK)
        .variant("BREAK_KW", rome_js_syntax::JsSyntaxKind::BREAK_KW)
        .variant("CASE_KW", rome_js_syntax::JsSyntaxKind::CASE_KW)
        .variant("CATCH_KW", rome_js_syntax::JsSyntaxKind::CATCH_KW)
        .variant("CLASS_KW", rome_js_syntax::JsSyntaxKind::CLASS_KW)
        .variant("CONST_KW", rome_js_syntax::JsSyntaxKind::CONST_KW)
        .variant("CONTINUE_KW", rome_js_syntax::JsSyntaxKind::CONTINUE_KW)
        .variant("DEBUGGER_KW", rome_js_syntax::JsSyntaxKind::DEBUGGER_KW)
        .variant("DEFAULT_KW", rome_js_syntax::JsSyntaxKind::DEFAULT_KW)
        .variant("DELETE_KW", rome_js_syntax::JsSyntaxKind::DELETE_KW)
        .variant("DO_KW", rome_js_syntax::JsSyntaxKind::DO_KW)
        .variant("ELSE_KW", rome_js_syntax::JsSyntaxKind::ELSE_KW)
        .variant("ENUM_KW", rome_js_syntax::JsSyntaxKind::ENUM_KW)
        .variant("EXPORT_KW", rome_js_syntax::JsSyntaxKind::EXPORT_KW)
        .variant("EXTENDS_KW", rome_js_syntax::JsSyntaxKind::EXTENDS_KW)
        .variant("FALSE_KW", rome_js_syntax::JsSyntaxKind::FALSE_KW)
        .variant("FINALLY_KW", rome_js_syntax::JsSyntaxKind::FINALLY_KW)
        .variant("FOR_KW", rome_js_syntax::JsSyntaxKind::FOR_KW)
        .variant("FUNCTION_KW", rome_js_syntax::JsSyntaxKind::FUNCTION_KW)
        .variant("IF_KW", rome_js_syntax::JsSyntaxKind::IF_KW)
        .variant("IN_KW", rome_js_syntax::JsSyntaxKind::IN_KW)
        .variant("INSTANCEOF_KW", rome_js_syntax::JsSyntaxKind::INSTANCEOF_KW)
        .variant("IMPORT_KW", rome_js_syntax::JsSyntaxKind::IMPORT_KW)
        .variant("NEW_KW", rome_js_syntax::JsSyntaxKind::NEW_KW)
        .variant("NULL_KW", rome_js_syntax::JsSyntaxKind::NULL_KW)
        .variant("RETURN_KW", rome_js_syntax::JsSyntaxKind::RETURN_KW)
        .variant("SUPER_KW", rome_js_syntax::JsSyntaxKind::SUPER_KW)
        .variant("SWITCH_KW", rome_js_syntax::JsSyntaxKind::SWITCH_KW)
        .variant("THIS_KW", rome_js_syntax::JsSyntaxKind::THIS_KW)
        .variant("THROW_KW", rome_js_syntax::JsSyntaxKind::THROW_KW)
        .variant("TRY_KW", rome_js_syntax::JsSyntaxKind::TRY_KW)
        .variant("TRUE_KW", rome_js_syntax::JsSyntaxKind::TRUE_KW)
        .variant("TYPEOF_KW", rome_js_syntax::JsSyntaxKind::TYPEOF_KW)
        .variant("VAR_KW", rome_js_syntax::JsSyntaxKind::VAR_KW)
        .variant("VOID_KW", rome_js_syntax::JsSyntaxKind::VOID_KW)
        .variant("WHILE_KW", rome_js_syntax::JsSyntaxKind::WHILE_KW)
        .variant("WITH_KW", rome_js_syntax::JsSyntaxKind::WITH_KW)
        .variant("IMPLEMENTS_KW", rome_js_syntax::JsSyntaxKind::IMPLEMENTS_KW)
        .variant("INTERFACE_KW", rome_js_syntax::JsSyntaxKind::INTERFACE_KW)
        .variant("LET_KW", rome_js_syntax::JsSyntaxKind::LET_KW)
        .variant("PACKAGE_KW", rome_js_syntax::JsSyntaxKind::PACKAGE_KW)
        .variant("PRIVATE_KW", rome_js_syntax::JsSyntaxKind::PRIVATE_KW)
        .variant("PROTECTED_KW", rome_js_syntax::JsSyntaxKind::PROTECTED_KW)
        .variant("PUBLIC_KW", rome_js_syntax::JsSyntaxKind::PUBLIC_KW)
        .variant("STATIC_KW", rome_js_syntax::JsSyntaxKind::STATIC_KW)
        .variant("YIELD_KW", rome_js_syntax::JsSyntaxKind::YIELD_KW)
        .variant("ABSTRACT_KW", rome_js_syntax::JsSyntaxKind::ABSTRACT_KW)
        .variant("ACCESSOR_KW", rome_js_syntax::JsSyntaxKind::ACCESSOR_KW)
        .variant("AS_KW", rome_js_syntax::JsSyntaxKind::AS_KW)
        .variant("SATISFIES_KW", rome_js_syntax::JsSyntaxKind::SATISFIES_KW)
        .variant("ASSERTS_KW", rome_js_syntax::JsSyntaxKind::ASSERTS_KW)
        .variant("ASSERT_KW", rome_js_syntax::JsSyntaxKind::ASSERT_KW)
        .variant("ANY_KW", rome_js_syntax::JsSyntaxKind::ANY_KW)
        .variant("ASYNC_KW", rome_js_syntax::JsSyntaxKind::ASYNC_KW)
        .variant("AWAIT_KW", rome_js_syntax::JsSyntaxKind::AWAIT_KW)
        .variant("BOOLEAN_KW", rome_js_syntax::JsSyntaxKind::BOOLEAN_KW)
        .variant(
            "CONSTRUCTOR_KW",
            rome_js_syntax::JsSyntaxKind::CONSTRUCTOR_KW,
        )
        .variant("DECLARE_KW", rome_js_syntax::JsSyntaxKind::DECLARE_KW)
        .variant("GET_KW", rome_js_syntax::JsSyntaxKind::GET_KW)
        .variant("INFER_KW", rome_js_syntax::JsSyntaxKind::INFER_KW)
        .variant("IS_KW", rome_js_syntax::JsSyntaxKind::IS_KW)
        .variant("KEYOF_KW", rome_js_syntax::JsSyntaxKind::KEYOF_KW)
        .variant("MODULE_KW", rome_js_syntax::JsSyntaxKind::MODULE_KW)
        .variant("NAMESPACE_KW", rome_js_syntax::JsSyntaxKind::NAMESPACE_KW)
        .variant("NEVER_KW", rome_js_syntax::JsSyntaxKind::NEVER_KW)
        .variant("READONLY_KW", rome_js_syntax::JsSyntaxKind::READONLY_KW)
        .variant("REQUIRE_KW", rome_js_syntax::JsSyntaxKind::REQUIRE_KW)
        .variant("NUMBER_KW", rome_js_syntax::JsSyntaxKind::NUMBER_KW)
        .variant("OBJECT_KW", rome_js_syntax::JsSyntaxKind::OBJECT_KW)
        .variant("SET_KW", rome_js_syntax::JsSyntaxKind::SET_KW)
        .variant("STRING_KW", rome_js_syntax::JsSyntaxKind::STRING_KW)
        .variant("SYMBOL_KW", rome_js_syntax::JsSyntaxKind::SYMBOL_KW)
        .variant("TYPE_KW", rome_js_syntax::JsSyntaxKind::TYPE_KW)
        .variant("UNDEFINED_KW", rome_js_syntax::JsSyntaxKind::UNDEFINED_KW)
        .variant("UNIQUE_KW", rome_js_syntax::JsSyntaxKind::UNIQUE_KW)
        .variant("UNKNOWN_KW", rome_js_syntax::JsSyntaxKind::UNKNOWN_KW)
        .variant("FROM_KW", rome_js_syntax::JsSyntaxKind::FROM_KW)
        .variant("GLOBAL_KW", rome_js_syntax::JsSyntaxKind::GLOBAL_KW)
        .variant("BIGINT_KW", rome_js_syntax::JsSyntaxKind::BIGINT_KW)
        .variant("OVERRIDE_KW", rome_js_syntax::JsSyntaxKind::OVERRIDE_KW)
        .variant("OF_KW", rome_js_syntax::JsSyntaxKind::OF_KW)
        .variant("OUT_KW", rome_js_syntax::JsSyntaxKind::OUT_KW)
        .variant(
            "JS_NUMBER_LITERAL",
            rome_js_syntax::JsSyntaxKind::JS_NUMBER_LITERAL,
        )
        .variant(
            "JS_BIGINT_LITERAL",
            rome_js_syntax::JsSyntaxKind::JS_BIGINT_LITERAL,
        )
        .variant(
            "JS_STRING_LITERAL",
            rome_js_syntax::JsSyntaxKind::JS_STRING_LITERAL,
        )
        .variant(
            "JS_REGEX_LITERAL",
            rome_js_syntax::JsSyntaxKind::JS_REGEX_LITERAL,
        )
        .variant(
            "JSX_TEXT_LITERAL",
            rome_js_syntax::JsSyntaxKind::JSX_TEXT_LITERAL,
        )
        .variant(
            "JSX_STRING_LITERAL",
            rome_js_syntax::JsSyntaxKind::JSX_STRING_LITERAL,
        )
        .variant("TARGET", rome_js_syntax::JsSyntaxKind::TARGET)
        .variant("META", rome_js_syntax::JsSyntaxKind::META)
        .variant("HASH", rome_js_syntax::JsSyntaxKind::HASH)
        .variant(
            "TEMPLATE_CHUNK",
            rome_js_syntax::JsSyntaxKind::TEMPLATE_CHUNK,
        )
        .variant("DOLLAR_CURLY", rome_js_syntax::JsSyntaxKind::DOLLAR_CURLY)
        .variant("ERROR_TOKEN", rome_js_syntax::JsSyntaxKind::ERROR_TOKEN)
        .variant("IDENT", rome_js_syntax::JsSyntaxKind::IDENT)
        .variant("JSX_IDENT", rome_js_syntax::JsSyntaxKind::JSX_IDENT)
        .variant("NEWLINE", rome_js_syntax::JsSyntaxKind::NEWLINE)
        .variant("WHITESPACE", rome_js_syntax::JsSyntaxKind::WHITESPACE)
        .variant("COMMENT", rome_js_syntax::JsSyntaxKind::COMMENT)
        .variant(
            "MULTILINE_COMMENT",
            rome_js_syntax::JsSyntaxKind::MULTILINE_COMMENT,
        )
        .variant("JS_SHEBANG", rome_js_syntax::JsSyntaxKind::JS_SHEBANG)
        .variant("JS_MODULE", rome_js_syntax::JsSyntaxKind::JS_MODULE)
        .variant(
            "JS_MODULE_ITEM_LIST",
            rome_js_syntax::JsSyntaxKind::JS_MODULE_ITEM_LIST,
        )
        .variant("JS_SCRIPT", rome_js_syntax::JsSyntaxKind::JS_SCRIPT)
        .variant(
            "JS_EXPRESSION_SNIPPED",
            rome_js_syntax::JsSyntaxKind::JS_EXPRESSION_SNIPPED,
        )
        .variant("JS_DIRECTIVE", rome_js_syntax::JsSyntaxKind::JS_DIRECTIVE)
        .variant(
            "JS_DIRECTIVE_LIST",
            rome_js_syntax::JsSyntaxKind::JS_DIRECTIVE_LIST,
        )
        .variant(
            "JS_STATEMENT_LIST",
            rome_js_syntax::JsSyntaxKind::JS_STATEMENT_LIST,
        )
        .variant(
            "JS_BLOCK_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_BLOCK_STATEMENT,
        )
        .variant(
            "JS_FUNCTION_BODY",
            rome_js_syntax::JsSyntaxKind::JS_FUNCTION_BODY,
        )
        .variant(
            "JS_VARIABLE_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_VARIABLE_STATEMENT,
        )
        .variant(
            "JS_VARIABLE_DECLARATION",
            rome_js_syntax::JsSyntaxKind::JS_VARIABLE_DECLARATION,
        )
        .variant(
            "JS_VARIABLE_DECLARATOR_LIST",
            rome_js_syntax::JsSyntaxKind::JS_VARIABLE_DECLARATOR_LIST,
        )
        .variant(
            "JS_VARIABLE_DECLARATOR",
            rome_js_syntax::JsSyntaxKind::JS_VARIABLE_DECLARATOR,
        )
        .variant(
            "JS_VARIABLE_DECLARATION_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_VARIABLE_DECLARATION_CLAUSE,
        )
        .variant(
            "TS_DEFINITE_VARIABLE_ANNOTATION",
            rome_js_syntax::JsSyntaxKind::TS_DEFINITE_VARIABLE_ANNOTATION,
        )
        .variant(
            "JS_INITIALIZER_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_INITIALIZER_CLAUSE,
        )
        .variant(
            "JS_EMPTY_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_EMPTY_STATEMENT,
        )
        .variant(
            "JS_EXPRESSION_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_EXPRESSION_STATEMENT,
        )
        .variant(
            "JS_IF_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_IF_STATEMENT,
        )
        .variant(
            "JS_ELSE_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_ELSE_CLAUSE,
        )
        .variant(
            "JS_DO_WHILE_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_DO_WHILE_STATEMENT,
        )
        .variant(
            "JS_WHILE_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_WHILE_STATEMENT,
        )
        .variant(
            "JS_FOR_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_FOR_STATEMENT,
        )
        .variant(
            "JS_FOR_IN_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_FOR_IN_STATEMENT,
        )
        .variant(
            "JS_FOR_OF_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_FOR_OF_STATEMENT,
        )
        .variant(
            "JS_FOR_VARIABLE_DECLARATION",
            rome_js_syntax::JsSyntaxKind::JS_FOR_VARIABLE_DECLARATION,
        )
        .variant(
            "JS_CONTINUE_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_CONTINUE_STATEMENT,
        )
        .variant(
            "JS_BREAK_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_BREAK_STATEMENT,
        )
        .variant(
            "JS_RETURN_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_RETURN_STATEMENT,
        )
        .variant(
            "JS_WITH_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_WITH_STATEMENT,
        )
        .variant(
            "JS_SWITCH_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_SWITCH_STATEMENT,
        )
        .variant(
            "JS_SWITCH_CASE_LIST",
            rome_js_syntax::JsSyntaxKind::JS_SWITCH_CASE_LIST,
        )
        .variant(
            "JS_CASE_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_CASE_CLAUSE,
        )
        .variant(
            "JS_DEFAULT_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_DEFAULT_CLAUSE,
        )
        .variant(
            "JS_LABELED_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_LABELED_STATEMENT,
        )
        .variant(
            "JS_THROW_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_THROW_STATEMENT,
        )
        .variant(
            "JS_TRY_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_TRY_STATEMENT,
        )
        .variant(
            "JS_TRY_FINALLY_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_TRY_FINALLY_STATEMENT,
        )
        .variant(
            "JS_CATCH_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_CATCH_CLAUSE,
        )
        .variant(
            "JS_CATCH_DECLARATION",
            rome_js_syntax::JsSyntaxKind::JS_CATCH_DECLARATION,
        )
        .variant(
            "JS_FINALLY_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_FINALLY_CLAUSE,
        )
        .variant(
            "JS_DEBUGGER_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_DEBUGGER_STATEMENT,
        )
        .variant(
            "JS_FUNCTION_DECLARATION",
            rome_js_syntax::JsSyntaxKind::JS_FUNCTION_DECLARATION,
        )
        .variant("JS_PARAMETERS", rome_js_syntax::JsSyntaxKind::JS_PARAMETERS)
        .variant(
            "JS_PARAMETER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_PARAMETER_LIST,
        )
        .variant(
            "JS_FORMAL_PARAMETER",
            rome_js_syntax::JsSyntaxKind::JS_FORMAL_PARAMETER,
        )
        .variant(
            "JS_REST_PARAMETER",
            rome_js_syntax::JsSyntaxKind::JS_REST_PARAMETER,
        )
        .variant(
            "TS_THIS_PARAMETER",
            rome_js_syntax::JsSyntaxKind::TS_THIS_PARAMETER,
        )
        .variant(
            "TS_PROPERTY_PARAMETER",
            rome_js_syntax::JsSyntaxKind::TS_PROPERTY_PARAMETER,
        )
        .variant(
            "TS_PROPERTY_PARAMETER_MODIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::TS_PROPERTY_PARAMETER_MODIFIER_LIST,
        )
        .variant(
            "TS_TYPE_ANNOTATION",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_ANNOTATION,
        )
        .variant(
            "TS_RETURN_TYPE_ANNOTATION",
            rome_js_syntax::JsSyntaxKind::TS_RETURN_TYPE_ANNOTATION,
        )
        .variant(
            "JS_IDENTIFIER_BINDING",
            rome_js_syntax::JsSyntaxKind::JS_IDENTIFIER_BINDING,
        )
        .variant(
            "JS_IDENTIFIER_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_IDENTIFIER_EXPRESSION,
        )
        .variant(
            "JS_REFERENCE_IDENTIFIER",
            rome_js_syntax::JsSyntaxKind::JS_REFERENCE_IDENTIFIER,
        )
        .variant("JS_NAME", rome_js_syntax::JsSyntaxKind::JS_NAME)
        .variant(
            "JS_PRIVATE_NAME",
            rome_js_syntax::JsSyntaxKind::JS_PRIVATE_NAME,
        )
        .variant(
            "JS_THIS_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_THIS_EXPRESSION,
        )
        .variant(
            "JS_ARRAY_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_ARRAY_EXPRESSION,
        )
        .variant(
            "JS_ARRAY_ELEMENT_LIST",
            rome_js_syntax::JsSyntaxKind::JS_ARRAY_ELEMENT_LIST,
        )
        .variant("JS_ARRAY_HOLE", rome_js_syntax::JsSyntaxKind::JS_ARRAY_HOLE)
        .variant(
            "JS_COMPUTED_MEMBER_NAME",
            rome_js_syntax::JsSyntaxKind::JS_COMPUTED_MEMBER_NAME,
        )
        .variant(
            "JS_LITERAL_MEMBER_NAME",
            rome_js_syntax::JsSyntaxKind::JS_LITERAL_MEMBER_NAME,
        )
        .variant(
            "JS_OBJECT_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_EXPRESSION,
        )
        .variant(
            "JS_OBJECT_MEMBER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_MEMBER_LIST,
        )
        .variant(
            "JS_PROPERTY_OBJECT_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_PROPERTY_OBJECT_MEMBER,
        )
        .variant(
            "JS_GETTER_OBJECT_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_GETTER_OBJECT_MEMBER,
        )
        .variant(
            "JS_SETTER_OBJECT_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_SETTER_OBJECT_MEMBER,
        )
        .variant(
            "JS_METHOD_OBJECT_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_METHOD_OBJECT_MEMBER,
        )
        .variant(
            "JS_SUPER_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_SUPER_EXPRESSION,
        )
        .variant(
            "JS_PARENTHESIZED_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_PARENTHESIZED_EXPRESSION,
        )
        .variant(
            "JS_NEW_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_NEW_EXPRESSION,
        )
        .variant(
            "JS_FUNCTION_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_FUNCTION_EXPRESSION,
        )
        .variant(
            "JS_STATIC_MEMBER_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_STATIC_MEMBER_EXPRESSION,
        )
        .variant(
            "JS_COMPUTED_MEMBER_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_COMPUTED_MEMBER_EXPRESSION,
        )
        .variant(
            "JS_CALL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_CALL_EXPRESSION,
        )
        .variant(
            "JS_UNARY_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_UNARY_EXPRESSION,
        )
        .variant(
            "JS_PRE_UPDATE_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_PRE_UPDATE_EXPRESSION,
        )
        .variant(
            "JS_POST_UPDATE_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_POST_UPDATE_EXPRESSION,
        )
        .variant(
            "JS_BINARY_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_BINARY_EXPRESSION,
        )
        .variant(
            "JS_INSTANCEOF_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_INSTANCEOF_EXPRESSION,
        )
        .variant(
            "JS_IN_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_IN_EXPRESSION,
        )
        .variant(
            "JS_LOGICAL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_LOGICAL_EXPRESSION,
        )
        .variant(
            "JS_CONDITIONAL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_CONDITIONAL_EXPRESSION,
        )
        .variant(
            "JS_ASSIGNMENT_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_ASSIGNMENT_EXPRESSION,
        )
        .variant(
            "JS_SEQUENCE_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_SEQUENCE_EXPRESSION,
        )
        .variant(
            "JS_CALL_ARGUMENTS",
            rome_js_syntax::JsSyntaxKind::JS_CALL_ARGUMENTS,
        )
        .variant(
            "JS_CALL_ARGUMENT_LIST",
            rome_js_syntax::JsSyntaxKind::JS_CALL_ARGUMENT_LIST,
        )
        .variant(
            "JS_STRING_LITERAL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_STRING_LITERAL_EXPRESSION,
        )
        .variant(
            "JS_NUMBER_LITERAL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_NUMBER_LITERAL_EXPRESSION,
        )
        .variant(
            "JS_BIGINT_LITERAL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_BIGINT_LITERAL_EXPRESSION,
        )
        .variant(
            "JS_BOOLEAN_LITERAL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_BOOLEAN_LITERAL_EXPRESSION,
        )
        .variant(
            "JS_NULL_LITERAL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_NULL_LITERAL_EXPRESSION,
        )
        .variant(
            "JS_REGEX_LITERAL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_REGEX_LITERAL_EXPRESSION,
        )
        .variant(
            "JS_TEMPLATE_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_TEMPLATE_EXPRESSION,
        )
        .variant(
            "JS_TEMPLATE_ELEMENT",
            rome_js_syntax::JsSyntaxKind::JS_TEMPLATE_ELEMENT,
        )
        .variant(
            "JS_TEMPLATE_CHUNK_ELEMENT",
            rome_js_syntax::JsSyntaxKind::JS_TEMPLATE_CHUNK_ELEMENT,
        )
        .variant(
            "JS_TEMPLATE_ELEMENT_LIST",
            rome_js_syntax::JsSyntaxKind::JS_TEMPLATE_ELEMENT_LIST,
        )
        .variant(
            "JS_IMPORT_CALL_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_CALL_EXPRESSION,
        )
        .variant(
            "JS_NEW_TARGET_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_NEW_TARGET_EXPRESSION,
        )
        .variant(
            "JS_IMPORT_META_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_META_EXPRESSION,
        )
        .variant(
            "JS_SHORTHAND_PROPERTY_OBJECT_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_SHORTHAND_PROPERTY_OBJECT_MEMBER,
        )
        .variant("JS_SPREAD", rome_js_syntax::JsSyntaxKind::JS_SPREAD)
        .variant(
            "JS_OBJECT_BINDING_PATTERN",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_BINDING_PATTERN,
        )
        .variant(
            "JS_ARRAY_BINDING_PATTERN",
            rome_js_syntax::JsSyntaxKind::JS_ARRAY_BINDING_PATTERN,
        )
        .variant(
            "JS_ARRAY_BINDING_PATTERN_ELEMENT_LIST",
            rome_js_syntax::JsSyntaxKind::JS_ARRAY_BINDING_PATTERN_ELEMENT_LIST,
        )
        .variant(
            "JS_BINDING_PATTERN_WITH_DEFAULT",
            rome_js_syntax::JsSyntaxKind::JS_BINDING_PATTERN_WITH_DEFAULT,
        )
        .variant(
            "JS_ARRAY_BINDING_PATTERN_REST_ELEMENT",
            rome_js_syntax::JsSyntaxKind::JS_ARRAY_BINDING_PATTERN_REST_ELEMENT,
        )
        .variant(
            "JS_OBJECT_BINDING_PATTERN_PROPERTY_LIST",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_BINDING_PATTERN_PROPERTY_LIST,
        )
        .variant(
            "JS_OBJECT_BINDING_PATTERN_REST",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_BINDING_PATTERN_REST,
        )
        .variant(
            "JS_OBJECT_BINDING_PATTERN_PROPERTY",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_BINDING_PATTERN_PROPERTY,
        )
        .variant(
            "JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_BINDING_PATTERN_SHORTHAND_PROPERTY,
        )
        .variant(
            "JS_ARROW_FUNCTION_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_ARROW_FUNCTION_EXPRESSION,
        )
        .variant(
            "JS_YIELD_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_YIELD_EXPRESSION,
        )
        .variant(
            "JS_YIELD_ARGUMENT",
            rome_js_syntax::JsSyntaxKind::JS_YIELD_ARGUMENT,
        )
        .variant(
            "JS_CLASS_DECLARATION",
            rome_js_syntax::JsSyntaxKind::JS_CLASS_DECLARATION,
        )
        .variant(
            "JS_CLASS_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_CLASS_EXPRESSION,
        )
        .variant(
            "JS_CLASS_MEMBER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_CLASS_MEMBER_LIST,
        )
        .variant(
            "JS_STATIC_MODIFIER",
            rome_js_syntax::JsSyntaxKind::JS_STATIC_MODIFIER,
        )
        .variant(
            "JS_ACCESSOR_MODIFIER",
            rome_js_syntax::JsSyntaxKind::JS_ACCESSOR_MODIFIER,
        )
        .variant(
            "TS_DECLARE_MODIFIER",
            rome_js_syntax::JsSyntaxKind::TS_DECLARE_MODIFIER,
        )
        .variant(
            "TS_READONLY_MODIFIER",
            rome_js_syntax::JsSyntaxKind::TS_READONLY_MODIFIER,
        )
        .variant(
            "TS_ABSTRACT_MODIFIER",
            rome_js_syntax::JsSyntaxKind::TS_ABSTRACT_MODIFIER,
        )
        .variant(
            "TS_OVERRIDE_MODIFIER",
            rome_js_syntax::JsSyntaxKind::TS_OVERRIDE_MODIFIER,
        )
        .variant(
            "TS_ACCESSIBILITY_MODIFIER",
            rome_js_syntax::JsSyntaxKind::TS_ACCESSIBILITY_MODIFIER,
        )
        .variant(
            "TS_CONST_MODIFIER",
            rome_js_syntax::JsSyntaxKind::TS_CONST_MODIFIER,
        )
        .variant(
            "TS_IN_MODIFIER",
            rome_js_syntax::JsSyntaxKind::TS_IN_MODIFIER,
        )
        .variant(
            "TS_OUT_MODIFIER",
            rome_js_syntax::JsSyntaxKind::TS_OUT_MODIFIER,
        )
        .variant(
            "JS_EXTENDS_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_EXTENDS_CLAUSE,
        )
        .variant(
            "TS_IMPLEMENTS_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_IMPLEMENTS_CLAUSE,
        )
        .variant(
            "JS_PRIVATE_CLASS_MEMBER_NAME",
            rome_js_syntax::JsSyntaxKind::JS_PRIVATE_CLASS_MEMBER_NAME,
        )
        .variant(
            "JS_CONSTRUCTOR_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_CONSTRUCTOR_CLASS_MEMBER,
        )
        .variant(
            "TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_CONSTRUCTOR_SIGNATURE_CLASS_MEMBER,
        )
        .variant(
            "JS_CONSTRUCTOR_MODIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_CONSTRUCTOR_MODIFIER_LIST,
        )
        .variant(
            "JS_CONSTRUCTOR_PARAMETER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_CONSTRUCTOR_PARAMETER_LIST,
        )
        .variant(
            "JS_CONSTRUCTOR_PARAMETERS",
            rome_js_syntax::JsSyntaxKind::JS_CONSTRUCTOR_PARAMETERS,
        )
        .variant(
            "JS_PROPERTY_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_PROPERTY_CLASS_MEMBER,
        )
        .variant(
            "JS_PROPERTY_MODIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_PROPERTY_MODIFIER_LIST,
        )
        .variant(
            "TS_OPTIONAL_PROPERTY_ANNOTATION",
            rome_js_syntax::JsSyntaxKind::TS_OPTIONAL_PROPERTY_ANNOTATION,
        )
        .variant(
            "TS_DEFINITE_PROPERTY_ANNOTATION",
            rome_js_syntax::JsSyntaxKind::TS_DEFINITE_PROPERTY_ANNOTATION,
        )
        .variant(
            "JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_STATIC_INITIALIZATION_BLOCK_CLASS_MEMBER,
        )
        .variant(
            "JS_METHOD_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_METHOD_CLASS_MEMBER,
        )
        .variant(
            "JS_METHOD_MODIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_METHOD_MODIFIER_LIST,
        )
        .variant(
            "JS_GETTER_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_GETTER_CLASS_MEMBER,
        )
        .variant(
            "JS_SETTER_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_SETTER_CLASS_MEMBER,
        )
        .variant(
            "JS_EMPTY_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_EMPTY_CLASS_MEMBER,
        )
        .variant(
            "JS_ASSIGNMENT_WITH_DEFAULT",
            rome_js_syntax::JsSyntaxKind::JS_ASSIGNMENT_WITH_DEFAULT,
        )
        .variant(
            "JS_PARENTHESIZED_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::JS_PARENTHESIZED_ASSIGNMENT,
        )
        .variant(
            "JS_IDENTIFIER_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::JS_IDENTIFIER_ASSIGNMENT,
        )
        .variant(
            "JS_STATIC_MEMBER_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::JS_STATIC_MEMBER_ASSIGNMENT,
        )
        .variant(
            "JS_COMPUTED_MEMBER_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::JS_COMPUTED_MEMBER_ASSIGNMENT,
        )
        .variant(
            "TS_NON_NULL_ASSERTION_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::TS_NON_NULL_ASSERTION_ASSIGNMENT,
        )
        .variant(
            "TS_AS_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::TS_AS_ASSIGNMENT,
        )
        .variant(
            "TS_SATISFIES_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::TS_SATISFIES_ASSIGNMENT,
        )
        .variant(
            "TS_TYPE_ASSERTION_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_ASSERTION_ASSIGNMENT,
        )
        .variant(
            "JS_ARRAY_ASSIGNMENT_PATTERN",
            rome_js_syntax::JsSyntaxKind::JS_ARRAY_ASSIGNMENT_PATTERN,
        )
        .variant(
            "JS_ARRAY_ASSIGNMENT_PATTERN_ELEMENT_LIST",
            rome_js_syntax::JsSyntaxKind::JS_ARRAY_ASSIGNMENT_PATTERN_ELEMENT_LIST,
        )
        .variant(
            "JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT",
            rome_js_syntax::JsSyntaxKind::JS_ARRAY_ASSIGNMENT_PATTERN_REST_ELEMENT,
        )
        .variant(
            "JS_OBJECT_ASSIGNMENT_PATTERN",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_ASSIGNMENT_PATTERN,
        )
        .variant(
            "JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY_LIST",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY_LIST,
        )
        .variant(
            "JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_ASSIGNMENT_PATTERN_SHORTHAND_PROPERTY,
        )
        .variant(
            "JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_ASSIGNMENT_PATTERN_PROPERTY,
        )
        .variant(
            "JS_OBJECT_ASSIGNMENT_PATTERN_REST",
            rome_js_syntax::JsSyntaxKind::JS_OBJECT_ASSIGNMENT_PATTERN_REST,
        )
        .variant("JS_IMPORT", rome_js_syntax::JsSyntaxKind::JS_IMPORT)
        .variant(
            "JS_IMPORT_BARE_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_BARE_CLAUSE,
        )
        .variant(
            "JS_IMPORT_DEFAULT_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_DEFAULT_CLAUSE,
        )
        .variant(
            "JS_IMPORT_NAMESPACE_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_NAMESPACE_CLAUSE,
        )
        .variant(
            "JS_IMPORT_NAMED_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_NAMED_CLAUSE,
        )
        .variant(
            "JS_NAMED_IMPORT_SPECIFIERS",
            rome_js_syntax::JsSyntaxKind::JS_NAMED_IMPORT_SPECIFIERS,
        )
        .variant(
            "JS_NAMED_IMPORT_SPECIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_NAMED_IMPORT_SPECIFIER_LIST,
        )
        .variant(
            "JS_NAMESPACE_IMPORT_SPECIFIER",
            rome_js_syntax::JsSyntaxKind::JS_NAMESPACE_IMPORT_SPECIFIER,
        )
        .variant(
            "JS_DEFAULT_IMPORT_SPECIFIER",
            rome_js_syntax::JsSyntaxKind::JS_DEFAULT_IMPORT_SPECIFIER,
        )
        .variant(
            "JS_NAMED_IMPORT_SPECIFIER",
            rome_js_syntax::JsSyntaxKind::JS_NAMED_IMPORT_SPECIFIER,
        )
        .variant(
            "JS_SHORTHAND_NAMED_IMPORT_SPECIFIER",
            rome_js_syntax::JsSyntaxKind::JS_SHORTHAND_NAMED_IMPORT_SPECIFIER,
        )
        .variant(
            "JS_IMPORT_ASSERTION",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_ASSERTION,
        )
        .variant(
            "JS_IMPORT_ASSERTION_ENTRY_LIST",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_ASSERTION_ENTRY_LIST,
        )
        .variant(
            "JS_IMPORT_ASSERTION_ENTRY",
            rome_js_syntax::JsSyntaxKind::JS_IMPORT_ASSERTION_ENTRY,
        )
        .variant(
            "JS_MODULE_SOURCE",
            rome_js_syntax::JsSyntaxKind::JS_MODULE_SOURCE,
        )
        .variant("JS_EXPORT", rome_js_syntax::JsSyntaxKind::JS_EXPORT)
        .variant(
            "JS_EXPORT_NAMED_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_NAMED_CLAUSE,
        )
        .variant(
            "JS_EXPORT_NAMED_SPECIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_NAMED_SPECIFIER_LIST,
        )
        .variant(
            "JS_EXPORT_NAMED_SHORTHAND_SPECIFIER",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_NAMED_SHORTHAND_SPECIFIER,
        )
        .variant(
            "JS_EXPORT_NAMED_SPECIFIER",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_NAMED_SPECIFIER,
        )
        .variant(
            "JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_DEFAULT_EXPRESSION_CLAUSE,
        )
        .variant(
            "JS_EXPORT_DEFAULT_DECLARATION_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_DEFAULT_DECLARATION_CLAUSE,
        )
        .variant(
            "JS_CLASS_EXPORT_DEFAULT_DECLARATION",
            rome_js_syntax::JsSyntaxKind::JS_CLASS_EXPORT_DEFAULT_DECLARATION,
        )
        .variant(
            "JS_FUNCTION_EXPORT_DEFAULT_DECLARATION",
            rome_js_syntax::JsSyntaxKind::JS_FUNCTION_EXPORT_DEFAULT_DECLARATION,
        )
        .variant(
            "JS_EXPORT_FROM_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_FROM_CLAUSE,
        )
        .variant(
            "JS_EXPORT_NAMED_FROM_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_NAMED_FROM_CLAUSE,
        )
        .variant(
            "JS_EXPORT_NAMED_FROM_SPECIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_NAMED_FROM_SPECIFIER_LIST,
        )
        .variant(
            "JS_EXPORT_NAMED_FROM_SPECIFIER",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_NAMED_FROM_SPECIFIER,
        )
        .variant(
            "JS_EXPORT_AS_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JS_EXPORT_AS_CLAUSE,
        )
        .variant(
            "TS_EXPORT_AS_NAMESPACE_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_EXPORT_AS_NAMESPACE_CLAUSE,
        )
        .variant(
            "TS_EXPORT_ASSIGNMENT_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_EXPORT_ASSIGNMENT_CLAUSE,
        )
        .variant(
            "TS_EXPORT_DECLARE_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_EXPORT_DECLARE_CLAUSE,
        )
        .variant(
            "JS_LITERAL_EXPORT_NAME",
            rome_js_syntax::JsSyntaxKind::JS_LITERAL_EXPORT_NAME,
        )
        .variant(
            "JS_AWAIT_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_AWAIT_EXPRESSION,
        )
        .variant("JS_DECORATOR", rome_js_syntax::JsSyntaxKind::JS_DECORATOR)
        .variant(
            "JS_DECORATOR_LIST",
            rome_js_syntax::JsSyntaxKind::JS_DECORATOR_LIST,
        )
        .variant(
            "TS_IDENTIFIER_BINDING",
            rome_js_syntax::JsSyntaxKind::TS_IDENTIFIER_BINDING,
        )
        .variant("TS_ANY_TYPE", rome_js_syntax::JsSyntaxKind::TS_ANY_TYPE)
        .variant(
            "TS_UNKNOWN_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_UNKNOWN_TYPE,
        )
        .variant(
            "TS_NUMBER_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_NUMBER_TYPE,
        )
        .variant(
            "TS_NON_PRIMITIVE_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_NON_PRIMITIVE_TYPE,
        )
        .variant(
            "TS_BOOLEAN_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_BOOLEAN_TYPE,
        )
        .variant(
            "TS_BIGINT_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_BIGINT_TYPE,
        )
        .variant(
            "TS_STRING_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_STRING_TYPE,
        )
        .variant(
            "TS_SYMBOL_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_SYMBOL_TYPE,
        )
        .variant("TS_VOID_TYPE", rome_js_syntax::JsSyntaxKind::TS_VOID_TYPE)
        .variant(
            "TS_UNDEFINED_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_UNDEFINED_TYPE,
        )
        .variant("TS_NEVER_TYPE", rome_js_syntax::JsSyntaxKind::TS_NEVER_TYPE)
        .variant("TS_THIS_TYPE", rome_js_syntax::JsSyntaxKind::TS_THIS_TYPE)
        .variant(
            "TS_TYPEOF_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_TYPEOF_TYPE,
        )
        .variant(
            "TS_PARENTHESIZED_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_PARENTHESIZED_TYPE,
        )
        .variant(
            "TS_MAPPED_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_MAPPED_TYPE,
        )
        .variant(
            "TS_MAPPED_TYPE_OPTIONAL_MODIFIER_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_MAPPED_TYPE_OPTIONAL_MODIFIER_CLAUSE,
        )
        .variant(
            "TS_MAPPED_TYPE_READONLY_MODIFIER_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_MAPPED_TYPE_READONLY_MODIFIER_CLAUSE,
        )
        .variant(
            "TS_MAPPED_TYPE_AS_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_MAPPED_TYPE_AS_CLAUSE,
        )
        .variant(
            "TS_TYPE_ALIAS_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_ALIAS_DECLARATION,
        )
        .variant(
            "TS_MODULE_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_MODULE_DECLARATION,
        )
        .variant(
            "TS_GLOBAL_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_GLOBAL_DECLARATION,
        )
        .variant(
            "TS_QUALIFIED_MODULE_NAME",
            rome_js_syntax::JsSyntaxKind::TS_QUALIFIED_MODULE_NAME,
        )
        .variant(
            "TS_MODULE_BLOCK",
            rome_js_syntax::JsSyntaxKind::TS_MODULE_BLOCK,
        )
        .variant(
            "TS_EXTERNAL_MODULE_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_EXTERNAL_MODULE_DECLARATION,
        )
        .variant(
            "TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY",
            rome_js_syntax::JsSyntaxKind::TS_EMPTY_EXTERNAL_MODULE_DECLARATION_BODY,
        )
        .variant(
            "TS_QUALIFIED_NAME",
            rome_js_syntax::JsSyntaxKind::TS_QUALIFIED_NAME,
        )
        .variant(
            "TS_REFERENCE_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_REFERENCE_TYPE,
        )
        .variant("TS_UNION_TYPE", rome_js_syntax::JsSyntaxKind::TS_UNION_TYPE)
        .variant(
            "TS_UNION_TYPE_VARIANT_LIST",
            rome_js_syntax::JsSyntaxKind::TS_UNION_TYPE_VARIANT_LIST,
        )
        .variant(
            "TS_INTERSECTION_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_INTERSECTION_TYPE,
        )
        .variant(
            "TS_INTERSECTION_TYPE_ELEMENT_LIST",
            rome_js_syntax::JsSyntaxKind::TS_INTERSECTION_TYPE_ELEMENT_LIST,
        )
        .variant(
            "TS_OBJECT_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_OBJECT_TYPE,
        )
        .variant(
            "TS_TYPE_MEMBER_LIST",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_MEMBER_LIST,
        )
        .variant(
            "TS_INTERFACE_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_INTERFACE_DECLARATION,
        )
        .variant(
            "TS_EXTENDS_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_EXTENDS_CLAUSE,
        )
        .variant(
            "TS_PROPERTY_SIGNATURE_TYPE_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_PROPERTY_SIGNATURE_TYPE_MEMBER,
        )
        .variant(
            "TS_METHOD_SIGNATURE_TYPE_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_METHOD_SIGNATURE_TYPE_MEMBER,
        )
        .variant(
            "TS_CALL_SIGNATURE_TYPE_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_CALL_SIGNATURE_TYPE_MEMBER,
        )
        .variant(
            "TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_CONSTRUCT_SIGNATURE_TYPE_MEMBER,
        )
        .variant(
            "TS_GETTER_SIGNATURE_TYPE_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_GETTER_SIGNATURE_TYPE_MEMBER,
        )
        .variant(
            "TS_SETTER_SIGNATURE_TYPE_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_SETTER_SIGNATURE_TYPE_MEMBER,
        )
        .variant(
            "TS_INDEX_SIGNATURE_TYPE_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_INDEX_SIGNATURE_TYPE_MEMBER,
        )
        .variant(
            "TS_IMPORT_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_IMPORT_TYPE,
        )
        .variant(
            "TS_IMPORT_TYPE_QUALIFIER",
            rome_js_syntax::JsSyntaxKind::TS_IMPORT_TYPE_QUALIFIER,
        )
        .variant("TS_ARRAY_TYPE", rome_js_syntax::JsSyntaxKind::TS_ARRAY_TYPE)
        .variant(
            "TS_INDEXED_ACCESS_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_INDEXED_ACCESS_TYPE,
        )
        .variant("TS_TUPLE_TYPE", rome_js_syntax::JsSyntaxKind::TS_TUPLE_TYPE)
        .variant(
            "TS_TUPLE_TYPE_ELEMENT_LIST",
            rome_js_syntax::JsSyntaxKind::TS_TUPLE_TYPE_ELEMENT_LIST,
        )
        .variant(
            "TS_REST_TUPLE_TYPE_ELEMENT",
            rome_js_syntax::JsSyntaxKind::TS_REST_TUPLE_TYPE_ELEMENT,
        )
        .variant(
            "TS_OPTIONAL_TUPLE_TYPE_ELEMENT",
            rome_js_syntax::JsSyntaxKind::TS_OPTIONAL_TUPLE_TYPE_ELEMENT,
        )
        .variant(
            "TS_NAMED_TUPLE_TYPE_ELEMENT",
            rome_js_syntax::JsSyntaxKind::TS_NAMED_TUPLE_TYPE_ELEMENT,
        )
        .variant(
            "TS_TYPE_OPERATOR_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_OPERATOR_TYPE,
        )
        .variant("TS_INFER_TYPE", rome_js_syntax::JsSyntaxKind::TS_INFER_TYPE)
        .variant(
            "TS_CONSTRUCTOR_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_CONSTRUCTOR_TYPE,
        )
        .variant(
            "TS_FUNCTION_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_FUNCTION_TYPE,
        )
        .variant(
            "TS_PREDICATE_RETURN_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_PREDICATE_RETURN_TYPE,
        )
        .variant(
            "TS_ASSERTS_RETURN_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_ASSERTS_RETURN_TYPE,
        )
        .variant(
            "TS_ASSERTS_CONDITION",
            rome_js_syntax::JsSyntaxKind::TS_ASSERTS_CONDITION,
        )
        .variant(
            "TS_TYPE_PARAMETERS",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_PARAMETERS,
        )
        .variant(
            "TS_TYPE_PARAMETER_LIST",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_PARAMETER_LIST,
        )
        .variant(
            "TS_TYPE_PARAMETER",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_PARAMETER,
        )
        .variant(
            "TS_TYPE_PARAMETER_MODIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_PARAMETER_MODIFIER_LIST,
        )
        .variant(
            "TS_TYPE_PARAMETER_NAME",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_PARAMETER_NAME,
        )
        .variant(
            "TS_TYPE_CONSTRAINT_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_CONSTRAINT_CLAUSE,
        )
        .variant(
            "TS_DEFAULT_TYPE_CLAUSE",
            rome_js_syntax::JsSyntaxKind::TS_DEFAULT_TYPE_CLAUSE,
        )
        .variant(
            "TS_STRING_LITERAL_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_STRING_LITERAL_TYPE,
        )
        .variant(
            "TS_NUMBER_LITERAL_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_NUMBER_LITERAL_TYPE,
        )
        .variant(
            "TS_BIGINT_LITERAL_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_BIGINT_LITERAL_TYPE,
        )
        .variant(
            "TS_BOOLEAN_LITERAL_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_BOOLEAN_LITERAL_TYPE,
        )
        .variant(
            "TS_NULL_LITERAL_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_NULL_LITERAL_TYPE,
        )
        .variant(
            "TS_TEMPLATE_LITERAL_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_TEMPLATE_LITERAL_TYPE,
        )
        .variant(
            "TS_TEMPLATE_ELEMENT_LIST",
            rome_js_syntax::JsSyntaxKind::TS_TEMPLATE_ELEMENT_LIST,
        )
        .variant(
            "TS_TEMPLATE_CHUNK_ELEMENT",
            rome_js_syntax::JsSyntaxKind::TS_TEMPLATE_CHUNK_ELEMENT,
        )
        .variant(
            "TS_TEMPLATE_ELEMENT",
            rome_js_syntax::JsSyntaxKind::TS_TEMPLATE_ELEMENT,
        )
        .variant(
            "TS_TYPE_ARGUMENTS",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_ARGUMENTS,
        )
        .variant(
            "TS_TYPE_ARGUMENT_LIST",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_ARGUMENT_LIST,
        )
        .variant("TS_TYPE_LIST", rome_js_syntax::JsSyntaxKind::TS_TYPE_LIST)
        .variant("TS_EXTENDS", rome_js_syntax::JsSyntaxKind::TS_EXTENDS)
        .variant(
            "TS_CONDITIONAL_TYPE",
            rome_js_syntax::JsSyntaxKind::TS_CONDITIONAL_TYPE,
        )
        .variant(
            "TS_NON_NULL_ASSERTION_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::TS_NON_NULL_ASSERTION_EXPRESSION,
        )
        .variant(
            "TS_TYPE_ASSERTION_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::TS_TYPE_ASSERTION_EXPRESSION,
        )
        .variant(
            "TS_AS_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::TS_AS_EXPRESSION,
        )
        .variant(
            "TS_SATISFIES_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::TS_SATISFIES_EXPRESSION,
        )
        .variant(
            "TS_INSTANTIATION_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::TS_INSTANTIATION_EXPRESSION,
        )
        .variant(
            "TS_ENUM_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_ENUM_DECLARATION,
        )
        .variant(
            "TS_ENUM_MEMBER_LIST",
            rome_js_syntax::JsSyntaxKind::TS_ENUM_MEMBER_LIST,
        )
        .variant(
            "TS_ENUM_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_ENUM_MEMBER,
        )
        .variant(
            "TS_IMPORT_EQUALS_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_IMPORT_EQUALS_DECLARATION,
        )
        .variant(
            "TS_EXTERNAL_MODULE_REFERENCE",
            rome_js_syntax::JsSyntaxKind::TS_EXTERNAL_MODULE_REFERENCE,
        )
        .variant(
            "TS_NAME_WITH_TYPE_ARGUMENTS",
            rome_js_syntax::JsSyntaxKind::TS_NAME_WITH_TYPE_ARGUMENTS,
        )
        .variant(
            "TS_DECLARE_FUNCTION_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_DECLARE_FUNCTION_DECLARATION,
        )
        .variant(
            "TS_DECLARE_FUNCTION_EXPORT_DEFAULT_DECLARATION",
            rome_js_syntax::JsSyntaxKind::TS_DECLARE_FUNCTION_EXPORT_DEFAULT_DECLARATION,
        )
        .variant(
            "TS_DECLARE_STATEMENT",
            rome_js_syntax::JsSyntaxKind::TS_DECLARE_STATEMENT,
        )
        .variant(
            "TS_INDEX_SIGNATURE_PARAMETER",
            rome_js_syntax::JsSyntaxKind::TS_INDEX_SIGNATURE_PARAMETER,
        )
        .variant(
            "TS_PROPERTY_SIGNATURE_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_PROPERTY_SIGNATURE_CLASS_MEMBER,
        )
        .variant(
            "TS_INITIALIZED_PROPERTY_SIGNATURE_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_INITIALIZED_PROPERTY_SIGNATURE_CLASS_MEMBER,
        )
        .variant(
            "TS_PROPERTY_SIGNATURE_MODIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::TS_PROPERTY_SIGNATURE_MODIFIER_LIST,
        )
        .variant(
            "TS_METHOD_SIGNATURE_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_METHOD_SIGNATURE_CLASS_MEMBER,
        )
        .variant(
            "TS_METHOD_SIGNATURE_MODIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::TS_METHOD_SIGNATURE_MODIFIER_LIST,
        )
        .variant(
            "TS_GETTER_SIGNATURE_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_GETTER_SIGNATURE_CLASS_MEMBER,
        )
        .variant(
            "TS_SETTER_SIGNATURE_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_SETTER_SIGNATURE_CLASS_MEMBER,
        )
        .variant(
            "TS_INDEX_SIGNATURE_CLASS_MEMBER",
            rome_js_syntax::JsSyntaxKind::TS_INDEX_SIGNATURE_CLASS_MEMBER,
        )
        .variant(
            "TS_INDEX_SIGNATURE_MODIFIER_LIST",
            rome_js_syntax::JsSyntaxKind::TS_INDEX_SIGNATURE_MODIFIER_LIST,
        )
        .variant("JSX_NAME", rome_js_syntax::JsSyntaxKind::JSX_NAME)
        .variant(
            "JSX_NAMESPACE_NAME",
            rome_js_syntax::JsSyntaxKind::JSX_NAMESPACE_NAME,
        )
        .variant(
            "JSX_REFERENCE_IDENTIFIER",
            rome_js_syntax::JsSyntaxKind::JSX_REFERENCE_IDENTIFIER,
        )
        .variant(
            "JSX_TAG_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JSX_TAG_EXPRESSION,
        )
        .variant("JSX_ELEMENT", rome_js_syntax::JsSyntaxKind::JSX_ELEMENT)
        .variant("JSX_FRAGMENT", rome_js_syntax::JsSyntaxKind::JSX_FRAGMENT)
        .variant(
            "JSX_OPENING_FRAGMENT",
            rome_js_syntax::JsSyntaxKind::JSX_OPENING_FRAGMENT,
        )
        .variant(
            "JSX_CLOSING_FRAGMENT",
            rome_js_syntax::JsSyntaxKind::JSX_CLOSING_FRAGMENT,
        )
        .variant(
            "JSX_SELF_CLOSING_ELEMENT",
            rome_js_syntax::JsSyntaxKind::JSX_SELF_CLOSING_ELEMENT,
        )
        .variant(
            "JSX_OPENING_ELEMENT",
            rome_js_syntax::JsSyntaxKind::JSX_OPENING_ELEMENT,
        )
        .variant(
            "JSX_CLOSING_ELEMENT",
            rome_js_syntax::JsSyntaxKind::JSX_CLOSING_ELEMENT,
        )
        .variant(
            "JSX_MEMBER_NAME",
            rome_js_syntax::JsSyntaxKind::JSX_MEMBER_NAME,
        )
        .variant("JSX_TEXT", rome_js_syntax::JsSyntaxKind::JSX_TEXT)
        .variant(
            "JSX_ATTRIBUTE_LIST",
            rome_js_syntax::JsSyntaxKind::JSX_ATTRIBUTE_LIST,
        )
        .variant("JSX_ATTRIBUTE", rome_js_syntax::JsSyntaxKind::JSX_ATTRIBUTE)
        .variant(
            "JSX_SPREAD_ATTRIBUTE",
            rome_js_syntax::JsSyntaxKind::JSX_SPREAD_ATTRIBUTE,
        )
        .variant(
            "JSX_ATTRIBUTE_INITIALIZER_CLAUSE",
            rome_js_syntax::JsSyntaxKind::JSX_ATTRIBUTE_INITIALIZER_CLAUSE,
        )
        .variant(
            "JSX_EXPRESSION_ATTRIBUTE_VALUE",
            rome_js_syntax::JsSyntaxKind::JSX_EXPRESSION_ATTRIBUTE_VALUE,
        )
        .variant(
            "JSX_CHILD_LIST",
            rome_js_syntax::JsSyntaxKind::JSX_CHILD_LIST,
        )
        .variant(
            "JSX_EXPRESSION_CHILD",
            rome_js_syntax::JsSyntaxKind::JSX_EXPRESSION_CHILD,
        )
        .variant(
            "JSX_SPREAD_CHILD",
            rome_js_syntax::JsSyntaxKind::JSX_SPREAD_CHILD,
        )
        .variant("JSX_STRING", rome_js_syntax::JsSyntaxKind::JSX_STRING)
        .variant("JS_BOGUS", rome_js_syntax::JsSyntaxKind::JS_BOGUS)
        .variant(
            "JS_BOGUS_EXPRESSION",
            rome_js_syntax::JsSyntaxKind::JS_BOGUS_EXPRESSION,
        )
        .variant(
            "JS_BOGUS_STATEMENT",
            rome_js_syntax::JsSyntaxKind::JS_BOGUS_STATEMENT,
        )
        .variant(
            "JS_BOGUS_MEMBER",
            rome_js_syntax::JsSyntaxKind::JS_BOGUS_MEMBER,
        )
        .variant(
            "JS_BOGUS_BINDING",
            rome_js_syntax::JsSyntaxKind::JS_BOGUS_BINDING,
        )
        .variant(
            "JS_BOGUS_PARAMETER",
            rome_js_syntax::JsSyntaxKind::JS_BOGUS_PARAMETER,
        )
        .variant(
            "JS_BOGUS_IMPORT_ASSERTION_ENTRY",
            rome_js_syntax::JsSyntaxKind::JS_BOGUS_IMPORT_ASSERTION_ENTRY,
        )
        .variant(
            "JS_BOGUS_NAMED_IMPORT_SPECIFIER",
            rome_js_syntax::JsSyntaxKind::JS_BOGUS_NAMED_IMPORT_SPECIFIER,
        )
        .variant(
            "JS_BOGUS_ASSIGNMENT",
            rome_js_syntax::JsSyntaxKind::JS_BOGUS_ASSIGNMENT,
        )
        .variant("TS_BOGUS_TYPE", rome_js_syntax::JsSyntaxKind::TS_BOGUS_TYPE)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsAccessorModifier>(scope, global, "JsAccessorModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", JsAccessorModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayAssignmentPattern>(
            scope,
            global,
            "JsArrayAssignmentPattern",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_brack_token",
            JsArrayAssignmentPattern_l_brack_token,
        )
        .method(scope, "elements", JsArrayAssignmentPattern_elements)
        .method(
            scope,
            "r_brack_token",
            JsArrayAssignmentPattern_r_brack_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayAssignmentPatternRestElement>(
            scope,
            global,
            "JsArrayAssignmentPatternRestElement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "dotdotdot_token",
            JsArrayAssignmentPatternRestElement_dotdotdot_token,
        )
        .method(
            scope,
            "pattern",
            JsArrayAssignmentPatternRestElement_pattern,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayBindingPattern>(
            scope,
            global,
            "JsArrayBindingPattern",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_brack_token", JsArrayBindingPattern_l_brack_token)
        .method(scope, "elements", JsArrayBindingPattern_elements)
        .method(scope, "r_brack_token", JsArrayBindingPattern_r_brack_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayBindingPatternRestElement>(
            scope,
            global,
            "JsArrayBindingPatternRestElement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "dotdotdot_token",
            JsArrayBindingPatternRestElement_dotdotdot_token,
        )
        .method(scope, "pattern", JsArrayBindingPatternRestElement_pattern)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayExpression>(scope, global, "JsArrayExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_brack_token", JsArrayExpression_l_brack_token)
        .method(scope, "elements", JsArrayExpression_elements)
        .method(scope, "r_brack_token", JsArrayExpression_r_brack_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayHole>(scope, global, "JsArrayHole")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrowFunctionExpression>(
            scope,
            global,
            "JsArrowFunctionExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "async_token", JsArrowFunctionExpression_async_token)
        .method(
            scope,
            "type_parameters",
            JsArrowFunctionExpression_type_parameters,
        )
        .method(scope, "parameters", JsArrowFunctionExpression_parameters)
        .method(
            scope,
            "return_type_annotation",
            JsArrowFunctionExpression_return_type_annotation,
        )
        .method(
            scope,
            "fat_arrow_token",
            JsArrowFunctionExpression_fat_arrow_token,
        )
        .method(scope, "body", JsArrowFunctionExpression_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsAssignmentExpression>(
            scope,
            global,
            "JsAssignmentExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "left", JsAssignmentExpression_left)
        .method(
            scope,
            "operator_token",
            JsAssignmentExpression_operator_token,
        )
        .method(scope, "right", JsAssignmentExpression_right)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsAssignmentWithDefault>(
            scope,
            global,
            "JsAssignmentWithDefault",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "pattern", JsAssignmentWithDefault_pattern)
        .method(scope, "eq_token", JsAssignmentWithDefault_eq_token)
        .method(scope, "default", JsAssignmentWithDefault_default)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsAwaitExpression>(scope, global, "JsAwaitExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "await_token", JsAwaitExpression_await_token)
        .method(scope, "argument", JsAwaitExpression_argument)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBigintLiteralExpression>(
            scope,
            global,
            "JsBigintLiteralExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsBigintLiteralExpression_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBinaryExpression>(scope, global, "JsBinaryExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "left", JsBinaryExpression_left)
        .method(scope, "operator_token", JsBinaryExpression_operator_token)
        .method(scope, "right", JsBinaryExpression_right)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBindingPatternWithDefault>(
            scope,
            global,
            "JsBindingPatternWithDefault",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "pattern", JsBindingPatternWithDefault_pattern)
        .method(scope, "eq_token", JsBindingPatternWithDefault_eq_token)
        .method(scope, "default", JsBindingPatternWithDefault_default)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBlockStatement>(scope, global, "JsBlockStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", JsBlockStatement_l_curly_token)
        .method(scope, "statements", JsBlockStatement_statements)
        .method(scope, "r_curly_token", JsBlockStatement_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBooleanLiteralExpression>(
            scope,
            global,
            "JsBooleanLiteralExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsBooleanLiteralExpression_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBreakStatement>(scope, global, "JsBreakStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "break_token", JsBreakStatement_break_token)
        .method(scope, "label_token", JsBreakStatement_label_token)
        .method(scope, "semicolon_token", JsBreakStatement_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsCallArguments>(scope, global, "JsCallArguments")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_paren_token", JsCallArguments_l_paren_token)
        .method(scope, "args", JsCallArguments_args)
        .method(scope, "r_paren_token", JsCallArguments_r_paren_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsCallExpression>(scope, global, "JsCallExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "callee", JsCallExpression_callee)
        .method(
            scope,
            "optional_chain_token",
            JsCallExpression_optional_chain_token,
        )
        .method(scope, "type_arguments", JsCallExpression_type_arguments)
        .method(scope, "arguments", JsCallExpression_arguments)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsCaseClause>(scope, global, "JsCaseClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "case_token", JsCaseClause_case_token)
        .method(scope, "test", JsCaseClause_test)
        .method(scope, "colon_token", JsCaseClause_colon_token)
        .method(scope, "consequent", JsCaseClause_consequent)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsCatchClause>(scope, global, "JsCatchClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "catch_token", JsCatchClause_catch_token)
        .method(scope, "declaration", JsCatchClause_declaration)
        .method(scope, "body", JsCatchClause_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsCatchDeclaration>(scope, global, "JsCatchDeclaration")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_paren_token", JsCatchDeclaration_l_paren_token)
        .method(scope, "binding", JsCatchDeclaration_binding)
        .method(scope, "type_annotation", JsCatchDeclaration_type_annotation)
        .method(scope, "r_paren_token", JsCatchDeclaration_r_paren_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsClassDeclaration>(scope, global, "JsClassDeclaration")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "decorators", JsClassDeclaration_decorators)
        .method(scope, "abstract_token", JsClassDeclaration_abstract_token)
        .method(scope, "class_token", JsClassDeclaration_class_token)
        .method(scope, "id", JsClassDeclaration_id)
        .method(scope, "type_parameters", JsClassDeclaration_type_parameters)
        .method(scope, "extends_clause", JsClassDeclaration_extends_clause)
        .method(
            scope,
            "implements_clause",
            JsClassDeclaration_implements_clause,
        )
        .method(scope, "l_curly_token", JsClassDeclaration_l_curly_token)
        .method(scope, "members", JsClassDeclaration_members)
        .method(scope, "r_curly_token", JsClassDeclaration_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsClassExportDefaultDeclaration>(
            scope,
            global,
            "JsClassExportDefaultDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "decorators",
            JsClassExportDefaultDeclaration_decorators,
        )
        .method(
            scope,
            "abstract_token",
            JsClassExportDefaultDeclaration_abstract_token,
        )
        .method(
            scope,
            "class_token",
            JsClassExportDefaultDeclaration_class_token,
        )
        .method(scope, "id", JsClassExportDefaultDeclaration_id)
        .method(
            scope,
            "type_parameters",
            JsClassExportDefaultDeclaration_type_parameters,
        )
        .method(
            scope,
            "extends_clause",
            JsClassExportDefaultDeclaration_extends_clause,
        )
        .method(
            scope,
            "implements_clause",
            JsClassExportDefaultDeclaration_implements_clause,
        )
        .method(
            scope,
            "l_curly_token",
            JsClassExportDefaultDeclaration_l_curly_token,
        )
        .method(scope, "members", JsClassExportDefaultDeclaration_members)
        .method(
            scope,
            "r_curly_token",
            JsClassExportDefaultDeclaration_r_curly_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsClassExpression>(scope, global, "JsClassExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "decorators", JsClassExpression_decorators)
        .method(scope, "class_token", JsClassExpression_class_token)
        .method(scope, "id", JsClassExpression_id)
        .method(scope, "type_parameters", JsClassExpression_type_parameters)
        .method(scope, "extends_clause", JsClassExpression_extends_clause)
        .method(
            scope,
            "implements_clause",
            JsClassExpression_implements_clause,
        )
        .method(scope, "l_curly_token", JsClassExpression_l_curly_token)
        .method(scope, "members", JsClassExpression_members)
        .method(scope, "r_curly_token", JsClassExpression_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsComputedMemberAssignment>(
            scope,
            global,
            "JsComputedMemberAssignment",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "object", JsComputedMemberAssignment_object)
        .method(
            scope,
            "l_brack_token",
            JsComputedMemberAssignment_l_brack_token,
        )
        .method(scope, "member", JsComputedMemberAssignment_member)
        .method(
            scope,
            "r_brack_token",
            JsComputedMemberAssignment_r_brack_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsComputedMemberExpression>(
            scope,
            global,
            "JsComputedMemberExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "object", JsComputedMemberExpression_object)
        .method(
            scope,
            "optional_chain_token",
            JsComputedMemberExpression_optional_chain_token,
        )
        .method(
            scope,
            "l_brack_token",
            JsComputedMemberExpression_l_brack_token,
        )
        .method(scope, "member", JsComputedMemberExpression_member)
        .method(
            scope,
            "r_brack_token",
            JsComputedMemberExpression_r_brack_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsComputedMemberName>(scope, global, "JsComputedMemberName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_brack_token", JsComputedMemberName_l_brack_token)
        .method(scope, "expression", JsComputedMemberName_expression)
        .method(scope, "r_brack_token", JsComputedMemberName_r_brack_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsConditionalExpression>(
            scope,
            global,
            "JsConditionalExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "test", JsConditionalExpression_test)
        .method(
            scope,
            "question_mark_token",
            JsConditionalExpression_question_mark_token,
        )
        .method(scope, "consequent", JsConditionalExpression_consequent)
        .method(scope, "colon_token", JsConditionalExpression_colon_token)
        .method(scope, "alternate", JsConditionalExpression_alternate)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsConstructorClassMember>(
            scope,
            global,
            "JsConstructorClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", JsConstructorClassMember_modifiers)
        .method(scope, "name", JsConstructorClassMember_name)
        .method(scope, "parameters", JsConstructorClassMember_parameters)
        .method(scope, "body", JsConstructorClassMember_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsConstructorParameters>(
            scope,
            global,
            "JsConstructorParameters",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_paren_token",
            JsConstructorParameters_l_paren_token,
        )
        .method(scope, "parameters", JsConstructorParameters_parameters)
        .method(
            scope,
            "r_paren_token",
            JsConstructorParameters_r_paren_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsContinueStatement>(scope, global, "JsContinueStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "continue_token", JsContinueStatement_continue_token)
        .method(scope, "label_token", JsContinueStatement_label_token)
        .method(
            scope,
            "semicolon_token",
            JsContinueStatement_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsDebuggerStatement>(scope, global, "JsDebuggerStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "debugger_token", JsDebuggerStatement_debugger_token)
        .method(
            scope,
            "semicolon_token",
            JsDebuggerStatement_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsDecorator>(scope, global, "JsDecorator")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "at_token", JsDecorator_at_token)
        .method(scope, "expression", JsDecorator_expression)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsDefaultClause>(scope, global, "JsDefaultClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "default_token", JsDefaultClause_default_token)
        .method(scope, "colon_token", JsDefaultClause_colon_token)
        .method(scope, "consequent", JsDefaultClause_consequent)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsDefaultImportSpecifier>(
            scope,
            global,
            "JsDefaultImportSpecifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "local_name", JsDefaultImportSpecifier_local_name)
        .method(
            scope,
            "trailing_comma_token",
            JsDefaultImportSpecifier_trailing_comma_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsDirective>(scope, global, "JsDirective")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsDirective_value_token)
        .method(scope, "semicolon_token", JsDirective_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsDoWhileStatement>(scope, global, "JsDoWhileStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "do_token", JsDoWhileStatement_do_token)
        .method(scope, "body", JsDoWhileStatement_body)
        .method(scope, "while_token", JsDoWhileStatement_while_token)
        .method(scope, "l_paren_token", JsDoWhileStatement_l_paren_token)
        .method(scope, "test", JsDoWhileStatement_test)
        .method(scope, "r_paren_token", JsDoWhileStatement_r_paren_token)
        .method(scope, "semicolon_token", JsDoWhileStatement_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsElseClause>(scope, global, "JsElseClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "else_token", JsElseClause_else_token)
        .method(scope, "alternate", JsElseClause_alternate)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsEmptyClassMember>(scope, global, "JsEmptyClassMember")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "semicolon_token", JsEmptyClassMember_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsEmptyStatement>(scope, global, "JsEmptyStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "semicolon_token", JsEmptyStatement_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExport>(scope, global, "JsExport")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "decorators", JsExport_decorators)
        .method(scope, "export_token", JsExport_export_token)
        .method(scope, "export_clause", JsExport_export_clause)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportAsClause>(scope, global, "JsExportAsClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "as_token", JsExportAsClause_as_token)
        .method(scope, "exported_name", JsExportAsClause_exported_name)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportDefaultDeclarationClause>(
            scope,
            global,
            "JsExportDefaultDeclarationClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "default_token",
            JsExportDefaultDeclarationClause_default_token,
        )
        .method(
            scope,
            "declaration",
            JsExportDefaultDeclarationClause_declaration,
        )
        .method(
            scope,
            "semicolon_token",
            JsExportDefaultDeclarationClause_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportDefaultExpressionClause>(
            scope,
            global,
            "JsExportDefaultExpressionClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "default_token",
            JsExportDefaultExpressionClause_default_token,
        )
        .method(
            scope,
            "expression",
            JsExportDefaultExpressionClause_expression,
        )
        .method(
            scope,
            "semicolon_token",
            JsExportDefaultExpressionClause_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportFromClause>(scope, global, "JsExportFromClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsExportFromClause_type_token)
        .method(scope, "star_token", JsExportFromClause_star_token)
        .method(scope, "export_as", JsExportFromClause_export_as)
        .method(scope, "from_token", JsExportFromClause_from_token)
        .method(scope, "source", JsExportFromClause_source)
        .method(scope, "assertion", JsExportFromClause_assertion)
        .method(scope, "semicolon_token", JsExportFromClause_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportNamedClause>(scope, global, "JsExportNamedClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsExportNamedClause_type_token)
        .method(scope, "l_curly_token", JsExportNamedClause_l_curly_token)
        .method(scope, "specifiers", JsExportNamedClause_specifiers)
        .method(scope, "r_curly_token", JsExportNamedClause_r_curly_token)
        .method(
            scope,
            "semicolon_token",
            JsExportNamedClause_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportNamedFromClause>(
            scope,
            global,
            "JsExportNamedFromClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsExportNamedFromClause_type_token)
        .method(
            scope,
            "l_curly_token",
            JsExportNamedFromClause_l_curly_token,
        )
        .method(scope, "specifiers", JsExportNamedFromClause_specifiers)
        .method(
            scope,
            "r_curly_token",
            JsExportNamedFromClause_r_curly_token,
        )
        .method(scope, "from_token", JsExportNamedFromClause_from_token)
        .method(scope, "source", JsExportNamedFromClause_source)
        .method(scope, "assertion", JsExportNamedFromClause_assertion)
        .method(
            scope,
            "semicolon_token",
            JsExportNamedFromClause_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportNamedFromSpecifier>(
            scope,
            global,
            "JsExportNamedFromSpecifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsExportNamedFromSpecifier_type_token)
        .method(scope, "source_name", JsExportNamedFromSpecifier_source_name)
        .method(scope, "export_as", JsExportNamedFromSpecifier_export_as)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportNamedShorthandSpecifier>(
            scope,
            global,
            "JsExportNamedShorthandSpecifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "type_token",
            JsExportNamedShorthandSpecifier_type_token,
        )
        .method(scope, "name", JsExportNamedShorthandSpecifier_name)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportNamedSpecifier>(
            scope,
            global,
            "JsExportNamedSpecifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsExportNamedSpecifier_type_token)
        .method(scope, "local_name", JsExportNamedSpecifier_local_name)
        .method(scope, "as_token", JsExportNamedSpecifier_as_token)
        .method(scope, "exported_name", JsExportNamedSpecifier_exported_name)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExpressionSnipped>(scope, global, "JsExpressionSnipped")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "expression", JsExpressionSnipped_expression)
        .method(scope, "eof_token", JsExpressionSnipped_eof_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExpressionStatement>(
            scope,
            global,
            "JsExpressionStatement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "expression", JsExpressionStatement_expression)
        .method(
            scope,
            "semicolon_token",
            JsExpressionStatement_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExtendsClause>(scope, global, "JsExtendsClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "extends_token", JsExtendsClause_extends_token)
        .method(scope, "super_class", JsExtendsClause_super_class)
        .method(scope, "type_arguments", JsExtendsClause_type_arguments)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsFinallyClause>(scope, global, "JsFinallyClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "finally_token", JsFinallyClause_finally_token)
        .method(scope, "body", JsFinallyClause_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsForInStatement>(scope, global, "JsForInStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "for_token", JsForInStatement_for_token)
        .method(scope, "l_paren_token", JsForInStatement_l_paren_token)
        .method(scope, "initializer", JsForInStatement_initializer)
        .method(scope, "in_token", JsForInStatement_in_token)
        .method(scope, "expression", JsForInStatement_expression)
        .method(scope, "r_paren_token", JsForInStatement_r_paren_token)
        .method(scope, "body", JsForInStatement_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsForOfStatement>(scope, global, "JsForOfStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "for_token", JsForOfStatement_for_token)
        .method(scope, "await_token", JsForOfStatement_await_token)
        .method(scope, "l_paren_token", JsForOfStatement_l_paren_token)
        .method(scope, "initializer", JsForOfStatement_initializer)
        .method(scope, "of_token", JsForOfStatement_of_token)
        .method(scope, "expression", JsForOfStatement_expression)
        .method(scope, "r_paren_token", JsForOfStatement_r_paren_token)
        .method(scope, "body", JsForOfStatement_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsForStatement>(scope, global, "JsForStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "for_token", JsForStatement_for_token)
        .method(scope, "l_paren_token", JsForStatement_l_paren_token)
        .method(scope, "initializer", JsForStatement_initializer)
        .method(scope, "first_semi_token", JsForStatement_first_semi_token)
        .method(scope, "test", JsForStatement_test)
        .method(scope, "second_semi_token", JsForStatement_second_semi_token)
        .method(scope, "update", JsForStatement_update)
        .method(scope, "r_paren_token", JsForStatement_r_paren_token)
        .method(scope, "body", JsForStatement_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsForVariableDeclaration>(
            scope,
            global,
            "JsForVariableDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "kind_token", JsForVariableDeclaration_kind_token)
        .method(scope, "declarator", JsForVariableDeclaration_declarator)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsFormalParameter>(scope, global, "JsFormalParameter")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "decorators", JsFormalParameter_decorators)
        .method(scope, "binding", JsFormalParameter_binding)
        .method(
            scope,
            "question_mark_token",
            JsFormalParameter_question_mark_token,
        )
        .method(scope, "type_annotation", JsFormalParameter_type_annotation)
        .method(scope, "initializer", JsFormalParameter_initializer)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsFunctionBody>(scope, global, "JsFunctionBody")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", JsFunctionBody_l_curly_token)
        .method(scope, "directives", JsFunctionBody_directives)
        .method(scope, "statements", JsFunctionBody_statements)
        .method(scope, "r_curly_token", JsFunctionBody_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsFunctionDeclaration>(
            scope,
            global,
            "JsFunctionDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "async_token", JsFunctionDeclaration_async_token)
        .method(
            scope,
            "function_token",
            JsFunctionDeclaration_function_token,
        )
        .method(scope, "star_token", JsFunctionDeclaration_star_token)
        .method(scope, "id", JsFunctionDeclaration_id)
        .method(
            scope,
            "type_parameters",
            JsFunctionDeclaration_type_parameters,
        )
        .method(scope, "parameters", JsFunctionDeclaration_parameters)
        .method(
            scope,
            "return_type_annotation",
            JsFunctionDeclaration_return_type_annotation,
        )
        .method(scope, "body", JsFunctionDeclaration_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsFunctionExportDefaultDeclaration>(
            scope,
            global,
            "JsFunctionExportDefaultDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "async_token",
            JsFunctionExportDefaultDeclaration_async_token,
        )
        .method(
            scope,
            "function_token",
            JsFunctionExportDefaultDeclaration_function_token,
        )
        .method(
            scope,
            "star_token",
            JsFunctionExportDefaultDeclaration_star_token,
        )
        .method(scope, "id", JsFunctionExportDefaultDeclaration_id)
        .method(
            scope,
            "type_parameters",
            JsFunctionExportDefaultDeclaration_type_parameters,
        )
        .method(
            scope,
            "parameters",
            JsFunctionExportDefaultDeclaration_parameters,
        )
        .method(
            scope,
            "return_type_annotation",
            JsFunctionExportDefaultDeclaration_return_type_annotation,
        )
        .method(scope, "body", JsFunctionExportDefaultDeclaration_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsFunctionExpression>(scope, global, "JsFunctionExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "async_token", JsFunctionExpression_async_token)
        .method(scope, "function_token", JsFunctionExpression_function_token)
        .method(scope, "star_token", JsFunctionExpression_star_token)
        .method(scope, "id", JsFunctionExpression_id)
        .method(
            scope,
            "type_parameters",
            JsFunctionExpression_type_parameters,
        )
        .method(scope, "parameters", JsFunctionExpression_parameters)
        .method(
            scope,
            "return_type_annotation",
            JsFunctionExpression_return_type_annotation,
        )
        .method(scope, "body", JsFunctionExpression_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsGetterClassMember>(scope, global, "JsGetterClassMember")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", JsGetterClassMember_modifiers)
        .method(scope, "get_token", JsGetterClassMember_get_token)
        .method(scope, "name", JsGetterClassMember_name)
        .method(scope, "l_paren_token", JsGetterClassMember_l_paren_token)
        .method(scope, "r_paren_token", JsGetterClassMember_r_paren_token)
        .method(scope, "return_type", JsGetterClassMember_return_type)
        .method(scope, "body", JsGetterClassMember_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsGetterObjectMember>(scope, global, "JsGetterObjectMember")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "get_token", JsGetterObjectMember_get_token)
        .method(scope, "name", JsGetterObjectMember_name)
        .method(scope, "l_paren_token", JsGetterObjectMember_l_paren_token)
        .method(scope, "r_paren_token", JsGetterObjectMember_r_paren_token)
        .method(scope, "return_type", JsGetterObjectMember_return_type)
        .method(scope, "body", JsGetterObjectMember_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsIdentifierAssignment>(
            scope,
            global,
            "JsIdentifierAssignment",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name_token", JsIdentifierAssignment_name_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsIdentifierBinding>(scope, global, "JsIdentifierBinding")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name_token", JsIdentifierBinding_name_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsIdentifierExpression>(
            scope,
            global,
            "JsIdentifierExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name", JsIdentifierExpression_name)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsIfStatement>(scope, global, "JsIfStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "if_token", JsIfStatement_if_token)
        .method(scope, "l_paren_token", JsIfStatement_l_paren_token)
        .method(scope, "test", JsIfStatement_test)
        .method(scope, "r_paren_token", JsIfStatement_r_paren_token)
        .method(scope, "consequent", JsIfStatement_consequent)
        .method(scope, "else_clause", JsIfStatement_else_clause)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImport>(scope, global, "JsImport")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "import_token", JsImport_import_token)
        .method(scope, "import_clause", JsImport_import_clause)
        .method(scope, "semicolon_token", JsImport_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportAssertion>(scope, global, "JsImportAssertion")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "assertion_kind", JsImportAssertion_assertion_kind)
        .method(scope, "l_curly_token", JsImportAssertion_l_curly_token)
        .method(scope, "assertions", JsImportAssertion_assertions)
        .method(scope, "r_curly_token", JsImportAssertion_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportAssertionEntry>(
            scope,
            global,
            "JsImportAssertionEntry",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "key", JsImportAssertionEntry_key)
        .method(scope, "colon_token", JsImportAssertionEntry_colon_token)
        .method(scope, "value_token", JsImportAssertionEntry_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportBareClause>(scope, global, "JsImportBareClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "source", JsImportBareClause_source)
        .method(scope, "assertion", JsImportBareClause_assertion)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportCallExpression>(
            scope,
            global,
            "JsImportCallExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "import_token", JsImportCallExpression_import_token)
        .method(scope, "arguments", JsImportCallExpression_arguments)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportDefaultClause>(
            scope,
            global,
            "JsImportDefaultClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsImportDefaultClause_type_token)
        .method(scope, "local_name", JsImportDefaultClause_local_name)
        .method(scope, "from_token", JsImportDefaultClause_from_token)
        .method(scope, "source", JsImportDefaultClause_source)
        .method(scope, "assertion", JsImportDefaultClause_assertion)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportMetaExpression>(
            scope,
            global,
            "JsImportMetaExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "import_token", JsImportMetaExpression_import_token)
        .method(scope, "dot_token", JsImportMetaExpression_dot_token)
        .method(scope, "meta_token", JsImportMetaExpression_meta_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportNamedClause>(scope, global, "JsImportNamedClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsImportNamedClause_type_token)
        .method(
            scope,
            "default_specifier",
            JsImportNamedClause_default_specifier,
        )
        .method(scope, "named_import", JsImportNamedClause_named_import)
        .method(scope, "from_token", JsImportNamedClause_from_token)
        .method(scope, "source", JsImportNamedClause_source)
        .method(scope, "assertion", JsImportNamedClause_assertion)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportNamespaceClause>(
            scope,
            global,
            "JsImportNamespaceClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsImportNamespaceClause_type_token)
        .method(scope, "star_token", JsImportNamespaceClause_star_token)
        .method(scope, "as_token", JsImportNamespaceClause_as_token)
        .method(scope, "local_name", JsImportNamespaceClause_local_name)
        .method(scope, "from_token", JsImportNamespaceClause_from_token)
        .method(scope, "source", JsImportNamespaceClause_source)
        .method(scope, "assertion", JsImportNamespaceClause_assertion)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsInExpression>(scope, global, "JsInExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "property", JsInExpression_property)
        .method(scope, "in_token", JsInExpression_in_token)
        .method(scope, "object", JsInExpression_object)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsInitializerClause>(scope, global, "JsInitializerClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "eq_token", JsInitializerClause_eq_token)
        .method(scope, "expression", JsInitializerClause_expression)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsInstanceofExpression>(
            scope,
            global,
            "JsInstanceofExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "left", JsInstanceofExpression_left)
        .method(
            scope,
            "instanceof_token",
            JsInstanceofExpression_instanceof_token,
        )
        .method(scope, "right", JsInstanceofExpression_right)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsLabeledStatement>(scope, global, "JsLabeledStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "label_token", JsLabeledStatement_label_token)
        .method(scope, "colon_token", JsLabeledStatement_colon_token)
        .method(scope, "body", JsLabeledStatement_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsLiteralExportName>(scope, global, "JsLiteralExportName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value", JsLiteralExportName_value)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsLiteralMemberName>(scope, global, "JsLiteralMemberName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value", JsLiteralMemberName_value)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsLogicalExpression>(scope, global, "JsLogicalExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "left", JsLogicalExpression_left)
        .method(scope, "operator_token", JsLogicalExpression_operator_token)
        .method(scope, "right", JsLogicalExpression_right)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsMethodClassMember>(scope, global, "JsMethodClassMember")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", JsMethodClassMember_modifiers)
        .method(scope, "async_token", JsMethodClassMember_async_token)
        .method(scope, "star_token", JsMethodClassMember_star_token)
        .method(scope, "name", JsMethodClassMember_name)
        .method(
            scope,
            "question_mark_token",
            JsMethodClassMember_question_mark_token,
        )
        .method(
            scope,
            "type_parameters",
            JsMethodClassMember_type_parameters,
        )
        .method(scope, "parameters", JsMethodClassMember_parameters)
        .method(
            scope,
            "return_type_annotation",
            JsMethodClassMember_return_type_annotation,
        )
        .method(scope, "body", JsMethodClassMember_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsMethodObjectMember>(scope, global, "JsMethodObjectMember")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "async_token", JsMethodObjectMember_async_token)
        .method(scope, "star_token", JsMethodObjectMember_star_token)
        .method(scope, "name", JsMethodObjectMember_name)
        .method(
            scope,
            "type_parameters",
            JsMethodObjectMember_type_parameters,
        )
        .method(scope, "parameters", JsMethodObjectMember_parameters)
        .method(
            scope,
            "return_type_annotation",
            JsMethodObjectMember_return_type_annotation,
        )
        .method(scope, "body", JsMethodObjectMember_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsModule>(scope, global, "JsModule")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "interpreter_token", JsModule_interpreter_token)
        .method(scope, "directives", JsModule_directives)
        .method(scope, "items", JsModule_items)
        .method(scope, "eof_token", JsModule_eof_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsModuleSource>(scope, global, "JsModuleSource")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsModuleSource_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsName>(scope, global, "JsName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsName_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsNamedImportSpecifier>(
            scope,
            global,
            "JsNamedImportSpecifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", JsNamedImportSpecifier_type_token)
        .method(scope, "name", JsNamedImportSpecifier_name)
        .method(scope, "as_token", JsNamedImportSpecifier_as_token)
        .method(scope, "local_name", JsNamedImportSpecifier_local_name)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsNamedImportSpecifiers>(
            scope,
            global,
            "JsNamedImportSpecifiers",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_curly_token",
            JsNamedImportSpecifiers_l_curly_token,
        )
        .method(scope, "specifiers", JsNamedImportSpecifiers_specifiers)
        .method(
            scope,
            "r_curly_token",
            JsNamedImportSpecifiers_r_curly_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsNamespaceImportSpecifier>(
            scope,
            global,
            "JsNamespaceImportSpecifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "star_token", JsNamespaceImportSpecifier_star_token)
        .method(scope, "as_token", JsNamespaceImportSpecifier_as_token)
        .method(scope, "local_name", JsNamespaceImportSpecifier_local_name)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsNewExpression>(scope, global, "JsNewExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "new_token", JsNewExpression_new_token)
        .method(scope, "callee", JsNewExpression_callee)
        .method(scope, "type_arguments", JsNewExpression_type_arguments)
        .method(scope, "arguments", JsNewExpression_arguments)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsNewTargetExpression>(
            scope,
            global,
            "JsNewTargetExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "new_token", JsNewTargetExpression_new_token)
        .method(scope, "dot_token", JsNewTargetExpression_dot_token)
        .method(scope, "target_token", JsNewTargetExpression_target_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsNullLiteralExpression>(
            scope,
            global,
            "JsNullLiteralExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsNullLiteralExpression_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsNumberLiteralExpression>(
            scope,
            global,
            "JsNumberLiteralExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsNumberLiteralExpression_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectAssignmentPattern>(
            scope,
            global,
            "JsObjectAssignmentPattern",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_curly_token",
            JsObjectAssignmentPattern_l_curly_token,
        )
        .method(scope, "properties", JsObjectAssignmentPattern_properties)
        .method(
            scope,
            "r_curly_token",
            JsObjectAssignmentPattern_r_curly_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectAssignmentPatternProperty>(
            scope,
            global,
            "JsObjectAssignmentPatternProperty",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "member", JsObjectAssignmentPatternProperty_member)
        .method(
            scope,
            "colon_token",
            JsObjectAssignmentPatternProperty_colon_token,
        )
        .method(scope, "pattern", JsObjectAssignmentPatternProperty_pattern)
        .method(scope, "init", JsObjectAssignmentPatternProperty_init)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectAssignmentPatternRest>(
            scope,
            global,
            "JsObjectAssignmentPatternRest",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "dotdotdot_token",
            JsObjectAssignmentPatternRest_dotdotdot_token,
        )
        .method(scope, "target", JsObjectAssignmentPatternRest_target)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectAssignmentPatternShorthandProperty>(
            scope,
            global,
            "JsObjectAssignmentPatternShorthandProperty",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "identifier",
            JsObjectAssignmentPatternShorthandProperty_identifier,
        )
        .method(
            scope,
            "init",
            JsObjectAssignmentPatternShorthandProperty_init,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectBindingPattern>(
            scope,
            global,
            "JsObjectBindingPattern",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", JsObjectBindingPattern_l_curly_token)
        .method(scope, "properties", JsObjectBindingPattern_properties)
        .method(scope, "r_curly_token", JsObjectBindingPattern_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectBindingPatternProperty>(
            scope,
            global,
            "JsObjectBindingPatternProperty",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "member", JsObjectBindingPatternProperty_member)
        .method(
            scope,
            "colon_token",
            JsObjectBindingPatternProperty_colon_token,
        )
        .method(scope, "pattern", JsObjectBindingPatternProperty_pattern)
        .method(scope, "init", JsObjectBindingPatternProperty_init)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectBindingPatternRest>(
            scope,
            global,
            "JsObjectBindingPatternRest",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "dotdotdot_token",
            JsObjectBindingPatternRest_dotdotdot_token,
        )
        .method(scope, "binding", JsObjectBindingPatternRest_binding)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectBindingPatternShorthandProperty>(
            scope,
            global,
            "JsObjectBindingPatternShorthandProperty",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "identifier",
            JsObjectBindingPatternShorthandProperty_identifier,
        )
        .method(scope, "init", JsObjectBindingPatternShorthandProperty_init)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectExpression>(scope, global, "JsObjectExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", JsObjectExpression_l_curly_token)
        .method(scope, "members", JsObjectExpression_members)
        .method(scope, "r_curly_token", JsObjectExpression_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsParameters>(scope, global, "JsParameters")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_paren_token", JsParameters_l_paren_token)
        .method(scope, "items", JsParameters_items)
        .method(scope, "r_paren_token", JsParameters_r_paren_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsParenthesizedAssignment>(
            scope,
            global,
            "JsParenthesizedAssignment",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_paren_token",
            JsParenthesizedAssignment_l_paren_token,
        )
        .method(scope, "assignment", JsParenthesizedAssignment_assignment)
        .method(
            scope,
            "r_paren_token",
            JsParenthesizedAssignment_r_paren_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsParenthesizedExpression>(
            scope,
            global,
            "JsParenthesizedExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_paren_token",
            JsParenthesizedExpression_l_paren_token,
        )
        .method(scope, "expression", JsParenthesizedExpression_expression)
        .method(
            scope,
            "r_paren_token",
            JsParenthesizedExpression_r_paren_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsPostUpdateExpression>(
            scope,
            global,
            "JsPostUpdateExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "operand", JsPostUpdateExpression_operand)
        .method(
            scope,
            "operator_token",
            JsPostUpdateExpression_operator_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsPreUpdateExpression>(
            scope,
            global,
            "JsPreUpdateExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "operator_token",
            JsPreUpdateExpression_operator_token,
        )
        .method(scope, "operand", JsPreUpdateExpression_operand)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsPrivateClassMemberName>(
            scope,
            global,
            "JsPrivateClassMemberName",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "hash_token", JsPrivateClassMemberName_hash_token)
        .method(scope, "id_token", JsPrivateClassMemberName_id_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsPrivateName>(scope, global, "JsPrivateName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "hash_token", JsPrivateName_hash_token)
        .method(scope, "value_token", JsPrivateName_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsPropertyClassMember>(
            scope,
            global,
            "JsPropertyClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", JsPropertyClassMember_modifiers)
        .method(scope, "name", JsPropertyClassMember_name)
        .method(
            scope,
            "property_annotation",
            JsPropertyClassMember_property_annotation,
        )
        .method(scope, "value", JsPropertyClassMember_value)
        .method(
            scope,
            "semicolon_token",
            JsPropertyClassMember_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsPropertyObjectMember>(
            scope,
            global,
            "JsPropertyObjectMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name", JsPropertyObjectMember_name)
        .method(scope, "colon_token", JsPropertyObjectMember_colon_token)
        .method(scope, "value", JsPropertyObjectMember_value)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsReferenceIdentifier>(
            scope,
            global,
            "JsReferenceIdentifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsReferenceIdentifier_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsRegexLiteralExpression>(
            scope,
            global,
            "JsRegexLiteralExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsRegexLiteralExpression_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsRestParameter>(scope, global, "JsRestParameter")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "decorators", JsRestParameter_decorators)
        .method(scope, "dotdotdot_token", JsRestParameter_dotdotdot_token)
        .method(scope, "binding", JsRestParameter_binding)
        .method(scope, "type_annotation", JsRestParameter_type_annotation)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsReturnStatement>(scope, global, "JsReturnStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "return_token", JsReturnStatement_return_token)
        .method(scope, "argument", JsReturnStatement_argument)
        .method(scope, "semicolon_token", JsReturnStatement_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsScript>(scope, global, "JsScript")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "interpreter_token", JsScript_interpreter_token)
        .method(scope, "directives", JsScript_directives)
        .method(scope, "statements", JsScript_statements)
        .method(scope, "eof_token", JsScript_eof_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsSequenceExpression>(scope, global, "JsSequenceExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "left", JsSequenceExpression_left)
        .method(scope, "comma_token", JsSequenceExpression_comma_token)
        .method(scope, "right", JsSequenceExpression_right)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsSetterClassMember>(scope, global, "JsSetterClassMember")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", JsSetterClassMember_modifiers)
        .method(scope, "set_token", JsSetterClassMember_set_token)
        .method(scope, "name", JsSetterClassMember_name)
        .method(scope, "l_paren_token", JsSetterClassMember_l_paren_token)
        .method(scope, "parameter", JsSetterClassMember_parameter)
        .method(scope, "r_paren_token", JsSetterClassMember_r_paren_token)
        .method(scope, "body", JsSetterClassMember_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsSetterObjectMember>(scope, global, "JsSetterObjectMember")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "set_token", JsSetterObjectMember_set_token)
        .method(scope, "name", JsSetterObjectMember_name)
        .method(scope, "l_paren_token", JsSetterObjectMember_l_paren_token)
        .method(scope, "parameter", JsSetterObjectMember_parameter)
        .method(scope, "r_paren_token", JsSetterObjectMember_r_paren_token)
        .method(scope, "body", JsSetterObjectMember_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsShorthandNamedImportSpecifier>(
            scope,
            global,
            "JsShorthandNamedImportSpecifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "type_token",
            JsShorthandNamedImportSpecifier_type_token,
        )
        .method(
            scope,
            "local_name",
            JsShorthandNamedImportSpecifier_local_name,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsShorthandPropertyObjectMember>(
            scope,
            global,
            "JsShorthandPropertyObjectMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name", JsShorthandPropertyObjectMember_name)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsSpread>(scope, global, "JsSpread")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "dotdotdot_token", JsSpread_dotdotdot_token)
        .method(scope, "argument", JsSpread_argument)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsStaticInitializationBlockClassMember>(
            scope,
            global,
            "JsStaticInitializationBlockClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "static_token",
            JsStaticInitializationBlockClassMember_static_token,
        )
        .method(
            scope,
            "l_curly_token",
            JsStaticInitializationBlockClassMember_l_curly_token,
        )
        .method(
            scope,
            "statements",
            JsStaticInitializationBlockClassMember_statements,
        )
        .method(
            scope,
            "r_curly_token",
            JsStaticInitializationBlockClassMember_r_curly_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsStaticMemberAssignment>(
            scope,
            global,
            "JsStaticMemberAssignment",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "object", JsStaticMemberAssignment_object)
        .method(scope, "dot_token", JsStaticMemberAssignment_dot_token)
        .method(scope, "member", JsStaticMemberAssignment_member)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsStaticMemberExpression>(
            scope,
            global,
            "JsStaticMemberExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "object", JsStaticMemberExpression_object)
        .method(
            scope,
            "operator_token",
            JsStaticMemberExpression_operator_token,
        )
        .method(scope, "member", JsStaticMemberExpression_member)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsStaticModifier>(scope, global, "JsStaticModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", JsStaticModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsStringLiteralExpression>(
            scope,
            global,
            "JsStringLiteralExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsStringLiteralExpression_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsSuperExpression>(scope, global, "JsSuperExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "super_token", JsSuperExpression_super_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsSwitchStatement>(scope, global, "JsSwitchStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "switch_token", JsSwitchStatement_switch_token)
        .method(scope, "l_paren_token", JsSwitchStatement_l_paren_token)
        .method(scope, "discriminant", JsSwitchStatement_discriminant)
        .method(scope, "r_paren_token", JsSwitchStatement_r_paren_token)
        .method(scope, "l_curly_token", JsSwitchStatement_l_curly_token)
        .method(scope, "cases", JsSwitchStatement_cases)
        .method(scope, "r_curly_token", JsSwitchStatement_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsTemplateChunkElement>(
            scope,
            global,
            "JsTemplateChunkElement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "template_chunk_token",
            JsTemplateChunkElement_template_chunk_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsTemplateElement>(scope, global, "JsTemplateElement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "dollar_curly_token",
            JsTemplateElement_dollar_curly_token,
        )
        .method(scope, "expression", JsTemplateElement_expression)
        .method(scope, "r_curly_token", JsTemplateElement_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsTemplateExpression>(scope, global, "JsTemplateExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "tag", JsTemplateExpression_tag)
        .method(scope, "type_arguments", JsTemplateExpression_type_arguments)
        .method(scope, "l_tick_token", JsTemplateExpression_l_tick_token)
        .method(scope, "elements", JsTemplateExpression_elements)
        .method(scope, "r_tick_token", JsTemplateExpression_r_tick_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsThisExpression>(scope, global, "JsThisExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "this_token", JsThisExpression_this_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsThrowStatement>(scope, global, "JsThrowStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "throw_token", JsThrowStatement_throw_token)
        .method(scope, "argument", JsThrowStatement_argument)
        .method(scope, "semicolon_token", JsThrowStatement_semicolon_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsTryFinallyStatement>(
            scope,
            global,
            "JsTryFinallyStatement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "try_token", JsTryFinallyStatement_try_token)
        .method(scope, "body", JsTryFinallyStatement_body)
        .method(scope, "catch_clause", JsTryFinallyStatement_catch_clause)
        .method(
            scope,
            "finally_clause",
            JsTryFinallyStatement_finally_clause,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsTryStatement>(scope, global, "JsTryStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "try_token", JsTryStatement_try_token)
        .method(scope, "body", JsTryStatement_body)
        .method(scope, "catch_clause", JsTryStatement_catch_clause)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsUnaryExpression>(scope, global, "JsUnaryExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "operator_token", JsUnaryExpression_operator_token)
        .method(scope, "argument", JsUnaryExpression_argument)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsVariableDeclaration>(
            scope,
            global,
            "JsVariableDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "kind", JsVariableDeclaration_kind)
        .method(scope, "declarators", JsVariableDeclaration_declarators)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsVariableDeclarationClause>(
            scope,
            global,
            "JsVariableDeclarationClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "declaration",
            JsVariableDeclarationClause_declaration,
        )
        .method(
            scope,
            "semicolon_token",
            JsVariableDeclarationClause_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsVariableDeclarator>(scope, global, "JsVariableDeclarator")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "id", JsVariableDeclarator_id)
        .method(
            scope,
            "variable_annotation",
            JsVariableDeclarator_variable_annotation,
        )
        .method(scope, "initializer", JsVariableDeclarator_initializer)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsVariableStatement>(scope, global, "JsVariableStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "declaration", JsVariableStatement_declaration)
        .method(
            scope,
            "semicolon_token",
            JsVariableStatement_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsWhileStatement>(scope, global, "JsWhileStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "while_token", JsWhileStatement_while_token)
        .method(scope, "l_paren_token", JsWhileStatement_l_paren_token)
        .method(scope, "test", JsWhileStatement_test)
        .method(scope, "r_paren_token", JsWhileStatement_r_paren_token)
        .method(scope, "body", JsWhileStatement_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsWithStatement>(scope, global, "JsWithStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "with_token", JsWithStatement_with_token)
        .method(scope, "l_paren_token", JsWithStatement_l_paren_token)
        .method(scope, "object", JsWithStatement_object)
        .method(scope, "r_paren_token", JsWithStatement_r_paren_token)
        .method(scope, "body", JsWithStatement_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsYieldArgument>(scope, global, "JsYieldArgument")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "star_token", JsYieldArgument_star_token)
        .method(scope, "expression", JsYieldArgument_expression)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsYieldExpression>(scope, global, "JsYieldExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "yield_token", JsYieldExpression_yield_token)
        .method(scope, "argument", JsYieldExpression_argument)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxAttribute>(scope, global, "JsxAttribute")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name", JsxAttribute_name)
        .method(scope, "initializer", JsxAttribute_initializer)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxAttributeInitializerClause>(
            scope,
            global,
            "JsxAttributeInitializerClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "eq_token", JsxAttributeInitializerClause_eq_token)
        .method(scope, "value", JsxAttributeInitializerClause_value)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxClosingElement>(scope, global, "JsxClosingElement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_angle_token", JsxClosingElement_l_angle_token)
        .method(scope, "slash_token", JsxClosingElement_slash_token)
        .method(scope, "name", JsxClosingElement_name)
        .method(scope, "r_angle_token", JsxClosingElement_r_angle_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxClosingFragment>(scope, global, "JsxClosingFragment")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_angle_token", JsxClosingFragment_l_angle_token)
        .method(scope, "slash_token", JsxClosingFragment_slash_token)
        .method(scope, "r_angle_token", JsxClosingFragment_r_angle_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxElement>(scope, global, "JsxElement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "opening_element", JsxElement_opening_element)
        .method(scope, "children", JsxElement_children)
        .method(scope, "closing_element", JsxElement_closing_element)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxExpressionAttributeValue>(
            scope,
            global,
            "JsxExpressionAttributeValue",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_curly_token",
            JsxExpressionAttributeValue_l_curly_token,
        )
        .method(scope, "expression", JsxExpressionAttributeValue_expression)
        .method(
            scope,
            "r_curly_token",
            JsxExpressionAttributeValue_r_curly_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxExpressionChild>(scope, global, "JsxExpressionChild")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", JsxExpressionChild_l_curly_token)
        .method(scope, "expression", JsxExpressionChild_expression)
        .method(scope, "r_curly_token", JsxExpressionChild_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxFragment>(scope, global, "JsxFragment")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "opening_fragment", JsxFragment_opening_fragment)
        .method(scope, "children", JsxFragment_children)
        .method(scope, "closing_fragment", JsxFragment_closing_fragment)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxMemberName>(scope, global, "JsxMemberName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "object", JsxMemberName_object)
        .method(scope, "dot_token", JsxMemberName_dot_token)
        .method(scope, "member", JsxMemberName_member)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxName>(scope, global, "JsxName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsxName_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxNamespaceName>(scope, global, "JsxNamespaceName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "namespace", JsxNamespaceName_namespace)
        .method(scope, "colon_token", JsxNamespaceName_colon_token)
        .method(scope, "name", JsxNamespaceName_name)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxOpeningElement>(scope, global, "JsxOpeningElement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_angle_token", JsxOpeningElement_l_angle_token)
        .method(scope, "name", JsxOpeningElement_name)
        .method(scope, "type_arguments", JsxOpeningElement_type_arguments)
        .method(scope, "attributes", JsxOpeningElement_attributes)
        .method(scope, "r_angle_token", JsxOpeningElement_r_angle_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxOpeningFragment>(scope, global, "JsxOpeningFragment")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_angle_token", JsxOpeningFragment_l_angle_token)
        .method(scope, "r_angle_token", JsxOpeningFragment_r_angle_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxReferenceIdentifier>(
            scope,
            global,
            "JsxReferenceIdentifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsxReferenceIdentifier_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxSelfClosingElement>(
            scope,
            global,
            "JsxSelfClosingElement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_angle_token", JsxSelfClosingElement_l_angle_token)
        .method(scope, "name", JsxSelfClosingElement_name)
        .method(
            scope,
            "type_arguments",
            JsxSelfClosingElement_type_arguments,
        )
        .method(scope, "attributes", JsxSelfClosingElement_attributes)
        .method(scope, "slash_token", JsxSelfClosingElement_slash_token)
        .method(scope, "r_angle_token", JsxSelfClosingElement_r_angle_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxSpreadAttribute>(scope, global, "JsxSpreadAttribute")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", JsxSpreadAttribute_l_curly_token)
        .method(scope, "dotdotdot_token", JsxSpreadAttribute_dotdotdot_token)
        .method(scope, "argument", JsxSpreadAttribute_argument)
        .method(scope, "r_curly_token", JsxSpreadAttribute_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxSpreadChild>(scope, global, "JsxSpreadChild")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", JsxSpreadChild_l_curly_token)
        .method(scope, "dotdotdot_token", JsxSpreadChild_dotdotdot_token)
        .method(scope, "expression", JsxSpreadChild_expression)
        .method(scope, "r_curly_token", JsxSpreadChild_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxString>(scope, global, "JsxString")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsxString_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxTagExpression>(scope, global, "JsxTagExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "tag", JsxTagExpression_tag)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxText>(scope, global, "JsxText")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "value_token", JsxText_value_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsAbstractModifier>(scope, global, "TsAbstractModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", TsAbstractModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsAccessibilityModifier>(
            scope,
            global,
            "TsAccessibilityModifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "modifier_token",
            TsAccessibilityModifier_modifier_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsAnyType>(scope, global, "TsAnyType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "any_token", TsAnyType_any_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsArrayType>(scope, global, "TsArrayType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "element_type", TsArrayType_element_type)
        .method(scope, "l_brack_token", TsArrayType_l_brack_token)
        .method(scope, "r_brack_token", TsArrayType_r_brack_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsAsAssignment>(scope, global, "TsAsAssignment")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "assignment", TsAsAssignment_assignment)
        .method(scope, "as_token", TsAsAssignment_as_token)
        .method(scope, "ty", TsAsAssignment_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsAsExpression>(scope, global, "TsAsExpression")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "expression", TsAsExpression_expression)
        .method(scope, "as_token", TsAsExpression_as_token)
        .method(scope, "ty", TsAsExpression_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsAssertsCondition>(scope, global, "TsAssertsCondition")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "is_token", TsAssertsCondition_is_token)
        .method(scope, "ty", TsAssertsCondition_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsAssertsReturnType>(scope, global, "TsAssertsReturnType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "asserts_token", TsAssertsReturnType_asserts_token)
        .method(scope, "parameter_name", TsAssertsReturnType_parameter_name)
        .method(scope, "predicate", TsAssertsReturnType_predicate)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsBigintLiteralType>(scope, global, "TsBigintLiteralType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "minus_token", TsBigintLiteralType_minus_token)
        .method(scope, "literal_token", TsBigintLiteralType_literal_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsBigintType>(scope, global, "TsBigintType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "bigint_token", TsBigintType_bigint_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsBooleanLiteralType>(scope, global, "TsBooleanLiteralType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "literal", TsBooleanLiteralType_literal)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsBooleanType>(scope, global, "TsBooleanType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "boolean_token", TsBooleanType_boolean_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsCallSignatureTypeMember>(
            scope,
            global,
            "TsCallSignatureTypeMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "type_parameters",
            TsCallSignatureTypeMember_type_parameters,
        )
        .method(scope, "parameters", TsCallSignatureTypeMember_parameters)
        .method(
            scope,
            "return_type_annotation",
            TsCallSignatureTypeMember_return_type_annotation,
        )
        .method(
            scope,
            "separator_token",
            TsCallSignatureTypeMember_separator_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsConditionalType>(scope, global, "TsConditionalType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "check_type", TsConditionalType_check_type)
        .method(scope, "extends_token", TsConditionalType_extends_token)
        .method(scope, "extends_type", TsConditionalType_extends_type)
        .method(
            scope,
            "question_mark_token",
            TsConditionalType_question_mark_token,
        )
        .method(scope, "true_type", TsConditionalType_true_type)
        .method(scope, "colon_token", TsConditionalType_colon_token)
        .method(scope, "false_type", TsConditionalType_false_type)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsConstModifier>(scope, global, "TsConstModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", TsConstModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsConstructSignatureTypeMember>(
            scope,
            global,
            "TsConstructSignatureTypeMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "new_token", TsConstructSignatureTypeMember_new_token)
        .method(
            scope,
            "type_parameters",
            TsConstructSignatureTypeMember_type_parameters,
        )
        .method(
            scope,
            "parameters",
            TsConstructSignatureTypeMember_parameters,
        )
        .method(
            scope,
            "type_annotation",
            TsConstructSignatureTypeMember_type_annotation,
        )
        .method(
            scope,
            "separator_token",
            TsConstructSignatureTypeMember_separator_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsConstructorSignatureClassMember>(
            scope,
            global,
            "TsConstructorSignatureClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "modifiers",
            TsConstructorSignatureClassMember_modifiers,
        )
        .method(scope, "name", TsConstructorSignatureClassMember_name)
        .method(
            scope,
            "parameters",
            TsConstructorSignatureClassMember_parameters,
        )
        .method(
            scope,
            "semicolon_token",
            TsConstructorSignatureClassMember_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsConstructorType>(scope, global, "TsConstructorType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "abstract_token", TsConstructorType_abstract_token)
        .method(scope, "new_token", TsConstructorType_new_token)
        .method(scope, "type_parameters", TsConstructorType_type_parameters)
        .method(scope, "parameters", TsConstructorType_parameters)
        .method(scope, "fat_arrow_token", TsConstructorType_fat_arrow_token)
        .method(scope, "return_type", TsConstructorType_return_type)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsDeclareFunctionDeclaration>(
            scope,
            global,
            "TsDeclareFunctionDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "async_token",
            TsDeclareFunctionDeclaration_async_token,
        )
        .method(
            scope,
            "function_token",
            TsDeclareFunctionDeclaration_function_token,
        )
        .method(scope, "id", TsDeclareFunctionDeclaration_id)
        .method(
            scope,
            "type_parameters",
            TsDeclareFunctionDeclaration_type_parameters,
        )
        .method(scope, "parameters", TsDeclareFunctionDeclaration_parameters)
        .method(
            scope,
            "return_type_annotation",
            TsDeclareFunctionDeclaration_return_type_annotation,
        )
        .method(
            scope,
            "semicolon_token",
            TsDeclareFunctionDeclaration_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration>(
            scope,
            global,
            "TsDeclareFunctionExportDefaultDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "async_token",
            TsDeclareFunctionExportDefaultDeclaration_async_token,
        )
        .method(
            scope,
            "function_token",
            TsDeclareFunctionExportDefaultDeclaration_function_token,
        )
        .method(scope, "id", TsDeclareFunctionExportDefaultDeclaration_id)
        .method(
            scope,
            "type_parameters",
            TsDeclareFunctionExportDefaultDeclaration_type_parameters,
        )
        .method(
            scope,
            "parameters",
            TsDeclareFunctionExportDefaultDeclaration_parameters,
        )
        .method(
            scope,
            "return_type_annotation",
            TsDeclareFunctionExportDefaultDeclaration_return_type_annotation,
        )
        .method(
            scope,
            "semicolon_token",
            TsDeclareFunctionExportDefaultDeclaration_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsDeclareModifier>(scope, global, "TsDeclareModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", TsDeclareModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsDeclareStatement>(scope, global, "TsDeclareStatement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "declare_token", TsDeclareStatement_declare_token)
        .method(scope, "declaration", TsDeclareStatement_declaration)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsDefaultTypeClause>(scope, global, "TsDefaultTypeClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "eq_token", TsDefaultTypeClause_eq_token)
        .method(scope, "ty", TsDefaultTypeClause_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsDefinitePropertyAnnotation>(
            scope,
            global,
            "TsDefinitePropertyAnnotation",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "excl_token", TsDefinitePropertyAnnotation_excl_token)
        .method(
            scope,
            "type_annotation",
            TsDefinitePropertyAnnotation_type_annotation,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsDefiniteVariableAnnotation>(
            scope,
            global,
            "TsDefiniteVariableAnnotation",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "excl_token", TsDefiniteVariableAnnotation_excl_token)
        .method(
            scope,
            "type_annotation",
            TsDefiniteVariableAnnotation_type_annotation,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsEmptyExternalModuleDeclarationBody>(
            scope,
            global,
            "TsEmptyExternalModuleDeclarationBody",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "semicolon_token",
            TsEmptyExternalModuleDeclarationBody_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsEnumDeclaration>(scope, global, "TsEnumDeclaration")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "const_token", TsEnumDeclaration_const_token)
        .method(scope, "enum_token", TsEnumDeclaration_enum_token)
        .method(scope, "id", TsEnumDeclaration_id)
        .method(scope, "l_curly_token", TsEnumDeclaration_l_curly_token)
        .method(scope, "members", TsEnumDeclaration_members)
        .method(scope, "r_curly_token", TsEnumDeclaration_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsEnumMember>(scope, global, "TsEnumMember")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name", TsEnumMember_name)
        .method(scope, "initializer", TsEnumMember_initializer)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsExportAsNamespaceClause>(
            scope,
            global,
            "TsExportAsNamespaceClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "as_token", TsExportAsNamespaceClause_as_token)
        .method(
            scope,
            "namespace_token",
            TsExportAsNamespaceClause_namespace_token,
        )
        .method(scope, "name", TsExportAsNamespaceClause_name)
        .method(
            scope,
            "semicolon_token",
            TsExportAsNamespaceClause_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsExportAssignmentClause>(
            scope,
            global,
            "TsExportAssignmentClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "eq_token", TsExportAssignmentClause_eq_token)
        .method(scope, "expression", TsExportAssignmentClause_expression)
        .method(
            scope,
            "semicolon_token",
            TsExportAssignmentClause_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsExportDeclareClause>(
            scope,
            global,
            "TsExportDeclareClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "declare_token", TsExportDeclareClause_declare_token)
        .method(scope, "declaration", TsExportDeclareClause_declaration)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsExtendsClause>(scope, global, "TsExtendsClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "extends_token", TsExtendsClause_extends_token)
        .method(scope, "types", TsExtendsClause_types)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsExternalModuleDeclaration>(
            scope,
            global,
            "TsExternalModuleDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "module_token",
            TsExternalModuleDeclaration_module_token,
        )
        .method(scope, "source", TsExternalModuleDeclaration_source)
        .method(scope, "body", TsExternalModuleDeclaration_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsExternalModuleReference>(
            scope,
            global,
            "TsExternalModuleReference",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "require_token",
            TsExternalModuleReference_require_token,
        )
        .method(
            scope,
            "l_paren_token",
            TsExternalModuleReference_l_paren_token,
        )
        .method(scope, "source", TsExternalModuleReference_source)
        .method(
            scope,
            "r_paren_token",
            TsExternalModuleReference_r_paren_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsFunctionType>(scope, global, "TsFunctionType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_parameters", TsFunctionType_type_parameters)
        .method(scope, "parameters", TsFunctionType_parameters)
        .method(scope, "fat_arrow_token", TsFunctionType_fat_arrow_token)
        .method(scope, "return_type", TsFunctionType_return_type)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsGetterSignatureClassMember>(
            scope,
            global,
            "TsGetterSignatureClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", TsGetterSignatureClassMember_modifiers)
        .method(scope, "get_token", TsGetterSignatureClassMember_get_token)
        .method(scope, "name", TsGetterSignatureClassMember_name)
        .method(
            scope,
            "l_paren_token",
            TsGetterSignatureClassMember_l_paren_token,
        )
        .method(
            scope,
            "r_paren_token",
            TsGetterSignatureClassMember_r_paren_token,
        )
        .method(
            scope,
            "return_type",
            TsGetterSignatureClassMember_return_type,
        )
        .method(
            scope,
            "semicolon_token",
            TsGetterSignatureClassMember_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsGetterSignatureTypeMember>(
            scope,
            global,
            "TsGetterSignatureTypeMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "get_token", TsGetterSignatureTypeMember_get_token)
        .method(scope, "name", TsGetterSignatureTypeMember_name)
        .method(
            scope,
            "l_paren_token",
            TsGetterSignatureTypeMember_l_paren_token,
        )
        .method(
            scope,
            "r_paren_token",
            TsGetterSignatureTypeMember_r_paren_token,
        )
        .method(
            scope,
            "type_annotation",
            TsGetterSignatureTypeMember_type_annotation,
        )
        .method(
            scope,
            "separator_token",
            TsGetterSignatureTypeMember_separator_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsGlobalDeclaration>(scope, global, "TsGlobalDeclaration")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "global_token", TsGlobalDeclaration_global_token)
        .method(scope, "body", TsGlobalDeclaration_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsIdentifierBinding>(scope, global, "TsIdentifierBinding")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name_token", TsIdentifierBinding_name_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsImplementsClause>(scope, global, "TsImplementsClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "implements_token",
            TsImplementsClause_implements_token,
        )
        .method(scope, "types", TsImplementsClause_types)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsImportEqualsDeclaration>(
            scope,
            global,
            "TsImportEqualsDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "import_token",
            TsImportEqualsDeclaration_import_token,
        )
        .method(scope, "type_token", TsImportEqualsDeclaration_type_token)
        .method(scope, "id", TsImportEqualsDeclaration_id)
        .method(scope, "eq_token", TsImportEqualsDeclaration_eq_token)
        .method(
            scope,
            "module_reference",
            TsImportEqualsDeclaration_module_reference,
        )
        .method(
            scope,
            "semicolon_token",
            TsImportEqualsDeclaration_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsImportType>(scope, global, "TsImportType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "typeof_token", TsImportType_typeof_token)
        .method(scope, "import_token", TsImportType_import_token)
        .method(scope, "l_paren_token", TsImportType_l_paren_token)
        .method(scope, "argument_token", TsImportType_argument_token)
        .method(scope, "r_paren_token", TsImportType_r_paren_token)
        .method(scope, "qualifier_clause", TsImportType_qualifier_clause)
        .method(scope, "type_arguments", TsImportType_type_arguments)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsImportTypeQualifier>(
            scope,
            global,
            "TsImportTypeQualifier",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "dot_token", TsImportTypeQualifier_dot_token)
        .method(scope, "right", TsImportTypeQualifier_right)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsInModifier>(scope, global, "TsInModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", TsInModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsIndexSignatureClassMember>(
            scope,
            global,
            "TsIndexSignatureClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", TsIndexSignatureClassMember_modifiers)
        .method(
            scope,
            "l_brack_token",
            TsIndexSignatureClassMember_l_brack_token,
        )
        .method(scope, "parameter", TsIndexSignatureClassMember_parameter)
        .method(
            scope,
            "r_brack_token",
            TsIndexSignatureClassMember_r_brack_token,
        )
        .method(
            scope,
            "type_annotation",
            TsIndexSignatureClassMember_type_annotation,
        )
        .method(
            scope,
            "semicolon_token",
            TsIndexSignatureClassMember_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsIndexSignatureParameter>(
            scope,
            global,
            "TsIndexSignatureParameter",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "binding", TsIndexSignatureParameter_binding)
        .method(
            scope,
            "type_annotation",
            TsIndexSignatureParameter_type_annotation,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsIndexSignatureTypeMember>(
            scope,
            global,
            "TsIndexSignatureTypeMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "readonly_token",
            TsIndexSignatureTypeMember_readonly_token,
        )
        .method(
            scope,
            "l_brack_token",
            TsIndexSignatureTypeMember_l_brack_token,
        )
        .method(scope, "parameter", TsIndexSignatureTypeMember_parameter)
        .method(
            scope,
            "r_brack_token",
            TsIndexSignatureTypeMember_r_brack_token,
        )
        .method(
            scope,
            "type_annotation",
            TsIndexSignatureTypeMember_type_annotation,
        )
        .method(
            scope,
            "separator_token",
            TsIndexSignatureTypeMember_separator_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsIndexedAccessType>(scope, global, "TsIndexedAccessType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "object_type", TsIndexedAccessType_object_type)
        .method(scope, "l_brack_token", TsIndexedAccessType_l_brack_token)
        .method(scope, "index_type", TsIndexedAccessType_index_type)
        .method(scope, "r_brack_token", TsIndexedAccessType_r_brack_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsInferType>(scope, global, "TsInferType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "infer_token", TsInferType_infer_token)
        .method(scope, "name", TsInferType_name)
        .method(scope, "constraint", TsInferType_constraint)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsInitializedPropertySignatureClassMember>(
            scope,
            global,
            "TsInitializedPropertySignatureClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "modifiers",
            TsInitializedPropertySignatureClassMember_modifiers,
        )
        .method(
            scope,
            "name",
            TsInitializedPropertySignatureClassMember_name,
        )
        .method(
            scope,
            "question_mark_token",
            TsInitializedPropertySignatureClassMember_question_mark_token,
        )
        .method(
            scope,
            "value",
            TsInitializedPropertySignatureClassMember_value,
        )
        .method(
            scope,
            "semicolon_token",
            TsInitializedPropertySignatureClassMember_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsInstantiationExpression>(
            scope,
            global,
            "TsInstantiationExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "expression", TsInstantiationExpression_expression)
        .method(scope, "arguments", TsInstantiationExpression_arguments)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsInterfaceDeclaration>(
            scope,
            global,
            "TsInterfaceDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "interface_token",
            TsInterfaceDeclaration_interface_token,
        )
        .method(scope, "id", TsInterfaceDeclaration_id)
        .method(
            scope,
            "type_parameters",
            TsInterfaceDeclaration_type_parameters,
        )
        .method(
            scope,
            "extends_clause",
            TsInterfaceDeclaration_extends_clause,
        )
        .method(scope, "l_curly_token", TsInterfaceDeclaration_l_curly_token)
        .method(scope, "members", TsInterfaceDeclaration_members)
        .method(scope, "r_curly_token", TsInterfaceDeclaration_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsIntersectionType>(scope, global, "TsIntersectionType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "leading_separator_token",
            TsIntersectionType_leading_separator_token,
        )
        .method(scope, "types", TsIntersectionType_types)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsMappedType>(scope, global, "TsMappedType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", TsMappedType_l_curly_token)
        .method(scope, "readonly_modifier", TsMappedType_readonly_modifier)
        .method(scope, "l_brack_token", TsMappedType_l_brack_token)
        .method(scope, "property_name", TsMappedType_property_name)
        .method(scope, "in_token", TsMappedType_in_token)
        .method(scope, "keys_type", TsMappedType_keys_type)
        .method(scope, "as_clause", TsMappedType_as_clause)
        .method(scope, "r_brack_token", TsMappedType_r_brack_token)
        .method(scope, "optional_modifier", TsMappedType_optional_modifier)
        .method(scope, "mapped_type", TsMappedType_mapped_type)
        .method(scope, "semicolon_token", TsMappedType_semicolon_token)
        .method(scope, "r_curly_token", TsMappedType_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsMappedTypeAsClause>(scope, global, "TsMappedTypeAsClause")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "as_token", TsMappedTypeAsClause_as_token)
        .method(scope, "ty", TsMappedTypeAsClause_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsMappedTypeOptionalModifierClause>(
            scope,
            global,
            "TsMappedTypeOptionalModifierClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "operator_token",
            TsMappedTypeOptionalModifierClause_operator_token,
        )
        .method(
            scope,
            "question_mark_token",
            TsMappedTypeOptionalModifierClause_question_mark_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsMappedTypeReadonlyModifierClause>(
            scope,
            global,
            "TsMappedTypeReadonlyModifierClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "operator_token",
            TsMappedTypeReadonlyModifierClause_operator_token,
        )
        .method(
            scope,
            "readonly_token",
            TsMappedTypeReadonlyModifierClause_readonly_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsMethodSignatureClassMember>(
            scope,
            global,
            "TsMethodSignatureClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", TsMethodSignatureClassMember_modifiers)
        .method(
            scope,
            "async_token",
            TsMethodSignatureClassMember_async_token,
        )
        .method(scope, "name", TsMethodSignatureClassMember_name)
        .method(
            scope,
            "question_mark_token",
            TsMethodSignatureClassMember_question_mark_token,
        )
        .method(
            scope,
            "type_parameters",
            TsMethodSignatureClassMember_type_parameters,
        )
        .method(scope, "parameters", TsMethodSignatureClassMember_parameters)
        .method(
            scope,
            "return_type_annotation",
            TsMethodSignatureClassMember_return_type_annotation,
        )
        .method(
            scope,
            "semicolon_token",
            TsMethodSignatureClassMember_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsMethodSignatureTypeMember>(
            scope,
            global,
            "TsMethodSignatureTypeMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name", TsMethodSignatureTypeMember_name)
        .method(
            scope,
            "optional_token",
            TsMethodSignatureTypeMember_optional_token,
        )
        .method(
            scope,
            "type_parameters",
            TsMethodSignatureTypeMember_type_parameters,
        )
        .method(scope, "parameters", TsMethodSignatureTypeMember_parameters)
        .method(
            scope,
            "return_type_annotation",
            TsMethodSignatureTypeMember_return_type_annotation,
        )
        .method(
            scope,
            "separator_token",
            TsMethodSignatureTypeMember_separator_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsModuleBlock>(scope, global, "TsModuleBlock")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", TsModuleBlock_l_curly_token)
        .method(scope, "items", TsModuleBlock_items)
        .method(scope, "r_curly_token", TsModuleBlock_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsModuleDeclaration>(scope, global, "TsModuleDeclaration")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "module_or_namespace",
            TsModuleDeclaration_module_or_namespace,
        )
        .method(scope, "name", TsModuleDeclaration_name)
        .method(scope, "body", TsModuleDeclaration_body)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNameWithTypeArguments>(
            scope,
            global,
            "TsNameWithTypeArguments",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name", TsNameWithTypeArguments_name)
        .method(
            scope,
            "type_arguments",
            TsNameWithTypeArguments_type_arguments,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNamedTupleTypeElement>(
            scope,
            global,
            "TsNamedTupleTypeElement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "dotdotdot_token",
            TsNamedTupleTypeElement_dotdotdot_token,
        )
        .method(scope, "name", TsNamedTupleTypeElement_name)
        .method(
            scope,
            "question_mark_token",
            TsNamedTupleTypeElement_question_mark_token,
        )
        .method(scope, "colon_token", TsNamedTupleTypeElement_colon_token)
        .method(scope, "ty", TsNamedTupleTypeElement_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNeverType>(scope, global, "TsNeverType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "never_token", TsNeverType_never_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNonNullAssertionAssignment>(
            scope,
            global,
            "TsNonNullAssertionAssignment",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "assignment", TsNonNullAssertionAssignment_assignment)
        .method(scope, "excl_token", TsNonNullAssertionAssignment_excl_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNonNullAssertionExpression>(
            scope,
            global,
            "TsNonNullAssertionExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "expression", TsNonNullAssertionExpression_expression)
        .method(scope, "excl_token", TsNonNullAssertionExpression_excl_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNonPrimitiveType>(scope, global, "TsNonPrimitiveType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "object_token", TsNonPrimitiveType_object_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNullLiteralType>(scope, global, "TsNullLiteralType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "literal_token", TsNullLiteralType_literal_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNumberLiteralType>(scope, global, "TsNumberLiteralType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "minus_token", TsNumberLiteralType_minus_token)
        .method(scope, "literal_token", TsNumberLiteralType_literal_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsNumberType>(scope, global, "TsNumberType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "number_token", TsNumberType_number_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsObjectType>(scope, global, "TsObjectType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_curly_token", TsObjectType_l_curly_token)
        .method(scope, "members", TsObjectType_members)
        .method(scope, "r_curly_token", TsObjectType_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsOptionalPropertyAnnotation>(
            scope,
            global,
            "TsOptionalPropertyAnnotation",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "question_mark_token",
            TsOptionalPropertyAnnotation_question_mark_token,
        )
        .method(
            scope,
            "type_annotation",
            TsOptionalPropertyAnnotation_type_annotation,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsOptionalTupleTypeElement>(
            scope,
            global,
            "TsOptionalTupleTypeElement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "ty", TsOptionalTupleTypeElement_ty)
        .method(
            scope,
            "question_mark_token",
            TsOptionalTupleTypeElement_question_mark_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsOutModifier>(scope, global, "TsOutModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", TsOutModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsOverrideModifier>(scope, global, "TsOverrideModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", TsOverrideModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsParenthesizedType>(scope, global, "TsParenthesizedType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_paren_token", TsParenthesizedType_l_paren_token)
        .method(scope, "ty", TsParenthesizedType_ty)
        .method(scope, "r_paren_token", TsParenthesizedType_r_paren_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsPredicateReturnType>(
            scope,
            global,
            "TsPredicateReturnType",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "parameter_name",
            TsPredicateReturnType_parameter_name,
        )
        .method(scope, "is_token", TsPredicateReturnType_is_token)
        .method(scope, "ty", TsPredicateReturnType_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsPropertyParameter>(scope, global, "TsPropertyParameter")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "decorators", TsPropertyParameter_decorators)
        .method(scope, "modifiers", TsPropertyParameter_modifiers)
        .method(
            scope,
            "formal_parameter",
            TsPropertyParameter_formal_parameter,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsPropertySignatureClassMember>(
            scope,
            global,
            "TsPropertySignatureClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", TsPropertySignatureClassMember_modifiers)
        .method(scope, "name", TsPropertySignatureClassMember_name)
        .method(
            scope,
            "property_annotation",
            TsPropertySignatureClassMember_property_annotation,
        )
        .method(
            scope,
            "semicolon_token",
            TsPropertySignatureClassMember_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsPropertySignatureTypeMember>(
            scope,
            global,
            "TsPropertySignatureTypeMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "readonly_token",
            TsPropertySignatureTypeMember_readonly_token,
        )
        .method(scope, "name", TsPropertySignatureTypeMember_name)
        .method(
            scope,
            "optional_token",
            TsPropertySignatureTypeMember_optional_token,
        )
        .method(
            scope,
            "type_annotation",
            TsPropertySignatureTypeMember_type_annotation,
        )
        .method(
            scope,
            "separator_token",
            TsPropertySignatureTypeMember_separator_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsQualifiedModuleName>(
            scope,
            global,
            "TsQualifiedModuleName",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "left", TsQualifiedModuleName_left)
        .method(scope, "dot_token", TsQualifiedModuleName_dot_token)
        .method(scope, "right", TsQualifiedModuleName_right)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsQualifiedName>(scope, global, "TsQualifiedName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "left", TsQualifiedName_left)
        .method(scope, "dot_token", TsQualifiedName_dot_token)
        .method(scope, "right", TsQualifiedName_right)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsReadonlyModifier>(scope, global, "TsReadonlyModifier")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifier_token", TsReadonlyModifier_modifier_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsReferenceType>(scope, global, "TsReferenceType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "name", TsReferenceType_name)
        .method(scope, "type_arguments", TsReferenceType_type_arguments)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsRestTupleTypeElement>(
            scope,
            global,
            "TsRestTupleTypeElement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "dotdotdot_token",
            TsRestTupleTypeElement_dotdotdot_token,
        )
        .method(scope, "ty", TsRestTupleTypeElement_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsReturnTypeAnnotation>(
            scope,
            global,
            "TsReturnTypeAnnotation",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "colon_token", TsReturnTypeAnnotation_colon_token)
        .method(scope, "ty", TsReturnTypeAnnotation_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsSatisfiesAssignment>(
            scope,
            global,
            "TsSatisfiesAssignment",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "assignment", TsSatisfiesAssignment_assignment)
        .method(
            scope,
            "satisfies_token",
            TsSatisfiesAssignment_satisfies_token,
        )
        .method(scope, "ty", TsSatisfiesAssignment_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsSatisfiesExpression>(
            scope,
            global,
            "TsSatisfiesExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "expression", TsSatisfiesExpression_expression)
        .method(
            scope,
            "satisfies_token",
            TsSatisfiesExpression_satisfies_token,
        )
        .method(scope, "ty", TsSatisfiesExpression_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsSetterSignatureClassMember>(
            scope,
            global,
            "TsSetterSignatureClassMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", TsSetterSignatureClassMember_modifiers)
        .method(scope, "set_token", TsSetterSignatureClassMember_set_token)
        .method(scope, "name", TsSetterSignatureClassMember_name)
        .method(
            scope,
            "l_paren_token",
            TsSetterSignatureClassMember_l_paren_token,
        )
        .method(scope, "parameter", TsSetterSignatureClassMember_parameter)
        .method(
            scope,
            "r_paren_token",
            TsSetterSignatureClassMember_r_paren_token,
        )
        .method(
            scope,
            "semicolon_token",
            TsSetterSignatureClassMember_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsSetterSignatureTypeMember>(
            scope,
            global,
            "TsSetterSignatureTypeMember",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "set_token", TsSetterSignatureTypeMember_set_token)
        .method(scope, "name", TsSetterSignatureTypeMember_name)
        .method(
            scope,
            "l_paren_token",
            TsSetterSignatureTypeMember_l_paren_token,
        )
        .method(scope, "parameter", TsSetterSignatureTypeMember_parameter)
        .method(
            scope,
            "r_paren_token",
            TsSetterSignatureTypeMember_r_paren_token,
        )
        .method(
            scope,
            "separator_token",
            TsSetterSignatureTypeMember_separator_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsStringLiteralType>(scope, global, "TsStringLiteralType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "literal_token", TsStringLiteralType_literal_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsStringType>(scope, global, "TsStringType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "string_token", TsStringType_string_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsSymbolType>(scope, global, "TsSymbolType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "symbol_token", TsSymbolType_symbol_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTemplateChunkElement>(
            scope,
            global,
            "TsTemplateChunkElement",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "template_chunk_token",
            TsTemplateChunkElement_template_chunk_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTemplateElement>(scope, global, "TsTemplateElement")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "dollar_curly_token",
            TsTemplateElement_dollar_curly_token,
        )
        .method(scope, "ty", TsTemplateElement_ty)
        .method(scope, "r_curly_token", TsTemplateElement_r_curly_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTemplateLiteralType>(
            scope,
            global,
            "TsTemplateLiteralType",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_tick_token", TsTemplateLiteralType_l_tick_token)
        .method(scope, "elements", TsTemplateLiteralType_elements)
        .method(scope, "r_tick_token", TsTemplateLiteralType_r_tick_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsThisParameter>(scope, global, "TsThisParameter")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "this_token", TsThisParameter_this_token)
        .method(scope, "type_annotation", TsThisParameter_type_annotation)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsThisType>(scope, global, "TsThisType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "this_token", TsThisType_this_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTupleType>(scope, global, "TsTupleType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_brack_token", TsTupleType_l_brack_token)
        .method(scope, "elements", TsTupleType_elements)
        .method(scope, "r_brack_token", TsTupleType_r_brack_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeAliasDeclaration>(
            scope,
            global,
            "TsTypeAliasDeclaration",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "type_token", TsTypeAliasDeclaration_type_token)
        .method(
            scope,
            "binding_identifier",
            TsTypeAliasDeclaration_binding_identifier,
        )
        .method(
            scope,
            "type_parameters",
            TsTypeAliasDeclaration_type_parameters,
        )
        .method(scope, "eq_token", TsTypeAliasDeclaration_eq_token)
        .method(scope, "ty", TsTypeAliasDeclaration_ty)
        .method(
            scope,
            "semicolon_token",
            TsTypeAliasDeclaration_semicolon_token,
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeAnnotation>(scope, global, "TsTypeAnnotation")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "colon_token", TsTypeAnnotation_colon_token)
        .method(scope, "ty", TsTypeAnnotation_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeArguments>(scope, global, "TsTypeArguments")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_angle_token", TsTypeArguments_l_angle_token)
        .method(
            scope,
            "ts_type_argument_list",
            TsTypeArguments_ts_type_argument_list,
        )
        .method(scope, "r_angle_token", TsTypeArguments_r_angle_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeAssertionAssignment>(
            scope,
            global,
            "TsTypeAssertionAssignment",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_angle_token",
            TsTypeAssertionAssignment_l_angle_token,
        )
        .method(scope, "ty", TsTypeAssertionAssignment_ty)
        .method(
            scope,
            "r_angle_token",
            TsTypeAssertionAssignment_r_angle_token,
        )
        .method(scope, "assignment", TsTypeAssertionAssignment_assignment)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeAssertionExpression>(
            scope,
            global,
            "TsTypeAssertionExpression",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "l_angle_token",
            TsTypeAssertionExpression_l_angle_token,
        )
        .method(scope, "ty", TsTypeAssertionExpression_ty)
        .method(
            scope,
            "r_angle_token",
            TsTypeAssertionExpression_r_angle_token,
        )
        .method(scope, "expression", TsTypeAssertionExpression_expression)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeConstraintClause>(
            scope,
            global,
            "TsTypeConstraintClause",
        )
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "extends_token", TsTypeConstraintClause_extends_token)
        .method(scope, "ty", TsTypeConstraintClause_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeOperatorType>(scope, global, "TsTypeOperatorType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "operator_token", TsTypeOperatorType_operator_token)
        .method(scope, "ty", TsTypeOperatorType_ty)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeParameter>(scope, global, "TsTypeParameter")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "modifiers", TsTypeParameter_modifiers)
        .method(scope, "name", TsTypeParameter_name)
        .method(scope, "constraint", TsTypeParameter_constraint)
        .method(scope, "default", TsTypeParameter_default)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeParameterName>(scope, global, "TsTypeParameterName")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "ident_token", TsTypeParameterName_ident_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeParameters>(scope, global, "TsTypeParameters")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "l_angle_token", TsTypeParameters_l_angle_token)
        .method(scope, "items", TsTypeParameters_items)
        .method(scope, "r_angle_token", TsTypeParameters_r_angle_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeofType>(scope, global, "TsTypeofType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "typeof_token", TsTypeofType_typeof_token)
        .method(scope, "expression_name", TsTypeofType_expression_name)
        .method(scope, "type_arguments", TsTypeofType_type_arguments)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsUndefinedType>(scope, global, "TsUndefinedType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "undefined_token", TsUndefinedType_undefined_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsUnionType>(scope, global, "TsUnionType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(
            scope,
            "leading_separator_token",
            TsUnionType_leading_separator_token,
        )
        .method(scope, "types", TsUnionType_types)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsUnknownType>(scope, global, "TsUnknownType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "unknown_token", TsUnknownType_unknown_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsVoidType>(scope, global, "TsVoidType")
        .extends::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>(scope)
        .method(scope, "void_token", TsVoidType_void_token)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogus>(scope, global, "JsBogus")
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogusAssignment>(scope, global, "JsBogusAssignment")
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogusBinding>(scope, global, "JsBogusBinding")
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogusExpression>(scope, global, "JsBogusExpression")
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogusImportAssertionEntry>(
            scope,
            global,
            "JsBogusImportAssertionEntry",
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogusMember>(scope, global, "JsBogusMember")
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogusNamedImportSpecifier>(
            scope,
            global,
            "JsBogusNamedImportSpecifier",
        )
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogusParameter>(scope, global, "JsBogusParameter")
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsBogusStatement>(scope, global, "JsBogusStatement")
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsBogusType>(scope, global, "TsBogusType")
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayAssignmentPatternElementList>(
            scope,
            global,
            "JsArrayAssignmentPatternElementList",
        )
        .method(scope, "iter", JsArrayAssignmentPatternElementList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayBindingPatternElementList>(
            scope,
            global,
            "JsArrayBindingPatternElementList",
        )
        .method(scope, "iter", JsArrayBindingPatternElementList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsArrayElementList>(scope, global, "JsArrayElementList")
        .method(scope, "iter", JsArrayElementList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsCallArgumentList>(scope, global, "JsCallArgumentList")
        .method(scope, "iter", JsCallArgumentList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsClassMemberList>(scope, global, "JsClassMemberList")
        .method(scope, "iter", JsClassMemberList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsConstructorModifierList>(
            scope,
            global,
            "JsConstructorModifierList",
        )
        .method(scope, "iter", JsConstructorModifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsConstructorParameterList>(
            scope,
            global,
            "JsConstructorParameterList",
        )
        .method(scope, "iter", JsConstructorParameterList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsDecoratorList>(scope, global, "JsDecoratorList")
        .method(scope, "iter", JsDecoratorList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsDirectiveList>(scope, global, "JsDirectiveList")
        .method(scope, "iter", JsDirectiveList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportNamedFromSpecifierList>(
            scope,
            global,
            "JsExportNamedFromSpecifierList",
        )
        .method(scope, "iter", JsExportNamedFromSpecifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsExportNamedSpecifierList>(
            scope,
            global,
            "JsExportNamedSpecifierList",
        )
        .method(scope, "iter", JsExportNamedSpecifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsImportAssertionEntryList>(
            scope,
            global,
            "JsImportAssertionEntryList",
        )
        .method(scope, "iter", JsImportAssertionEntryList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsMethodModifierList>(scope, global, "JsMethodModifierList")
        .method(scope, "iter", JsMethodModifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsModuleItemList>(scope, global, "JsModuleItemList")
        .method(scope, "iter", JsModuleItemList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsNamedImportSpecifierList>(
            scope,
            global,
            "JsNamedImportSpecifierList",
        )
        .method(scope, "iter", JsNamedImportSpecifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectAssignmentPatternPropertyList>(
            scope,
            global,
            "JsObjectAssignmentPatternPropertyList",
        )
        .method(scope, "iter", JsObjectAssignmentPatternPropertyList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectBindingPatternPropertyList>(
            scope,
            global,
            "JsObjectBindingPatternPropertyList",
        )
        .method(scope, "iter", JsObjectBindingPatternPropertyList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsObjectMemberList>(scope, global, "JsObjectMemberList")
        .method(scope, "iter", JsObjectMemberList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsParameterList>(scope, global, "JsParameterList")
        .method(scope, "iter", JsParameterList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsPropertyModifierList>(
            scope,
            global,
            "JsPropertyModifierList",
        )
        .method(scope, "iter", JsPropertyModifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsStatementList>(scope, global, "JsStatementList")
        .method(scope, "iter", JsStatementList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsSwitchCaseList>(scope, global, "JsSwitchCaseList")
        .method(scope, "iter", JsSwitchCaseList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsTemplateElementList>(
            scope,
            global,
            "JsTemplateElementList",
        )
        .method(scope, "iter", JsTemplateElementList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsVariableDeclaratorList>(
            scope,
            global,
            "JsVariableDeclaratorList",
        )
        .method(scope, "iter", JsVariableDeclaratorList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxAttributeList>(scope, global, "JsxAttributeList")
        .method(scope, "iter", JsxAttributeList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::JsxChildList>(scope, global, "JsxChildList")
        .method(scope, "iter", JsxChildList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsEnumMemberList>(scope, global, "TsEnumMemberList")
        .method(scope, "iter", TsEnumMemberList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsIndexSignatureModifierList>(
            scope,
            global,
            "TsIndexSignatureModifierList",
        )
        .method(scope, "iter", TsIndexSignatureModifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsIntersectionTypeElementList>(
            scope,
            global,
            "TsIntersectionTypeElementList",
        )
        .method(scope, "iter", TsIntersectionTypeElementList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsMethodSignatureModifierList>(
            scope,
            global,
            "TsMethodSignatureModifierList",
        )
        .method(scope, "iter", TsMethodSignatureModifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsPropertyParameterModifierList>(
            scope,
            global,
            "TsPropertyParameterModifierList",
        )
        .method(scope, "iter", TsPropertyParameterModifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsPropertySignatureModifierList>(
            scope,
            global,
            "TsPropertySignatureModifierList",
        )
        .method(scope, "iter", TsPropertySignatureModifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTemplateElementList>(
            scope,
            global,
            "TsTemplateElementList",
        )
        .method(scope, "iter", TsTemplateElementList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTupleTypeElementList>(
            scope,
            global,
            "TsTupleTypeElementList",
        )
        .method(scope, "iter", TsTupleTypeElementList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeArgumentList>(scope, global, "TsTypeArgumentList")
        .method(scope, "iter", TsTypeArgumentList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeList>(scope, global, "TsTypeList")
        .method(scope, "iter", TsTypeList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeMemberList>(scope, global, "TsTypeMemberList")
        .method(scope, "iter", TsTypeMemberList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeParameterList>(scope, global, "TsTypeParameterList")
        .method(scope, "iter", TsTypeParameterList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsTypeParameterModifierList>(
            scope,
            global,
            "TsTypeParameterModifierList",
        )
        .method(scope, "iter", TsTypeParameterModifierList_iter)
        .finish(scope);
    registry
        .build_class::<rome_js_syntax::TsUnionTypeVariantList>(
            scope,
            global,
            "TsUnionTypeVariantList",
        )
        .method(scope, "iter", TsUnionTypeVariantList_iter)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsArrayAssignmentPatternElement,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsArrayBindingPatternElement,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsArrayElement,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsCallArgument,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsClassMember,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsConstructorParameter,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsExportNamedSpecifier,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsImportAssertionEntry,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsMethodModifier,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry . build_interface :: < rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsModuleItem > > (scope) . iterable (scope , ToV8 :: to_v8) . finish (scope) ;
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsNamedImportSpecifier,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsObjectAssignmentPatternMember,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsObjectBindingPatternMember,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsObjectMember,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsParameter,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsPropertyModifier,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry . build_interface :: < rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsStatement > > (scope) . iterable (scope , ToV8 :: to_v8) . finish (scope) ;
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsSwitchClause,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyJsTemplateElement,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry . build_interface :: < rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsxAttribute > > (scope) . iterable (scope , ToV8 :: to_v8) . finish (scope) ;
    registry . build_interface :: < rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsxChild > > (scope) . iterable (scope , ToV8 :: to_v8) . finish (scope) ;
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyTsIndexSignatureModifier,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyTsMethodSignatureModifier,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyTsPropertyParameterModifier,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyTsPropertySignatureModifier,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyTsTemplateElement,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyTsTupleTypeElement,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyTsType,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry . build_interface :: < rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsTypeMember > > (scope) . iterable (scope , ToV8 :: to_v8) . finish (scope) ;
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::AnyTsTypeParameterModifier,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry . build_interface :: < rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: JsDecorator > > (scope) . iterable (scope , ToV8 :: to_v8) . finish (scope) ;
    registry . build_interface :: < rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: JsDirective > > (scope) . iterable (scope , ToV8 :: to_v8) . finish (scope) ;
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::JsExportNamedFromSpecifier,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::JsVariableDeclarator,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstNodeListIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::TsAccessibilityModifier,
        >>(scope)
        .iterable(scope, ToV8::to_v8)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::TsEnumMember,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::TsNameWithTypeArguments,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
    registry
        .build_interface::<rome_rowan::AstSeparatedListNodesIterator<
            rome_js_syntax::JsLanguage,
            rome_js_syntax::TsTypeParameter,
        >>(scope)
        .iterable(scope, AstSeparatedListNodesIterator_next)
        .finish(scope);
}
#[allow(non_snake_case)]
fn AstSeparatedListNodesIterator_next<'s, T: ToV8<'s>>(
    item: rome_rowan::SyntaxResult<T>,
    scope: &mut v8::HandleScope<'s>,
) -> anyhow::Result<v8::Local<'s, v8::Value>> {
    ToV8::to_v8(item?, scope)
}
impl<'s> ToV8<'s> for rome_js_syntax::JsAccessorModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsAccessorModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsAccessorModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAccessorModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsArrayAssignmentPattern {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsArrayAssignmentPattern,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsArrayAssignmentPattern_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayAssignmentPattern::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsArrayAssignmentPattern_elements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayAssignmentPattern::cast_ref(&*this).unwrap();
    let result = this.elements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsArrayAssignmentPattern_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayAssignmentPattern::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsArrayAssignmentPatternRestElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsArrayAssignmentPatternRestElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsArrayAssignmentPatternRestElement_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayAssignmentPatternRestElement::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsArrayAssignmentPatternRestElement_pattern<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayAssignmentPatternRestElement::cast_ref(&*this).unwrap();
    let result = this.pattern();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsArrayBindingPattern {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsArrayBindingPattern,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsArrayBindingPattern_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayBindingPattern::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsArrayBindingPattern_elements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayBindingPattern::cast_ref(&*this).unwrap();
    let result = this.elements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsArrayBindingPattern_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayBindingPattern::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsArrayBindingPatternRestElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsArrayBindingPatternRestElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsArrayBindingPatternRestElement_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayBindingPatternRestElement::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsArrayBindingPatternRestElement_pattern<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayBindingPatternRestElement::cast_ref(&*this).unwrap();
    let result = this.pattern();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsArrayExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsArrayExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsArrayExpression_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayExpression::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsArrayExpression_elements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayExpression::cast_ref(&*this).unwrap();
    let result = this.elements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsArrayExpression_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrayExpression::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsArrayHole {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsArrayHole,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsArrowFunctionExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsArrowFunctionExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsArrowFunctionExpression_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrowFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsArrowFunctionExpression_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrowFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsArrowFunctionExpression_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrowFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsArrowFunctionExpression_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrowFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsArrowFunctionExpression_fat_arrow_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrowFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.fat_arrow_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsArrowFunctionExpression_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsArrowFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsAssignmentExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsAssignmentExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsAssignmentExpression_left<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAssignmentExpression::cast_ref(&*this).unwrap();
    let result = this.left();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsAssignmentExpression_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAssignmentExpression::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsAssignmentExpression_right<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAssignmentExpression::cast_ref(&*this).unwrap();
    let result = this.right();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsAssignmentWithDefault {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsAssignmentWithDefault,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsAssignmentWithDefault_pattern<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAssignmentWithDefault::cast_ref(&*this).unwrap();
    let result = this.pattern();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsAssignmentWithDefault_eq_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAssignmentWithDefault::cast_ref(&*this).unwrap();
    let result = this.eq_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsAssignmentWithDefault_default<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAssignmentWithDefault::cast_ref(&*this).unwrap();
    let result = this.default();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsAwaitExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsAwaitExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsAwaitExpression_await_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAwaitExpression::cast_ref(&*this).unwrap();
    let result = this.await_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsAwaitExpression_argument<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsAwaitExpression::cast_ref(&*this).unwrap();
    let result = this.argument();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsBigintLiteralExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsBigintLiteralExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsBigintLiteralExpression_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBigintLiteralExpression::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsBinaryExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsBinaryExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsBinaryExpression_left<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBinaryExpression::cast_ref(&*this).unwrap();
    let result = this.left();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsBinaryExpression_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBinaryExpression::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsBinaryExpression_right<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBinaryExpression::cast_ref(&*this).unwrap();
    let result = this.right();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsBindingPatternWithDefault {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsBindingPatternWithDefault,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsBindingPatternWithDefault_pattern<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBindingPatternWithDefault::cast_ref(&*this).unwrap();
    let result = this.pattern();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsBindingPatternWithDefault_eq_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBindingPatternWithDefault::cast_ref(&*this).unwrap();
    let result = this.eq_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsBindingPatternWithDefault_default<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBindingPatternWithDefault::cast_ref(&*this).unwrap();
    let result = this.default();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsBlockStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsBlockStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsBlockStatement_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBlockStatement::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsBlockStatement_statements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBlockStatement::cast_ref(&*this).unwrap();
    let result = this.statements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsBlockStatement_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBlockStatement::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsBooleanLiteralExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsBooleanLiteralExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsBooleanLiteralExpression_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBooleanLiteralExpression::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsBreakStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsBreakStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsBreakStatement_break_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBreakStatement::cast_ref(&*this).unwrap();
    let result = this.break_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsBreakStatement_label_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBreakStatement::cast_ref(&*this).unwrap();
    let result = this.label_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsBreakStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsBreakStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsCallArguments {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsCallArguments,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsCallArguments_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCallArguments::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsCallArguments_args<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCallArguments::cast_ref(&*this).unwrap();
    let result = this.args();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsCallArguments_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCallArguments::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsCallExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsCallExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsCallExpression_callee<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCallExpression::cast_ref(&*this).unwrap();
    let result = this.callee();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsCallExpression_optional_chain_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCallExpression::cast_ref(&*this).unwrap();
    let result = this.optional_chain_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsCallExpression_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCallExpression::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsCallExpression_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCallExpression::cast_ref(&*this).unwrap();
    let result = this.arguments();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsCaseClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsCaseClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsCaseClause_case_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCaseClause::cast_ref(&*this).unwrap();
    let result = this.case_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsCaseClause_test<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCaseClause::cast_ref(&*this).unwrap();
    let result = this.test();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsCaseClause_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCaseClause::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsCaseClause_consequent<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCaseClause::cast_ref(&*this).unwrap();
    let result = this.consequent();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
impl<'s> ToV8<'s> for rome_js_syntax::JsCatchClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsCatchClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsCatchClause_catch_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCatchClause::cast_ref(&*this).unwrap();
    let result = this.catch_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsCatchClause_declaration<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCatchClause::cast_ref(&*this).unwrap();
    let result = this.declaration();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsCatchClause_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCatchClause::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsCatchDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsCatchDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsCatchDeclaration_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCatchDeclaration::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsCatchDeclaration_binding<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCatchDeclaration::cast_ref(&*this).unwrap();
    let result = this.binding();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsCatchDeclaration_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCatchDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsCatchDeclaration_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsCatchDeclaration::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsClassDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsClassDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsClassDeclaration_decorators<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.decorators();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsClassDeclaration_abstract_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.abstract_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassDeclaration_class_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.class_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsClassDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsClassDeclaration_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassDeclaration_extends_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.extends_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassDeclaration_implements_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.implements_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassDeclaration_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsClassDeclaration_members<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.members();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsClassDeclaration_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassDeclaration::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsClassExportDefaultDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsClassExportDefaultDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_decorators<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.decorators();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_abstract_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.abstract_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_class_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.class_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_extends_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.extends_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_implements_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.implements_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_members<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.members();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsClassExportDefaultDeclaration_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsClassExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsClassExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsClassExpression_decorators<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.decorators();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsClassExpression_class_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.class_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsClassExpression_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.id();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExpression_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExpression_extends_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.extends_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExpression_implements_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.implements_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsClassExpression_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsClassExpression_members<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.members();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsClassExpression_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsClassExpression::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsComputedMemberAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsComputedMemberAssignment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberAssignment_object<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberAssignment::cast_ref(&*this).unwrap();
    let result = this.object();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberAssignment_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberAssignment::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberAssignment_member<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberAssignment::cast_ref(&*this).unwrap();
    let result = this.member();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberAssignment_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberAssignment::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsComputedMemberExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsComputedMemberExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberExpression_object<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberExpression::cast_ref(&*this).unwrap();
    let result = this.object();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberExpression_optional_chain_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberExpression::cast_ref(&*this).unwrap();
    let result = this.optional_chain_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberExpression_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberExpression::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberExpression_member<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberExpression::cast_ref(&*this).unwrap();
    let result = this.member();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberExpression_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberExpression::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsComputedMemberName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsComputedMemberName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberName_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberName::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberName_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberName::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsComputedMemberName_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsComputedMemberName::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsConditionalExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsConditionalExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsConditionalExpression_test<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConditionalExpression::cast_ref(&*this).unwrap();
    let result = this.test();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsConditionalExpression_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConditionalExpression::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsConditionalExpression_consequent<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConditionalExpression::cast_ref(&*this).unwrap();
    let result = this.consequent();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsConditionalExpression_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConditionalExpression::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsConditionalExpression_alternate<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConditionalExpression::cast_ref(&*this).unwrap();
    let result = this.alternate();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsConstructorClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsConstructorClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsConstructorClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConstructorClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsConstructorClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConstructorClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsConstructorClassMember_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConstructorClassMember::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsConstructorClassMember_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConstructorClassMember::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsConstructorParameters {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsConstructorParameters,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsConstructorParameters_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConstructorParameters::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsConstructorParameters_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConstructorParameters::cast_ref(&*this).unwrap();
    let result = this.parameters();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsConstructorParameters_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsConstructorParameters::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsContinueStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsContinueStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsContinueStatement_continue_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsContinueStatement::cast_ref(&*this).unwrap();
    let result = this.continue_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsContinueStatement_label_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsContinueStatement::cast_ref(&*this).unwrap();
    let result = this.label_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsContinueStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsContinueStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsDebuggerStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsDebuggerStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsDebuggerStatement_debugger_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDebuggerStatement::cast_ref(&*this).unwrap();
    let result = this.debugger_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDebuggerStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDebuggerStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsDecorator {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsDecorator,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsDecorator_at_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDecorator::cast_ref(&*this).unwrap();
    let result = this.at_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDecorator_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDecorator::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsDefaultClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsDefaultClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsDefaultClause_default_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDefaultClause::cast_ref(&*this).unwrap();
    let result = this.default_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDefaultClause_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDefaultClause::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDefaultClause_consequent<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDefaultClause::cast_ref(&*this).unwrap();
    let result = this.consequent();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
impl<'s> ToV8<'s> for rome_js_syntax::JsDefaultImportSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsDefaultImportSpecifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsDefaultImportSpecifier_local_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDefaultImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.local_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDefaultImportSpecifier_trailing_comma_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDefaultImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.trailing_comma_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsDirective {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsDirective,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsDirective_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDirective::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDirective_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDirective::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsDoWhileStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsDoWhileStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsDoWhileStatement_do_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDoWhileStatement::cast_ref(&*this).unwrap();
    let result = this.do_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDoWhileStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDoWhileStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDoWhileStatement_while_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDoWhileStatement::cast_ref(&*this).unwrap();
    let result = this.while_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDoWhileStatement_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDoWhileStatement::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDoWhileStatement_test<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDoWhileStatement::cast_ref(&*this).unwrap();
    let result = this.test();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDoWhileStatement_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDoWhileStatement::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsDoWhileStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsDoWhileStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsElseClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsElseClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsElseClause_else_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsElseClause::cast_ref(&*this).unwrap();
    let result = this.else_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsElseClause_alternate<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsElseClause::cast_ref(&*this).unwrap();
    let result = this.alternate();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsEmptyClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsEmptyClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsEmptyClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsEmptyClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsEmptyStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsEmptyStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsEmptyStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsEmptyStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExport {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExport,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExport_decorators<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExport::cast_ref(&*this).unwrap();
    let result = this.decorators();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsExport_export_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExport::cast_ref(&*this).unwrap();
    let result = this.export_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExport_export_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExport::cast_ref(&*this).unwrap();
    let result = this.export_clause();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportAsClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportAsClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportAsClause_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportAsClause::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportAsClause_exported_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportAsClause::cast_ref(&*this).unwrap();
    let result = this.exported_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportDefaultDeclarationClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportDefaultDeclarationClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportDefaultDeclarationClause_default_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportDefaultDeclarationClause::cast_ref(&*this).unwrap();
    let result = this.default_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportDefaultDeclarationClause_declaration<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportDefaultDeclarationClause::cast_ref(&*this).unwrap();
    let result = this.declaration();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportDefaultDeclarationClause_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportDefaultDeclarationClause::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportDefaultExpressionClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportDefaultExpressionClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportDefaultExpressionClause_default_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportDefaultExpressionClause::cast_ref(&*this).unwrap();
    let result = this.default_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportDefaultExpressionClause_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportDefaultExpressionClause::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportDefaultExpressionClause_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportDefaultExpressionClause::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportFromClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportFromClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportFromClause_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportFromClause::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportFromClause_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportFromClause::cast_ref(&*this).unwrap();
    let result = this.star_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportFromClause_export_as<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportFromClause::cast_ref(&*this).unwrap();
    let result = this.export_as();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportFromClause_from_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportFromClause::cast_ref(&*this).unwrap();
    let result = this.from_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportFromClause_source<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportFromClause::cast_ref(&*this).unwrap();
    let result = this.source();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportFromClause_assertion<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportFromClause::cast_ref(&*this).unwrap();
    let result = this.assertion();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportFromClause_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportFromClause::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportNamedClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportNamedClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportNamedClause_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedClause::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportNamedClause_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedClause::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedClause_specifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedClause::cast_ref(&*this).unwrap();
    let result = this.specifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsExportNamedClause_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedClause::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedClause_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedClause::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportNamedFromClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportNamedFromClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromClause_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromClause::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromClause_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromClause::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromClause_specifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromClause::cast_ref(&*this).unwrap();
    let result = this.specifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsExportNamedFromClause_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromClause::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromClause_from_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromClause::cast_ref(&*this).unwrap();
    let result = this.from_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromClause_source<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromClause::cast_ref(&*this).unwrap();
    let result = this.source();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromClause_assertion<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromClause::cast_ref(&*this).unwrap();
    let result = this.assertion();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromClause_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromClause::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportNamedFromSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportNamedFromSpecifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromSpecifier_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromSpecifier::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromSpecifier_source_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromSpecifier::cast_ref(&*this).unwrap();
    let result = this.source_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedFromSpecifier_export_as<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedFromSpecifier::cast_ref(&*this).unwrap();
    let result = this.export_as();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportNamedShorthandSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportNamedShorthandSpecifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportNamedShorthandSpecifier_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedShorthandSpecifier::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportNamedShorthandSpecifier_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedShorthandSpecifier::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExportNamedSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExportNamedSpecifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExportNamedSpecifier_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedSpecifier::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsExportNamedSpecifier_local_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedSpecifier::cast_ref(&*this).unwrap();
    let result = this.local_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedSpecifier_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedSpecifier::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExportNamedSpecifier_exported_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExportNamedSpecifier::cast_ref(&*this).unwrap();
    let result = this.exported_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExpressionSnipped {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExpressionSnipped,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExpressionSnipped_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExpressionSnipped::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExpressionSnipped_eof_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExpressionSnipped::cast_ref(&*this).unwrap();
    let result = this.eof_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExpressionStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExpressionStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExpressionStatement_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExpressionStatement::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExpressionStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExpressionStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsExtendsClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsExtendsClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsExtendsClause_extends_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExtendsClause::cast_ref(&*this).unwrap();
    let result = this.extends_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExtendsClause_super_class<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExtendsClause::cast_ref(&*this).unwrap();
    let result = this.super_class();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsExtendsClause_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsExtendsClause::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsFinallyClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsFinallyClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsFinallyClause_finally_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFinallyClause::cast_ref(&*this).unwrap();
    let result = this.finally_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFinallyClause_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFinallyClause::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsForInStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsForInStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsForInStatement_for_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForInStatement::cast_ref(&*this).unwrap();
    let result = this.for_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForInStatement_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForInStatement::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForInStatement_initializer<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForInStatement::cast_ref(&*this).unwrap();
    let result = this.initializer();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForInStatement_in_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForInStatement::cast_ref(&*this).unwrap();
    let result = this.in_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForInStatement_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForInStatement::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForInStatement_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForInStatement::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForInStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForInStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsForOfStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsForOfStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsForOfStatement_for_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForOfStatement::cast_ref(&*this).unwrap();
    let result = this.for_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForOfStatement_await_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForOfStatement::cast_ref(&*this).unwrap();
    let result = this.await_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsForOfStatement_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForOfStatement::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForOfStatement_initializer<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForOfStatement::cast_ref(&*this).unwrap();
    let result = this.initializer();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForOfStatement_of_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForOfStatement::cast_ref(&*this).unwrap();
    let result = this.of_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForOfStatement_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForOfStatement::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForOfStatement_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForOfStatement::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForOfStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForOfStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsForStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsForStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsForStatement_for_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.for_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForStatement_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForStatement_initializer<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.initializer();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsForStatement_first_semi_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.first_semi_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForStatement_test<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.test();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsForStatement_second_semi_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.second_semi_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForStatement_update<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.update();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsForStatement_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsForVariableDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsForVariableDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsForVariableDeclaration_kind_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForVariableDeclaration::cast_ref(&*this).unwrap();
    let result = this.kind_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsForVariableDeclaration_declarator<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsForVariableDeclaration::cast_ref(&*this).unwrap();
    let result = this.declarator();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsFormalParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsFormalParameter,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsFormalParameter_decorators<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFormalParameter::cast_ref(&*this).unwrap();
    let result = this.decorators();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsFormalParameter_binding<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFormalParameter::cast_ref(&*this).unwrap();
    let result = this.binding();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFormalParameter_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFormalParameter::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFormalParameter_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFormalParameter::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFormalParameter_initializer<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFormalParameter::cast_ref(&*this).unwrap();
    let result = this.initializer();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsFunctionBody {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsFunctionBody,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsFunctionBody_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionBody::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFunctionBody_directives<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionBody::cast_ref(&*this).unwrap();
    let result = this.directives();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsFunctionBody_statements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionBody::cast_ref(&*this).unwrap();
    let result = this.statements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsFunctionBody_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionBody::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsFunctionDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsFunctionDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsFunctionDeclaration_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionDeclaration_function_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.function_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFunctionDeclaration_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.star_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFunctionDeclaration_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionDeclaration_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFunctionDeclaration_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionDeclaration_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsFunctionExportDefaultDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsFunctionExportDefaultDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsFunctionExportDefaultDeclaration_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExportDefaultDeclaration_function_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.function_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFunctionExportDefaultDeclaration_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.star_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExportDefaultDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExportDefaultDeclaration_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExportDefaultDeclaration_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFunctionExportDefaultDeclaration_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExportDefaultDeclaration_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsFunctionExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsFunctionExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsFunctionExpression_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExpression_function_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.function_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFunctionExpression_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.star_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExpression_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.id();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExpression_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExpression_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsFunctionExpression_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsFunctionExpression_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsFunctionExpression::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsGetterClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsGetterClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsGetterClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsGetterClassMember_get_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterClassMember::cast_ref(&*this).unwrap();
    let result = this.get_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsGetterClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsGetterClassMember_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterClassMember::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsGetterClassMember_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterClassMember::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsGetterClassMember_return_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterClassMember::cast_ref(&*this).unwrap();
    let result = this.return_type();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsGetterClassMember_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterClassMember::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsGetterObjectMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsGetterObjectMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsGetterObjectMember_get_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.get_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsGetterObjectMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsGetterObjectMember_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsGetterObjectMember_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsGetterObjectMember_return_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.return_type();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsGetterObjectMember_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsGetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsIdentifierAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsIdentifierAssignment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsIdentifierAssignment_name_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIdentifierAssignment::cast_ref(&*this).unwrap();
    let result = this.name_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsIdentifierBinding {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsIdentifierBinding,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsIdentifierBinding_name_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIdentifierBinding::cast_ref(&*this).unwrap();
    let result = this.name_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsIdentifierExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsIdentifierExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsIdentifierExpression_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIdentifierExpression::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsIfStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsIfStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsIfStatement_if_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIfStatement::cast_ref(&*this).unwrap();
    let result = this.if_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsIfStatement_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIfStatement::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsIfStatement_test<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIfStatement::cast_ref(&*this).unwrap();
    let result = this.test();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsIfStatement_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIfStatement::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsIfStatement_consequent<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIfStatement::cast_ref(&*this).unwrap();
    let result = this.consequent();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsIfStatement_else_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsIfStatement::cast_ref(&*this).unwrap();
    let result = this.else_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImport {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImport,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImport_import_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImport::cast_ref(&*this).unwrap();
    let result = this.import_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImport_import_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImport::cast_ref(&*this).unwrap();
    let result = this.import_clause();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImport_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImport::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImportAssertion {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImportAssertion,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImportAssertion_assertion_kind<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportAssertion::cast_ref(&*this).unwrap();
    let result = this.assertion_kind();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportAssertion_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportAssertion::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportAssertion_assertions<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportAssertion::cast_ref(&*this).unwrap();
    let result = this.assertions();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsImportAssertion_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportAssertion::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImportAssertionEntry {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImportAssertionEntry,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImportAssertionEntry_key<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportAssertionEntry::cast_ref(&*this).unwrap();
    let result = this.key();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportAssertionEntry_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportAssertionEntry::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportAssertionEntry_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportAssertionEntry::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImportBareClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImportBareClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImportBareClause_source<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportBareClause::cast_ref(&*this).unwrap();
    let result = this.source();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportBareClause_assertion<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportBareClause::cast_ref(&*this).unwrap();
    let result = this.assertion();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImportCallExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImportCallExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImportCallExpression_import_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportCallExpression::cast_ref(&*this).unwrap();
    let result = this.import_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportCallExpression_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportCallExpression::cast_ref(&*this).unwrap();
    let result = this.arguments();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImportDefaultClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImportDefaultClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImportDefaultClause_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportDefaultClause::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsImportDefaultClause_local_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportDefaultClause::cast_ref(&*this).unwrap();
    let result = this.local_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportDefaultClause_from_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportDefaultClause::cast_ref(&*this).unwrap();
    let result = this.from_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportDefaultClause_source<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportDefaultClause::cast_ref(&*this).unwrap();
    let result = this.source();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportDefaultClause_assertion<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportDefaultClause::cast_ref(&*this).unwrap();
    let result = this.assertion();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImportMetaExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImportMetaExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImportMetaExpression_import_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportMetaExpression::cast_ref(&*this).unwrap();
    let result = this.import_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportMetaExpression_dot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportMetaExpression::cast_ref(&*this).unwrap();
    let result = this.dot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportMetaExpression_meta_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportMetaExpression::cast_ref(&*this).unwrap();
    let result = this.meta_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImportNamedClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImportNamedClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImportNamedClause_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamedClause::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsImportNamedClause_default_specifier<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamedClause::cast_ref(&*this).unwrap();
    let result = this.default_specifier();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsImportNamedClause_named_import<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamedClause::cast_ref(&*this).unwrap();
    let result = this.named_import();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportNamedClause_from_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamedClause::cast_ref(&*this).unwrap();
    let result = this.from_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportNamedClause_source<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamedClause::cast_ref(&*this).unwrap();
    let result = this.source();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportNamedClause_assertion<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamedClause::cast_ref(&*this).unwrap();
    let result = this.assertion();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsImportNamespaceClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsImportNamespaceClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsImportNamespaceClause_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsImportNamespaceClause_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.star_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportNamespaceClause_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportNamespaceClause_local_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.local_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportNamespaceClause_from_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.from_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportNamespaceClause_source<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.source();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsImportNamespaceClause_assertion<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsImportNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.assertion();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsInExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsInExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsInExpression_property<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsInExpression::cast_ref(&*this).unwrap();
    let result = this.property();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsInExpression_in_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsInExpression::cast_ref(&*this).unwrap();
    let result = this.in_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsInExpression_object<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsInExpression::cast_ref(&*this).unwrap();
    let result = this.object();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsInitializerClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsInitializerClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsInitializerClause_eq_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsInitializerClause::cast_ref(&*this).unwrap();
    let result = this.eq_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsInitializerClause_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsInitializerClause::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsInstanceofExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsInstanceofExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsInstanceofExpression_left<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsInstanceofExpression::cast_ref(&*this).unwrap();
    let result = this.left();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsInstanceofExpression_instanceof_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsInstanceofExpression::cast_ref(&*this).unwrap();
    let result = this.instanceof_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsInstanceofExpression_right<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsInstanceofExpression::cast_ref(&*this).unwrap();
    let result = this.right();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsLabeledStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsLabeledStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsLabeledStatement_label_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsLabeledStatement::cast_ref(&*this).unwrap();
    let result = this.label_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsLabeledStatement_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsLabeledStatement::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsLabeledStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsLabeledStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsLiteralExportName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsLiteralExportName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsLiteralExportName_value<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsLiteralExportName::cast_ref(&*this).unwrap();
    let result = this.value();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsLiteralMemberName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsLiteralMemberName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsLiteralMemberName_value<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsLiteralMemberName::cast_ref(&*this).unwrap();
    let result = this.value();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsLogicalExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsLogicalExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsLogicalExpression_left<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsLogicalExpression::cast_ref(&*this).unwrap();
    let result = this.left();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsLogicalExpression_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsLogicalExpression::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsLogicalExpression_right<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsLogicalExpression::cast_ref(&*this).unwrap();
    let result = this.right();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsMethodClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsMethodClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsMethodClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsMethodClassMember_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodClassMember_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.star_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsMethodClassMember_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodClassMember_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodClassMember_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsMethodClassMember_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodClassMember_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodClassMember::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsMethodObjectMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsMethodObjectMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsMethodObjectMember_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodObjectMember::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodObjectMember_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodObjectMember::cast_ref(&*this).unwrap();
    let result = this.star_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodObjectMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodObjectMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsMethodObjectMember_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodObjectMember::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodObjectMember_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodObjectMember::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsMethodObjectMember_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodObjectMember::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsMethodObjectMember_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsMethodObjectMember::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsModule {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsModule,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsModule_interpreter_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsModule::cast_ref(&*this).unwrap();
    let result = this.interpreter_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsModule_directives<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsModule::cast_ref(&*this).unwrap();
    let result = this.directives();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsModule_items<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsModule::cast_ref(&*this).unwrap();
    let result = this.items();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsModule_eof_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsModule::cast_ref(&*this).unwrap();
    let result = this.eof_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsModuleSource {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsModuleSource,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsModuleSource_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsModuleSource::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsName_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsName::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsNamedImportSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsNamedImportSpecifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsNamedImportSpecifier_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamedImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsNamedImportSpecifier_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamedImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNamedImportSpecifier_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamedImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNamedImportSpecifier_local_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamedImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.local_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsNamedImportSpecifiers {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsNamedImportSpecifiers,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsNamedImportSpecifiers_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamedImportSpecifiers::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNamedImportSpecifiers_specifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamedImportSpecifiers::cast_ref(&*this).unwrap();
    let result = this.specifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsNamedImportSpecifiers_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamedImportSpecifiers::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsNamespaceImportSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsNamespaceImportSpecifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsNamespaceImportSpecifier_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamespaceImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.star_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNamespaceImportSpecifier_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamespaceImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNamespaceImportSpecifier_local_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNamespaceImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.local_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsNewExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsNewExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsNewExpression_new_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNewExpression::cast_ref(&*this).unwrap();
    let result = this.new_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNewExpression_callee<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNewExpression::cast_ref(&*this).unwrap();
    let result = this.callee();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNewExpression_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNewExpression::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsNewExpression_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNewExpression::cast_ref(&*this).unwrap();
    let result = this.arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsNewTargetExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsNewTargetExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsNewTargetExpression_new_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNewTargetExpression::cast_ref(&*this).unwrap();
    let result = this.new_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNewTargetExpression_dot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNewTargetExpression::cast_ref(&*this).unwrap();
    let result = this.dot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsNewTargetExpression_target_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNewTargetExpression::cast_ref(&*this).unwrap();
    let result = this.target_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsNullLiteralExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsNullLiteralExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsNullLiteralExpression_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNullLiteralExpression::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsNumberLiteralExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsNumberLiteralExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsNumberLiteralExpression_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsNumberLiteralExpression::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectAssignmentPattern {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectAssignmentPattern,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPattern_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPattern::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPattern_properties<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPattern::cast_ref(&*this).unwrap();
    let result = this.properties();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPattern_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPattern::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectAssignmentPatternProperty {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectAssignmentPatternProperty,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternProperty_member<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPatternProperty::cast_ref(&*this).unwrap();
    let result = this.member();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternProperty_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPatternProperty::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternProperty_pattern<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPatternProperty::cast_ref(&*this).unwrap();
    let result = this.pattern();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternProperty_init<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPatternProperty::cast_ref(&*this).unwrap();
    let result = this.init();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectAssignmentPatternRest {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectAssignmentPatternRest,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternRest_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPatternRest::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternRest_target<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectAssignmentPatternRest::cast_ref(&*this).unwrap();
    let result = this.target();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectAssignmentPatternShorthandProperty {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectAssignmentPatternShorthandProperty,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternShorthandProperty_identifier<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this =
        rome_js_syntax::JsObjectAssignmentPatternShorthandProperty::cast_ref(&*this).unwrap();
    let result = this.identifier();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternShorthandProperty_init<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this =
        rome_js_syntax::JsObjectAssignmentPatternShorthandProperty::cast_ref(&*this).unwrap();
    let result = this.init();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectBindingPattern {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectBindingPattern,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPattern_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPattern::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPattern_properties<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPattern::cast_ref(&*this).unwrap();
    let result = this.properties();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsObjectBindingPattern_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPattern::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectBindingPatternProperty {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectBindingPatternProperty,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPatternProperty_member<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPatternProperty::cast_ref(&*this).unwrap();
    let result = this.member();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPatternProperty_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPatternProperty::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPatternProperty_pattern<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPatternProperty::cast_ref(&*this).unwrap();
    let result = this.pattern();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPatternProperty_init<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPatternProperty::cast_ref(&*this).unwrap();
    let result = this.init();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectBindingPatternRest {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectBindingPatternRest,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPatternRest_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPatternRest::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPatternRest_binding<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPatternRest::cast_ref(&*this).unwrap();
    let result = this.binding();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectBindingPatternShorthandProperty {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectBindingPatternShorthandProperty,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPatternShorthandProperty_identifier<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPatternShorthandProperty::cast_ref(&*this).unwrap();
    let result = this.identifier();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectBindingPatternShorthandProperty_init<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectBindingPatternShorthandProperty::cast_ref(&*this).unwrap();
    let result = this.init();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsObjectExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsObjectExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsObjectExpression_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectExpression::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsObjectExpression_members<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectExpression::cast_ref(&*this).unwrap();
    let result = this.members();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsObjectExpression_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsObjectExpression::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsParameters {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsParameters,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsParameters_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParameters::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsParameters_items<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParameters::cast_ref(&*this).unwrap();
    let result = this.items();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsParameters_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParameters::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsParenthesizedAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsParenthesizedAssignment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsParenthesizedAssignment_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParenthesizedAssignment::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsParenthesizedAssignment_assignment<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParenthesizedAssignment::cast_ref(&*this).unwrap();
    let result = this.assignment();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsParenthesizedAssignment_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParenthesizedAssignment::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsParenthesizedExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsParenthesizedExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsParenthesizedExpression_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParenthesizedExpression::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsParenthesizedExpression_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParenthesizedExpression::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsParenthesizedExpression_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsParenthesizedExpression::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsPostUpdateExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsPostUpdateExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsPostUpdateExpression_operand<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPostUpdateExpression::cast_ref(&*this).unwrap();
    let result = this.operand();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsPostUpdateExpression_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPostUpdateExpression::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsPreUpdateExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsPreUpdateExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsPreUpdateExpression_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPreUpdateExpression::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsPreUpdateExpression_operand<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPreUpdateExpression::cast_ref(&*this).unwrap();
    let result = this.operand();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsPrivateClassMemberName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsPrivateClassMemberName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsPrivateClassMemberName_hash_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPrivateClassMemberName::cast_ref(&*this).unwrap();
    let result = this.hash_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsPrivateClassMemberName_id_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPrivateClassMemberName::cast_ref(&*this).unwrap();
    let result = this.id_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsPrivateName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsPrivateName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsPrivateName_hash_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPrivateName::cast_ref(&*this).unwrap();
    let result = this.hash_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsPrivateName_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPrivateName::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsPropertyClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsPropertyClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsPropertyClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPropertyClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsPropertyClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPropertyClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsPropertyClassMember_property_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPropertyClassMember::cast_ref(&*this).unwrap();
    let result = this.property_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsPropertyClassMember_value<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPropertyClassMember::cast_ref(&*this).unwrap();
    let result = this.value();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsPropertyClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPropertyClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsPropertyObjectMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsPropertyObjectMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsPropertyObjectMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPropertyObjectMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsPropertyObjectMember_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPropertyObjectMember::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsPropertyObjectMember_value<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsPropertyObjectMember::cast_ref(&*this).unwrap();
    let result = this.value();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsReferenceIdentifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsReferenceIdentifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsReferenceIdentifier_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsReferenceIdentifier::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsRegexLiteralExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsRegexLiteralExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsRegexLiteralExpression_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsRegexLiteralExpression::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsRestParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsRestParameter,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsRestParameter_decorators<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsRestParameter::cast_ref(&*this).unwrap();
    let result = this.decorators();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsRestParameter_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsRestParameter::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsRestParameter_binding<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsRestParameter::cast_ref(&*this).unwrap();
    let result = this.binding();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsRestParameter_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsRestParameter::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsReturnStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsReturnStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsReturnStatement_return_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsReturnStatement::cast_ref(&*this).unwrap();
    let result = this.return_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsReturnStatement_argument<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsReturnStatement::cast_ref(&*this).unwrap();
    let result = this.argument();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsReturnStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsReturnStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsScript {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsScript,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsScript_interpreter_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsScript::cast_ref(&*this).unwrap();
    let result = this.interpreter_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsScript_directives<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsScript::cast_ref(&*this).unwrap();
    let result = this.directives();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsScript_statements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsScript::cast_ref(&*this).unwrap();
    let result = this.statements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsScript_eof_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsScript::cast_ref(&*this).unwrap();
    let result = this.eof_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsSequenceExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsSequenceExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsSequenceExpression_left<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSequenceExpression::cast_ref(&*this).unwrap();
    let result = this.left();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSequenceExpression_comma_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSequenceExpression::cast_ref(&*this).unwrap();
    let result = this.comma_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSequenceExpression_right<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSequenceExpression::cast_ref(&*this).unwrap();
    let result = this.right();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsSetterClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsSetterClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsSetterClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsSetterClassMember_set_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterClassMember::cast_ref(&*this).unwrap();
    let result = this.set_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterClassMember_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterClassMember::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterClassMember_parameter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterClassMember::cast_ref(&*this).unwrap();
    let result = this.parameter();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterClassMember_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterClassMember::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterClassMember_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterClassMember::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsSetterObjectMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsSetterObjectMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsSetterObjectMember_set_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.set_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterObjectMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterObjectMember_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterObjectMember_parameter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.parameter();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterObjectMember_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSetterObjectMember_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSetterObjectMember::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsShorthandNamedImportSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsShorthandNamedImportSpecifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsShorthandNamedImportSpecifier_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsShorthandNamedImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsShorthandNamedImportSpecifier_local_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsShorthandNamedImportSpecifier::cast_ref(&*this).unwrap();
    let result = this.local_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsShorthandPropertyObjectMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsShorthandPropertyObjectMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsShorthandPropertyObjectMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsShorthandPropertyObjectMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsSpread {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsSpread,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsSpread_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSpread::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSpread_argument<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSpread::cast_ref(&*this).unwrap();
    let result = this.argument();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsStaticInitializationBlockClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsStaticInitializationBlockClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsStaticInitializationBlockClassMember_static_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticInitializationBlockClassMember::cast_ref(&*this).unwrap();
    let result = this.static_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsStaticInitializationBlockClassMember_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticInitializationBlockClassMember::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsStaticInitializationBlockClassMember_statements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticInitializationBlockClassMember::cast_ref(&*this).unwrap();
    let result = this.statements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsStaticInitializationBlockClassMember_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticInitializationBlockClassMember::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsStaticMemberAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsStaticMemberAssignment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsStaticMemberAssignment_object<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticMemberAssignment::cast_ref(&*this).unwrap();
    let result = this.object();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsStaticMemberAssignment_dot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticMemberAssignment::cast_ref(&*this).unwrap();
    let result = this.dot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsStaticMemberAssignment_member<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticMemberAssignment::cast_ref(&*this).unwrap();
    let result = this.member();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsStaticMemberExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsStaticMemberExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsStaticMemberExpression_object<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticMemberExpression::cast_ref(&*this).unwrap();
    let result = this.object();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsStaticMemberExpression_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticMemberExpression::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsStaticMemberExpression_member<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticMemberExpression::cast_ref(&*this).unwrap();
    let result = this.member();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsStaticModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsStaticModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsStaticModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStaticModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsStringLiteralExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsStringLiteralExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsStringLiteralExpression_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsStringLiteralExpression::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsSuperExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsSuperExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsSuperExpression_super_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSuperExpression::cast_ref(&*this).unwrap();
    let result = this.super_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsSwitchStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsSwitchStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsSwitchStatement_switch_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSwitchStatement::cast_ref(&*this).unwrap();
    let result = this.switch_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSwitchStatement_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSwitchStatement::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSwitchStatement_discriminant<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSwitchStatement::cast_ref(&*this).unwrap();
    let result = this.discriminant();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSwitchStatement_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSwitchStatement::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSwitchStatement_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSwitchStatement::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsSwitchStatement_cases<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSwitchStatement::cast_ref(&*this).unwrap();
    let result = this.cases();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsSwitchStatement_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsSwitchStatement::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsTemplateChunkElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsTemplateChunkElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsTemplateChunkElement_template_chunk_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateChunkElement::cast_ref(&*this).unwrap();
    let result = this.template_chunk_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsTemplateElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsTemplateElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsTemplateElement_dollar_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateElement::cast_ref(&*this).unwrap();
    let result = this.dollar_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsTemplateElement_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateElement::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsTemplateElement_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateElement::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsTemplateExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsTemplateExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsTemplateExpression_tag<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateExpression::cast_ref(&*this).unwrap();
    let result = this.tag();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsTemplateExpression_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateExpression::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsTemplateExpression_l_tick_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateExpression::cast_ref(&*this).unwrap();
    let result = this.l_tick_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsTemplateExpression_elements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateExpression::cast_ref(&*this).unwrap();
    let result = this.elements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsTemplateExpression_r_tick_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTemplateExpression::cast_ref(&*this).unwrap();
    let result = this.r_tick_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsThisExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsThisExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsThisExpression_this_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsThisExpression::cast_ref(&*this).unwrap();
    let result = this.this_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsThrowStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsThrowStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsThrowStatement_throw_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsThrowStatement::cast_ref(&*this).unwrap();
    let result = this.throw_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsThrowStatement_argument<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsThrowStatement::cast_ref(&*this).unwrap();
    let result = this.argument();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsThrowStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsThrowStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsTryFinallyStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsTryFinallyStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsTryFinallyStatement_try_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTryFinallyStatement::cast_ref(&*this).unwrap();
    let result = this.try_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsTryFinallyStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTryFinallyStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsTryFinallyStatement_catch_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTryFinallyStatement::cast_ref(&*this).unwrap();
    let result = this.catch_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsTryFinallyStatement_finally_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTryFinallyStatement::cast_ref(&*this).unwrap();
    let result = this.finally_clause();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsTryStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsTryStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsTryStatement_try_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTryStatement::cast_ref(&*this).unwrap();
    let result = this.try_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsTryStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTryStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsTryStatement_catch_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsTryStatement::cast_ref(&*this).unwrap();
    let result = this.catch_clause();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsUnaryExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsUnaryExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsUnaryExpression_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsUnaryExpression::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsUnaryExpression_argument<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsUnaryExpression::cast_ref(&*this).unwrap();
    let result = this.argument();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsVariableDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsVariableDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsVariableDeclaration_kind<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableDeclaration::cast_ref(&*this).unwrap();
    let result = this.kind();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsVariableDeclaration_declarators<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableDeclaration::cast_ref(&*this).unwrap();
    let result = this.declarators();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
impl<'s> ToV8<'s> for rome_js_syntax::JsVariableDeclarationClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsVariableDeclarationClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsVariableDeclarationClause_declaration<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableDeclarationClause::cast_ref(&*this).unwrap();
    let result = this.declaration();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsVariableDeclarationClause_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableDeclarationClause::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsVariableDeclarator {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsVariableDeclarator,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsVariableDeclarator_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableDeclarator::cast_ref(&*this).unwrap();
    let result = this.id();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsVariableDeclarator_variable_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableDeclarator::cast_ref(&*this).unwrap();
    let result = this.variable_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsVariableDeclarator_initializer<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableDeclarator::cast_ref(&*this).unwrap();
    let result = this.initializer();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsVariableStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsVariableStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsVariableStatement_declaration<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableStatement::cast_ref(&*this).unwrap();
    let result = this.declaration();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsVariableStatement_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsVariableStatement::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsWhileStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsWhileStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsWhileStatement_while_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWhileStatement::cast_ref(&*this).unwrap();
    let result = this.while_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsWhileStatement_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWhileStatement::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsWhileStatement_test<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWhileStatement::cast_ref(&*this).unwrap();
    let result = this.test();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsWhileStatement_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWhileStatement::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsWhileStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWhileStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsWithStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsWithStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsWithStatement_with_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWithStatement::cast_ref(&*this).unwrap();
    let result = this.with_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsWithStatement_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWithStatement::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsWithStatement_object<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWithStatement::cast_ref(&*this).unwrap();
    let result = this.object();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsWithStatement_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWithStatement::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsWithStatement_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsWithStatement::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsYieldArgument {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsYieldArgument,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsYieldArgument_star_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsYieldArgument::cast_ref(&*this).unwrap();
    let result = this.star_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsYieldArgument_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsYieldArgument::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsYieldExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsYieldExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsYieldExpression_yield_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsYieldExpression::cast_ref(&*this).unwrap();
    let result = this.yield_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsYieldExpression_argument<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsYieldExpression::cast_ref(&*this).unwrap();
    let result = this.argument();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxAttribute {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxAttribute,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxAttribute_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxAttribute::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxAttribute_initializer<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxAttribute::cast_ref(&*this).unwrap();
    let result = this.initializer();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxAttributeInitializerClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxAttributeInitializerClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxAttributeInitializerClause_eq_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxAttributeInitializerClause::cast_ref(&*this).unwrap();
    let result = this.eq_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxAttributeInitializerClause_value<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxAttributeInitializerClause::cast_ref(&*this).unwrap();
    let result = this.value();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxClosingElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxClosingElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxClosingElement_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxClosingElement::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxClosingElement_slash_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxClosingElement::cast_ref(&*this).unwrap();
    let result = this.slash_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxClosingElement_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxClosingElement::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxClosingElement_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxClosingElement::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxClosingFragment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxClosingFragment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxClosingFragment_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxClosingFragment::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxClosingFragment_slash_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxClosingFragment::cast_ref(&*this).unwrap();
    let result = this.slash_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxClosingFragment_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxClosingFragment::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxElement_opening_element<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxElement::cast_ref(&*this).unwrap();
    let result = this.opening_element();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxElement_children<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxElement::cast_ref(&*this).unwrap();
    let result = this.children();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsxElement_closing_element<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxElement::cast_ref(&*this).unwrap();
    let result = this.closing_element();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxExpressionAttributeValue {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxExpressionAttributeValue,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxExpressionAttributeValue_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxExpressionAttributeValue::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxExpressionAttributeValue_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxExpressionAttributeValue::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxExpressionAttributeValue_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxExpressionAttributeValue::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxExpressionChild {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxExpressionChild,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxExpressionChild_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxExpressionChild::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxExpressionChild_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxExpressionChild::cast_ref(&*this).unwrap();
    let result = this.expression();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsxExpressionChild_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxExpressionChild::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxFragment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxFragment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxFragment_opening_fragment<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxFragment::cast_ref(&*this).unwrap();
    let result = this.opening_fragment();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxFragment_children<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxFragment::cast_ref(&*this).unwrap();
    let result = this.children();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsxFragment_closing_fragment<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxFragment::cast_ref(&*this).unwrap();
    let result = this.closing_fragment();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxMemberName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxMemberName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxMemberName_object<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxMemberName::cast_ref(&*this).unwrap();
    let result = this.object();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxMemberName_dot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxMemberName::cast_ref(&*this).unwrap();
    let result = this.dot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxMemberName_member<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxMemberName::cast_ref(&*this).unwrap();
    let result = this.member();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxName_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxName::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxNamespaceName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxNamespaceName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxNamespaceName_namespace<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxNamespaceName::cast_ref(&*this).unwrap();
    let result = this.namespace();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxNamespaceName_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxNamespaceName::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxNamespaceName_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxNamespaceName::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxOpeningElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxOpeningElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxOpeningElement_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxOpeningElement::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxOpeningElement_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxOpeningElement::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxOpeningElement_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxOpeningElement::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsxOpeningElement_attributes<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxOpeningElement::cast_ref(&*this).unwrap();
    let result = this.attributes();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsxOpeningElement_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxOpeningElement::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxOpeningFragment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxOpeningFragment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxOpeningFragment_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxOpeningFragment::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxOpeningFragment_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxOpeningFragment::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxReferenceIdentifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxReferenceIdentifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxReferenceIdentifier_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxReferenceIdentifier::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxSelfClosingElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxSelfClosingElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxSelfClosingElement_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSelfClosingElement::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSelfClosingElement_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSelfClosingElement::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSelfClosingElement_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSelfClosingElement::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn JsxSelfClosingElement_attributes<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSelfClosingElement::cast_ref(&*this).unwrap();
    let result = this.attributes();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn JsxSelfClosingElement_slash_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSelfClosingElement::cast_ref(&*this).unwrap();
    let result = this.slash_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSelfClosingElement_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSelfClosingElement::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxSpreadAttribute {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxSpreadAttribute,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxSpreadAttribute_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSpreadAttribute::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSpreadAttribute_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSpreadAttribute::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSpreadAttribute_argument<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSpreadAttribute::cast_ref(&*this).unwrap();
    let result = this.argument();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSpreadAttribute_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSpreadAttribute::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxSpreadChild {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxSpreadChild,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxSpreadChild_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSpreadChild::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSpreadChild_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSpreadChild::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSpreadChild_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSpreadChild::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn JsxSpreadChild_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxSpreadChild::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxString {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxString,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxString_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxString::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxTagExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxTagExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxTagExpression_tag<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxTagExpression::cast_ref(&*this).unwrap();
    let result = this.tag();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::JsxText {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::JsxText,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn JsxText_value_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::JsxText::cast_ref(&*this).unwrap();
    let result = this.value_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsAbstractModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsAbstractModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsAbstractModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAbstractModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsAccessibilityModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsAccessibilityModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsAccessibilityModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAccessibilityModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsAnyType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsAnyType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsAnyType_any_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAnyType::cast_ref(&*this).unwrap();
    let result = this.any_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsArrayType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsArrayType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsArrayType_element_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsArrayType::cast_ref(&*this).unwrap();
    let result = this.element_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsArrayType_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsArrayType::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsArrayType_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsArrayType::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsAsAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsAsAssignment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsAsAssignment_assignment<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAsAssignment::cast_ref(&*this).unwrap();
    let result = this.assignment();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsAsAssignment_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAsAssignment::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsAsAssignment_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAsAssignment::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsAsExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsAsExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsAsExpression_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAsExpression::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsAsExpression_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAsExpression::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsAsExpression_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAsExpression::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsAssertsCondition {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsAssertsCondition,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsAssertsCondition_is_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAssertsCondition::cast_ref(&*this).unwrap();
    let result = this.is_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsAssertsCondition_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAssertsCondition::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsAssertsReturnType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsAssertsReturnType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsAssertsReturnType_asserts_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAssertsReturnType::cast_ref(&*this).unwrap();
    let result = this.asserts_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsAssertsReturnType_parameter_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAssertsReturnType::cast_ref(&*this).unwrap();
    let result = this.parameter_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsAssertsReturnType_predicate<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsAssertsReturnType::cast_ref(&*this).unwrap();
    let result = this.predicate();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsBigintLiteralType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsBigintLiteralType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsBigintLiteralType_minus_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsBigintLiteralType::cast_ref(&*this).unwrap();
    let result = this.minus_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsBigintLiteralType_literal_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsBigintLiteralType::cast_ref(&*this).unwrap();
    let result = this.literal_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsBigintType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsBigintType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsBigintType_bigint_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsBigintType::cast_ref(&*this).unwrap();
    let result = this.bigint_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsBooleanLiteralType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsBooleanLiteralType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsBooleanLiteralType_literal<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsBooleanLiteralType::cast_ref(&*this).unwrap();
    let result = this.literal();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsBooleanType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsBooleanType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsBooleanType_boolean_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsBooleanType::cast_ref(&*this).unwrap();
    let result = this.boolean_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsCallSignatureTypeMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsCallSignatureTypeMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsCallSignatureTypeMember_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsCallSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsCallSignatureTypeMember_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsCallSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsCallSignatureTypeMember_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsCallSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsCallSignatureTypeMember_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsCallSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsConditionalType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsConditionalType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsConditionalType_check_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConditionalType::cast_ref(&*this).unwrap();
    let result = this.check_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConditionalType_extends_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConditionalType::cast_ref(&*this).unwrap();
    let result = this.extends_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConditionalType_extends_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConditionalType::cast_ref(&*this).unwrap();
    let result = this.extends_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConditionalType_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConditionalType::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConditionalType_true_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConditionalType::cast_ref(&*this).unwrap();
    let result = this.true_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConditionalType_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConditionalType::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConditionalType_false_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConditionalType::cast_ref(&*this).unwrap();
    let result = this.false_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsConstModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsConstModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsConstModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsConstructSignatureTypeMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsConstructSignatureTypeMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsConstructSignatureTypeMember_new_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.new_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConstructSignatureTypeMember_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsConstructSignatureTypeMember_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConstructSignatureTypeMember_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsConstructSignatureTypeMember_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsConstructorSignatureClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsConstructorSignatureClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsConstructorSignatureClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsConstructorSignatureClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConstructorSignatureClassMember_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConstructorSignatureClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsConstructorType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsConstructorType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsConstructorType_abstract_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorType::cast_ref(&*this).unwrap();
    let result = this.abstract_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsConstructorType_new_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorType::cast_ref(&*this).unwrap();
    let result = this.new_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConstructorType_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorType::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsConstructorType_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorType::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConstructorType_fat_arrow_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorType::cast_ref(&*this).unwrap();
    let result = this.fat_arrow_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsConstructorType_return_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsConstructorType::cast_ref(&*this).unwrap();
    let result = this.return_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsDeclareFunctionDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsDeclareFunctionDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionDeclaration_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionDeclaration_function_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.function_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionDeclaration_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionDeclaration_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionDeclaration_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionDeclaration_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionDeclaration::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionExportDefaultDeclaration_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionExportDefaultDeclaration_function_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.function_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionExportDefaultDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionExportDefaultDeclaration_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionExportDefaultDeclaration_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionExportDefaultDeclaration_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsDeclareFunctionExportDefaultDeclaration_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareFunctionExportDefaultDeclaration::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsDeclareModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsDeclareModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsDeclareModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsDeclareStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsDeclareStatement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsDeclareStatement_declare_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareStatement::cast_ref(&*this).unwrap();
    let result = this.declare_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDeclareStatement_declaration<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDeclareStatement::cast_ref(&*this).unwrap();
    let result = this.declaration();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsDefaultTypeClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsDefaultTypeClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsDefaultTypeClause_eq_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDefaultTypeClause::cast_ref(&*this).unwrap();
    let result = this.eq_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDefaultTypeClause_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDefaultTypeClause::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsDefinitePropertyAnnotation {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsDefinitePropertyAnnotation,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsDefinitePropertyAnnotation_excl_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDefinitePropertyAnnotation::cast_ref(&*this).unwrap();
    let result = this.excl_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDefinitePropertyAnnotation_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDefinitePropertyAnnotation::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsDefiniteVariableAnnotation {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsDefiniteVariableAnnotation,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsDefiniteVariableAnnotation_excl_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDefiniteVariableAnnotation::cast_ref(&*this).unwrap();
    let result = this.excl_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsDefiniteVariableAnnotation_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsDefiniteVariableAnnotation::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsEmptyExternalModuleDeclarationBody {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsEmptyExternalModuleDeclarationBody,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsEmptyExternalModuleDeclarationBody_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEmptyExternalModuleDeclarationBody::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsEnumDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsEnumDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsEnumDeclaration_const_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEnumDeclaration::cast_ref(&*this).unwrap();
    let result = this.const_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsEnumDeclaration_enum_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEnumDeclaration::cast_ref(&*this).unwrap();
    let result = this.enum_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsEnumDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEnumDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsEnumDeclaration_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEnumDeclaration::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsEnumDeclaration_members<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEnumDeclaration::cast_ref(&*this).unwrap();
    let result = this.members();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsEnumDeclaration_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEnumDeclaration::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsEnumMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsEnumMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsEnumMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEnumMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsEnumMember_initializer<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsEnumMember::cast_ref(&*this).unwrap();
    let result = this.initializer();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsExportAsNamespaceClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsExportAsNamespaceClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsExportAsNamespaceClause_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportAsNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExportAsNamespaceClause_namespace_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportAsNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.namespace_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExportAsNamespaceClause_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportAsNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExportAsNamespaceClause_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportAsNamespaceClause::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsExportAssignmentClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsExportAssignmentClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsExportAssignmentClause_eq_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportAssignmentClause::cast_ref(&*this).unwrap();
    let result = this.eq_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExportAssignmentClause_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportAssignmentClause::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExportAssignmentClause_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportAssignmentClause::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsExportDeclareClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsExportDeclareClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsExportDeclareClause_declare_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportDeclareClause::cast_ref(&*this).unwrap();
    let result = this.declare_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExportDeclareClause_declaration<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExportDeclareClause::cast_ref(&*this).unwrap();
    let result = this.declaration();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsExtendsClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsExtendsClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsExtendsClause_extends_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExtendsClause::cast_ref(&*this).unwrap();
    let result = this.extends_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExtendsClause_types<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExtendsClause::cast_ref(&*this).unwrap();
    let result = this.types();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
impl<'s> ToV8<'s> for rome_js_syntax::TsExternalModuleDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsExternalModuleDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsExternalModuleDeclaration_module_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExternalModuleDeclaration::cast_ref(&*this).unwrap();
    let result = this.module_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExternalModuleDeclaration_source<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExternalModuleDeclaration::cast_ref(&*this).unwrap();
    let result = this.source();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExternalModuleDeclaration_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExternalModuleDeclaration::cast_ref(&*this).unwrap();
    let result = this.body();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsExternalModuleReference {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsExternalModuleReference,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsExternalModuleReference_require_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExternalModuleReference::cast_ref(&*this).unwrap();
    let result = this.require_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExternalModuleReference_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExternalModuleReference::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExternalModuleReference_source<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExternalModuleReference::cast_ref(&*this).unwrap();
    let result = this.source();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsExternalModuleReference_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsExternalModuleReference::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsFunctionType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsFunctionType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsFunctionType_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsFunctionType::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsFunctionType_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsFunctionType::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsFunctionType_fat_arrow_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsFunctionType::cast_ref(&*this).unwrap();
    let result = this.fat_arrow_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsFunctionType_return_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsFunctionType::cast_ref(&*this).unwrap();
    let result = this.return_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsGetterSignatureClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsGetterSignatureClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsGetterSignatureClassMember_get_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.get_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureClassMember_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureClassMember_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureClassMember_return_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.return_type();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsGetterSignatureTypeMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsGetterSignatureTypeMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureTypeMember_get_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.get_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureTypeMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureTypeMember_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureTypeMember_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureTypeMember_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsGetterSignatureTypeMember_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsGlobalDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsGlobalDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsGlobalDeclaration_global_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGlobalDeclaration::cast_ref(&*this).unwrap();
    let result = this.global_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsGlobalDeclaration_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsGlobalDeclaration::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsIdentifierBinding {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsIdentifierBinding,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsIdentifierBinding_name_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIdentifierBinding::cast_ref(&*this).unwrap();
    let result = this.name_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsImplementsClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsImplementsClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsImplementsClause_implements_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImplementsClause::cast_ref(&*this).unwrap();
    let result = this.implements_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImplementsClause_types<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImplementsClause::cast_ref(&*this).unwrap();
    let result = this.types();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
impl<'s> ToV8<'s> for rome_js_syntax::TsImportEqualsDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsImportEqualsDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsImportEqualsDeclaration_import_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportEqualsDeclaration::cast_ref(&*this).unwrap();
    let result = this.import_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportEqualsDeclaration_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportEqualsDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsImportEqualsDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportEqualsDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportEqualsDeclaration_eq_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportEqualsDeclaration::cast_ref(&*this).unwrap();
    let result = this.eq_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportEqualsDeclaration_module_reference<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportEqualsDeclaration::cast_ref(&*this).unwrap();
    let result = this.module_reference();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportEqualsDeclaration_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportEqualsDeclaration::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsImportType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsImportType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsImportType_typeof_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportType::cast_ref(&*this).unwrap();
    let result = this.typeof_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsImportType_import_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportType::cast_ref(&*this).unwrap();
    let result = this.import_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportType_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportType::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportType_argument_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportType::cast_ref(&*this).unwrap();
    let result = this.argument_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportType_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportType::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportType_qualifier_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportType::cast_ref(&*this).unwrap();
    let result = this.qualifier_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsImportType_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportType::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsImportTypeQualifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsImportTypeQualifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsImportTypeQualifier_dot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportTypeQualifier::cast_ref(&*this).unwrap();
    let result = this.dot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsImportTypeQualifier_right<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsImportTypeQualifier::cast_ref(&*this).unwrap();
    let result = this.right();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsInModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsInModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsInModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsIndexSignatureClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsIndexSignatureClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsIndexSignatureClassMember_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureClassMember_parameter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.parameter();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureClassMember_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureClassMember_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsIndexSignatureParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsIndexSignatureParameter,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureParameter_binding<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureParameter::cast_ref(&*this).unwrap();
    let result = this.binding();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureParameter_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureParameter::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsIndexSignatureTypeMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsIndexSignatureTypeMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureTypeMember_readonly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.readonly_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureTypeMember_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureTypeMember_parameter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.parameter();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureTypeMember_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureTypeMember_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexSignatureTypeMember_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsIndexedAccessType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsIndexedAccessType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsIndexedAccessType_object_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexedAccessType::cast_ref(&*this).unwrap();
    let result = this.object_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexedAccessType_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexedAccessType::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexedAccessType_index_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexedAccessType::cast_ref(&*this).unwrap();
    let result = this.index_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsIndexedAccessType_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIndexedAccessType::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsInferType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsInferType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsInferType_infer_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInferType::cast_ref(&*this).unwrap();
    let result = this.infer_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsInferType_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInferType::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsInferType_constraint<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInferType::cast_ref(&*this).unwrap();
    let result = this.constraint();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsInitializedPropertySignatureClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsInitializedPropertySignatureClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsInitializedPropertySignatureClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInitializedPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsInitializedPropertySignatureClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInitializedPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsInitializedPropertySignatureClassMember_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInitializedPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsInitializedPropertySignatureClassMember_value<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInitializedPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.value();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsInitializedPropertySignatureClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInitializedPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsInstantiationExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsInstantiationExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsInstantiationExpression_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInstantiationExpression::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsInstantiationExpression_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInstantiationExpression::cast_ref(&*this).unwrap();
    let result = this.arguments();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsInterfaceDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsInterfaceDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsInterfaceDeclaration_interface_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInterfaceDeclaration::cast_ref(&*this).unwrap();
    let result = this.interface_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsInterfaceDeclaration_id<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInterfaceDeclaration::cast_ref(&*this).unwrap();
    let result = this.id();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsInterfaceDeclaration_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInterfaceDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsInterfaceDeclaration_extends_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInterfaceDeclaration::cast_ref(&*this).unwrap();
    let result = this.extends_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsInterfaceDeclaration_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInterfaceDeclaration::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsInterfaceDeclaration_members<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInterfaceDeclaration::cast_ref(&*this).unwrap();
    let result = this.members();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsInterfaceDeclaration_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsInterfaceDeclaration::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsIntersectionType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsIntersectionType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsIntersectionType_leading_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIntersectionType::cast_ref(&*this).unwrap();
    let result = this.leading_separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsIntersectionType_types<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsIntersectionType::cast_ref(&*this).unwrap();
    let result = this.types();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
impl<'s> ToV8<'s> for rome_js_syntax::TsMappedType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsMappedType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsMappedType_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMappedType_readonly_modifier<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.readonly_modifier();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMappedType_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMappedType_property_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.property_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMappedType_in_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.in_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMappedType_keys_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.keys_type();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMappedType_as_clause<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.as_clause();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMappedType_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMappedType_optional_modifier<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.optional_modifier();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMappedType_mapped_type<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.mapped_type();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMappedType_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMappedType_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedType::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsMappedTypeAsClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsMappedTypeAsClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsMappedTypeAsClause_as_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedTypeAsClause::cast_ref(&*this).unwrap();
    let result = this.as_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMappedTypeAsClause_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedTypeAsClause::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsMappedTypeOptionalModifierClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsMappedTypeOptionalModifierClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsMappedTypeOptionalModifierClause_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedTypeOptionalModifierClause::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMappedTypeOptionalModifierClause_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedTypeOptionalModifierClause::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsMappedTypeReadonlyModifierClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsMappedTypeReadonlyModifierClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsMappedTypeReadonlyModifierClause_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedTypeReadonlyModifierClause::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMappedTypeReadonlyModifierClause_readonly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMappedTypeReadonlyModifierClause::cast_ref(&*this).unwrap();
    let result = this.readonly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsMethodSignatureClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsMethodSignatureClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsMethodSignatureClassMember_async_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.async_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureClassMember_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureClassMember_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureClassMember_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureClassMember_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsMethodSignatureTypeMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsMethodSignatureTypeMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureTypeMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureTypeMember_optional_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.optional_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureTypeMember_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureTypeMember_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.parameters();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureTypeMember_return_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.return_type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsMethodSignatureTypeMember_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsMethodSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsModuleBlock {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsModuleBlock,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsModuleBlock_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsModuleBlock::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsModuleBlock_items<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsModuleBlock::cast_ref(&*this).unwrap();
    let result = this.items();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsModuleBlock_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsModuleBlock::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsModuleDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsModuleDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsModuleDeclaration_module_or_namespace<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsModuleDeclaration::cast_ref(&*this).unwrap();
    let result = this.module_or_namespace();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsModuleDeclaration_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsModuleDeclaration::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsModuleDeclaration_body<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsModuleDeclaration::cast_ref(&*this).unwrap();
    let result = this.body();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNameWithTypeArguments {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNameWithTypeArguments,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNameWithTypeArguments_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNameWithTypeArguments::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsNameWithTypeArguments_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNameWithTypeArguments::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNamedTupleTypeElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNamedTupleTypeElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNamedTupleTypeElement_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNamedTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsNamedTupleTypeElement_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNamedTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsNamedTupleTypeElement_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNamedTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsNamedTupleTypeElement_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNamedTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsNamedTupleTypeElement_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNamedTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNeverType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNeverType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNeverType_never_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNeverType::cast_ref(&*this).unwrap();
    let result = this.never_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNonNullAssertionAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNonNullAssertionAssignment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNonNullAssertionAssignment_assignment<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNonNullAssertionAssignment::cast_ref(&*this).unwrap();
    let result = this.assignment();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsNonNullAssertionAssignment_excl_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNonNullAssertionAssignment::cast_ref(&*this).unwrap();
    let result = this.excl_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNonNullAssertionExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNonNullAssertionExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNonNullAssertionExpression_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNonNullAssertionExpression::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsNonNullAssertionExpression_excl_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNonNullAssertionExpression::cast_ref(&*this).unwrap();
    let result = this.excl_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNonPrimitiveType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNonPrimitiveType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNonPrimitiveType_object_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNonPrimitiveType::cast_ref(&*this).unwrap();
    let result = this.object_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNullLiteralType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNullLiteralType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNullLiteralType_literal_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNullLiteralType::cast_ref(&*this).unwrap();
    let result = this.literal_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNumberLiteralType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNumberLiteralType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNumberLiteralType_minus_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNumberLiteralType::cast_ref(&*this).unwrap();
    let result = this.minus_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsNumberLiteralType_literal_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNumberLiteralType::cast_ref(&*this).unwrap();
    let result = this.literal_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsNumberType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsNumberType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsNumberType_number_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsNumberType::cast_ref(&*this).unwrap();
    let result = this.number_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsObjectType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsObjectType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsObjectType_l_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsObjectType::cast_ref(&*this).unwrap();
    let result = this.l_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsObjectType_members<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsObjectType::cast_ref(&*this).unwrap();
    let result = this.members();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsObjectType_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsObjectType::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsOptionalPropertyAnnotation {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsOptionalPropertyAnnotation,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsOptionalPropertyAnnotation_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsOptionalPropertyAnnotation::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsOptionalPropertyAnnotation_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsOptionalPropertyAnnotation::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsOptionalTupleTypeElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsOptionalTupleTypeElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsOptionalTupleTypeElement_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsOptionalTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsOptionalTupleTypeElement_question_mark_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsOptionalTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.question_mark_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsOutModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsOutModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsOutModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsOutModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsOverrideModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsOverrideModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsOverrideModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsOverrideModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsParenthesizedType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsParenthesizedType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsParenthesizedType_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsParenthesizedType::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsParenthesizedType_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsParenthesizedType::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsParenthesizedType_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsParenthesizedType::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsPredicateReturnType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsPredicateReturnType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsPredicateReturnType_parameter_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPredicateReturnType::cast_ref(&*this).unwrap();
    let result = this.parameter_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsPredicateReturnType_is_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPredicateReturnType::cast_ref(&*this).unwrap();
    let result = this.is_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsPredicateReturnType_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPredicateReturnType::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsPropertyParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsPropertyParameter,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsPropertyParameter_decorators<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertyParameter::cast_ref(&*this).unwrap();
    let result = this.decorators();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsPropertyParameter_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertyParameter::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsPropertyParameter_formal_parameter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertyParameter::cast_ref(&*this).unwrap();
    let result = this.formal_parameter();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsPropertySignatureClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsPropertySignatureClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsPropertySignatureClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsPropertySignatureClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsPropertySignatureClassMember_property_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.property_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsPropertySignatureClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsPropertySignatureTypeMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsPropertySignatureTypeMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsPropertySignatureTypeMember_readonly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.readonly_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsPropertySignatureTypeMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsPropertySignatureTypeMember_optional_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.optional_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsPropertySignatureTypeMember_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsPropertySignatureTypeMember_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsPropertySignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsQualifiedModuleName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsQualifiedModuleName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsQualifiedModuleName_left<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsQualifiedModuleName::cast_ref(&*this).unwrap();
    let result = this.left();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsQualifiedModuleName_dot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsQualifiedModuleName::cast_ref(&*this).unwrap();
    let result = this.dot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsQualifiedModuleName_right<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsQualifiedModuleName::cast_ref(&*this).unwrap();
    let result = this.right();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsQualifiedName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsQualifiedName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsQualifiedName_left<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsQualifiedName::cast_ref(&*this).unwrap();
    let result = this.left();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsQualifiedName_dot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsQualifiedName::cast_ref(&*this).unwrap();
    let result = this.dot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsQualifiedName_right<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsQualifiedName::cast_ref(&*this).unwrap();
    let result = this.right();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsReadonlyModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsReadonlyModifier,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsReadonlyModifier_modifier_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsReadonlyModifier::cast_ref(&*this).unwrap();
    let result = this.modifier_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsReferenceType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsReferenceType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsReferenceType_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsReferenceType::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsReferenceType_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsReferenceType::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsRestTupleTypeElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsRestTupleTypeElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsRestTupleTypeElement_dotdotdot_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsRestTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.dotdotdot_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsRestTupleTypeElement_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsRestTupleTypeElement::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsReturnTypeAnnotation {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsReturnTypeAnnotation,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsReturnTypeAnnotation_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsReturnTypeAnnotation::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsReturnTypeAnnotation_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsReturnTypeAnnotation::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsSatisfiesAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsSatisfiesAssignment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsSatisfiesAssignment_assignment<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSatisfiesAssignment::cast_ref(&*this).unwrap();
    let result = this.assignment();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSatisfiesAssignment_satisfies_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSatisfiesAssignment::cast_ref(&*this).unwrap();
    let result = this.satisfies_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSatisfiesAssignment_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSatisfiesAssignment::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsSatisfiesExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsSatisfiesExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsSatisfiesExpression_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSatisfiesExpression::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSatisfiesExpression_satisfies_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSatisfiesExpression::cast_ref(&*this).unwrap();
    let result = this.satisfies_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSatisfiesExpression_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSatisfiesExpression::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsSetterSignatureClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsSetterSignatureClassMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureClassMember_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsSetterSignatureClassMember_set_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.set_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureClassMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureClassMember_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureClassMember_parameter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.parameter();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureClassMember_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureClassMember_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureClassMember::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsSetterSignatureTypeMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsSetterSignatureTypeMember,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureTypeMember_set_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.set_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureTypeMember_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureTypeMember_l_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.l_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureTypeMember_parameter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.parameter();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureTypeMember_r_paren_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.r_paren_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsSetterSignatureTypeMember_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSetterSignatureTypeMember::cast_ref(&*this).unwrap();
    let result = this.separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsStringLiteralType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsStringLiteralType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsStringLiteralType_literal_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsStringLiteralType::cast_ref(&*this).unwrap();
    let result = this.literal_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsStringType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsStringType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsStringType_string_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsStringType::cast_ref(&*this).unwrap();
    let result = this.string_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsSymbolType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsSymbolType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsSymbolType_symbol_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsSymbolType::cast_ref(&*this).unwrap();
    let result = this.symbol_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTemplateChunkElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTemplateChunkElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTemplateChunkElement_template_chunk_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTemplateChunkElement::cast_ref(&*this).unwrap();
    let result = this.template_chunk_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTemplateElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTemplateElement,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTemplateElement_dollar_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTemplateElement::cast_ref(&*this).unwrap();
    let result = this.dollar_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTemplateElement_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTemplateElement::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTemplateElement_r_curly_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTemplateElement::cast_ref(&*this).unwrap();
    let result = this.r_curly_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTemplateLiteralType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTemplateLiteralType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTemplateLiteralType_l_tick_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTemplateLiteralType::cast_ref(&*this).unwrap();
    let result = this.l_tick_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTemplateLiteralType_elements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTemplateLiteralType::cast_ref(&*this).unwrap();
    let result = this.elements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsTemplateLiteralType_r_tick_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTemplateLiteralType::cast_ref(&*this).unwrap();
    let result = this.r_tick_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsThisParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsThisParameter,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsThisParameter_this_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsThisParameter::cast_ref(&*this).unwrap();
    let result = this.this_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsThisParameter_type_annotation<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsThisParameter::cast_ref(&*this).unwrap();
    let result = this.type_annotation();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsThisType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsThisType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsThisType_this_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsThisType::cast_ref(&*this).unwrap();
    let result = this.this_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTupleType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTupleType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTupleType_l_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTupleType::cast_ref(&*this).unwrap();
    let result = this.l_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTupleType_elements<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTupleType::cast_ref(&*this).unwrap();
    let result = this.elements();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsTupleType_r_brack_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTupleType::cast_ref(&*this).unwrap();
    let result = this.r_brack_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeAliasDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeAliasDeclaration,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeAliasDeclaration_type_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAliasDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAliasDeclaration_binding_identifier<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAliasDeclaration::cast_ref(&*this).unwrap();
    let result = this.binding_identifier();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAliasDeclaration_type_parameters<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAliasDeclaration::cast_ref(&*this).unwrap();
    let result = this.type_parameters();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsTypeAliasDeclaration_eq_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAliasDeclaration::cast_ref(&*this).unwrap();
    let result = this.eq_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAliasDeclaration_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAliasDeclaration::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAliasDeclaration_semicolon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAliasDeclaration::cast_ref(&*this).unwrap();
    let result = this.semicolon_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeAnnotation {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeAnnotation,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeAnnotation_colon_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAnnotation::cast_ref(&*this).unwrap();
    let result = this.colon_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAnnotation_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAnnotation::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeArguments {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeArguments,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeArguments_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeArguments::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeArguments_ts_type_argument_list<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeArguments::cast_ref(&*this).unwrap();
    let result = this.ts_type_argument_list();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsTypeArguments_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeArguments::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeAssertionAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeAssertionAssignment,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeAssertionAssignment_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAssertionAssignment::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAssertionAssignment_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAssertionAssignment::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAssertionAssignment_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAssertionAssignment::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAssertionAssignment_assignment<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAssertionAssignment::cast_ref(&*this).unwrap();
    let result = this.assignment();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeAssertionExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeAssertionExpression,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeAssertionExpression_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAssertionExpression::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAssertionExpression_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAssertionExpression::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAssertionExpression_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAssertionExpression::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeAssertionExpression_expression<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeAssertionExpression::cast_ref(&*this).unwrap();
    let result = this.expression();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeConstraintClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeConstraintClause,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeConstraintClause_extends_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeConstraintClause::cast_ref(&*this).unwrap();
    let result = this.extends_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeConstraintClause_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeConstraintClause::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeOperatorType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeOperatorType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeOperatorType_operator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeOperatorType::cast_ref(&*this).unwrap();
    let result = this.operator_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeOperatorType_ty<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeOperatorType::cast_ref(&*this).unwrap();
    let result = this.ty();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeParameter,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeParameter_modifiers<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeParameter::cast_ref(&*this).unwrap();
    let result = this.modifiers();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsTypeParameter_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeParameter::cast_ref(&*this).unwrap();
    let result = this.name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeParameter_constraint<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeParameter::cast_ref(&*this).unwrap();
    let result = this.constraint();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsTypeParameter_default<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeParameter::cast_ref(&*this).unwrap();
    let result = this.default();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeParameterName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeParameterName,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeParameterName_ident_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeParameterName::cast_ref(&*this).unwrap();
    let result = this.ident_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeParameters {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeParameters,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeParameters_l_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeParameters::cast_ref(&*this).unwrap();
    let result = this.l_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeParameters_items<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeParameters::cast_ref(&*this).unwrap();
    let result = this.items();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
#[allow(non_snake_case)]
fn TsTypeParameters_r_angle_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeParameters::cast_ref(&*this).unwrap();
    let result = this.r_angle_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsTypeofType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsTypeofType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsTypeofType_typeof_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeofType::cast_ref(&*this).unwrap();
    let result = this.typeof_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeofType_expression_name<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeofType::cast_ref(&*this).unwrap();
    let result = this.expression_name();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
#[allow(non_snake_case)]
fn TsTypeofType_type_arguments<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsTypeofType::cast_ref(&*this).unwrap();
    let result = this.type_arguments();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsUndefinedType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsUndefinedType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsUndefinedType_undefined_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsUndefinedType::cast_ref(&*this).unwrap();
    let result = this.undefined_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsUnionType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsUnionType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsUnionType_leading_separator_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsUnionType::cast_ref(&*this).unwrap();
    let result = this.leading_separator_token();
    if let Some(result) = result {
        let result = ToV8::to_v8(result, scope).unwrap();
        res.set(result);
    } else {
        res.set_undefined();
    }
}
#[allow(non_snake_case)]
fn TsUnionType_types<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsUnionType::cast_ref(&*this).unwrap();
    let result = this.types();
    let result = ToV8::to_v8(result, scope).unwrap();
    res.set(result);
}
impl<'s> ToV8<'s> for rome_js_syntax::TsUnknownType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsUnknownType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsUnknownType_unknown_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsUnknownType::cast_ref(&*this).unwrap();
    let result = this.unknown_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::TsVoidType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        let node = self.into_syntax();
        crate::registry::instantiate_as::<
            rome_js_syntax::TsVoidType,
            rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>,
        >(scope, node)
        .map(Into::into)
    }
}
#[allow(non_snake_case)]
fn TsVoidType_void_token<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_rowan::SyntaxNode<rome_js_syntax::JsLanguage>>::from_v8(scope, this)
            .unwrap();
    let this = rome_js_syntax::TsVoidType::cast_ref(&*this).unwrap();
    let result = this.void_token();
    match result {
        Ok(result) => {
            let result = ToV8::to_v8(result, scope).unwrap();
            res.set(result);
        }
        Err(err) => {
            let message = err.to_string();
            let message = v8::String::new(scope, &message).unwrap();
            let exception = v8::Exception::error(scope, message);
            scope.throw_exception(exception);
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsArrayAssignmentPatternElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsAssignmentPattern(node) => ToV8::to_v8(node, scope),
            Self::JsArrayAssignmentPatternRestElement(node) => ToV8::to_v8(node, scope),
            Self::JsArrayHole(node) => ToV8::to_v8(node, scope),
            Self::JsAssignmentWithDefault(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsArrayBindingPatternElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsBindingPattern(node) => ToV8::to_v8(node, scope),
            Self::JsArrayBindingPatternRestElement(node) => ToV8::to_v8(node, scope),
            Self::JsArrayHole(node) => ToV8::to_v8(node, scope),
            Self::JsBindingPatternWithDefault(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsArrayElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsExpression(node) => ToV8::to_v8(node, scope),
            Self::JsArrayHole(node) => ToV8::to_v8(node, scope),
            Self::JsSpread(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsArrowFunctionParameters {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsBinding(node) => ToV8::to_v8(node, scope),
            Self::JsParameters(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsAssignment {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusAssignment(node) => ToV8::to_v8(node, scope),
            Self::JsComputedMemberAssignment(node) => ToV8::to_v8(node, scope),
            Self::JsIdentifierAssignment(node) => ToV8::to_v8(node, scope),
            Self::JsParenthesizedAssignment(node) => ToV8::to_v8(node, scope),
            Self::JsStaticMemberAssignment(node) => ToV8::to_v8(node, scope),
            Self::TsAsAssignment(node) => ToV8::to_v8(node, scope),
            Self::TsNonNullAssertionAssignment(node) => ToV8::to_v8(node, scope),
            Self::TsSatisfiesAssignment(node) => ToV8::to_v8(node, scope),
            Self::TsTypeAssertionAssignment(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsAssignmentPattern {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsAssignment(node) => ToV8::to_v8(node, scope),
            Self::JsArrayAssignmentPattern(node) => ToV8::to_v8(node, scope),
            Self::JsObjectAssignmentPattern(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsBinding {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusBinding(node) => ToV8::to_v8(node, scope),
            Self::JsIdentifierBinding(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsBindingPattern {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsBinding(node) => ToV8::to_v8(node, scope),
            Self::JsArrayBindingPattern(node) => ToV8::to_v8(node, scope),
            Self::JsObjectBindingPattern(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsCallArgument {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsExpression(node) => ToV8::to_v8(node, scope),
            Self::JsSpread(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsClass {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsClassDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsClassExportDefaultDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsClassExpression(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsClassMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusMember(node) => ToV8::to_v8(node, scope),
            Self::JsConstructorClassMember(node) => ToV8::to_v8(node, scope),
            Self::JsEmptyClassMember(node) => ToV8::to_v8(node, scope),
            Self::JsGetterClassMember(node) => ToV8::to_v8(node, scope),
            Self::JsMethodClassMember(node) => ToV8::to_v8(node, scope),
            Self::JsPropertyClassMember(node) => ToV8::to_v8(node, scope),
            Self::JsSetterClassMember(node) => ToV8::to_v8(node, scope),
            Self::JsStaticInitializationBlockClassMember(node) => ToV8::to_v8(node, scope),
            Self::TsConstructorSignatureClassMember(node) => ToV8::to_v8(node, scope),
            Self::TsGetterSignatureClassMember(node) => ToV8::to_v8(node, scope),
            Self::TsIndexSignatureClassMember(node) => ToV8::to_v8(node, scope),
            Self::TsInitializedPropertySignatureClassMember(node) => ToV8::to_v8(node, scope),
            Self::TsMethodSignatureClassMember(node) => ToV8::to_v8(node, scope),
            Self::TsPropertySignatureClassMember(node) => ToV8::to_v8(node, scope),
            Self::TsSetterSignatureClassMember(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsClassMemberName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsComputedMemberName(node) => ToV8::to_v8(node, scope),
            Self::JsLiteralMemberName(node) => ToV8::to_v8(node, scope),
            Self::JsPrivateClassMemberName(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsConstructorParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsFormalParameter(node) => ToV8::to_v8(node, scope),
            Self::JsRestParameter(node) => ToV8::to_v8(node, scope),
            Self::TsPropertyParameter(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsClassDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsVariableDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsDeclareFunctionDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsEnumDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsExternalModuleDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsGlobalDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsImportEqualsDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsInterfaceDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsModuleDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsTypeAliasDeclaration(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsDeclarationClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsClassDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsVariableDeclarationClause(node) => ToV8::to_v8(node, scope),
            Self::TsDeclareFunctionDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsEnumDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsExternalModuleDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsGlobalDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsImportEqualsDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsInterfaceDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsModuleDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsTypeAliasDeclaration(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsDecorator {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusExpression(node) => ToV8::to_v8(node, scope),
            Self::JsCallExpression(node) => ToV8::to_v8(node, scope),
            Self::JsIdentifierExpression(node) => ToV8::to_v8(node, scope),
            Self::JsParenthesizedExpression(node) => ToV8::to_v8(node, scope),
            Self::JsStaticMemberExpression(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsExportClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsDeclarationClause(node) => ToV8::to_v8(node, scope),
            Self::JsExportDefaultDeclarationClause(node) => ToV8::to_v8(node, scope),
            Self::JsExportDefaultExpressionClause(node) => ToV8::to_v8(node, scope),
            Self::JsExportFromClause(node) => ToV8::to_v8(node, scope),
            Self::JsExportNamedClause(node) => ToV8::to_v8(node, scope),
            Self::JsExportNamedFromClause(node) => ToV8::to_v8(node, scope),
            Self::TsExportAsNamespaceClause(node) => ToV8::to_v8(node, scope),
            Self::TsExportAssignmentClause(node) => ToV8::to_v8(node, scope),
            Self::TsExportDeclareClause(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsExportDefaultDeclaration {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsClassExportDefaultDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionExportDefaultDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsDeclareFunctionExportDefaultDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsInterfaceDeclaration(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsExportNamedSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsExportNamedShorthandSpecifier(node) => ToV8::to_v8(node, scope),
            Self::JsExportNamedSpecifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsLiteralExpression(node) => ToV8::to_v8(node, scope),
            Self::JsArrayExpression(node) => ToV8::to_v8(node, scope),
            Self::JsArrowFunctionExpression(node) => ToV8::to_v8(node, scope),
            Self::JsAssignmentExpression(node) => ToV8::to_v8(node, scope),
            Self::JsAwaitExpression(node) => ToV8::to_v8(node, scope),
            Self::JsBinaryExpression(node) => ToV8::to_v8(node, scope),
            Self::JsBogusExpression(node) => ToV8::to_v8(node, scope),
            Self::JsCallExpression(node) => ToV8::to_v8(node, scope),
            Self::JsClassExpression(node) => ToV8::to_v8(node, scope),
            Self::JsComputedMemberExpression(node) => ToV8::to_v8(node, scope),
            Self::JsConditionalExpression(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionExpression(node) => ToV8::to_v8(node, scope),
            Self::JsIdentifierExpression(node) => ToV8::to_v8(node, scope),
            Self::JsImportCallExpression(node) => ToV8::to_v8(node, scope),
            Self::JsImportMetaExpression(node) => ToV8::to_v8(node, scope),
            Self::JsInExpression(node) => ToV8::to_v8(node, scope),
            Self::JsInstanceofExpression(node) => ToV8::to_v8(node, scope),
            Self::JsLogicalExpression(node) => ToV8::to_v8(node, scope),
            Self::JsNewExpression(node) => ToV8::to_v8(node, scope),
            Self::JsNewTargetExpression(node) => ToV8::to_v8(node, scope),
            Self::JsObjectExpression(node) => ToV8::to_v8(node, scope),
            Self::JsParenthesizedExpression(node) => ToV8::to_v8(node, scope),
            Self::JsPostUpdateExpression(node) => ToV8::to_v8(node, scope),
            Self::JsPreUpdateExpression(node) => ToV8::to_v8(node, scope),
            Self::JsSequenceExpression(node) => ToV8::to_v8(node, scope),
            Self::JsStaticMemberExpression(node) => ToV8::to_v8(node, scope),
            Self::JsSuperExpression(node) => ToV8::to_v8(node, scope),
            Self::JsTemplateExpression(node) => ToV8::to_v8(node, scope),
            Self::JsThisExpression(node) => ToV8::to_v8(node, scope),
            Self::JsUnaryExpression(node) => ToV8::to_v8(node, scope),
            Self::JsYieldExpression(node) => ToV8::to_v8(node, scope),
            Self::JsxTagExpression(node) => ToV8::to_v8(node, scope),
            Self::TsAsExpression(node) => ToV8::to_v8(node, scope),
            Self::TsInstantiationExpression(node) => ToV8::to_v8(node, scope),
            Self::TsNonNullAssertionExpression(node) => ToV8::to_v8(node, scope),
            Self::TsSatisfiesExpression(node) => ToV8::to_v8(node, scope),
            Self::TsTypeAssertionExpression(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsForInOrOfInitializer {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsAssignmentPattern(node) => ToV8::to_v8(node, scope),
            Self::JsForVariableDeclaration(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsForInitializer {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsExpression(node) => ToV8::to_v8(node, scope),
            Self::JsVariableDeclaration(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsFormalParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusParameter(node) => ToV8::to_v8(node, scope),
            Self::JsFormalParameter(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsFunction {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsArrowFunctionExpression(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionExportDefaultDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionExpression(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsFunctionBody {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsExpression(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionBody(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsImportAssertionEntry {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusImportAssertionEntry(node) => ToV8::to_v8(node, scope),
            Self::JsImportAssertionEntry(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsImportClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsImportBareClause(node) => ToV8::to_v8(node, scope),
            Self::JsImportDefaultClause(node) => ToV8::to_v8(node, scope),
            Self::JsImportNamedClause(node) => ToV8::to_v8(node, scope),
            Self::JsImportNamespaceClause(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsInProperty {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsExpression(node) => ToV8::to_v8(node, scope),
            Self::JsPrivateName(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsLiteralExpression {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBigintLiteralExpression(node) => ToV8::to_v8(node, scope),
            Self::JsBooleanLiteralExpression(node) => ToV8::to_v8(node, scope),
            Self::JsNullLiteralExpression(node) => ToV8::to_v8(node, scope),
            Self::JsNumberLiteralExpression(node) => ToV8::to_v8(node, scope),
            Self::JsRegexLiteralExpression(node) => ToV8::to_v8(node, scope),
            Self::JsStringLiteralExpression(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsMethodModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsDecorator(node) => ToV8::to_v8(node, scope),
            Self::JsStaticModifier(node) => ToV8::to_v8(node, scope),
            Self::TsAccessibilityModifier(node) => ToV8::to_v8(node, scope),
            Self::TsOverrideModifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsModuleItem {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsStatement(node) => ToV8::to_v8(node, scope),
            Self::JsExport(node) => ToV8::to_v8(node, scope),
            Self::JsImport(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsName(node) => ToV8::to_v8(node, scope),
            Self::JsPrivateName(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsNamedImport {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsNamedImportSpecifiers(node) => ToV8::to_v8(node, scope),
            Self::JsNamespaceImportSpecifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsNamedImportSpecifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusNamedImportSpecifier(node) => ToV8::to_v8(node, scope),
            Self::JsNamedImportSpecifier(node) => ToV8::to_v8(node, scope),
            Self::JsShorthandNamedImportSpecifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsObjectAssignmentPatternMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusAssignment(node) => ToV8::to_v8(node, scope),
            Self::JsObjectAssignmentPatternProperty(node) => ToV8::to_v8(node, scope),
            Self::JsObjectAssignmentPatternRest(node) => ToV8::to_v8(node, scope),
            Self::JsObjectAssignmentPatternShorthandProperty(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsObjectBindingPatternMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusBinding(node) => ToV8::to_v8(node, scope),
            Self::JsObjectBindingPatternProperty(node) => ToV8::to_v8(node, scope),
            Self::JsObjectBindingPatternRest(node) => ToV8::to_v8(node, scope),
            Self::JsObjectBindingPatternShorthandProperty(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsObjectMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusMember(node) => ToV8::to_v8(node, scope),
            Self::JsGetterObjectMember(node) => ToV8::to_v8(node, scope),
            Self::JsMethodObjectMember(node) => ToV8::to_v8(node, scope),
            Self::JsPropertyObjectMember(node) => ToV8::to_v8(node, scope),
            Self::JsSetterObjectMember(node) => ToV8::to_v8(node, scope),
            Self::JsShorthandPropertyObjectMember(node) => ToV8::to_v8(node, scope),
            Self::JsSpread(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsObjectMemberName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsComputedMemberName(node) => ToV8::to_v8(node, scope),
            Self::JsLiteralMemberName(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsParameter {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsFormalParameter(node) => ToV8::to_v8(node, scope),
            Self::JsRestParameter(node) => ToV8::to_v8(node, scope),
            Self::TsThisParameter(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsPropertyModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsAccessorModifier(node) => ToV8::to_v8(node, scope),
            Self::JsDecorator(node) => ToV8::to_v8(node, scope),
            Self::JsStaticModifier(node) => ToV8::to_v8(node, scope),
            Self::TsAccessibilityModifier(node) => ToV8::to_v8(node, scope),
            Self::TsOverrideModifier(node) => ToV8::to_v8(node, scope),
            Self::TsReadonlyModifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsRoot {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsExpressionSnipped(node) => ToV8::to_v8(node, scope),
            Self::JsModule(node) => ToV8::to_v8(node, scope),
            Self::JsScript(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsStatement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBlockStatement(node) => ToV8::to_v8(node, scope),
            Self::JsBogusStatement(node) => ToV8::to_v8(node, scope),
            Self::JsBreakStatement(node) => ToV8::to_v8(node, scope),
            Self::JsClassDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsContinueStatement(node) => ToV8::to_v8(node, scope),
            Self::JsDebuggerStatement(node) => ToV8::to_v8(node, scope),
            Self::JsDoWhileStatement(node) => ToV8::to_v8(node, scope),
            Self::JsEmptyStatement(node) => ToV8::to_v8(node, scope),
            Self::JsExpressionStatement(node) => ToV8::to_v8(node, scope),
            Self::JsForInStatement(node) => ToV8::to_v8(node, scope),
            Self::JsForOfStatement(node) => ToV8::to_v8(node, scope),
            Self::JsForStatement(node) => ToV8::to_v8(node, scope),
            Self::JsFunctionDeclaration(node) => ToV8::to_v8(node, scope),
            Self::JsIfStatement(node) => ToV8::to_v8(node, scope),
            Self::JsLabeledStatement(node) => ToV8::to_v8(node, scope),
            Self::JsReturnStatement(node) => ToV8::to_v8(node, scope),
            Self::JsSwitchStatement(node) => ToV8::to_v8(node, scope),
            Self::JsThrowStatement(node) => ToV8::to_v8(node, scope),
            Self::JsTryFinallyStatement(node) => ToV8::to_v8(node, scope),
            Self::JsTryStatement(node) => ToV8::to_v8(node, scope),
            Self::JsVariableStatement(node) => ToV8::to_v8(node, scope),
            Self::JsWhileStatement(node) => ToV8::to_v8(node, scope),
            Self::JsWithStatement(node) => ToV8::to_v8(node, scope),
            Self::TsDeclareFunctionDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsDeclareStatement(node) => ToV8::to_v8(node, scope),
            Self::TsEnumDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsExternalModuleDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsGlobalDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsImportEqualsDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsInterfaceDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsModuleDeclaration(node) => ToV8::to_v8(node, scope),
            Self::TsTypeAliasDeclaration(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsSwitchClause {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsCaseClause(node) => ToV8::to_v8(node, scope),
            Self::JsDefaultClause(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsTemplateElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsTemplateChunkElement(node) => ToV8::to_v8(node, scope),
            Self::JsTemplateElement(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsxAttribute {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsxAttribute(node) => ToV8::to_v8(node, scope),
            Self::JsxSpreadAttribute(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsxAttributeName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsxName(node) => ToV8::to_v8(node, scope),
            Self::JsxNamespaceName(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsxAttributeValue {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyJsxTag(node) => ToV8::to_v8(node, scope),
            Self::JsxExpressionAttributeValue(node) => ToV8::to_v8(node, scope),
            Self::JsxString(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsxChild {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsxElement(node) => ToV8::to_v8(node, scope),
            Self::JsxExpressionChild(node) => ToV8::to_v8(node, scope),
            Self::JsxFragment(node) => ToV8::to_v8(node, scope),
            Self::JsxSelfClosingElement(node) => ToV8::to_v8(node, scope),
            Self::JsxSpreadChild(node) => ToV8::to_v8(node, scope),
            Self::JsxText(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsxElementName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsxMemberName(node) => ToV8::to_v8(node, scope),
            Self::JsxName(node) => ToV8::to_v8(node, scope),
            Self::JsxNamespaceName(node) => ToV8::to_v8(node, scope),
            Self::JsxReferenceIdentifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsxName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsxName(node) => ToV8::to_v8(node, scope),
            Self::JsxNamespaceName(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsxObjectName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsxMemberName(node) => ToV8::to_v8(node, scope),
            Self::JsxNamespaceName(node) => ToV8::to_v8(node, scope),
            Self::JsxReferenceIdentifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyJsxTag {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsxElement(node) => ToV8::to_v8(node, scope),
            Self::JsxFragment(node) => ToV8::to_v8(node, scope),
            Self::JsxSelfClosingElement(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsExternalModuleDeclarationBody {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsEmptyExternalModuleDeclarationBody(node) => ToV8::to_v8(node, scope),
            Self::TsModuleBlock(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsIndexSignatureModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsStaticModifier(node) => ToV8::to_v8(node, scope),
            Self::TsReadonlyModifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsMethodSignatureModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsDecorator(node) => ToV8::to_v8(node, scope),
            Self::JsStaticModifier(node) => ToV8::to_v8(node, scope),
            Self::TsAbstractModifier(node) => ToV8::to_v8(node, scope),
            Self::TsAccessibilityModifier(node) => ToV8::to_v8(node, scope),
            Self::TsOverrideModifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsModuleName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsIdentifierBinding(node) => ToV8::to_v8(node, scope),
            Self::TsQualifiedModuleName(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsModuleReference {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyTsName(node) => ToV8::to_v8(node, scope),
            Self::TsExternalModuleReference(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsReferenceIdentifier(node) => ToV8::to_v8(node, scope),
            Self::TsQualifiedName(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsPropertyAnnotation {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsDefinitePropertyAnnotation(node) => ToV8::to_v8(node, scope),
            Self::TsOptionalPropertyAnnotation(node) => ToV8::to_v8(node, scope),
            Self::TsTypeAnnotation(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsPropertyParameterModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsAccessibilityModifier(node) => ToV8::to_v8(node, scope),
            Self::TsOverrideModifier(node) => ToV8::to_v8(node, scope),
            Self::TsReadonlyModifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsPropertySignatureAnnotation {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsOptionalPropertyAnnotation(node) => ToV8::to_v8(node, scope),
            Self::TsTypeAnnotation(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsPropertySignatureModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsAccessorModifier(node) => ToV8::to_v8(node, scope),
            Self::JsDecorator(node) => ToV8::to_v8(node, scope),
            Self::JsStaticModifier(node) => ToV8::to_v8(node, scope),
            Self::TsAbstractModifier(node) => ToV8::to_v8(node, scope),
            Self::TsAccessibilityModifier(node) => ToV8::to_v8(node, scope),
            Self::TsDeclareModifier(node) => ToV8::to_v8(node, scope),
            Self::TsOverrideModifier(node) => ToV8::to_v8(node, scope),
            Self::TsReadonlyModifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsReturnType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyTsType(node) => ToV8::to_v8(node, scope),
            Self::TsAssertsReturnType(node) => ToV8::to_v8(node, scope),
            Self::TsPredicateReturnType(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsTemplateElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsTemplateChunkElement(node) => ToV8::to_v8(node, scope),
            Self::TsTemplateElement(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsTupleTypeElement {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::AnyTsType(node) => ToV8::to_v8(node, scope),
            Self::TsNamedTupleTypeElement(node) => ToV8::to_v8(node, scope),
            Self::TsOptionalTupleTypeElement(node) => ToV8::to_v8(node, scope),
            Self::TsRestTupleTypeElement(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsType {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsAnyType(node) => ToV8::to_v8(node, scope),
            Self::TsArrayType(node) => ToV8::to_v8(node, scope),
            Self::TsBigintLiteralType(node) => ToV8::to_v8(node, scope),
            Self::TsBigintType(node) => ToV8::to_v8(node, scope),
            Self::TsBogusType(node) => ToV8::to_v8(node, scope),
            Self::TsBooleanLiteralType(node) => ToV8::to_v8(node, scope),
            Self::TsBooleanType(node) => ToV8::to_v8(node, scope),
            Self::TsConditionalType(node) => ToV8::to_v8(node, scope),
            Self::TsConstructorType(node) => ToV8::to_v8(node, scope),
            Self::TsFunctionType(node) => ToV8::to_v8(node, scope),
            Self::TsImportType(node) => ToV8::to_v8(node, scope),
            Self::TsIndexedAccessType(node) => ToV8::to_v8(node, scope),
            Self::TsInferType(node) => ToV8::to_v8(node, scope),
            Self::TsIntersectionType(node) => ToV8::to_v8(node, scope),
            Self::TsMappedType(node) => ToV8::to_v8(node, scope),
            Self::TsNeverType(node) => ToV8::to_v8(node, scope),
            Self::TsNonPrimitiveType(node) => ToV8::to_v8(node, scope),
            Self::TsNullLiteralType(node) => ToV8::to_v8(node, scope),
            Self::TsNumberLiteralType(node) => ToV8::to_v8(node, scope),
            Self::TsNumberType(node) => ToV8::to_v8(node, scope),
            Self::TsObjectType(node) => ToV8::to_v8(node, scope),
            Self::TsParenthesizedType(node) => ToV8::to_v8(node, scope),
            Self::TsReferenceType(node) => ToV8::to_v8(node, scope),
            Self::TsStringLiteralType(node) => ToV8::to_v8(node, scope),
            Self::TsStringType(node) => ToV8::to_v8(node, scope),
            Self::TsSymbolType(node) => ToV8::to_v8(node, scope),
            Self::TsTemplateLiteralType(node) => ToV8::to_v8(node, scope),
            Self::TsThisType(node) => ToV8::to_v8(node, scope),
            Self::TsTupleType(node) => ToV8::to_v8(node, scope),
            Self::TsTypeOperatorType(node) => ToV8::to_v8(node, scope),
            Self::TsTypeofType(node) => ToV8::to_v8(node, scope),
            Self::TsUndefinedType(node) => ToV8::to_v8(node, scope),
            Self::TsUnionType(node) => ToV8::to_v8(node, scope),
            Self::TsUnknownType(node) => ToV8::to_v8(node, scope),
            Self::TsVoidType(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsTypeMember {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsBogusMember(node) => ToV8::to_v8(node, scope),
            Self::TsCallSignatureTypeMember(node) => ToV8::to_v8(node, scope),
            Self::TsConstructSignatureTypeMember(node) => ToV8::to_v8(node, scope),
            Self::TsGetterSignatureTypeMember(node) => ToV8::to_v8(node, scope),
            Self::TsIndexSignatureTypeMember(node) => ToV8::to_v8(node, scope),
            Self::TsMethodSignatureTypeMember(node) => ToV8::to_v8(node, scope),
            Self::TsPropertySignatureTypeMember(node) => ToV8::to_v8(node, scope),
            Self::TsSetterSignatureTypeMember(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsTypeParameterModifier {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsConstModifier(node) => ToV8::to_v8(node, scope),
            Self::TsInModifier(node) => ToV8::to_v8(node, scope),
            Self::TsOutModifier(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsTypePredicateParameterName {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::JsReferenceIdentifier(node) => ToV8::to_v8(node, scope),
            Self::TsThisType(node) => ToV8::to_v8(node, scope),
        }
    }
}
impl<'s> ToV8<'s> for rome_js_syntax::AnyTsVariableAnnotation {
    fn to_v8(self, scope: &mut v8::HandleScope<'s>) -> anyhow::Result<v8::Local<'s, v8::Value>> {
        match self {
            Self::TsDefiniteVariableAnnotation(node) => ToV8::to_v8(node, scope),
            Self::TsTypeAnnotation(node) => ToV8::to_v8(node, scope),
        }
    }
}
crate::convert::impl_convert_native!(rome_js_syntax::JsBogus);
crate::convert::impl_convert_native!(rome_js_syntax::JsBogusAssignment);
crate::convert::impl_convert_native!(rome_js_syntax::JsBogusBinding);
crate::convert::impl_convert_native!(rome_js_syntax::JsBogusExpression);
crate::convert::impl_convert_native!(rome_js_syntax::JsBogusImportAssertionEntry);
crate::convert::impl_convert_native!(rome_js_syntax::JsBogusMember);
crate::convert::impl_convert_native!(rome_js_syntax::JsBogusNamedImportSpecifier);
crate::convert::impl_convert_native!(rome_js_syntax::JsBogusParameter);
crate::convert::impl_convert_native!(rome_js_syntax::JsBogusStatement);
crate::convert::impl_convert_native!(rome_js_syntax::TsBogusType);
crate::convert::impl_convert_native!(rome_js_syntax::JsArrayAssignmentPatternElementList);
#[allow(non_snake_case)]
fn JsArrayAssignmentPatternElementList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsArrayAssignmentPatternElementList>::from_v8(scope, this)
            .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsArrayBindingPatternElementList);
#[allow(non_snake_case)]
fn JsArrayBindingPatternElementList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsArrayBindingPatternElementList>::from_v8(scope, this)
            .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsArrayElementList);
#[allow(non_snake_case)]
fn JsArrayElementList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsArrayElementList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsCallArgumentList);
#[allow(non_snake_case)]
fn JsCallArgumentList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsCallArgumentList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsClassMemberList);
#[allow(non_snake_case)]
fn JsClassMemberList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsClassMemberList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsConstructorModifierList);
#[allow(non_snake_case)]
fn JsConstructorModifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsConstructorModifierList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsConstructorParameterList);
#[allow(non_snake_case)]
fn JsConstructorParameterList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsConstructorParameterList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsDecoratorList);
#[allow(non_snake_case)]
fn JsDecoratorList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsDecoratorList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsDirectiveList);
#[allow(non_snake_case)]
fn JsDirectiveList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsDirectiveList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsExportNamedFromSpecifierList);
#[allow(non_snake_case)]
fn JsExportNamedFromSpecifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsExportNamedFromSpecifierList>::from_v8(scope, this)
            .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsExportNamedSpecifierList);
#[allow(non_snake_case)]
fn JsExportNamedSpecifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsExportNamedSpecifierList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsImportAssertionEntryList);
#[allow(non_snake_case)]
fn JsImportAssertionEntryList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsImportAssertionEntryList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsMethodModifierList);
#[allow(non_snake_case)]
fn JsMethodModifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsMethodModifierList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsModuleItemList);
#[allow(non_snake_case)]
fn JsModuleItemList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsModuleItemList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsNamedImportSpecifierList);
#[allow(non_snake_case)]
fn JsNamedImportSpecifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsNamedImportSpecifierList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsObjectAssignmentPatternPropertyList);
#[allow(non_snake_case)]
fn JsObjectAssignmentPatternPropertyList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsObjectAssignmentPatternPropertyList>::from_v8(
        scope, this,
    )
    .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsObjectBindingPatternPropertyList);
#[allow(non_snake_case)]
fn JsObjectBindingPatternPropertyList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsObjectBindingPatternPropertyList>::from_v8(scope, this)
            .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsObjectMemberList);
#[allow(non_snake_case)]
fn JsObjectMemberList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsObjectMemberList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsParameterList);
#[allow(non_snake_case)]
fn JsParameterList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsParameterList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsPropertyModifierList);
#[allow(non_snake_case)]
fn JsPropertyModifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsPropertyModifierList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsStatementList);
#[allow(non_snake_case)]
fn JsStatementList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsStatementList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsSwitchCaseList);
#[allow(non_snake_case)]
fn JsSwitchCaseList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsSwitchCaseList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsTemplateElementList);
#[allow(non_snake_case)]
fn JsTemplateElementList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsTemplateElementList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsVariableDeclaratorList);
#[allow(non_snake_case)]
fn JsVariableDeclaratorList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::JsVariableDeclaratorList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsxAttributeList);
#[allow(non_snake_case)]
fn JsxAttributeList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsxAttributeList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::JsxChildList);
#[allow(non_snake_case)]
fn JsxChildList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::JsxChildList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsEnumMemberList);
#[allow(non_snake_case)]
fn TsEnumMemberList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::TsEnumMemberList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsIndexSignatureModifierList);
#[allow(non_snake_case)]
fn TsIndexSignatureModifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::TsIndexSignatureModifierList>::from_v8(scope, this)
        .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsIntersectionTypeElementList);
#[allow(non_snake_case)]
fn TsIntersectionTypeElementList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::TsIntersectionTypeElementList>::from_v8(scope, this)
            .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsMethodSignatureModifierList);
#[allow(non_snake_case)]
fn TsMethodSignatureModifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::TsMethodSignatureModifierList>::from_v8(scope, this)
            .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsPropertyParameterModifierList);
#[allow(non_snake_case)]
fn TsPropertyParameterModifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::TsPropertyParameterModifierList>::from_v8(scope, this)
            .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsPropertySignatureModifierList);
#[allow(non_snake_case)]
fn TsPropertySignatureModifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::TsPropertySignatureModifierList>::from_v8(scope, this)
            .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsTemplateElementList);
#[allow(non_snake_case)]
fn TsTemplateElementList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::TsTemplateElementList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsTupleTypeElementList);
#[allow(non_snake_case)]
fn TsTupleTypeElementList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::TsTupleTypeElementList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsTypeArgumentList);
#[allow(non_snake_case)]
fn TsTypeArgumentList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::TsTypeArgumentList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsTypeList);
#[allow(non_snake_case)]
fn TsTypeList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::TsTypeList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsTypeMemberList);
#[allow(non_snake_case)]
fn TsTypeMemberList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::TsTypeMemberList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsTypeParameterList);
#[allow(non_snake_case)]
fn TsTypeParameterList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::TsTypeParameterList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsTypeParameterModifierList);
#[allow(non_snake_case)]
fn TsTypeParameterModifierList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this = std::cell::Ref::<rome_js_syntax::TsTypeParameterModifierList>::from_v8(scope, this)
        .unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate::convert::impl_convert_native!(rome_js_syntax::TsUnionTypeVariantList);
#[allow(non_snake_case)]
fn TsUnionTypeVariantList_iter<'s>(
    scope: &mut v8::HandleScope<'s>,
    args: v8::FunctionCallbackArguments<'s>,
    mut res: v8::ReturnValue,
) {
    let this = args.this().into();
    let this =
        std::cell::Ref::<rome_js_syntax::TsUnionTypeVariantList>::from_v8(scope, this).unwrap();
    let iter = this.iter();
    let iter = ToV8::to_v8(iter, scope).unwrap();
    res.set(iter);
}
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsArrayAssignmentPatternElement >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsArrayBindingPatternElement >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsArrayElement >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsCallArgument >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsClassMember >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsConstructorParameter >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsExportNamedSpecifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsImportAssertionEntry >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsMethodModifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsModuleItem >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsNamedImportSpecifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsObjectAssignmentPatternMember >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsObjectBindingPatternMember >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsObjectMember >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsParameter >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsPropertyModifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsStatement >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsSwitchClause >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsTemplateElement >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsxAttribute >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyJsxChild >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsIndexSignatureModifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsMethodSignatureModifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsPropertyParameterModifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsPropertySignatureModifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsTemplateElement >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsTupleTypeElement >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsType >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsTypeMember >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: AnyTsTypeParameterModifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: JsDecorator >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: JsDirective >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: JsExportNamedFromSpecifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: JsVariableDeclarator >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstNodeListIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: TsAccessibilityModifier >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: TsEnumMember >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: TsNameWithTypeArguments >);
crate :: convert :: impl_convert_native ! (rome_rowan :: AstSeparatedListNodesIterator < rome_js_syntax :: JsLanguage , rome_js_syntax :: TsTypeParameter >);
