use rome_console::fmt::{Display, Formatter};
use rome_console::{markup, MarkupBuf};
use rome_diagnostics::adapters::{IoError, PicoArgsError};
use rome_diagnostics::{
    category, Advices, Category, Diagnostic, DiagnosticTags, Error, Location, LogCategory,
    MessageAndDescription, Resource, Severity, Visit,
};
use rome_service::WorkspaceError;
use rome_text_size::TextRange;
use std::{env::current_exe, fmt::Debug};

fn command_name() -> String {
    current_exe()
        .ok()
        .and_then(|path| Some(path.file_name()?.to_str()?.to_string()))
        .unwrap_or_else(|| String::from("rome"))
}

/// A diagnostic that is emitted when running rome via CLI.
///
/// When displaying the diagnostic,
#[derive(Debug)]
pub struct TerminationDiagnostic {
    /// Range where the error occurred, if applicable
    span: Option<TextRange>,
    /// A path to a file where the error occurred, if applicable. It defaults to [Resource::Memory]
    path: Resource<&'static str>,
    /// Message of the diagnostic
    message: MessageAndDescription,
    /// Optional advices
    advices: TerminationAdvice,
    /// Optional source
    source: Option<Error>,
    /// The category of the diagnostic
    category: &'static Category,
    /// Tags applied to the diagnostic
    tags: DiagnosticTags,
    /// Severity of the diagnostic
    severity: Severity,
    /// Whether the error was generated by [WorkspaceError]
    ///
    /// If set to [true], it delegates the implementation of all the diagnostics methods to the
    /// `source`, if it's present.
    is_workspace_error: bool,
}

/// Advices for the [TerminationDiagnostic]
#[derive(Debug, Default)]
struct TerminationAdvice {
    /// Additional messages to add the end of the diagnostic.
    /// The messages are printed as [LogCategory::Info]
    notes: Vec<MarkupBuf>,
}

impl Advices for TerminationAdvice {
    fn record(&self, visitor: &mut dyn Visit) -> std::io::Result<()> {
        for note in &self.notes {
            visitor.record_log(LogCategory::Info, note)?;
        }
        Ok(())
    }
}

impl TerminationDiagnostic {
    fn new(category: &'static Category, message: impl Display) -> Self {
        Self {
            category,
            span: None,
            path: Resource::Memory,
            message: MessageAndDescription::from(
                markup! {
                    {message}
                }
                .to_owned(),
            ),
            advices: TerminationAdvice::default(),
            source: None,
            tags: DiagnosticTags::FIXABLE,
            severity: Severity::Error,
            is_workspace_error: false,
        }
    }

    /// Returned when a subcommand is called with an unsupported combination of arguments
    pub fn incompatible_arguments(
        first_argument: impl Display,
        second_argument: impl Display,
    ) -> Self {
        Self::new(
            category!("internalError/io"),
            markup! {
                "Incompatible arguments "<Emphasis>{first_argument}</Emphasis>" and "<Emphasis>{second_argument}</Emphasis>
            },
        ).with_resource(Resource::Argv)
    }

    /// To throw when there's been an error while parsing an argument
    pub fn parse_error(argument: impl Into<String>, source: pico_args::Error) -> Self {
        let argument = argument.into();
        Self::new(
            category!("flags/invalid"),
            markup! {
                "Cannot parse the argument "<Emphasis>{argument}</Emphasis>
            },
        )
        .with_resource(Resource::Argv)
        .with_source(Error::from(PicoArgsError::from(source)))
    }

    /// Returned when it is called with a subcommand it doesn't know
    pub fn unknown_command(command: impl Display) -> Self {
        Self::new(
            category!("flags/invalid"),
            markup! {
                "Unknown command "<Emphasis>{command}</Emphasis>
            },
        )
        .with_resource(Resource::Argv)
    }

    /// Returned when a subcommand is called without any arguments
    pub fn empty_arguments() -> Self {
        Self::new(
            category!("flags/invalid"),
            markup! {
                "Empty arguments"
            },
        )
        .with_resource(Resource::Argv)
    }

    /// Returned when a required argument is not present in the command line
    pub fn missing_argument(argument: impl Display, subcommand: impl Display) -> Self {
        let command_name = command_name();
        Self::new(
            category!("flags/invalid"),
            markup! {
                "Missing argument "<Emphasis>{argument}</Emphasis>
            },
        )
        .with_resource(Resource::Argv)
        .with_note(markup! {
            "Type "<Italic>{command_name}" "{subcommand}" --help"</Italic>" for more information."
        })
    }

    /// When no files were processed while traversing the file system
    pub fn no_files_processed() -> Self {
        Self::new(
            category!("flags/invalid"),
            markup! {
                "No files were processed in the specified paths."
            },
        )
    }

    /// Returned when the CLI  doesn't recognize a command line argument
    pub fn unexpected_argument(argument: impl Display, subcommand: impl Display) -> Self {
        let command_name = command_name();
        Self::new(
            category!("flags/invalid"),
            markup! {
                "Unrecognized option "<Emphasis>{argument}</Emphasis>"."
            },
        )
        .with_resource(Resource::Argv)
        .with_note(markup! {
            "Type "<Italic>{command_name}" "{subcommand}" --help"</Italic>" for more information."
        })
    }

    /// When there's been error inside the workspace
    pub fn workspace_error(error: WorkspaceError) -> Self {
        let mut item = Self::new(
            category!("configuration"),
            markup! {
                "Workspace error."
            },
        )
        .with_source(Error::from(error));

        item.is_workspace_error = true;
        item
    }

    /// An I/O error
    pub fn io_error(error: std::io::Error) -> Self {
        Self::new(
            category!("flags/invalid"),
            markup! {
                "Errors occurred while executing I/O operations."
            },
        )
        .with_resource(Resource::Memory)
        .with_source(Error::from(IoError::from(error)))
    }

    /// Emitted when errors were emitted while traversing the file system
    pub fn check_error() -> Self {
        Self::new(
            category!("internalError/io"),
            markup! {
                "Some errors were emitted while running checks"
            },
        )
    }

    /// Emitted when the server is not running
    pub fn server_not_running() -> Self {
        let command_name = command_name();
        Self::new(
            category!("internalError/io"),
            markup! {
                "No running instance of the Rome daemon server was found."
            },
        )
        .with_resource(Resource::Memory)
        .with_note(markup! {
            "Run "<Italic>{command_name}" start"</Italic>" to start a server."
        })
    }

    /// Emitted when the end configuration (`rome.json` file + CLI arguments + LSP configuration)
    /// results in a combination of options that doesn't allow to run the command correctly.
    ///
    /// A reason needs to be provided
    pub fn incompatible_end_configuration(reason: impl Display) -> Self {
        Self::new(
            category!("flags/invalid"),
            markup! {
                "The combination of configuration and arguments is invalid: \n "{{reason}}
            },
        )
    }

    /// Emitted when an argument value is greater than the allowed value
    pub fn overflown_argument(argument: impl Into<String>, maximum: u16) -> Self {
        let argument = argument.into();
        Self::new(
            category!("flags/invalid"),
            markup! {
                 "The value of the argument "<Emphasis>{argument}</Emphasis>" is too high, maximum accepted "{{maximum}}
            }
        )
            .with_resource(Resource::Argv)
    }

    /// Return by the help command when it is called with a subcommand it doesn't know
    pub fn new_unknown_help(command: impl Display) -> Self {
        Self::new(
            category!("flags/invalid"),
            markup! {
                "Cannot print help for unknown command "<Emphasis>{command}</Emphasis>
            },
        )
        .with_resource(Resource::Argv)
    }

    fn with_resource(mut self, resource: Resource<&'static str>) -> Self {
        self.path = resource;
        self
    }

    fn with_note(mut self, message: impl Display) -> Self {
        self.advices.notes.push(markup! {{message}}.to_owned());
        self
    }

    fn with_source(mut self, error: Error) -> Self {
        self.source = Some(error);
        self
    }
}

impl Diagnostic for TerminationDiagnostic {
    fn category(&self) -> Option<&'static Category> {
        if self.is_workspace_error {
            if let Some(source) = self.source.as_ref() {
                return source.category();
            }
        }
        Some(self.category)
    }

    fn tags(&self) -> DiagnosticTags {
        if self.is_workspace_error {
            if let Some(source) = self.source.as_ref() {
                return source.tags();
            }
        }
        self.tags
    }

    fn severity(&self) -> Severity {
        if self.is_workspace_error {
            if let Some(source) = self.source.as_ref() {
                return source.severity();
            }
        }
        self.severity
    }

    fn location(&self) -> Location<'_> {
        if self.is_workspace_error {
            if let Some(source) = self.source.as_ref() {
                return source.location();
            }
        }
        Location::builder().span(&self.span).build()
    }

    fn message(&self, fmt: &mut Formatter<'_>) -> std::io::Result<()> {
        if self.is_workspace_error {
            if let Some(source) = self.source.as_ref() {
                return source.message(fmt);
            }
        }
        rome_console::fmt::Display::fmt(&self.message, fmt)
    }

    fn advices(&self, visitor: &mut dyn Visit) -> std::io::Result<()> {
        if self.is_workspace_error {
            if let Some(source) = self.source.as_ref() {
                return source.advices(visitor);
            }
        }
        self.advices.record(visitor)
    }

    fn source(&self) -> Option<&dyn Diagnostic> {
        if self.is_workspace_error {
            return self.source.as_ref().and_then(|error| error.source());
        }
        self.source.as_ref().map(|source| source.as_ref())
    }
}

impl From<WorkspaceError> for TerminationDiagnostic {
    fn from(error: WorkspaceError) -> Self {
        TerminationDiagnostic::workspace_error(error)
    }
}

impl From<std::io::Error> for TerminationDiagnostic {
    fn from(error: std::io::Error) -> Self {
        TerminationDiagnostic::io_error(error)
    }
}

#[cfg(test)]
mod test {
    use crate::TerminationDiagnostic;

    #[test]
    fn termination_diagnostic_size() {
        assert_eq!(
            std::mem::size_of::<TerminationDiagnostic>(),
            136,
            "you successfully decreased the size of the diagnostic!"
        )
    }
}
