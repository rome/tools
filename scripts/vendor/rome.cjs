#!/usr/bin/env node

(function(global) {
  'use strict';
  // project-rome/@romejs/cli-diagnostics/types.ts
const ___R$project$rome$$romejs$cli$diagnostics$types_ts = {};









  // project-rome/@romejs/ob1/index.ts
















	function ___R$project$rome$$romejs$ob1$index_ts$ob1Add(a, b) {
		// @ts-ignore
		return a + b;
	}








	function ___R$project$rome$$romejs$ob1$index_ts$ob1Sub(a, b) {
		// @ts-ignore
		return a - b;
	}



	function ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(x) {
		// @ts-ignore
		return x;
	}



	function ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(x) {
		// @ts-ignore
		return x;
	}




	function ___R$project$rome$$romejs$ob1$index_ts$ob1Get(x) {
		// @ts-ignore
		return x;
	}




	function ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(x) {
		return (x);
	}

	const ___R$project$rome$$romejs$ob1$index_ts$ob1Number0 = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
		0,
	);
	const ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1 = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
		-1,
	);




	function ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(x) {
		return (x);
	}

	const ___R$project$rome$$romejs$ob1$index_ts$ob1Number1 = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(
		1,
	);
	const ___R$project$rome$$romejs$ob1$index_ts$ob1Number1Neg1 = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(
		-1,
	);

	function ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0To1(x) {
		// @ts-ignore
		return (x + 1);
	}

	function ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1To0(x) {
		// @ts-ignore
		return (x - 1);
	}



	function ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(x) {
		// @ts-ignore
		return x + 1;
	}



	function ___R$project$rome$$romejs$ob1$index_ts$ob1Dec(x) {
		// @ts-ignore
		return x - 1;
	}


  // project-rome/@romejs/parser-core/types.ts
const ___R$project$rome$$romejs$parser$core$types_ts = {
		get UNKNOWN_POSITION() {
			return ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION;
		},
	};






























	const ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION = {
		index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1,
		line: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(-1),
		column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1,
	};


  // project-rome/@romejs/path/collections.ts
const ___R$project$rome$$romejs$path$collections_ts = {
		get AbsoluteFilePathMap() {
			return ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap;
		},
		get RelativeFilePathMap() {
			return ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathMap;
		},
		get UnknownFilePathMap() {
			return ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap;
		},
		get AbsoluteFilePathSet() {
			return ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet;
		},
		get RelativeFilePathSet() {
			return ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathSet;
		},
		get UnknownFilePathSet() {
			return ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathSet;
		},
	};
	// Sometimes we don't want to have to deal with what a FilePath serializes into
	// For those purposes we have these wrappers around Map and Set. Here we can add some custom logic
	// to speed up the usage of FilePaths in these scenarios.
	// The API here attempts to match what is expected from the native classes, however we may deviate from it
	// to avoid the usage of getters and generator/symbol indirection for iteration.
	class ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap {
		constructor(entries) {
			this.joinedToValue = new Map();
			this.joinedToPath = new Map();
			this.size = 0;

			if (entries !== undefined) {
				for (const [key, value] of entries) {
					this.set(key, value);
				}
			}
		}

		_updateSize() {
			this.size = this.joinedToValue.size;
		}

		*[Symbol.iterator]() {
			for (const [joined, value] of this.joinedToValue) {
				const path = this.joinedToPath.get(joined);
				yield [path, value];
			}
		}

		clear() {
			this.joinedToValue.clear();
			this.joinedToPath.clear();
			this._updateSize();
		}

		keys() {
			return this.joinedToPath.values();
		}

		values() {
			return this.joinedToValue.values();
		}

		delete(path) {
			const joined = path.getUnique().join();
			this.joinedToValue.delete(joined);
			this.joinedToPath.delete(joined);
			this._updateSize();
		}

		has(path) {
			return this.joinedToValue.has(path.getUnique().join());
		}

		get(path) {
			return this.joinedToValue.get(path.getUnique().join());
		}

		set(path, value) {
			const uniq = (path.getUnique());
			const joined = uniq.join();
			this.joinedToValue.set(joined, value);
			this.joinedToPath.set(joined, uniq);
			this._updateSize();
		}
	}

	class ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathSet {
		constructor(entries) {
			this.map = new ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap();
			this.size = 0;

			if (entries !== undefined) {
				for (const path of entries) {
					this.add(path);
				}
			}
		}

		_updateSize() {
			this.size = this.map.size;
		}

		[Symbol.iterator]() {
			return this.map.keys()[Symbol.iterator]();
		}

		has(path) {
			return this.map.has(path);
		}

		add(path) {
			this.map.set(path);
			this._updateSize();
		}

		delete(path) {
			this.map.delete(path);
			this._updateSize();
		}

		clear() {
			this.map.clear();
			this._updateSize();
		}
	}

	class ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap
		extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap {
		constructor(...args) {
			super(...args);
			this.type = "absolute";
		}
	}

	class ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathMap
		extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap {
		constructor(...args) {
			super(...args);
			this.type = "relative";
		}
	}

	class ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap
		extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathMap {
		constructor(...args) {
			super(...args);
			this.type = "unknown";
		}
	}

	class ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet
		extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathSet {
		constructor(...args) {
			super(...args);
			this.type = "absolute";
		}
	}

	class ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathSet
		extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathSet {
		constructor(...args) {
			super(...args);
			this.type = "relative";
		}
	}

	class ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathSet
		extends ___R$$priv$project$rome$$romejs$path$collections_ts$FilePathSet {
		constructor(...args) {
			super(...args);
			this.type = "unknown";
		}
	}


  // project-rome/@romejs/path/index.ts
const ___R$$priv$project$rome$$romejs$path$index_ts$os = require("os");




	function ___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(
		pathOrString,
	) {
		if (typeof pathOrString === "string") {
			return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
				pathOrString,
			);
		} else {
			return pathOrString;
		}
	}





	class ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath {
		constructor(parsed, opts) {
			if (parsed.segments.length === 0) {
				throw new Error("Cannot construct a FilePath with zero segments");
			}

			this.segments = parsed.segments;
			this.absoluteTarget = parsed.absoluteTarget;
			this.absoluteType = parsed.absoluteType;

			// Memoized
			this.memoizedUnique = undefined;
			this.memoizedParent = opts.parent;
			this.memoizedFilename = opts.filename;
			this.memoizedExtension = opts.ext;
			this.memoizedChildren = new Map();
		}

		getParsed() {
			return {
				segments: this.segments,
				absoluteTarget: this.absoluteTarget,
				absoluteType: this.absoluteType,
			};
		}

		// These methods ensure the correct return classes
		_assert() {
			throw new Error("Unimplemented");
		}

		_fork(parsed, opts) {
			throw new Error("Unimplemented");
		}

		addExtension(ext, clearExt = false) {
			const newBasename = clearExt
				? this.getExtensionlessBasename()
				: this.getBasename();
			const newExt = clearExt ? ext : this.memoizedExtension + ext;
			const segments = this.getParentSegments(false).concat(newBasename + ext);

			return this._fork(
				Object.assign({}, this.getParsed(), {segments}),
				{
					ext: newExt,
					parent: this.memoizedParent,
				},
			);
		}

		changeBasename(newBasename) {
			const segments = this.getParentSegments(false).concat(newBasename);
			return this._fork(
				Object.assign({}, this.getParsed(), {segments}),
				{
					parent: this.memoizedParent,
				},
			);
		}

		getBasename() {
			const {segments} = this;
			const offset = this.isExplicitFolder() ? 2 : 1;
			return segments[segments.length - offset] || "";
		}

		getExtensionlessBasename() {
			const basename = this.getBasename();
			const ext = this.getExtensions();

			if (ext === "") {
				return basename;
			} else {
				return basename.slice(0, -ext.length);
			}
		}

		getParent() {
			if (this.memoizedParent !== undefined) {
				return this.memoizedParent;
			}

			const parent = this._fork(
				Object.assign(
					{},
					this.getParsed(),
					{segments: this.getParentSegments()},
				),
				{},
			);
			this.memoizedParent = parent;
			return parent;
		}

		getParentSegments(explicit = true) {
			// Should we throw an error?
			if (this.isRoot()) {
				return this.segments;
			}

			const segments = this.getSegments().slice(0, -1);
			// Always make this an explicit folder
			if (explicit && segments.length > 0 && segments[0] !== "") {
				segments.push("");
			}
			return segments;
		}

		toExplicitRelative() {
			const relative = this.assertRelative();
			if (relative.isExplicitRelative()) {
				return relative;
			} else {
				return ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
					".",
				).append(relative);
			}
		}

		assertRelative() {
			if (this.isAbsolute()) {
				throw new Error("Expected relative file path but got: " + this.join());
			} else {
				return new ___R$project$rome$$romejs$path$index_ts$RelativeFilePath(
					this.getParsed(),
					{
						ext: this.memoizedExtension,
						filename: this.memoizedFilename,
					},
				);
			}
		}

		assertAbsolute() {
			if (this.isAbsolute()) {
				return new ___R$project$rome$$romejs$path$index_ts$AbsoluteFilePath(
					this.getParsed(),
					{
						ext: this.memoizedExtension,
						filename: this.memoizedFilename,
					},
				);
			} else {
				throw new Error("Expected absolute file path but got: " + this.join());
			}
		}

		assertURL() {
			if (this.isURL()) {
				return new ___R$project$rome$$romejs$path$index_ts$URLFilePath(
					this.getParsed(),
					{
						ext: this.memoizedExtension,
						filename: this.memoizedFilename,
					},
				);
			} else {
				throw new Error("Expected URL file path but got: " + this.join());
			}
		}

		isRoot() {
			if (this.segments.length === 1) {
				return true;
			}

			if (this.segments.length === 2) {
				// Explicit folder reference
				return this.segments[1] === "";
			}

			if (this.segments.length === 3) {
				return this.absoluteType === "windows-unc";
			}

			return false;
		}

		isWindows() {
			return (
				this.absoluteType === "windows-drive" ||
				this.absoluteType === "windows-unc"
			);
		}

		isPosix() {
			return !this.isWindows();
		}

		isURL() {
			return this.absoluteType === "url";
		}

		isAbsolute() {
			return this.absoluteTarget !== undefined && this.absoluteType !== "url";
		}

		isRelative() {
			return !this.isAbsolute();
		}

		isRelativeTo(otherRaw) {
			const other = ___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(
				otherRaw,
			);
			const otherSegments = other.getSegments();
			const ourSegments = this.getSegments();

			// We can't be relative to a path with more segments than us
			if (otherSegments.length > ourSegments.length) {
				return false;
			}

			// Check that we start with the same segments as the other
			for (let i = 0; i < otherSegments.length; i++) {
				if (otherSegments[i] !== ourSegments[i]) {
					return false;
				}
			}

			return true;
		}

		isImplicitRelative() {
			return !this.isExplicitRelative() && !this.isAbsolute() && !this.isURL();
		}

		isExplicitRelative() {
			const [firstSeg] = this.segments;
			return !this.isURL() && (firstSeg === "." || firstSeg === "..");
		}

		isExplicitFolder() {
			const {segments} = this;
			return segments[segments.length - 1] === "";
		}

		hasEndExtension(ext) {
			return this.getExtensions().endsWith("." + ext);
		}

		hasExtension(ext) {
			return (
				this.hasEndExtension(ext) ||
				this.getExtensions().includes("." + ext + ".")
			);
		}

		getExtensions() {
			if (this.memoizedExtension === undefined) {
				const ext = ___R$$priv$project$rome$$romejs$path$index_ts$getExtension(
					this.getBasename(),
				);
				this.memoizedExtension = ext;
				return ext;
			} else {
				return this.memoizedExtension;
			}
		}

		hasExtensions() {
			return this.getExtensions() !== "";
		}

		getSegments() {
			let {segments} = this;

			if (!this.isRoot()) {
				if (this.isExplicitFolder()) {
					segments = segments.slice(0, -1);
				}

				if (segments[0] === ".") {
					segments = segments.slice(1);
				}
			}

			return segments;
		}

		getRawSegments() {
			return this.segments;
		}

		getUnique() {
			if (this.memoizedUnique !== undefined) {
				return this.memoizedUnique;
			}

			let segments;

			if (!this.isRoot()) {
				if (this.isExplicitFolder()) {
					segments = this.getSegments();

					if (this.isExplicitRelative()) {
						segments = segments.slice(1);
					}
				} else if (this.isExplicitRelative()) {
					segments = this.getRawSegments().slice(1);
				}
			}

			if (segments === undefined) {
				return this._assert();
			} else {
				const path = this._fork(
					___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
						segments,
					),
					{},
				);
				this.memoizedUnique = path;
				return path;
			}
		}

		// Support some bad string coercion. Such as serialization in CLI flags.
		toString() {
			return this.join();
		}

		join() {
			if (this.memoizedFilename !== undefined) {
				return this.memoizedFilename;
			}

			const {segments} = this;

			let filename;
			if (this.isWindows()) {
				filename = segments.join("\\");
			} else {
				filename = segments.join("/");
			}
			this.memoizedFilename = filename;
			return filename;
		}

		// This does some weird optimizations to avoid materializing complete filenames

		// Might not be relevant... TODO benchmark this or something lol
		equal(other) {
			// Quick check if we've materalized the filename on both instances
			if (
				this.memoizedFilename !== undefined &&
				other.memoizedFilename !== undefined
			) {
				return this.memoizedFilename === other.memoizedFilename;
			}

			const a = this.getSegments();
			const b = other.getSegments();

			// Quick check
			if (a.length !== b.length) {
				return false;
			}

			for (let i = 0; i < a.length; i++) {
				if (a[i] !== b[i]) {
					return false;
				}
			}

			return true;
		}

		format(cwd) {
			const filename = this.join();
			const names = [];
			names.push(filename);

			// Get a path relative to HOME
			if (this.isRelativeTo(___R$project$rome$$romejs$path$index_ts$HOME_PATH)) {
				// Path starts with the home directory, so let's trim it off
				const relativeToHome = ___R$project$rome$$romejs$path$index_ts$HOME_PATH.relative(
					this._assert(),
				);

				// Add tilde and push it as a possible name

				// We construct this manually to get around the segment normalization which would explode ~
				names.push(
					new ___R$project$rome$$romejs$path$index_ts$RelativeFilePath(
						{
							segments: ["~", ...relativeToHome.getSegments()],
							absoluteType: "posix",
							absoluteTarget: undefined,
						},
						{},
					).join(),
				);
			}

			// Get a path relative to the cwd
			if (cwd !== undefined) {
				names.push(cwd.relative(filename).join());
			}

			// Get the shortest name
			const human = names.sort((a, b) => a.length - b.length)[0];
			if (human === "") {
				return "./";
			} else {
				return human;
			}
		}

		append(raw) {
			// Check if we have a memoized instance
			if (typeof raw === "string") {
				const cached = this.memoizedChildren.get(raw);
				if (cached !== undefined) {
					return cached;
				}
			}

			const items = Array.isArray(raw) ? raw : [raw];

			if (items.length === 0) {
				return this._assert();
			}

			let segments = this.getSegments();

			for (const item of items) {
				segments = segments.concat(
					___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(item).getSegments(),
				);
			}

			const parsed = ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
				segments,
			);
			const child = this._fork(parsed, {});

			// Set memoized child if possible
			if (typeof raw === "string") {
				this.memoizedChildren.set(raw, child);
			}

			return child;
		}
	}

	class ___R$project$rome$$romejs$path$index_ts$RelativeFilePath
		extends ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath {
		constructor(...args) {
			super(...args);
			this.type = "relative";
		}
		_assert() {
			return this;
		}

		_fork(parsed, opts) {
			return new ___R$project$rome$$romejs$path$index_ts$RelativeFilePath(
				parsed,
				opts,
			);
		}

		assertRelative() {
			return this;
		}
	}

	class ___R$project$rome$$romejs$path$index_ts$AbsoluteFilePath
		extends ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath {
		constructor(...args) {
			super(...args);
			this.type = "absolute";
		}
		_assert() {
			return this;
		}

		_fork(parsed, opts) {
			return new ___R$project$rome$$romejs$path$index_ts$AbsoluteFilePath(
				parsed,
				opts,
			);
		}

		assertAbsolute() {
			return this;
		}

		getChain() {
			if (this.chain !== undefined) {
				return this.chain;
			}

			const paths = [];
			this.chain = paths;

			// We use getParent here so we can reuse as much memoized information as possible
			let target = this;
			while (true) {
				paths.push(target);
				if (target.isRoot()) {
					break;
				} else {
					target = target.getParent();
				}
			}

			return paths;
		}

		resolveMaybeUrl(otherRaw) {
			const other = ___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(
				otherRaw,
			);
			if (other.isURL()) {
				return other.assertURL();
			} else {
				return this.resolve(other);
			}
		}

		resolve(otherRaw) {
			const other = ___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(
				otherRaw,
			);
			if (other.isAbsolute()) {
				return other.assertAbsolute();
			}

			return new ___R$project$rome$$romejs$path$index_ts$AbsoluteFilePath(
				___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments([
					...this.getSegments(),
					...other.getSegments(),
				]),
				{},
			);
		}

		relative(otherRaw) {
			const other = this.resolve(
				___R$$priv$project$rome$$romejs$path$index_ts$toFilePath(otherRaw),
			);

			if (other.equal(this)) {
				return ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
					".",
				);
			}

			const absolute = this.getSegments().slice();
			const relative = other.getSegments().slice();

			// Impossible to relativize two absolute paths with different roots
			if (absolute[0] !== relative[0]) {
				return other;
			}

			// Remove common starting segments
			while (absolute[0] === relative[0]) {
				absolute.shift();
				relative.shift();
			}

			let finalSegments = [];
			for (let i = 0; i < absolute.length; i++) {
				finalSegments.push("..");
			}
			finalSegments = finalSegments.concat(relative);

			return ___R$$priv$project$rome$$romejs$path$index_ts$createUnknownFilePathFromSegments(
				___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
					finalSegments,
				),
			);
		}
	}

	class ___R$project$rome$$romejs$path$index_ts$URLFilePath
		extends ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath {
		constructor(...args) {
			super(...args);
			this.type = "url";
		}
		_assert() {
			return this;
		}

		_fork(parsed, opts) {
			return new ___R$project$rome$$romejs$path$index_ts$URLFilePath(
				parsed,
				opts,
			);
		}

		assertURL() {
			return this;
		}

		isURL() {
			return true;
		}

		getDomain() {
			return this.segments[2];
		}

		getProtocol() {
			const {absoluteTarget} = this;
			if (absoluteTarget === undefined) {
				throw new Error(
					"Expected a URLFilePath to always have an absoluteTarget",
				);
			}
			return absoluteTarget;
		}

		resolve(path) {
			if (path.isURL()) {
				return path.assertURL();
			} else if (path.isAbsolute()) {
				// Get the segments that include the protocol and domain
				const domainSegments = this.getSegments().slice(0, 3);
				const finalSegments = [...domainSegments, ...path.getSegments()];
				return new ___R$project$rome$$romejs$path$index_ts$URLFilePath(
					___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
						finalSegments,
					),
					{},
				);
			} else {
				return this.append(path);
			}
		}
	}

	const ___R$project$rome$$romejs$path$index_ts$HOME_PATH = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
		___R$$priv$project$rome$$romejs$path$index_ts$os.userInfo().homedir,
	);
	const ___R$project$rome$$romejs$path$index_ts$TEMP_PATH = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
		___R$$priv$project$rome$$romejs$path$index_ts$os.tmpdir(),
	);
	const ___R$project$rome$$romejs$path$index_ts$CWD_PATH = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
		process.cwd(),
	);

	function ___R$$priv$project$rome$$romejs$path$index_ts$getExtension(basename) {
		const match = basename.match(/\.(.*?)$/);
		if (match == null) {
			return "";
		} else {
			return match[0];
		}
	}

	function ___R$$priv$project$rome$$romejs$path$index_ts$isWindowsDrive(first) {
		return first.length === 2 && first[1] === ":" && /[A-Z]/i.test(first[0]);
	}





	function ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
		segments,
	) {
		if (segments.length === 0) {
			throw new Error("Cannot construct a FilePath with zero segments");
		}

		let absoluteType = "posix";
		let absoluteTarget;
		let firstSeg = segments[0];

		// Detect URL
		if (
			!___R$$priv$project$rome$$romejs$path$index_ts$isWindowsDrive(firstSeg) &&
			firstSeg[firstSeg.length - 1] === ":" &&
			segments[1] === ""
		) {
			absoluteTarget = firstSeg.slice(0, -1);

			switch (absoluteTarget) {
				case "file":
					// Automatically normalize a file scheme into an absolute path
					return ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
						segments.slice(2).map((segment) => decodeURIComponent(segment)),
					);

				default: {
					const absoluteSegments = segments.slice(0, 3);
					return {
						segments: ___R$$priv$project$rome$$romejs$path$index_ts$normalizeSegments(
							segments,
							absoluteSegments.length,
							absoluteSegments,
						),
						absoluteType: "url",
						absoluteTarget,
					};
				}
			}
		}

		// Explode home directory
		if (firstSeg === "~") {
			segments = [
				...___R$project$rome$$romejs$path$index_ts$HOME_PATH.getSegments(),
			];
			firstSeg = segments[0];
		}

		let segmentOffset = 0;

		// We first extract the "absolute" portion of a path, this includes any Windows drive letters, UNC hostnames etc
		const absoluteSegments = [];
		if (firstSeg === "") {
			// POSIX path
			absoluteSegments.push("");
			absoluteTarget = "posix";
			segmentOffset++;

			// Windows UNC
			if (segments[1] === "" && segments.length >= 3 && segments[2] !== "") {
				const name = segments[2];
				segmentOffset += 2;
				absoluteSegments.push("");
				absoluteSegments.push(name);
				absoluteType = "windows-unc";
				absoluteTarget = "unc:" + name;
			}
		} else if (
			___R$$priv$project$rome$$romejs$path$index_ts$isWindowsDrive(firstSeg)
		) {
			const drive = firstSeg.toUpperCase();
			absoluteSegments.push(drive);
			absoluteType = "windows-drive";
			absoluteTarget = "drive:" + drive;
			segmentOffset++;
		}

		const pathSegments = ___R$$priv$project$rome$$romejs$path$index_ts$normalizeSegments(
			segments,
			segmentOffset,
			absoluteSegments,
		);
		return {
			segments: pathSegments,
			absoluteType,
			absoluteTarget,
		};
	}

	function ___R$$priv$project$rome$$romejs$path$index_ts$normalizeSegments(
		segments,
		offset,
		absoluteSegments,
	) {
		const relativeSegments = [];
		for (let i = offset; i < segments.length; i++) {
			let seg = segments[i];

			// Only allow a dot part in the first position, otherwise it's a noop
			if (
				seg === "." &&
				(segments[1] === ".." || i > 0 || absoluteSegments.length > 0)
			) {
				continue;
			}

			// Ignore empty segments
			if (seg === "") {
				continue;
			}

			// Remove the previous segment, as long as it's not also ..
			if (
				seg === ".." &&
				relativeSegments.length > 0 &&
				relativeSegments[relativeSegments.length - 1] !== ".."
			) {
				relativeSegments.pop();
				continue;
			}

			relativeSegments.push(seg);
		}

		const finalSegments = [...absoluteSegments, ...relativeSegments];

		// Retain explicit folder
		if (
			segments[segments.length - 1] === "" &&
			finalSegments[finalSegments.length - 1] !== "" &&
			relativeSegments.length !== 0
		) {
			finalSegments.push("");
		}

		return finalSegments;
	}

	function ___R$$priv$project$rome$$romejs$path$index_ts$createUnknownFilePathFromSegments(
		parsed,
	) {
		const path = new ___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath(
			parsed,
			{},
		);

		if (path.isAbsolute()) {
			return path.assertAbsolute();
		} else {
			return path.assertRelative();
		}
	}



	function ___R$project$rome$$romejs$path$index_ts$createFilePathFromSegments(
		segments,
	) {
		const parsed = ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
			segments,
		);
		return ___R$$priv$project$rome$$romejs$path$index_ts$createUnknownFilePathFromSegments(
			parsed,
		);
	}

	function ___R$project$rome$$romejs$path$index_ts$toJoinedFilePath(filename) {
		if (typeof filename === "string") {
			return filename;
		} else {
			return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
				filename,
			).join();
		}
	}

	function ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
		filename,
	) {
		return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
			filename,
		).assertRelative();
	}

	function ___R$project$rome$$romejs$path$index_ts$createURLFilePath(filename) {
		return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
			filename,
		).assertURL();
	}

	function ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
		filename,
	) {
		return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
			filename,
		).assertAbsolute();
	}

	function ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
		filename,
	) {
		// Allows using the create methods above to be used in places where strings are more ergonomic (eg. in third-party code)
		if (
			filename instanceof
			___R$$priv$project$rome$$romejs$path$index_ts$BaseFilePath
		) {
			return filename;
		}

		// Might be better to do a manual loop to detect escaped slashes or some other weirdness
		const segments = filename.split(/[\\\/]/g);
		const parsed = ___R$$priv$project$rome$$romejs$path$index_ts$parsePathSegments(
			segments,
		);
		return ___R$$priv$project$rome$$romejs$path$index_ts$createUnknownFilePathFromSegments(
			parsed,
		);
	}

	function ___R$project$rome$$romejs$path$index_ts$maybeCreateURLFilePath(
		filename,
	) {
		if (filename !== undefined) {
			return ___R$project$rome$$romejs$path$index_ts$createURLFilePath(filename);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$path$index_ts$maybeCreateRelativeFilePath(
		filename,
	) {
		if (filename !== undefined) {
			return ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
				filename,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$path$index_ts$maybeCreateAbsoluteFilePath(
		filename,
	) {
		if (filename !== undefined) {
			return ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
				filename,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$path$index_ts$maybeCreateUnknownFilePath(
		filename,
	) {
		if (filename !== undefined) {
			return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
				filename,
			);
		} else {
			return undefined;
		}
	}


  // project-rome/@romejs/string-utils/dedent.ts
function ___R$project$rome$$romejs$string$utils$dedent_ts$dedent(
		literals,
		...values
	) {
		var ___R$;
		let string = "";

		if (typeof literals === "string") {
			string = literals;
		} else {
			const parts = [];

			// Perform the interpolation
			for (let i = 0; i < literals.raw.length; i++) {
				parts.push(literals.raw[i]);
				if (i < values.length) {
					parts.push(values[i]);
				}
			}

			string = parts.join("");
		}

		// Find min indentation
		const match = string.match(/^[ \t]*(?=\S)/gm);
		if (match === null) {
			return string;
		}

		const indent =
			(___R$ = Math, ___R$.min.apply(___R$, [...match.map((x) => x.length)]));

		// Remove indentation
		return string.replace(new RegExp("^[ \\t]{" + indent + "}", "gm"), "").trim();
	}


  // project-rome/@romejs/string-utils/isEscaped.ts
function ___R$project$rome$$romejs$string$utils$isEscaped_ts$isEscaped(
		index,
		input,
	) {
		const prevChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) -
		1];

		if (prevChar === "\\") {
			return !___R$project$rome$$romejs$string$utils$isEscaped_ts$isEscaped(
				___R$project$rome$$romejs$ob1$index_ts$ob1Dec(index),
				input,
			);
		} else {
			return false;
		}
	}


  // project-rome/@romejs/string-utils/escapeSplit.ts
function ___R$project$rome$$romejs$string$utils$escapeSplit_ts$escapeSplit(
		input,
		splitChar,
	) {
		const parts = [];
		const unescapeRegex = new RegExp("\\\\" + splitChar, "g");

		let buff = "";

		function push() {
			buff = buff.replace(unescapeRegex, splitChar);
			parts.push(buff);
			buff = "";
		}

		for (let i = 0; i < input.length; i++) {
			let char = input[i];

			if (
				!___R$project$rome$$romejs$string$utils$isEscaped_ts$isEscaped(
					___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(i),
					input,
				) &&
				char === splitChar
			) {
				push();
			} else {
				buff += char;
			}
		}

		push();

		return parts;
	}


  // project-rome/@romejs/string-utils/orderBySimilarity.ts
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

	function ___R$$priv$project$rome$$romejs$string$utils$orderBySimilarity_ts$getMap(
		map,
		key,
		defaultValue,
	) {
		const existing = map.get(key);

		if (existing === undefined) {
			if (defaultValue === undefined) {
				throw new Error("Key didn't exist and no defaultValue passed");
			}

			map.set(key, defaultValue);
			return defaultValue;
		} else {
			return existing;
		}
	}

	/**
 * Forked from the project https://github.com/aceakash/string-similarity by Akash K, licensed under ISC
 */
	function ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings(
		aStr,
		bStr,
	) {
		const a = aStr.replace(/\s+/g, "");
		const b = bStr.replace(/\s+/g, "");

		// If both are empty strings
		if (!a.length && !b.length) {
			return 1;
		}

		// If only one is empty string
		if (!a.length || !b.length) {
			return 0;
		}

		// Identical
		if (a === b) {
			return 1;
		}

		// Both are 1-letter strings
		if (a.length === 1 && b.length === 1) {
			return 0;
		}

		// If either is a 1-letter string
		if (a.length < 2 || b.length < 2) {
			return 0;
		}

		let firstBigrams = new Map();
		for (let i = 0; i < a.length - 1; i++) {
			const bigram = a.substring(i, i + 2);

			const count = firstBigrams.has(bigram)
				? ___R$$priv$project$rome$$romejs$string$utils$orderBySimilarity_ts$getMap(
						firstBigrams,
						bigram,
					) + 1
				: 1;
			if (count === undefined) {
				throw new Error("Already used has() above");
			}

			firstBigrams.set(bigram, count);
		}

		let intersectionSize = 0;
		for (let i = 0; i < b.length - 1; i++) {
			const bigram = b.substring(i, i + 2);

			const count = ___R$$priv$project$rome$$romejs$string$utils$orderBySimilarity_ts$getMap(
				firstBigrams,
				bigram,
				0,
			);
			if (count === undefined) {
				throw new Error("Already used has() above");
			}

			if (count > 0) {
				firstBigrams.set(bigram, count - 1);
				intersectionSize++;
			}
		}

		return 2 * intersectionSize / (a.length + b.length - 2);
	}







	function ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
		compareStr,
		targets,
		{minRating, formatItem, ignoreCase = false} = {},
	) {
		if (targets.length === 0) {
			return [];
		}

		// Calculate the rating for each target string
		const ratings = Array.from(
			targets,
			(target) => {
				let compareTarget = target;
				if (formatItem !== undefined) {
					compareTarget = formatItem(target);
				}

				if (ignoreCase) {
					return {
						target,
						rating: ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings(
							compareStr.toLowerCase(),
							compareTarget.toLowerCase(),
						),
					};
				}

				return {
					target,
					rating: ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$compareTwoStrings(
						compareStr,
						compareTarget,
					),
				};
			},
		);

		// Sort ratings, with the highest at the beginning
		const sortedRatings = ratings.sort((a, b) => {
			return b.rating - a.rating;
		}).filter((item) => minRating === undefined || item.rating >= minRating);

		return sortedRatings;
	}


  // project-rome/@romejs/string-utils/findClosestStringMatch.ts
function ___R$project$rome$$romejs$string$utils$findClosestStringMatch_ts$findClosestStringMatch(
		name,
		matches,
		minRating = 0.8,
	) {
		if (matches.length === 0) {
			return undefined;
		}

		if (matches.length === 1) {
			return matches[0];
		}

		const ratings = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
			name,
			matches,
		);
		const bestMatch = ratings[0];

		if (bestMatch.rating >= minRating) {
			return bestMatch.target;
		} else {
			return undefined;
		}
	}


  // project-rome/@romejs/string-utils/humanizeNumber.ts
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

	const ___R$$priv$project$rome$$romejs$string$utils$humanizeNumber_ts$SCIENTIFIC_NOTATION = /e/i;

	function ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
		num,
		sep = "_",
	) {
		let str = String(num);

		if (num < 1_000) {
			return str;
		}

		if (
			___R$$priv$project$rome$$romejs$string$utils$humanizeNumber_ts$SCIENTIFIC_NOTATION.test(
				str,
			)
		) {
			return str;
		}

		const decimals = str.split(".");

		let intChars = String(decimals.shift()).split("");
		let intParts = [];

		while (intChars.length > 0) {
			const part = intChars.slice(-3).join("");
			intParts.unshift(part);

			intChars = intChars.slice(0, -3);
		}

		return [intParts.join(sep), ...decimals].join(".");
	}


  // project-rome/@romejs/string-utils/humanizeFileSize.ts
const ___R$$priv$project$rome$$romejs$string$utils$humanizeFileSize_ts$UNITS = [
		"B",
		"kB",
		"MB",
		"GB",
		"TB",
		"PB",
		"EB",
		"ZB",
		"YB",
	];

	function ___R$project$rome$$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize(
		bytes,
	) {
		const exponent = Math.min(
			Math.floor(Math.log10(bytes) / 3),
			___R$$priv$project$rome$$romejs$string$utils$humanizeFileSize_ts$UNITS.length -
			1,
		);
		const specific = Number((bytes / Math.pow(1_000, exponent)).toPrecision(3));
		const unit = ___R$$priv$project$rome$$romejs$string$utils$humanizeFileSize_ts$UNITS[exponent];
		return (
			___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
				specific,
			) + unit
		);
	}


  // project-rome/@romejs/string-utils/humanizeTime.ts
function ___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(
		ms,
		allowMilliseconds = false,
	) {
		const s = Math.floor(ms / 1_000);
		const m = Math.floor(s / 60);
		const h = Math.floor(m / 60);

		if (h === 0 && m === 0 && s === 0) {
			if (allowMilliseconds) {
				return ms + "ms";
			} else {
				return (ms / 1_000).toFixed(2) + "s";
			}
		}

		let buf = "";
		if (h > 0) {
			buf += String(h) + "h";
		}
		if (m > 0) {
			buf += String(m % 60) + "m";
		}
		buf += String(s % 60) + "s";
		return buf;
	}


  // project-rome/@romejs/string-charcodes/index.ts
const ___R$project$rome$$romejs$string$charcodes$index_ts = {
		get backSpace() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$backSpace;
		},
		get tab() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$tab;
		},
		get lineFeed() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lineFeed;
		},
		get carriageReturn() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$carriageReturn;
		},
		get shiftOut() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$shiftOut;
		},
		get space() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$space;
		},
		get exclamationMark() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$exclamationMark;
		},
		get quotationMark() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$quotationMark;
		},
		get numberSign() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$numberSign;
		},
		get dollarSign() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$dollarSign;
		},
		get percentSign() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$percentSign;
		},
		get ampersand() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$ampersand;
		},
		get apostrophe() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$apostrophe;
		},
		get leftParenthesis() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$leftParenthesis;
		},
		get rightParenthesis() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$rightParenthesis;
		},
		get asterisk() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$asterisk;
		},
		get plusSign() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$plusSign;
		},
		get comma() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$comma;
		},
		get dash() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$dash;
		},
		get dot() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$dot;
		},
		get slash() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$slash;
		},
		get digit0() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit0;
		},
		get digit1() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit1;
		},
		get digit2() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit2;
		},
		get digit3() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit3;
		},
		get digit4() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit4;
		},
		get digit5() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit5;
		},
		get digit6() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit6;
		},
		get digit7() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit7;
		},
		get digit8() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit8;
		},
		get digit9() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$digit9;
		},
		get colon() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$colon;
		},
		get semicolon() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$semicolon;
		},
		get lessThan() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lessThan;
		},
		get equalsTo() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$equalsTo;
		},
		get greaterThan() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$greaterThan;
		},
		get questionMark() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$questionMark;
		},
		get atSign() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$atSign;
		},
		get uppercaseA() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseA;
		},
		get uppercaseB() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseB;
		},
		get uppercaseC() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseC;
		},
		get uppercaseD() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseD;
		},
		get uppercaseE() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseE;
		},
		get uppercaseF() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseF;
		},
		get uppercaseG() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseG;
		},
		get uppercaseH() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseH;
		},
		get uppercaseI() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseI;
		},
		get uppercaseJ() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseJ;
		},
		get uppercaseK() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseK;
		},
		get uppercaseL() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseL;
		},
		get uppercaseM() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseM;
		},
		get uppercaseN() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseN;
		},
		get uppercaseO() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseO;
		},
		get uppercaseP() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseP;
		},
		get uppercaseQ() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseQ;
		},
		get uppercaseR() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseR;
		},
		get uppercaseS() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseS;
		},
		get uppercaseT() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseT;
		},
		get uppercaseU() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseU;
		},
		get uppercaseV() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseV;
		},
		get uppercaseW() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseW;
		},
		get uppercaseX() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseX;
		},
		get uppercaseY() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseY;
		},
		get uppercaseZ() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseZ;
		},
		get leftSquareBracket() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$leftSquareBracket;
		},
		get backslash() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$backslash;
		},
		get rightSquareBracket() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$rightSquareBracket;
		},
		get caret() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$caret;
		},
		get underscore() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$underscore;
		},
		get graveAccent() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$graveAccent;
		},
		get lowercaseA() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseA;
		},
		get lowercaseB() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseB;
		},
		get lowercaseC() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseC;
		},
		get lowercaseD() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseD;
		},
		get lowercaseE() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseE;
		},
		get lowercaseF() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseF;
		},
		get lowercaseG() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseG;
		},
		get lowercaseH() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseH;
		},
		get lowercaseI() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseI;
		},
		get lowercaseJ() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseJ;
		},
		get lowercaseK() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseK;
		},
		get lowercaseL() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseL;
		},
		get lowercaseM() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseM;
		},
		get lowercaseN() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseN;
		},
		get lowercaseO() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseO;
		},
		get lowercaseP() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseP;
		},
		get lowercaseQ() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseQ;
		},
		get lowercaseR() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseR;
		},
		get lowercaseS() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseS;
		},
		get lowercaseT() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseT;
		},
		get lowercaseU() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseU;
		},
		get lowercaseV() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseV;
		},
		get lowercaseW() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseW;
		},
		get lowercaseX() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseX;
		},
		get lowercaseY() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseY;
		},
		get lowercaseZ() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseZ;
		},
		get leftCurlyBrace() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$leftCurlyBrace;
		},
		get verticalBar() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$verticalBar;
		},
		get rightCurlyBrace() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$rightCurlyBrace;
		},
		get tilde() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$tilde;
		},
		get nonBreakingSpace() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$nonBreakingSpace;
		},
		get oghamSpaceMark() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$oghamSpaceMark;
		},
		get lineSeparator() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$lineSeparator;
		},
		get paragraphSeparator() {
			return ___R$project$rome$$romejs$string$charcodes$index_ts$paragraphSeparator;
		},
		isDigit: ___R$project$rome$$romejs$string$charcodes$index_ts$isDigit,
	};
	const ___R$project$rome$$romejs$string$charcodes$index_ts$backSpace = 8;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$tab = 9;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lineFeed = 10;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$carriageReturn = 13;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$shiftOut = 14;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$space = 32;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$exclamationMark = 33;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$quotationMark = 34;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$numberSign = 35;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$dollarSign = 36;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$percentSign = 37;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$ampersand = 38;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$apostrophe = 39;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$leftParenthesis = 40;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$rightParenthesis = 41;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$asterisk = 42;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$plusSign = 43;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$comma = 44;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$dash = 45;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$dot = 46;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$slash = 47;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit0 = 48;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit1 = 49;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit2 = 50;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit3 = 51;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit4 = 52;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit5 = 53;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit6 = 54;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit7 = 55;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit8 = 56;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$digit9 = 57;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$colon = 58;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$semicolon = 59;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lessThan = 60;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$equalsTo = 61;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$greaterThan = 62;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$questionMark = 63;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$atSign = 64;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseA = 65;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseB = 66;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseC = 67;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseD = 68;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseE = 69;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseF = 70;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseG = 71;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseH = 72;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseI = 73;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseJ = 74;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseK = 75;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseL = 76;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseM = 77;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseN = 78;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseO = 79;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseP = 80;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseQ = 81;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseR = 82;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseS = 83;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseT = 84;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseU = 85;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseV = 86;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseW = 87;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseX = 88;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseY = 89;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$uppercaseZ = 90;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$leftSquareBracket = 91;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$backslash = 92;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$rightSquareBracket = 93;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$caret = 94;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$underscore = 95;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$graveAccent = 96;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseA = 97;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseB = 98;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseC = 99;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseD = 100;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseE = 101;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseF = 102;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseG = 103;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseH = 104;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseI = 105;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseJ = 106;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseK = 107;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseL = 108;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseM = 109;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseN = 110;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseO = 111;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseP = 112;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseQ = 113;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseR = 114;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseS = 115;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseT = 116;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseU = 117;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseV = 118;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseW = 119;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseX = 120;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseY = 121;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lowercaseZ = 122;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$leftCurlyBrace = 123;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$verticalBar = 124;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$rightCurlyBrace = 125;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$tilde = 126;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$nonBreakingSpace = 160;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$oghamSpaceMark = 5_760;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$lineSeparator = 8_232;
	const ___R$project$rome$$romejs$string$charcodes$index_ts$paragraphSeparator = 8_233;

	function ___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(code) {
		return (
			code >= ___R$project$rome$$romejs$string$charcodes$index_ts$digit0 &&
			code <= ___R$project$rome$$romejs$string$charcodes$index_ts$digit9
		);
	}


  // project-rome/@romejs/string-utils/naturalCompare.ts
function ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
		a,
		b,
		insensitive = true,
	) {
		if (insensitive) {
			a = a.toLowerCase();
			b = b.toLowerCase();
		}

		const lengthA = a.length;
		const lengthB = b.length;

		let aIndex = 0;
		let bIndex = 0;

		while (aIndex < lengthA && bIndex < lengthB) {
			let charCodeA = a.charCodeAt(aIndex);
			let charCodeB = b.charCodeAt(bIndex);

			if (___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(charCodeA)) {
				if (
					!___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(
						charCodeB,
					)
				) {
					return charCodeA - charCodeB;
				}

				let numStartA = aIndex;
				let numStartB = bIndex;

				while (charCodeA === 48 && ++numStartA < lengthA) {
					charCodeA = a.charCodeAt(numStartA);
				}
				while (charCodeB === 48 && ++numStartB < lengthB) {
					charCodeB = b.charCodeAt(numStartB);
				}

				let numEndA = numStartA;
				let numEndB = numStartB;

				while (
					numEndA < lengthA &&
					___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(
						a.charCodeAt(numEndA),
					)
				) {
					++numEndA;
				}
				while (
					numEndB < lengthB &&
					___R$project$rome$$romejs$string$charcodes$index_ts$isDigit(
						b.charCodeAt(numEndB),
					)
				) {
					++numEndB;
				}

				let difference = numEndA - numStartA - numEndB + numStartB; // numA length - numB length
				if (difference) {
					return difference;
				}

				while (numStartA < numEndA) {
					difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);
					if (difference) {
						return difference;
					}
				}

				aIndex = numEndA;
				bIndex = numEndB;
				continue;
			}

			if (charCodeA !== charCodeB) {
				return charCodeA - charCodeB;
			}

			++aIndex;
			++bIndex;
		}

		return lengthA - lengthB;
	}


  // project-rome/@romejs/string-utils/orderByNatural.ts
function ___R$project$rome$$romejs$string$utils$orderByNatural_ts$orderByNatural(
		strs,
		insensitive = true,
	) {
		return strs.sort((a, b) =>
			___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
				a,
				b,
				insensitive,
			)
		);
	}


  // project-rome/@romejs/string-utils/preserveCasing.ts
function ___R$project$rome$$romejs$string$utils$preserveCasing_ts$preserveCasing(
		a,
		b,
	) {
		if (a === a.toUpperCase()) {
			// If a is upper case then make b uppercase
			return b.toUpperCase();
		} else if (a[0] === a[0].toUpperCase()) {
			// First letter is capitalized
			return b[0].toUpperCase() + b.slice(1);
		} else {
			return b;
		}
	}


  // project-rome/@romejs/string-utils/removeCarriageReturn.ts
function ___R$project$rome$$romejs$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
		str,
	) {
		return str.replace(/\r/g, "");
	}


  // project-rome/@romejs/string-utils/removePrefix.ts
function ___R$project$rome$$romejs$string$utils$removePrefix_ts$removePrefix(
		value,
		prefix,
	) {
		if (value.startsWith(prefix)) {
			return value.slice(prefix.length);
		} else {
			return value;
		}
	}


  // project-rome/@romejs/string-utils/removeSuffix.ts
function ___R$project$rome$$romejs$string$utils$removeSuffix_ts$removeSuffix(
		value,
		suffix,
	) {
		if (value.endsWith(suffix)) {
			return value.slice(0, -suffix.length);
		} else {
			return value;
		}
	}


  // project-rome/@romejs/string-utils/toCamelCase.ts
function ___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(
		str,
		forceCapitalize,
	) {
		// Rest of the code expects at least 1 character
		if (str.length === 0) {
			return str;
		}

		// Prepend uppercase letters with a space
		str = str.replace(/([A-Z+])/g, " $1");

		// We no longer care about the casing
		str = str.toLowerCase();

		// Capitalize all characters after a symbol or space
		str = str.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase());

		// Capitalize characters after a number
		str = str.replace(/\d+(\w|$)/g, (m) => m.toUpperCase());

		// Force capitalize if necessary
		if (forceCapitalize) {
			str = str[0].toUpperCase() + str.slice(1);
		}

		return str;
	}


  // project-rome/@romejs/string-utils/toKebabCase.ts
function ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(str) {
		return str.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
	}


  // project-rome/@romejs/string-utils/index.ts



  // project-rome/@romejs/parser-core/index.ts








	function ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
		parserOpts,
		opts,
	) {
		const {value} = ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnosticsSync(() => {
			return opts.parse(parserOpts);
		});

		if (value === undefined) {
			// Diagnostics must be present
			opts.parse(
				Object.assign(
					{},
					parserOpts,
					{offsetPosition: opts.getOffsetPosition()},
				),
			);
			throw new Error("Expected error");
		} else {
			return value;
		}
	}

	const ___R$$priv$project$rome$$romejs$parser$core$index_ts$SOF_TOKEN = {
		type: "SOF",
		start: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
		end: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
	};



	function ___R$$priv$project$rome$$romejs$parser$core$index_ts$normalizeInput(
		opts,
	) {
		const {input} = opts;

		if (input === undefined) {
			return "";
		} else if (opts.retainCarriageReturn) {
			return input;
		} else {
			return ___R$project$rome$$romejs$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
				input,
			);
		}
	}

	class ___R$project$rome$$romejs$parser$core$index_ts$ParserCore {
		constructor(opts, diagnosticCategory, initialState) {
			const {path, mtime, offsetPosition} = opts;

			// Input information
			this.path =
				path === undefined
					? undefined
					: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(path);
			this.filename = this.path === undefined ? undefined : this.path.join();
			this.mtime = mtime;
			this.input = ___R$$priv$project$rome$$romejs$parser$core$index_ts$normalizeInput(
				opts,
			);
			this.length = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
				this.input.length,
			);

			this.eofToken = {
				type: "EOF",
				start: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
					this.input.length,
				),
				end: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
					this.input.length,
				),
			};

			// Parser/tokenizer state
			this.offsetPosition = offsetPosition;
			this.diagnosticCategory = diagnosticCategory;
			this.tokenizing = false;
			this.currLine =
				offsetPosition === undefined
					? ___R$project$rome$$romejs$ob1$index_ts$ob1Number1
					: offsetPosition.line;
			this.currColumn =
				offsetPosition === undefined
					? ___R$project$rome$$romejs$ob1$index_ts$ob1Number0
					: offsetPosition.column;
			this.nextTokenIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
			this.currentToken = ___R$$priv$project$rome$$romejs$parser$core$index_ts$SOF_TOKEN;
			this.prevToken = ___R$$priv$project$rome$$romejs$parser$core$index_ts$SOF_TOKEN;
			this.state = initialState;
			this.ignoreWhitespaceTokens = false;

			this.indexTracker = new ___R$project$rome$$romejs$parser$core$index_ts$PositionTracker(
				this.input,
				offsetPosition,
				this.getPosition.bind(this),
			);
		}

		getPathAssert() {
			const {path} = this;
			if (path === undefined) {
				throw new Error("Path expected but none was passed to this Parser");
			} else {
				return path;
			}
		}

		getFilenameAssert() {
			const {filename} = this;
			if (filename === undefined) {
				throw new Error("Filename expected but none was passed to this Parser");
			} else {
				return filename;
			}
		}

		// Run the tokenizer over all tokens
		tokenizeAll() {
			const tokens = [];

			const {diagnostics} = ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnosticsSync(() => {
				while (!this.matchToken("EOF")) {
					tokens.push(this.getToken());
					this.nextToken();
				}
			});

			if (diagnostics !== undefined) {
				tokens.push({
					type: "Invalid",
					start: this.nextTokenIndex,
					end: this.length,
				});
			}

			return tokens;
		}

		// Tokenize method that must be implemented by subclasses
		tokenize(index, input) {
			throw new Error("Unimplemented");
		}

		// Alternate tokenize method to allow that allows the use of state
		tokenizeWithState(index, input, state) {
			const token = this.tokenize(index, input);
			if (token !== undefined) {
				return {token, state};
			} else {
				return undefined;
			}
		}

		_tokenizeWithState(index, input, state) {
			if (this.ignoreWhitespaceTokens) {
				switch (input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index)]) {
					case " ":
					case "\t":
					case "\r":
					case "\n":
						return this.lookahead(
							___R$project$rome$$romejs$ob1$index_ts$ob1Inc(index),
						);
				}
			}

			return this.tokenizeWithState(index, input, state);
		}

		// Get the current token
		getToken() {
			const {currentToken} = this;
			if (
				currentToken ===
				___R$$priv$project$rome$$romejs$parser$core$index_ts$SOF_TOKEN
			) {
				return this.nextToken();
			} else {
				return currentToken;
			}
		}

		getPrevToken() {
			return this.prevToken;
		}

		save() {
			return {
				nextTokenIndex: this.nextTokenIndex,
				currentToken: this.currentToken,
				prevToken: this.prevToken,
				state: this.state,
			};
		}

		restore(snapshot) {
			this.nextTokenIndex = snapshot.nextTokenIndex;
			this.currentToken = snapshot.currentToken;
			this.prevToken = snapshot.prevToken;
			this.state = snapshot.state;
		}

		// Advance to the next token, returning the new one
		nextToken() {
			if (this.isEOF(this.nextTokenIndex)) {
				this.currentToken = this.eofToken;
				return this.eofToken;
			}

			if (this.tokenizing) {
				throw new Error("Can't call nextToken while tokenizing");
			}

			const prevToken = this.currentToken;
			const {token: nextToken, state} = this.lookahead();

			if (nextToken.end === prevToken.end) {
				throw new Error(
					"tokenize() returned a token with the same position as the last - Previous token: " +
					JSON.stringify(prevToken) +
					"; Next token: " +
					JSON.stringify(nextToken) +
					"; Input: " +
					this.input.slice(0, 100),
				);
			}

			const {line, column} = this.getPositionFromIndex(nextToken.start);
			this.currLine = line;
			this.currColumn = column;

			this.nextTokenIndex = nextToken.end;
			this.prevToken = prevToken;
			this.currentToken = nextToken;
			this.state = state;
			return nextToken;
		}

		// Get the position of the current token
		getPosition() {
			const index = this.currentToken.start;

			const cached = this.indexTracker.cachedPositions.get(index);
			if (cached !== undefined) {
				return cached;
			}

			const pos = {
				index: this.indexTracker.addOffset(index),
				line: this.currLine,
				column: this.currColumn,
			};
			this.indexTracker.cachedPositions.set(index, pos);
			return pos;
		}

		// Get the end position of the current token
		getLastEndPosition() {
			return this.getPositionFromIndex(this.prevToken.end);
		}

		// Return the token that's after this current token without advancing to it
		lookaheadToken(index) {
			return this.lookahead(index).token;
		}

		// Return the token and state that's after the current token without advancing to it
		lookahead(index = this.nextTokenIndex) {
			if (this.isEOF(index)) {
				return {token: this.eofToken, state: this.state};
			}

			// Set the next token index, in the case of a lookahead we'll set it back later
			const prevNextTokenIndex = this.nextTokenIndex;
			this.nextTokenIndex = index;

			// Indicate that we're currently tokenizing to catch some weird recursive tokenizing errors
			const wasTokenizing = this.tokenizing;
			this.tokenizing = true;

			// Tokenize and do some validation
			const nextToken = this._tokenizeWithState(index, this.input, this.state);
			if (nextToken === undefined) {
				throw this.unexpected({
					start: this.getPositionFromIndex(index),
				});
			}

			// Reset to old values
			this.tokenizing = wasTokenizing;
			this.nextTokenIndex = prevNextTokenIndex;

			return nextToken;
		}

		getPositionFromIndex(index) {
			return this.indexTracker.getPositionFromIndex(index);
		}

		createDiagnostic(opts = {}) {
			const {currentToken} = this;
			let {description: metadata, start, end, loc, token} = opts;

			// Allow passing in a TokenBase
			if (token !== undefined) {
				start = this.getPositionFromIndex(token.start);
				end = this.getPositionFromIndex(token.end);
			}

			// Allow passing in a SourceLocation as an easy way to point to a particular node
			if (loc !== undefined) {
				start = loc.start;
				end = loc.end;
			}

			// When both properties are omitted then we will default to the current token range
			if (start === undefined && end === undefined) {
				end = this.getLastEndPosition();
			}

			if (start === undefined) {
				start = this.getPosition();
			}

			if (end === undefined) {
				end = start;
			}

			// Sometimes the end position may be empty as it hasn't been filled yet
			if (end.index === ___R$project$rome$$romejs$ob1$index_ts$ob1Number0) {
				end = start;
			}

			// Normalize message, we need to be defensive here because it could have been called while tokenizing the first token
			if (metadata === undefined) {
				if (
					currentToken !== undefined &&
					start !== undefined &&
					start.index === currentToken.start
				) {
					metadata = ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PARSER_CORE.UNEXPECTED(
						currentToken.type,
					);
				} else {
					if (this.isEOF(start.index)) {
						metadata = ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PARSER_CORE.UNEXPECTED_EOF;
					} else {
						const char = this.input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
							start.index,
						)];
						metadata = ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PARSER_CORE.UNEXPECTED_CHARACTER(
							char,
						);
					}
				}
			}

			const metadataWithCategory = Object.assign(
				{},
				metadata,
				{
					category: metadata.category === undefined
						? this.diagnosticCategory
						: metadata.category,
				},
			);

			return {
				description: metadataWithCategory,
				location: {
					sourceText: this.path === undefined ? this.input : undefined,
					mtime: this.mtime,
					start,
					end,
					filename: this.filename,
				},
			};
		}

		// Return an error to indicate a parser error, this must be thrown at the callsite for refinement
		unexpected(opts = {}) {
			return ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
				this.createDiagnostic(opts),
			);
		}

		//# Token utility methods
		assertNoSpace() {
			if (this.currentToken.start !== this.prevToken.end) {
				throw this.unexpected({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PARSER_CORE.EXPECTED_SPACE,
				});
			}
		}

		// If the current token is the specified type then return the next token, otherwise return null
		eatToken(type) {
			if (this.matchToken(type)) {
				return this.nextToken();
			} else {
				return undefined;
			}
		}

		didEatToken(type) {
			return this.eatToken(type) !== undefined;
		}

		// Check if we're at the end of the input
		isEOF(index) {
			return (
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) >=
				this.input.length
			);
		}

		// Check if the current token matches the input type
		matchToken(type) {
			return this.getToken().type === type;
		}

		// Get the current token and assert that it's of the specified type, the token stream will also be advanced
		expectToken(type, _metadata) {
			const token = this.getToken();
			if (token.type === type) {
				this.nextToken();
				// @ts-ignore
				return token;
			} else {
				throw this.unexpected({
					description: _metadata === undefined
						? ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PARSER_CORE.EXPECTED_TOKEN(
								token.type,
								(type),
							)
						: _metadata,
				});
			}
		}

		// Read from the input starting at the specified index, until the callback returns false
		readInputFrom(index, callback) {
			const {input} = this;
			let value = "";

			while (true) {
				if (
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) >=
					input.length
				) {
					return [value, index, true];
				}

				if (
					callback === undefined ||
					callback(
						input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index)],
						index,
						input,
					)
				) {
					value += input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index)];
					index = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(index);
				} else {
					break;
				}
			}

			return [value, index, false];
		}

		// Get the string between the specified range
		getRawInput(start, end) {
			return this.input.slice(
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(start),
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(end),
			);
		}

		//# Utility methods to make it easy to construct nodes or tokens
		getLoc(node) {
			if (node === undefined || node.loc === undefined) {
				throw new Error("Tried to fetch node loc start but none found");
			} else {
				return node.loc;
			}
		}

		finishToken(
			type,
			end = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(this.nextTokenIndex),
		) {
			return {
				type,
				start: this.nextTokenIndex,
				end,
			};
		}

		finishValueToken(
			type,
			value,
			end = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(this.nextTokenIndex),
		) {
			return {
				type,
				value,
				start: this.nextTokenIndex,
				end,
			};
		}

		finishComplexToken(
			type,
			data,
			end = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(this.nextTokenIndex),
		) {
			return Object.assign({type}, data, {start: this.nextTokenIndex, end});
		}

		finishLocFromToken(token) {
			return this.finishLocAt(
				this.getPositionFromIndex(token.start),
				this.getPositionFromIndex(token.end),
			);
		}

		finishLoc(start) {
			return this.finishLocAt(start, this.getLastEndPosition());
		}

		finishLocAt(start, end) {
			return {
				filename: this.filename,
				start,
				end,
			};
		}

		finalize() {
			if (!this.eatToken("EOF")) {
				throw this.unexpected({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PARSER_CORE.EXPECTED_EOF,
				});
			}
		}
	}

	class ___R$project$rome$$romejs$parser$core$index_ts$ParserWithRequiredPath
		extends ___R$project$rome$$romejs$parser$core$index_ts$ParserCore {
		constructor(opts, diagnosticCategory, initialState) {
			super(opts, diagnosticCategory, initialState);
			this.filename = this.getFilenameAssert();
			this.path = this.getPathAssert();
		}
	}



	class ___R$project$rome$$romejs$parser$core$index_ts$PositionTracker {
		constructor(
			input,
			offsetPosition = {
				line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
				column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
				index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			},
			getPosition,
		) {
			this.getPosition = getPosition;
			this.input = input;
			this.offsetPosition = offsetPosition;
			this.latestPosition = offsetPosition;
			this.cachedPositions = new Map();
		}

		addOffset(index) {
			return ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
				index,
				this.offsetPosition.index,
			);
		}

		removeOffset(index) {
			return ___R$project$rome$$romejs$ob1$index_ts$ob1Sub(
				index,
				this.offsetPosition.index,
			);
		}

		getPositionFromIndex(index) {
			const cached = this.cachedPositions.get(index);
			if (cached !== undefined) {
				return cached;
			}

			let line = ___R$project$rome$$romejs$ob1$index_ts$ob1Number1;
			let column = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
			let indexSearchWithoutOffset = 0;

			const indexWithOffset = this.addOffset(index);

			// Reuse existing line information if possible
			const {latestPosition} = this;
			const currPosition =
				this.getPosition === undefined ? undefined : this.getPosition();
			if (
				currPosition !== undefined &&
				currPosition.index > latestPosition.index &&
				currPosition.index < indexWithOffset
			) {
				line = currPosition.line;
				column = currPosition.column;
				indexSearchWithoutOffset = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
					this.removeOffset(currPosition.index),
				);
			} else if (latestPosition.index < indexWithOffset) {
				line = latestPosition.line;
				column = latestPosition.column;
				indexSearchWithoutOffset = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
					this.removeOffset(latestPosition.index),
				);
			}

			// Read the rest of the input until we hit the index
			for (
				let i = indexSearchWithoutOffset;
				i < ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index);
				i++
			) {
				const char = this.input[i];

				if (char === "\n") {
					line = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(line);
					column = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
				} else {
					column = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(column);
				}
			}

			const pos = {
				index: indexWithOffset,
				line,
				column,
			};

			if (latestPosition === undefined || pos.index > latestPosition.index) {
				this.latestPosition = pos;
			}

			this.cachedPositions.set(index, pos);
			return pos;
		}
	}

	function ___R$project$rome$$romejs$parser$core$index_ts$isDigit(char) {
		return char !== undefined && /[0-9]/.test(char);
	}

	function ___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char) {
		return char !== undefined && /[A-Za-z]/.test(char);
	}

	function ___R$project$rome$$romejs$parser$core$index_ts$isHexDigit(char) {
		return char !== undefined && /[0-9A-Fa-f]/.test(char);
	}

	function ___R$project$rome$$romejs$parser$core$index_ts$isESIdentifierChar(
		char,
	) {
		return char !== undefined && /[A-F0-9a-z_$]/.test(char);
	}

	function ___R$project$rome$$romejs$parser$core$index_ts$isESIdentifierStart(
		char,
	) {
		return char !== undefined && /[A-Fa-z_$]/.test(char);
	}

	function ___R$project$rome$$romejs$parser$core$index_ts$readUntilLineBreak(
		char,
	) {
		return char !== "\n";
	}

	function ___R$project$rome$$romejs$parser$core$index_ts$createParser(callback) {
		let klass;

		return (...args) => {
			if (klass === undefined) {
				klass = callback(
					___R$project$rome$$romejs$parser$core$index_ts$ParserCore,
					___R$project$rome$$romejs$parser$core$index_ts$ParserWithRequiredPath,
				);
			}

			return new klass(...args);
		};
	}

	function ___R$project$rome$$romejs$parser$core$index_ts$extractSourceLocationRangeFromNodes(
		nodes,
	) {
		if (nodes.length === 0) {
			return undefined;
		}

		let filename = undefined;
		let start = undefined;
		let end = undefined;

		for (const node of nodes) {
			const {loc} = node;
			if (loc === undefined) {
				continue;
			}

			if (start === undefined || loc.start.index < start.index) {
				start = loc.start;
			}

			if (end === undefined || loc.end.index > end.index) {
				end = loc.end;
			}

			if (filename === undefined) {
				filename = loc.filename;
			} else if (filename !== loc.filename) {
				throw new Error(
					"Mixed filenames in node, expected " +
					filename +
					" but got " +
					loc.filename,
				);
			}
		}

		if (start === undefined || end === undefined) {
			return undefined;
		}

		return {
			filename,
			start,
			end,
		};
	}


  // project-rome/@romejs/string-markup/escape.ts
const ___R$project$rome$$romejs$string$markup$escape_ts = {
		markup: ___R$project$rome$$romejs$string$markup$escape_ts$markup,
		safeMarkup: ___R$project$rome$$romejs$string$markup$escape_ts$safeMarkup,
		escapeMarkup: ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup,
		markupTag: ___R$project$rome$$romejs$string$markup$escape_ts$markupTag,
		unescapeTextValue: ___R$project$rome$$romejs$string$markup$escape_ts$unescapeTextValue,
	};
	function ___R$project$rome$$romejs$string$markup$escape_ts$markup(
		strs,
		...values
	) {
		let out = "";

		for (let i = 0; i < strs.length; i++) {
			const str = strs[i];
			out += str;

			const interpolated = values[i];

			if (
				interpolated instanceof
				___R$$priv$project$rome$$romejs$string$markup$escape_ts$SafeMarkup
			) {
				out += interpolated.value;
				continue;
			}

			if (interpolated !== undefined) {
				out += ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					String(interpolated),
				);
			}
		}

		return out;
	}

	class ___R$$priv$project$rome$$romejs$string$markup$escape_ts$SafeMarkup {
		constructor(value) {
			this.value = value;
		}
	}

	function ___R$project$rome$$romejs$string$markup$escape_ts$safeMarkup(input) {
		return new ___R$$priv$project$rome$$romejs$string$markup$escape_ts$SafeMarkup(
			input,
		);
	}

	function ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(input) {
		let escaped = "";
		for (let i = 0; i < input.length; i++) {
			const char = input[i];

			if (char === "<") {
				escaped += "\\<";
			} else if (char === "\\") {
				escaped += "\\\\";
			} else {
				escaped += char;
			}
		}
		return escaped;
	}

	function ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
		tagName,
		text,
		attrs,
	) {
		let ret = "<" + tagName;

		if (attrs !== undefined) {
			for (const key in attrs) {
				const value = attrs[key];
				if (value !== undefined) {
					ret += ___R$project$rome$$romejs$string$markup$escape_ts$markup` ${key}="${String(
						value,
					)}"`;
				}
			}
		}

		ret += ">" + text + "</" + tagName + ">";

		return ret;
	}

	function ___R$project$rome$$romejs$string$markup$escape_ts$unescapeTextValue(
		str,
	) {
		let unescaped = "";

		for (let i = 0; i < str.length; i++) {
			const char = str[i];

			// Unescape \\< to just <
			// Unescape \\\\ to just \\
			if (char === "\\") {
				const nextChar = str[i + 1];
				if (nextChar === "<" || nextChar === "\\") {
					i++;
					unescaped += nextChar;
					continue;
				}
			}

			unescaped += char;
		}

		return unescaped;
	}


  // project-rome/@romejs/string-markup/parse.ts
const ___R$project$rome$$romejs$string$markup$parse_ts = {
		isTagStartChar: ___R$project$rome$$romejs$string$markup$parse_ts$isTagStartChar,
		parseMarkup: ___R$project$rome$$romejs$string$markup$parse_ts$parseMarkup,
	};
	const ___R$$priv$project$rome$$romejs$string$markup$parse_ts$globalAttributes = [
		"emphasis",
		"dim",
	];

	// Tags and their corresponding supported attributes
	const ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags = new Map();
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"emphasis",
		[],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"number",
		["approx", "pluralSuffix", "singularSuffix"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"grammarNumber",
		["plural", "singular", "none"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"hyperlink",
		["target"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"filelink",
		["target", "column", "line"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("inverse", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("dim", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"filesize",
		[],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"duration",
		["approx"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("italic", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"underline",
		[],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("strike", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("error", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("success", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("warn", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("info", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("command", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"color",
		["fg", "bg"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"highlight",
		["i"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("table", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("tr", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"td",
		["align"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("hr", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"pad",
		["width", "align"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("nobr", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("li", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set("ul", []);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.set(
		"ol",
		["reversed", "start"],
	);

	// Tags that only support certain other tags as their children
	const ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyChildren = new Map();
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyChildren.set(
		"table",
		["tr"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyChildren.set(
		"tr",
		["td"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyChildren.set(
		"ol",
		["li"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyChildren.set(
		"ul",
		["li"],
	);

	// Tags that should only be children of other tags
	const ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyParent = new Map();
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyParent.set(
		"tr",
		["table"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyParent.set(
		"td",
		["tr"],
	);
	___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyParent.set(
		"li",
		["ol", "ul"],
	);

	//
	function ___R$$priv$project$rome$$romejs$string$markup$parse_ts$isStringValueChar(
		char,
		index,
		input,
	) {
		if (
			char === '"' &&
			!___R$project$rome$$romejs$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			)
		) {
			return false;
		}

		return true;
	}

	function ___R$$priv$project$rome$$romejs$string$markup$parse_ts$isTextChar(
		char,
		index,
		input,
	) {
		return !___R$project$rome$$romejs$string$markup$parse_ts$isTagStartChar(
			index,
			input,
		);
	}

	function ___R$project$rome$$romejs$string$markup$parse_ts$isTagStartChar(
		index,
		input,
	) {
		const i = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index);
		return (
			input[i] === "<" &&
			!___R$project$rome$$romejs$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			)
		);
	}





	const ___R$$priv$project$rome$$romejs$string$markup$parse_ts$createStringMarkupParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser((
		ParserCore,
	) =>
		class StringMarkupParser extends ParserCore {
			constructor(opts) {
				super(opts, "parse/stringMarkup", {inTagHead: false});
			}

			tokenizeWithState(index, input, state) {
				const escaped = ___R$project$rome$$romejs$string$utils$isEscaped_ts$isEscaped(
					index,
					input,
				);
				const char = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index)];

				if (!escaped && state.inTagHead) {
					if (char === " ") {
						return this.lookahead(
							___R$project$rome$$romejs$ob1$index_ts$ob1Inc(index),
						);
					}

					if (char === "=") {
						return {
							state,
							token: this.finishToken("Equals"),
						};
					}

					if (char === "/") {
						return {
							state,
							token: this.finishToken("Slash"),
						};
					}

					if (___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char)) {
						const [value, end] = this.readInputFrom(
							index,
							___R$project$rome$$romejs$parser$core$index_ts$isAlpha,
						);
						return {
							state,
							token: this.finishValueToken("Word", value, end),
						};
					}

					if (char === '"') {
						const [value, stringValueEnd, unclosed] = this.readInputFrom(
							___R$project$rome$$romejs$ob1$index_ts$ob1Inc(index),
							___R$$priv$project$rome$$romejs$string$markup$parse_ts$isStringValueChar,
						);

						if (unclosed) {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.UNCLOSED_STRING,
								start: this.getPositionFromIndex(stringValueEnd),
							});
						}

						const end = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							stringValueEnd,
							1,
						);
						return {
							state,
							token: this.finishValueToken(
								"String",
								___R$project$rome$$romejs$string$markup$escape_ts$unescapeTextValue(
									value,
								),
								end,
							),
						};
					}

					if (char === ">") {
						return {
							state: {
								inTagHead: false,
							},
							token: this.finishToken("Greater"),
						};
					}
				}

				if (
					___R$project$rome$$romejs$string$markup$parse_ts$isTagStartChar(
						index,
						input,
					)
				) {
					return {
						state: {
							inTagHead: true,
						},
						token: this.finishToken("Less"),
					};
				}

				// Keep eating text until we hit a <
				const [value, end] = this.readInputFrom(
					index,
					___R$$priv$project$rome$$romejs$string$markup$parse_ts$isTextChar,
				);
				return {
					state,
					token: {
						type: "Text",
						value: ___R$project$rome$$romejs$string$markup$escape_ts$unescapeTextValue(
							value,
						),
						start: index,
						end,
					},
				};
			}

			atTagEnd() {
				return (
					this.matchToken("Less") && this.lookahead().token.type === "Slash"
				);
			}

			parseTag(headStart, parentTagName) {
				const nameToken = this.expectToken("Word");
				const tagName = (nameToken.value);

				const allowedAttributes = ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tags.get(
					tagName,
				);
				if (allowedAttributes === undefined) {
					throw this.unexpected({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.UNKNOWN_TAG_NAME(
							tagName,
						),
						token: nameToken,
					});
				}

				// Check if this tag is restricted to certain parents
				const onlyAllowedAsChild = ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyParent.get(
					tagName,
				);
				if (onlyAllowedAsChild !== undefined) {
					if (
						parentTagName === undefined ||
						!onlyAllowedAsChild.includes(parentTagName)
					) {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.RESTRICTED_CHILD(
								tagName,
								onlyAllowedAsChild,
								parentTagName,
							),
							token: nameToken,
						});
					}
				}

				// Check if the parent only allows certain children
				if (parentTagName !== undefined) {
					const onlyAllowedAsParent = ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyChildren.get(
						parentTagName,
					);
					if (
						onlyAllowedAsParent !== undefined &&
						!onlyAllowedAsParent.includes(tagName)
					) {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.RESTRICTED_PARENT(
								parentTagName,
								onlyAllowedAsParent,
								tagName,
							),
							token: nameToken,
						});
					}
				}

				const attributes = {};
				const children = [];
				let selfClosing = false;

				// Parse attributes
				while (!this.matchToken("EOF") && !this.matchToken("Greater")) {
					const keyToken = this.getToken();

					let key;
					if (keyToken.type === "Word") {
						key = keyToken.value;

						if (
							!allowedAttributes.includes(key) &&
							!___R$$priv$project$rome$$romejs$string$markup$parse_ts$globalAttributes.includes(
								key,
							)
						) {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.INVALID_ATTRIBUTE_NAME_FOR_TAG(
									tagName,
									key,
									[
										...allowedAttributes,
										...___R$$priv$project$rome$$romejs$string$markup$parse_ts$globalAttributes,
									],
								),
							});
						}

						this.nextToken();

						// Shorthand properties
						if (
							this.matchToken("Word") ||
							this.matchToken("Slash") ||
							this.matchToken("Greater")
						) {
							attributes[key] = "true";
							continue;
						}

						this.expectToken("Equals");

						const valueToken = this.expectToken("String");
						if (valueToken.type !== "String") {
							throw new Error("Expected String");
						}
						const value = valueToken.value;

						attributes[key] = value;
					} else if (keyToken.type === "Slash") {
						this.nextToken();
						selfClosing = true;
					} else {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.EXPECTED_ATTRIBUTE_NAME,
						});
					}
				}

				this.expectToken("Greater");

				const headEnd = this.getPosition();

				// Verify closing tag
				if (!selfClosing) {
					while (
						// Build children
						!this.matchToken("EOF") &&
						!this.atTagEnd()
					) {
						const child = this.parseChild(tagName);
						if (child !== undefined) {
							children.push(child);
						}
					}

					if (this.matchToken("EOF")) {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.UNCLOSED_TAG(
								tagName,
								this.finishLocAt(headStart, headEnd),
							),
						});
					} else {
						this.expectToken("Less");
						this.expectToken("Slash");

						const name = this.getToken();
						if (name.type === "Word") {
							if (name.value !== tagName) {
								throw this.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.INCORRECT_CLOSING_TAG_NAME(
										tagName,
										name.value,
									),
								});
							}

							this.nextToken();
						} else {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.EXPECTED_CLOSING_TAG_NAME,
							});
						}

						this.expectToken("Greater");
					}
				}

				return {
					type: "Tag",
					attributes,
					name: tagName,
					children,
				};
			}

			parseChild(parentTagName) {
				const start = this.getPosition();
				const token = this.getToken();
				this.nextToken();

				if (token.type === "Text") {
					// If this tag has restricted children then no text is allowed
					if (parentTagName !== undefined) {
						const onlyAllowedAsParent = ___R$$priv$project$rome$$romejs$string$markup$parse_ts$tagsToOnlyChildren.get(
							parentTagName,
						);
						if (onlyAllowedAsParent !== undefined) {
							// Ignore text that's just whitespace
							if (token.value.trim() === "") {
								return undefined;
							} else {
								throw this.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.RESTRICTED_PARENT_TEXT(
										parentTagName,
									),
									token,
								});
							}
						}
					}

					return {
						type: "Text",
						value: token.value,
					};
				} else if (token.type === "Less") {
					return this.parseTag(start, parentTagName);
				} else {
					throw this.unexpected({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_MARKUP.UNKNOWN_START,
					});
				}
			}

			parse() {
				const children = [];
				while (!this.matchToken("EOF")) {
					const child = this.parseChild(undefined);
					if (child !== undefined) {
						children.push(child);
					}
				}
				return children;
			}
		}
	);

	function ___R$project$rome$$romejs$string$markup$parse_ts$parseMarkup(input) {
		try {
			return ___R$$priv$project$rome$$romejs$string$markup$parse_ts$createStringMarkupParser({
				input,
			}).parse();
		} catch (err) {
			throw err;
		}
	}


  // project-rome/@romejs/string-markup/types.ts

























  // project-rome/@romejs/string-markup/ansi.ts
const ___R$project$rome$$romejs$string$markup$ansi_ts = {
		get pattern() {
			return ___R$project$rome$$romejs$string$markup$ansi_ts$pattern;
		},
		get regex() {
			return ___R$project$rome$$romejs$string$markup$ansi_ts$regex;
		},
		get formatAnsi() {
			return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi;
		},
		stripAnsi: ___R$project$rome$$romejs$string$markup$ansi_ts$stripAnsi,
		hasAnsi: ___R$project$rome$$romejs$string$markup$ansi_ts$hasAnsi,
		get ansiEscapes() {
			return ___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes;
		},
	};
	/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

	const ___R$$priv$project$rome$$romejs$string$markup$ansi_ts$ESC = "\x1b[";

	const ___R$project$rome$$romejs$string$markup$ansi_ts$pattern = [
		"[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
		"(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
	].join("|");

	const ___R$project$rome$$romejs$string$markup$ansi_ts$regex = new RegExp(
		___R$project$rome$$romejs$string$markup$ansi_ts$pattern,
		"g",
	);

	function ___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(
		num,
	) {
		return (
			"" +
			___R$$priv$project$rome$$romejs$string$markup$ansi_ts$ESC +
			String(num) +
			"m"
		);
	}

	const ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi = {
		reset(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(0) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(0)
			);
		},
		fileHyperlink(name, filename) {
			let href = "file://";
			const {HOSTNAME} = process.env;
			if (HOSTNAME != null) {
				href += HOSTNAME + "/";
			}
			href += filename;
			return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.hyperlink(
				name,
				href,
			);
		},
		hyperlink(name, href) {
			return "\x1b]8;;" + href + "\x07" + name + "\x1b]8;;\x07";
		},
		rgb(str, color) {
			return (
				"\x1b[38;2;" +
				String(color.r) +
				";" +
				String(color.g) +
				";" +
				String(color.b) +
				"m" +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		bgRgb(str, color) {
			return (
				"\x1b[48;2;" +
				String(color.r) +
				";" +
				String(color.g) +
				";" +
				String(color.b) +
				"m" +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bold(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(1) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(22)
			);
		},
		dim(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(2) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(22)
			);
		},
		italic(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(3) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(23)
			);
		},
		underline(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(4) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(24)
			);
		},
		inverse(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(7) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(27)
			);
		},
		hidden(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(8) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(28)
			);
		},
		strikethrough(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(9) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(29)
			);
		},
		black(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(30) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		brightBlack(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(90) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		red(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(31) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		brightRed(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(91) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		green(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(32) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		brightGreen(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(92) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		yellow(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(33) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		brightYellow(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(93) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		blue(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(34) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		brightBlue(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(94) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		magenta(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(35) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		brightMagenta(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(95) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		cyan(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(36) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		brightCyan(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(96) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		white(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(37) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		brightWhite(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(97) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(39)
			);
		},
		bgBlack(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(40) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBrightBlack(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(100) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgRed(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(41) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBrightRed(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(101) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgGreen(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(42) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBrightGreen(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(102) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgYellow(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(43) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBrightYellow(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(103) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBlue(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(44) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBrightBlue(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(104) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgMagenta(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(45) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBrightMagenta(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(105) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgCyan(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(46) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBrightCyan(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(106) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgWhite(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(47) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
		bgBrightWhite(str) {
			return (
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(107) +
				str +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$createEscape(49)
			);
		},
	};

	function ___R$project$rome$$romejs$string$markup$ansi_ts$stripAnsi(str) {
		return str.replace(
			___R$project$rome$$romejs$string$markup$ansi_ts$regex,
			"",
		);
	}

	function ___R$project$rome$$romejs$string$markup$ansi_ts$hasAnsi(str) {
		return ___R$project$rome$$romejs$string$markup$ansi_ts$regex.test(str);
	}

	const ___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes = {
		clearScreen: "\x1bc",
		eraseLine: ___R$$priv$project$rome$$romejs$string$markup$ansi_ts$ESC + "2K",
		cursorUp(count = 1) {
			return (
				"" +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$ESC +
				count +
				"A"
			);
		},
		cursorTo(x, y) {
			if (y === undefined) {
				return (
					"" +
					___R$$priv$project$rome$$romejs$string$markup$ansi_ts$ESC +
					(x + 1) +
					"G"
				);
			}

			return (
				"" +
				___R$$priv$project$rome$$romejs$string$markup$ansi_ts$ESC +
				(y + 1) +
				";" +
				(x + 1) +
				"H"
			);
		},
	};


  // project-rome/@romejs/string-markup/tagFormatters.ts
function ___R$project$rome$$romejs$string$markup$tagFormatters_ts$humanizeMarkupFilename(
		filename,
		opts = {},
	) {
		if (opts.humanizeFilename !== undefined) {
			const override = opts.humanizeFilename(filename);
			if (override !== undefined) {
				return override;
			}
		}

		return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
			filename,
		).format(opts.cwd);
	}

	function ___R$project$rome$$romejs$string$markup$tagFormatters_ts$getFileLinkText(
		filename,
		attributes,
		opts,
	) {
		let text = ___R$project$rome$$romejs$string$markup$tagFormatters_ts$humanizeMarkupFilename(
			filename,
			opts,
		);

		const line = attributes.line;
		if (line !== undefined) {
			text += ":" + line;

			const column = attributes.column;
			// Ignore a 0 column and just target the line
			if (column !== undefined && column !== "0") {
				text += ":" + column;
			}
		}

		return text;
	}

	function ___R$project$rome$$romejs$string$markup$tagFormatters_ts$getFileLinkFilename(
		attributes,
		opts,
	) {
		let filename = attributes.target || "";
		if (opts.normalizeFilename !== undefined) {
			filename = opts.normalizeFilename(filename);
		}
		return filename;
	}

	function ___R$project$rome$$romejs$string$markup$tagFormatters_ts$formatApprox(
		attributes,
		value,
	) {
		if (attributes.approx === "true") {
			return "~" + value;
		} else {
			return value;
		}
	}

	function ___R$project$rome$$romejs$string$markup$tagFormatters_ts$formatGrammarNumber(
		attributes,
		value,
	) {
		const num = Number(value);

		const none = attributes.none;
		if (none !== undefined && num === 0) {
			return none;
		}

		const singular = attributes.singular;
		if (singular !== undefined && num === 1) {
			return singular;
		}

		const plural = attributes.plural;
		if (plural !== undefined) {
			return plural;
		}

		return "";
	}

	function ___R$project$rome$$romejs$string$markup$tagFormatters_ts$formatNumber(
		attributes,
		value,
	) {
		const num = Number(value);
		const human = ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
			num,
		);
		const humanWithApprox = ___R$project$rome$$romejs$string$markup$tagFormatters_ts$formatApprox(
			attributes,
			human,
		);
		return humanWithApprox;
	}


  // project-rome/@romejs/string-markup/Grid.ts


	function ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$cursorToIndex(
		cursor,
	) {
		return {
			line: ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(cursor.line) - 1,
			column: ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(cursor.column) - 1,
		};
	}



	function ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$createTag(
		name,
		attributes,
		children = [],
	) {
		return {
			type: "Tag",
			name,
			attributes,
			children,
		};
	}

	class ___R$project$rome$$romejs$string$markup$Grid_ts$default {
		constructor(opts) {
			this.viewportWidth =
				opts.columns === undefined
					? undefined
					: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(opts.columns);
			this.markupOptions = opts;

			this.cursor = {
				line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
				column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
			};

			this.canLineWrap = true;
			this.width = ___R$project$rome$$romejs$ob1$index_ts$ob1Number1;

			this.lines = [];
		}

		alignRight() {
			const viewportWidth = ___R$project$rome$$romejs$ob1$index_ts$ob1Get(
				this.viewportWidth,
			);
			if (viewportWidth === undefined) {
				return;
			}

			this.lines = this.lines.map(({ranges, columns}) => {
				const newColumns = [...columns];

				// Pad out line to viewport width
				while (newColumns.length < viewportWidth) {
					newColumns.push(" ");
				}

				// Skip if all it contains is spaces

				let onlySpaces = true;
				for (const char of newColumns) {
					if (char !== " ") {
						onlySpaces = false;
					}
				}
				if (onlySpaces) {
					return {
						columns: newColumns,
						ranges,
					};
				}

				let offset = 0;

				// Shift whitespace from right to left
				while (newColumns[newColumns.length - 1] === " ") {
					offset++;
					newColumns.pop();
					newColumns.unshift(" ");
				}

				const newRanges = ranges.map((range) => {
					return {
						start: range.start + offset,
						end: range.end + offset,
						ancestry: range.ancestry,
					};
				});

				return {
					ranges: newRanges,
					columns: newColumns,
				};
			});
		}

		doesOverflowViewport(column) {
			return (
				this.canLineWrap &&
				this.viewportWidth !== undefined &&
				___R$project$rome$$romejs$ob1$index_ts$ob1Get1(column) >
				___R$project$rome$$romejs$ob1$index_ts$ob1Get1(this.viewportWidth)
			);
		}

		getHeight() {
			return ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(
				this.lines.length,
			);
		}

		getLineWidth(lineIndex) {
			const line = this.lines[lineIndex];
			return line === undefined ? 0 : line.columns.length;
		}

		getWidth() {
			return this.width;
		}

		getSize() {
			return {
				height: this.getHeight(),
				width: this.getWidth(),
			};
		}

		getCursor() {
			return Object.assign({}, this.cursor);
		}

		getLines() {
			return this.lines.map(({columns}) => columns.join(""));
		}

		getFormattedLines() {
			const lines = [];

			for (const {ranges, columns} of this.lines) {
				let content = columns.join("");

				// Sort ranges from last to first
				const sortedRanges = ranges.sort((a, b) => b.end - a.end);

				for (const {start, end, ancestry} of sortedRanges) {
					let substr = content.slice(start, end);

					// Format tags in reverse
					for (let i = ancestry.length - 1; i >= 0; i--) {
						const tag = ancestry[i];
						substr = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$ansiFormatText(
							tag,
							substr,
							this.markupOptions,
						);
					}

					substr = ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.reset(
						substr,
					);

					content = content.slice(0, start) + substr + content.slice(end);
				}

				lines.push(content);
			}

			return lines;
		}

		fillCursor(cursor) {
			const {line: lineIndex, column: colIndex} = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$cursorToIndex(
				cursor,
			);

			// Pad lines
			for (let i = lineIndex; i >= 0 && this.lines[i] === undefined; i--) {
				this.lines[i] = {ranges: [], columns: []};
			}

			// Pad columns
			const line = this.lines[lineIndex];
			for (let i = colIndex - 1; i >= 0 && line.columns[i] === undefined; i--) {
				line.columns[i] = " ";
			}
		}

		moveCursor(cursor) {
			this.cursor = cursor;
		}

		moveCursorBottomStart() {
			this.moveCursor({
				line: ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(this.getHeight()),
				column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
			});
		}

		moveCursorRight(columns = ___R$project$rome$$romejs$ob1$index_ts$ob1Number1) {
			if (this.doesOverflowViewport(this.cursor.column)) {
				this.newline();
			} else {
				this.moveCursor({
					line: this.cursor.line,
					column: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
						this.cursor.column,
						columns,
					),
				});
			}
		}

		ensureNewline() {
			if (
				this.cursor.column !==
				___R$project$rome$$romejs$ob1$index_ts$ob1Number1
			) {
				this.newline();
			}
		}

		newline() {
			this.moveCursorDown();
			this.moveCursorStart();
		}

		moveCursorStart() {
			this.moveCursor({
				line: this.cursor.line,
				column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
			});
		}

		moveCursorDown() {
			this.moveCursor({
				line: ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(this.cursor.line),
				column: this.cursor.column,
			});
		}

		writeToCursor(cursor, char) {
			this.fillCursor(cursor);

			const {line: lineIndex, column: colIndex} = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$cursorToIndex(
				cursor,
			);
			this.lines[lineIndex].columns[colIndex] = char;

			if (cursor.column > this.width) {
				this.width = cursor.column;
			}
		}

		writeChar(char) {
			if (char === "\n") {
				this.newline();
				return;
			}

			this.writeToCursor(this.cursor, char);
			this.moveCursorRight();
		}

		writeText(text, ancestry) {
			if (text === "") {
				return;
			}

			const start = this.getCursor();

			const words = text.split(" ");

			for (let i = 0; i < words.length; i++) {
				const word = words[i];
				const isLastWord = i === words.length - 1;

				// Check if printing this word would overflow the viewport
				// If the whole word itself wouldn't fit on it's own line then we will
				// perform hard line wrapping in writeChar
				const willOverflow =
					this.doesOverflowViewport(
						___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							this.cursor.column,
							word.length - 1,
						),
					) &&
					!this.doesOverflowViewport(
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(word.length),
					);
				if (willOverflow) {
					this.newline();
				}

				for (const char of word) {
					this.writeChar(char);
				}

				let ignoreTrailingSpace = false;

				// Start of a sentence that was caused by line wrapping
				if (
					!word.endsWith("\n") &&
					this.cursor.column ===
					___R$project$rome$$romejs$ob1$index_ts$ob1Number1 &&
					word !== ""
				) {
					ignoreTrailingSpace = true;
				}

				// If the next word will cause an overflow then don't print a leading space as it will be pointless
				const nextWord = words[i + 1];
				if (
					nextWord !== undefined &&
					this.doesOverflowViewport(
						___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							this.cursor.column,
							nextWord.length,
						),
					)
				) {
					ignoreTrailingSpace = true;
				}

				if (isLastWord) {
					ignoreTrailingSpace = true;
				}

				if (!ignoreTrailingSpace) {
					this.writeChar(" ");
				}
			}

			const end = this.getCursor();
			this.addCursorRange(start, end, ancestry);
		}

		setRange(line, start, end, ancestry) {
			if (start === end) {
				// Nothing to format. Empty tag.
				return;
			}

			if (end < start) {
				throw new Error("end(" + end + ") < start(" + start + ")");
			}

			this.lines[line].ranges.push({
				start,
				end,
				ancestry,
			});
		}

		addCursorRange(_start, _end, ancestry) {
			if (ancestry.length === 0) {
				// No point storing a range without ancestry
				return;
			}

			const start = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$cursorToIndex(
				_start,
			);
			const end = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$cursorToIndex(
				_end,
			);

			if (start.line === end.line) {
				if (start.column === end.column) {
					// Empty range
					return;
				}

				this.setRange(start.line, start.column, end.column, ancestry);
			} else {
				// Add first line
				this.setRange(
					start.line,
					start.column,
					this.getLineWidth(start.line),
					ancestry,
				);

				// Add middle lines
				for (let line = start.line + 1; line < end.line; line++) {
					this.setRange(line, 0, this.getLineWidth(line), ancestry);
				}

				// Add last line
				this.setRange(end.line, 0, end.column, ancestry);
			}
		}

		drawList(tag, ancestry) {
			let items = [];
			for (const child of tag.children) {
				if (child.type === "Tag" && child.name === "li") {
					items.push(child);
				}
			}
			if (items.length === 0) {
				return;
			}

			this.ensureNewline();

			const ordered = tag.name === "ol";

			if (ordered) {
				const reversed = tag.attributes.reversed === "true";
				const startOffset = Number(tag.attributes.start) || 0;

				const highestNumSize = ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
					items.length + startOffset,
				).length;

				for (let i = 0; i < items.length; i++) {
					const item = items[i];

					let num = startOffset;
					if (reversed) {
						num += items.length - i;
					} else {
						num += i + 1;
					}

					const humanNum = ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
						num,
					);
					const padding = " ".repeat(highestNumSize - humanNum.length);
					this.writeText(
						"" + padding + humanNum + ". ",
						[
							___R$$priv$project$rome$$romejs$string$markup$Grid_ts$createTag(
								"dim",
								{},
							),
						],
					);
					this.drawListItem(item, ancestry);
				}
			} else {
				for (const item of items) {
					this.writeText(
						"- ",
						[
							___R$$priv$project$rome$$romejs$string$markup$Grid_ts$createTag(
								"dim",
								{},
							),
						],
					);
					this.drawListItem(item, ancestry);
				}
			}
		}

		drawListItem(item, ancestry) {
			const grid = new ___R$project$rome$$romejs$string$markup$Grid_ts$default(
				Object.assign(
					{},
					this.markupOptions,
					{
						columns: this.viewportWidth === undefined
							? undefined
							: ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(
									___R$project$rome$$romejs$ob1$index_ts$ob1Sub(
										this.viewportWidth,
										this.cursor.column,
									),
								),
					},
				),
			);
			grid.drawTag(item, ancestry);
			this.drawGrid(grid);
			this.moveCursorBottomStart();
		}

		drawTable(tag, ancestry) {
			var ___R$;
			const rows = [];

			for (const child of tag.children) {
				if (child.type === "Tag" && child.name === "tr") {
					const row = [];

					for (const field of child.children) {
						if (field.type === "Tag" && field.name === "td") {
							row.push(field);
						} else {
							// Probably error?
						}
					}

					rows.push(row);
				} else {
					// Probably error?
				}
			}

			// Get the max number of columns for a row
			const columnCount =
				(___R$ = Math,
				___R$.max.apply(___R$, [...rows.map((columns) => columns.length)]));

			// Get column widths
			const columnWidths = [];
			for (let i = 0; i < columnCount; i++) {
				var ___R$1;
				const widths = rows.map((row) => {
					const field = row[i];
					if (field === undefined) {
						// Could be an excessive column
						return 0;
					} else {
						const grid = new ___R$project$rome$$romejs$string$markup$Grid_ts$default(
							Object.assign({}, this.markupOptions, {columns: undefined}),
						);
						grid.drawTag(field, ancestry);
						return ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(
							grid.getSize().width,
						);
					}
				});
				columnWidths[i] = (___R$1 = Math, ___R$1.max.apply(___R$1, [...widths]));
			}

			// If the column size exceed the stream columns then scale them all down
			const colsNeeded = columnWidths.reduce((a, b) => a + b, 0);
			const {viewportWidth} = this;
			let availableCols =
				viewportWidth === undefined
					? undefined
					: ___R$project$rome$$romejs$ob1$index_ts$ob1Get(viewportWidth) -
						columnCount -
						1;
			if (availableCols !== undefined && colsNeeded > availableCols) {
				// Find the biggest column
				let biggestColIndex = 0;
				for (let i = 0; i < columnWidths.length; i++) {
					const ourSize = columnWidths[i];
					const biggestSize = columnWidths[biggestColIndex];

					if (ourSize > biggestSize) {
						biggestColIndex = i;
					}
				}

				// Remove all columns from availableCols
				for (let i = 0; i < columnWidths.length; i++) {
					if (i !== biggestColIndex) {
						availableCols -= columnWidths[i];
					}
				}

				// Set biggest column to the availableCols
				columnWidths[biggestColIndex] = availableCols;
			}

			for (const row of rows) {
				for (let colIndex = 0; colIndex < row.length; colIndex++) {
					const field = row[colIndex];
					const width = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(
						columnWidths[colIndex],
					);

					const grid = new ___R$project$rome$$romejs$string$markup$Grid_ts$default(
						Object.assign(
							{},
							this.markupOptions,
							{columns: ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(width)},
						),
					);
					grid.drawTag(field, ancestry);
					if (field.attributes.align === "right") {
						grid.alignRight();
					}

					this.drawGrid(grid);
					this.moveCursorRight(
						___R$project$rome$$romejs$ob1$index_ts$ob1Inc(width),
					);
				}

				this.moveCursorBottomStart();
			}
		}

		drawGrid(grid) {
			const {lines} = grid;
			const cursor = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$cursorToIndex(
				this.getCursor(),
			);

			// Write
			for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
				const {columns, ranges} = lines[lineIndex];

				const correctLine = cursor.line + lineIndex;

				for (let colIndex = 0; colIndex < columns.length; colIndex++) {
					const char = columns[colIndex];

					this.writeToCursor(
						{
							line: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(
								correctLine + 1,
							),
							column: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(
								cursor.column + colIndex + 1,
							),
						},
						char,
					);
				}

				for (const range of ranges) {
					this.setRange(
						correctLine,
						cursor.column + range.start,
						cursor.column + range.end,
						range.ancestry,
					);
				}
			}
		}

		drawTag(tag, ancestry) {
			const hook = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$hooks.get(
				tag.name,
			);

			const subAncestry = [...ancestry, tag];

			const oldCanLineWrap = this.canLineWrap;

			if (tag.name === "nobr") {
				this.canLineWrap = false;
			}

			if (hook !== undefined && hook.before !== undefined) {
				hook.before(tag, this, ancestry);
			}

			switch (tag.name) {
				case "ol":
				case "ul": {
					this.drawList(tag, subAncestry);
					break;
				}

				case "table": {
					this.drawTable(tag, subAncestry);
					break;
				}

				default: {
					this.drawChildren(tag.children, subAncestry);
					break;
				}
			}

			if (hook !== undefined && hook.after !== undefined) {
				hook.after(tag, this, ancestry);
			}

			this.canLineWrap = oldCanLineWrap;
		}

		drawChildren(children, ancestry) {
			for (const child of children) {
				if (child.type === "Text") {
					this.writeText(child.value, ancestry);
				} else {
					this.drawTag(child, ancestry);
				}
			}
		}

		drawRoot(children) {
			this.drawChildren(this.normalizeChildren(children), []);
		}

		normalizeChildren(children) {
			let newChildren = [];

			for (const child of children) {
				newChildren = newChildren.concat(this.normalizeChild(child));
			}

			return newChildren;
		}

		normalizeChild(child) {
			if (child.type === "Text") {
				let {value} = child;

				// Replace '\t' with '  '
				// Remove '\r' in case it snuck in as file contents
				value = value.replace(/\t/g, "  ");
				value = value.replace(/\r/g, "");

				return [
					{
						type: "Text",
						value,
					},
				];
			}

			const tag = child;
			const children = this.normalizeChildren(tag.children);
			const textLength = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$getChildrenTextLength(
				children,
			);
			const hasText = textLength > 0;
			const ___R$2 = tag.attributes;
			const attributesWithoutEmphasis = Object.assign({}, ___R$2);
			delete attributesWithoutEmphasis.emphasis;
			const {emphasis} = ___R$2;
			if (emphasis === "true") {
				return this.normalizeChild(
					___R$$priv$project$rome$$romejs$string$markup$Grid_ts$createTag(
						"emphasis",
						{},
						[Object.assign({}, tag, {attributes: attributesWithoutEmphasis})],
					),
				);
			}
			const ___R$3 = attributesWithoutEmphasis;
			const attributes = Object.assign({}, ___R$3);
			delete attributes.dim;
			const {dim} = ___R$3;
			if (dim === "true") {
				return this.normalizeChild(
					___R$$priv$project$rome$$romejs$string$markup$Grid_ts$createTag(
						"dim",
						{},
						[Object.assign({}, tag, {attributes})],
					),
				);
			}

			// Insert padding
			if (tag.name === "pad") {
				const width = Number(tag.attributes.width) || 0;
				const paddingSize = width - textLength;
				if (paddingSize > 0) {
					const paddingTextNode = {
						type: "Text",
						value: " ".repeat(paddingSize),
					};
					if (tag.attributes.align === "right") {
						return [paddingTextNode, ...tag.children];
					} else {
						return [...tag.children, paddingTextNode];
					}
				} else {
					return tag.children;
				}
			}

			// Insert highlight legend
			if (tag.name === "highlight") {
				const ___R$4 = attributes;
				const attributesWithoutLegend = Object.assign({}, ___R$4);
				delete attributesWithoutLegend.legend;
				const {legend} = ___R$4;
				const index = Math.min(0, Number(attributes.i) || 0);
				if (legend === "true") {
					return [
						Object.assign({}, tag, {attributes: attributesWithoutLegend}),
						___R$$priv$project$rome$$romejs$string$markup$Grid_ts$createTag(
							"dim",
							{},
							[
								{
									type: "Text",
									value: "[" + String(index + 1) + "]",
								},
							],
						),
					];
				}
			}

			if (hasText) {
				// Wrap hr text in spaces
				if (tag.name === "hr") {
					return [
						Object.assign(
							{},
							tag,
							{
								children: [
									{
										type: "Text",
										value: " ",
									},
									...children,
									{
										type: "Text",
										value: " ",
									},
								],
							},
						),
					];
				}
			} else {
				if (tag.name === "filelink") {
					return [
						Object.assign(
							{},
							tag,
							{
								children: [
									{
										type: "Text",
										value: ___R$project$rome$$romejs$string$markup$tagFormatters_ts$getFileLinkText(
											___R$project$rome$$romejs$string$markup$tagFormatters_ts$getFileLinkFilename(
												tag.attributes,
												this.markupOptions,
											),
											tag.attributes,
											this.markupOptions,
										),
									},
								],
							},
						),
					];
				} else if (tag.name === "hyperlink") {
					return [
						Object.assign(
							{},
							tag,
							{children: [{type: "Text", value: tag.attributes.target || ""}]},
						),
					];
				}
			}

			// These tags only expect text inside off them
			const singleInnerText =
				children.length === 1 && children[0].type === "Text"
					? children[0].value
					: undefined;
			if (singleInnerText !== undefined) {
				switch (tag.name) {
					case "filesize":
						return [
							{
								type: "Text",
								value: ___R$project$rome$$romejs$string$utils$humanizeFileSize_ts$humanizeFileSize(
									Number(singleInnerText),
								),
							},
						];

					case "duration":
						return [
							{
								type: "Text",
								value: ___R$project$rome$$romejs$string$markup$tagFormatters_ts$formatApprox(
									attributes,
									___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(
										Number(singleInnerText),
										true,
									),
								),
							},
						];

					case "number":
						return [
							{
								type: "Text",
								value: ___R$project$rome$$romejs$string$markup$tagFormatters_ts$formatNumber(
									attributes,
									singleInnerText,
								),
							},
						];

					case "grammarNumber":
						return [
							{
								type: "Text",
								value: ___R$project$rome$$romejs$string$markup$tagFormatters_ts$formatGrammarNumber(
									attributes,
									singleInnerText,
								),
							},
						];
				}
			}

			return [Object.assign({}, tag, {children})];
		}
	}

	function ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$getChildrenTextLength(
		children,
	) {
		let length = 0;

		for (const child of children) {
			if (child.type === "Text") {
				length += child.value.length;
			}

			if (child.type === "Tag") {
				length += ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$getChildrenTextLength(
					child.children,
				);
			}
		}

		return length;
	}

	const ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$hooks = new Map();

	___R$$priv$project$rome$$romejs$string$markup$Grid_ts$hooks.set(
		"hr",
		{
			after: (tag, grid, ancestry) => {
				const size =
					grid.viewportWidth === undefined
						? 100
						: ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(grid.viewportWidth) -
							___R$project$rome$$romejs$ob1$index_ts$ob1Get1(grid.cursor.column) +
							1;
				grid.writeText("\u2501".repeat(size), ancestry);
			},
		},
	);

	function ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$ansiFormatText(
		{name: tagName, attributes},
		value,
		opts,
	) {
		switch (tagName) {
			case "hyperlink": {
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.hyperlink(
					attributes.target || "",
					value,
				);
			}

			case "filelink": {
				const filename = ___R$project$rome$$romejs$string$markup$tagFormatters_ts$getFileLinkFilename(
					attributes,
					opts,
				);
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.hyperlink(
					value,
					"file://" + filename,
				);
			}

			case "inverse":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.inverse(
					" " + value + " ",
				);

			case "emphasis":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bold(
					value,
				);

			case "dim":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.dim(
					value,
				);

			case "italic":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.italic(
					value,
				);

			case "underline":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.underline(
					value,
				);

			case "strike":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.strikethrough(
					value,
				);

			case "error":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.red(
					value,
				);

			case "success":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.green(
					value,
				);

			case "warn":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.yellow(
					value,
				);

			case "info":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.blue(
					value,
				);

			case "command":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.italic(
					value,
				);

			case "highlight": {
				const index = Math.min(0, Number(attributes.i) || 0);
				const fn = ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$ansiHighlightFactories[index %
				___R$$priv$project$rome$$romejs$string$markup$Grid_ts$ansiHighlightFactories.length];
				return fn(value);
			}

			case "color":
				return ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$formatAnsiBackground(
					attributes.bg,
					___R$$priv$project$rome$$romejs$string$markup$Grid_ts$formatAnsiForeground(
						attributes.fg,
						value,
					),
				);

			default:
				return value;
		}
	}

	// TODO fill this
	const ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$ansiHighlightFactories = [
		___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.magenta,
		___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.cyan,
	];

	function ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$formatAnsiBackground(
		bg,
		text,
	) {
		if (bg === undefined) {
			return text;
		}

		switch (bg) {
			case "black":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBlack(
					text,
				);

			case "brightBlack":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBrightBlack(
					text,
				);

			case "red":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgRed(
					text,
				);

			case "brightRed":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBrightRed(
					text,
				);

			case "green":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgGreen(
					text,
				);

			case "brightGreen":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBrightGreen(
					text,
				);

			case "yellow":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgYellow(
					text,
				);

			case "brightYellow":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBrightYellow(
					text,
				);

			case "blue":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBlue(
					text,
				);

			case "brightBlue":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBrightBlue(
					text,
				);

			case "magenta":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgMagenta(
					text,
				);

			case "brightMagenta":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBrightMagenta(
					text,
				);

			case "cyan":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgCyan(
					text,
				);

			case "brightCyan":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBrightCyan(
					text,
				);

			case "white":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgWhite(
					text,
				);

			case "brightWhite":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgBrightWhite(
					text,
				);

			default:
				return text;
		}
	}

	function ___R$$priv$project$rome$$romejs$string$markup$Grid_ts$formatAnsiForeground(
		fg,
		text,
	) {
		if (fg === undefined) {
			return text;
		}

		switch (fg) {
			case "black":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.black(
					text,
				);

			case "brightBlack":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.brightBlack(
					text,
				);

			case "red":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.red(
					text,
				);

			case "brightRed":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.brightRed(
					text,
				);

			case "green":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.green(
					text,
				);

			case "brightGreen":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.brightGreen(
					text,
				);

			case "yellow":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.yellow(
					text,
				);

			case "brightYellow":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.brightYellow(
					text,
				);

			case "blue":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.blue(
					text,
				);

			case "brightBlue":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.brightBlue(
					text,
				);

			case "magenta":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.magenta(
					text,
				);

			case "brightMagenta":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.brightMagenta(
					text,
				);

			case "cyan":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.cyan(
					text,
				);

			case "brightCyan":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.brightCyan(
					text,
				);

			case "white":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.white(
					text,
				);

			case "brightWhite":
				return ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.brightWhite(
					text,
				);

			default:
				return text;
		}
	}


  // project-rome/@romejs/string-markup/format.ts
function ___R$$priv$project$rome$$romejs$string$markup$format_ts$buildTag(
		tag,
		inner,
		opts,
	) {
		let {attributes} = tag;

		switch (tag.name) {
			case // Normalize filename of <filelink target>
			"filelink": {
				// Clone
				attributes = Object.assign({}, attributes);

				const filename = ___R$project$rome$$romejs$string$markup$tagFormatters_ts$getFileLinkFilename(
					attributes,
					opts,
				);
				const text = ___R$project$rome$$romejs$string$markup$tagFormatters_ts$getFileLinkText(
					filename,
					attributes,
					opts,
				);
				attributes.target = filename;
				if (opts.stripPositions) {
					attributes.line = undefined;
					attributes.column = undefined;
				}
				inner = text;
				break;
			}

			// We don't technically need to normalize this but it's one less tag to have to support
			// if other tools need to consume it
			case "grammarNumber":
				return ___R$project$rome$$romejs$string$markup$tagFormatters_ts$formatGrammarNumber(
					attributes,
					inner,
				);
		}

		let open = "<" + tag.name;

		// Print attributes
		for (const key in attributes) {
			const value = attributes[key];
			if (value === undefined) {
				continue;
			}

			if (value === "true") {
				open += " " + key;
			} else {
				const escapedValue = ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					value,
				);
				open += " " + key + '="' + escapedValue + '"';
			}
		}

		if (inner === "") {
			return open + " />";
		} else {
			return open + ">" + inner + "</" + tag.name + ">";
		}
	}

	function ___R$$priv$project$rome$$romejs$string$markup$format_ts$normalizeMarkupChildren(
		children,
		opts,
	) {
		// Sometimes we'll populate the inner text of a tag with no children
		if (children.length === 0) {
			return "";
		}

		let buff = "";
		for (const child of children) {
			if (child.type === "Text") {
				buff += ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					child.value,
				);
			} else if (child.type === "Tag") {
				const inner = ___R$$priv$project$rome$$romejs$string$markup$format_ts$normalizeMarkupChildren(
					child.children,
					opts,
				);
				buff += ___R$$priv$project$rome$$romejs$string$markup$format_ts$buildTag(
					child,
					inner,
					opts,
				);
			} else {
				throw new Error("Unknown child node type");
			}
		}
		return buff;
	}

	function ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainTextString(
		input,
		opts = {},
	) {
		return ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainText(
			input,
			opts,
		).lines.join("\n");
	}

	function ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainText(
		input,
		opts = {},
	) {
		const grid = new ___R$project$rome$$romejs$string$markup$Grid_ts$default(
			opts,
		);
		grid.drawRoot(
			___R$project$rome$$romejs$string$markup$parse_ts$parseMarkup(input),
		);
		return {
			width: ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(grid.getWidth()),
			lines: grid.getLines(),
		};
	}



	function ___R$project$rome$$romejs$string$markup$format_ts$markupToAnsi(
		input,
		opts = {},
	) {
		const grid = new ___R$project$rome$$romejs$string$markup$Grid_ts$default(
			opts,
		);

		grid.drawRoot(
			___R$project$rome$$romejs$string$markup$parse_ts$parseMarkup(input),
		);

		return {
			width: ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(grid.getWidth()),
			lines: grid.getFormattedLines(),
		};
	}

	function ___R$project$rome$$romejs$string$markup$format_ts$normalizeMarkup(
		input,
		opts = {},
	) {
		return ___R$$priv$project$rome$$romejs$string$markup$format_ts$normalizeMarkupChildren(
			___R$project$rome$$romejs$string$markup$parse_ts$parseMarkup(input),
			opts,
		);
	}


  // project-rome/@romejs/string-markup/index.ts



  // project-rome/@romejs/cli-reporter/ProgressBase.ts
const ___R$$priv$project$rome$$romejs$cli$reporter$ProgressBase_ts$DEFAULT_PROGRESS_OPTIONS = {
		name: undefined,
		title: undefined,
		initDelay: undefined,
		elapsed: true,
		eta: true,
		persistent: false,
	};

	class ___R$project$rome$$romejs$cli$reporter$ProgressBase_ts$default {
		constructor(reporter, opts = {}) {
			this.total = undefined;
			this.reporter = reporter;
			this.current = 0;

			this.approximateTotal = false;
			this.approximateETA = undefined;

			this.textStack = [];
			this.text = undefined;
			this.title =
				opts.title === undefined ? undefined : reporter.stripMarkup(opts.title);

			this.paused = false;
			this.pausedStart = undefined;
			this.pausedElapsed = 0;

			this.opts = Object.assign(
				{},
				___R$$priv$project$rome$$romejs$cli$reporter$ProgressBase_ts$DEFAULT_PROGRESS_OPTIONS,
				opts,
			);
		}

		setCurrent(current) {
			this.current = current;
			this.queueRender();

			// Progress complete
			if (
				this.total !== undefined &&
				this.current >= this.total &&
				!this.opts.persistent
			) {
				this.end();
			}
		}

		getText() {
			const {text} = this;
			if (text === undefined || text === "") {
				return undefined;
			} else {
				return this.reporter.stripMarkup(text);
			}
		}

		setText(text) {
			this.text = text;
			this.queueRender();
		}

		setApproximateETA(duration) {
			this.approximateETA = duration;
		}

		setTotal(total, approximate = false) {
			this.total = total;
			this.approximateTotal = approximate;
			this.queueRender();
		}

		pushText(text) {
			this.setText(text);
			this.textStack.push(text);
		}

		popText(text) {
			// Find
			const {textStack} = this;
			const index = textStack.indexOf(text);
			if (index === -1) {
				throw new Error("No pushed text: " + text);
			}

			// Remove
			textStack.splice(index, 1);

			// Set last
			const last = textStack[textStack.length - 1];
			this.setText(last === undefined ? "" : last);
		}

		tick() {
			this.setCurrent(this.current + 1);
		}

		resume() {
			if (!this.paused || this.pausedStart === undefined) {
				return;
			}

			this.pausedElapsed += Date.now() - this.pausedStart;
			this.pausedStart = undefined;
			this.paused = false;
			this.render();
		}

		pause() {
			if (this.paused) {
				return;
			}

			this.pausedStart = Date.now();
			this.paused = true;
			this.render();
		}

		queueRender() {
			this.render();
		}

		end() {}

		render() {}
	}


  // project-rome/@romejs/cli-reporter/Progress.ts



	// 30 columns a second
	const ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL =
		1_000 / 30;
	const ___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH = 20;

	class ___R$project$rome$$romejs$cli$reporter$Progress_ts$default
		extends ___R$project$rome$$romejs$cli$reporter$ProgressBase_ts$default {
		constructor(reporter, opts = {}, onEnd) {
			super(reporter, opts);

			this.startTime = Date.now();
			this.lastRenderTime = Date.now();
			this.lastRenderCurrent = 0;

			this.closed = false;
			this.onEnd = onEnd;

			this.delay = 60;
			this.renderEvery = 0;

			this.streamToBouncerStart = new Map();
			this.startBouncer();

			this.queueRender(opts.initDelay);
			this.initName(opts.name);
		}

		initName(name) {
			if (name === undefined) {
				return;
			}

			// TODO fetch approximate total and eta based on `name`
		}

		processRemoteClientMessage(msg) {
			switch (msg.type) {
				case "PROGRESS_SET_CURRENT":
					return this.setCurrent(msg.current);

				case "PROGRESS_SET_TOTAL":
					return this.setTotal(msg.total, msg.approximate);

				case "PROGRESS_SET_TEXT":
					return this.setText(msg.text);

				case "PROGRESS_PUSH_TEXT":
					return this.pushText(msg.text);

				case "PROGRESS_POP_TEXT":
					return this.popText(msg.text);

				case "PROGRESS_SET_APPROXIMATE_ETA":
					return this.setApproximateETA(msg.duration);

				case "PROGRESS_TICK":
					return this.tick();

				case "PROGRESS_END":
					return this.end();

				case "PROGRESS_RESUME":
					return this.resume();

				case "PROGRESS_PAUSE":
					return this.pause();
			}
		}

		getElapsedTime() {
			return Date.now() - this.startTime - this.pausedElapsed;
		}

		getBouncerPosition(stream) {
			const start = this.streamToBouncerStart.get(stream);
			if (start === undefined) {
				return 0;
			} else {
				return start;
			}
		}

		startBouncer() {
			const queueTick = () => {
				this.bouncerTimer = setTimeout(
					tick,
					___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL,
				);
			};

			const tick = this.reporter.wrapCallback(() => {
				if (this.paused) {
					queueTick();
					return;
				}

				const elapsedTime = this.getElapsedTime();
				const elapsedFrames = Math.round(
					elapsedTime /
					___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_INTERVAL,
				);

				for (const stream of this.reporter.streams) {
					// We remove the bouncer width from the total columns since we'll append it
					const width =
						stream.columns -
						___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH;

					// Position to place the bouncer
					let position = elapsedFrames % width;

					// Every odd complete bounce should reverse direction
					const totalBounces = Math.floor(elapsedFrames / width);
					if (totalBounces % 2 === 1) {
						position = width - position;
					}

					this.streamToBouncerStart.set(stream, position);
				}

				queueTick();
				this.render();
			});

			queueTick();
		}

		setCurrent(current) {
			if (this.closed) {
				return;
			}

			super.setCurrent(current);

			if (this.isRenderDue()) {
				this.render();
			}
		}

		setTotal(total, approximate = false) {
			super.setTotal(total, approximate);
			this.renderEvery = Math.round(total / 100);
			this.endBouncer();
		}

		setText(text) {
			if (this.closed) {
				return;
			}

			super.setText(text);
		}

		queueRender(delay = this.delay) {
			if (this.closed) {
				// Progress bar has been removed
				return;
			}

			if (this.renderTimer !== undefined) {
				// Render already queued
				return;
			}

			this.renderTimer = setTimeout(
				this.reporter.wrapCallback(() => {
					this.render();
				}),
				delay,
			);
		}

		endBouncer() {
			if (this.bouncerTimer !== undefined) {
				clearTimeout(this.bouncerTimer);
			}
			this.bouncerTimer = undefined;
		}

		endRender() {
			if (this.renderTimer !== undefined) {
				clearTimeout(this.renderTimer);
			}
			this.renderTimer = undefined;
		}

		end() {
			this.closed = true;
			this.endBouncer();
			this.endRender();
			this.reporter.clearLineAll();

			if (this.onEnd !== undefined) {
				this.onEnd();
			}
		}

		// Ensure that we update the progress bar after a certain amount of ticks

		// This allows us to use the progress bar for sync work where the event loop is always blocked
		isRenderDue() {
			const isDue = this.current > this.lastRenderCurrent + this.renderEvery;
			if (isDue) {
				// We also make sure that we never force update more often than once a second
				// This is to ensure that the progress bar isn't negatively effecting performance
				const timeSinceLastRender = Date.now() - this.lastRenderTime;
				return timeSinceLastRender > 1_000;
			} else {
				return false;
			}
		}

		isBoldCharacter(i, ranges) {
			for (const [start, end] of ranges) {
				if (start >= i && end <= i) {
					return true;
				}
			}

			return false;
		}

		splitCharacters(str, boldRanges) {
			return str.split("").map((char, i) => {
				if (this.isBoldCharacter(i, boldRanges)) {
					return [
						i,
						___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bold(
							char,
						),
					];
				} else {
					return [i, char];
				}
			});
		}

		buildProgressBouncer(stream, bar) {
			let start = this.getBouncerPosition(stream);
			let fullBar = "";
			for (const [i, char] of bar) {
				const isBounce =
					i >= start &&
					i <
					start +
					___R$$priv$project$rome$$romejs$cli$reporter$Progress_ts$BOUNCER_WIDTH;

				if (isBounce) {
					if (this.paused) {
						fullBar += ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.inverse(
							char,
						);
					} else {
						fullBar += ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.white(
							___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgYellow(
								char,
							),
						);
					}
				} else {
					fullBar += char;
				}
			}
			return fullBar;
		}

		buildProgressBar(stream, bar, total) {
			const ratio = Math.min(Math.max(this.current / total, 0), 1);

			const completeLength = Math.round(stream.columns * ratio);
			let fullBar = "";
			for (const [i, char] of bar) {
				if (i < completeLength) {
					if (this.paused) {
						fullBar += ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.inverse(
							char,
						);
					} else {
						fullBar += ___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.white(
							___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgGreen(
								char,
							),
						);
					}
				} else {
					fullBar += char;
				}
			}
			return fullBar;
		}

		buildBar(stream) {
			const {total, current, title} = this;

			// Text ranges that we should make bold
			const boldRanges = [];

			// Text to prefix to the bar
			let prefix = "";
			if (title !== undefined) {
				prefix += title;

				// Only the title should be bold, not the subtext
				boldRanges.push([0, prefix.length - 1]);
			}

			const text = this.getText();
			if (text !== undefined) {
				// Separate a title and it's text with a colon
				if (title !== undefined) {
					prefix += ": ";
				}
				prefix += text;
			}

			// Text to put at the end of the bar
			let suffix = "";

			// Total time since the progress bar was created
			const elapsed = this.getElapsedTime();

			// Time elapsed eg: elapsed 1m5s
			if (this.opts.elapsed) {
				suffix +=
					"elapsed " +
					___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(
						elapsed,
					) +
					" ";
			}

			// Don't bother with a suffix if we haven't completed a single item
			if (current > 0) {
				// How many milliseconds spent per total items
				const averagePerItem = elapsed / current;

				// ETA eg: 1m5s
				if (this.opts.eta) {
					if (this.approximateETA !== undefined && elapsed < this.approximateETA) {
						// Approximate ETA
						const left = elapsed - this.approximateETA;
						suffix +=
							"eta ~" +
							___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(
								left,
							) +
							" ";
					} else if (total !== undefined) {
						// How many items we have left
						const itemsLeft = total - current;

						// Total estimated time left
						const eta = itemsLeft * averagePerItem;
						suffix +=
							"eta " +
							___R$project$rome$$romejs$string$utils$humanizeTime_ts$humanizeTime(
								eta,
							) +
							" ";
					} else {
						const ops = Math.round(1_000 / averagePerItem);
						suffix +=
							___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
								ops,
							) + " op/s ";
					}
				}

				// Counter eg: 5/100
				suffix += ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
					current,
				);
				if (total !== undefined) {
					suffix += "/";
					if (this.approximateTotal) {
						suffix += "~";
					}
					suffix += ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
						total,
					);
				}
			}

			// Get the full width of the bar. We take off 3 for padding.
			const width = stream.columns - 3;

			// The amount of spaces to put between the title and counter
			const spacerLength = Math.max(0, width - prefix.length - suffix.length);
			const spacer = " ".repeat(spacerLength);

			// Trim the prefix if it will overflow
			prefix = prefix.slice(0, width - spacerLength - suffix.length);

			// The full raw bar without any coloring
			const raw = " " + prefix + spacer + " " + suffix;

			// Make sure the counter is bold
			boldRanges.push([raw.length - suffix.length, raw.length - 1]);

			// Split the raw bar into an array of formatted characters
			const chars = this.splitCharacters(raw, boldRanges);

			if (total === undefined) {
				return this.buildProgressBouncer(stream, chars);
			} else {
				return this.buildProgressBar(stream, chars, total);
			}
		}

		render() {
			if (this.closed) {
				return;
			}

			this.endRender();

			this.lastRenderCurrent = this.current;
			this.lastRenderTime = Date.now();

			for (const stream of this.reporter.getStreams(false)) {
				if (stream.format === "ansi") {
					stream.write(
						___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorTo(
							0,
						),
					);
					stream.write(this.buildBar(stream));
				}
			}
		}
	}


  // project-rome/@romejs/typescript-helpers/index.ts












	function ___R$project$rome$$romejs$typescript$helpers$index_ts$isPlainObject(
		obj,
	) {
		return typeof obj === "object" && obj !== null && !Array.isArray(obj);
	}

	function ___R$project$rome$$romejs$typescript$helpers$index_ts$isIterable(obj) {
		if (typeof obj === "object" && obj != null) {
			// @ts-ignore
			return typeof obj[Symbol.iterator] === "function";
		} else {
			return false;
		}
	}


  // project-rome/@romejs/string-escape/constants.ts
const ___R$project$rome$$romejs$string$escape$constants_ts = {
		get DOUBLE_QUOTE() {
			return ___R$project$rome$$romejs$string$escape$constants_ts$DOUBLE_QUOTE;
		},
		get SINGLE_QUOTE() {
			return ___R$project$rome$$romejs$string$escape$constants_ts$SINGLE_QUOTE;
		},
		get TICK_QUOTE() {
			return ___R$project$rome$$romejs$string$escape$constants_ts$TICK_QUOTE;
		},
	};
	const ___R$project$rome$$romejs$string$escape$constants_ts$DOUBLE_QUOTE = '"';
	const ___R$project$rome$$romejs$string$escape$constants_ts$SINGLE_QUOTE = "'";
	const ___R$project$rome$$romejs$string$escape$constants_ts$TICK_QUOTE = "`";


  // project-rome/@romejs/string-escape/escapeString.ts
// This regex represents printable ASCII characters, except the characters: '"\`
	const ___R$$priv$project$rome$$romejs$string$escape$escapeString_ts$PRINTABLE_ASCII = /[ !#-&\(-\[\]-_a-~]/;

	function ___R$$priv$project$rome$$romejs$string$escape$escapeString_ts$escapeChar(
		char,
		ignoreWhitespaceEscapes,
	) {
		switch (char) {
			case '"':
				return '\\"';

			case "'":
				return "\\'";

			case "\b":
				return "\\b";

			case "\f":
				return "\\f";

			case "\\":
				return "\\\\";
		}

		if (ignoreWhitespaceEscapes) {
			return undefined;
		}

		switch (char) {
			case "\n":
				return "\\n";

			case "\r":
				return "\\r";

			case "\t":
				return "\\t";
		}

		return undefined;
	}





	function ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
		str,
		opts = {},
	) {
		let index = -1;
		let result = "";

		const {
			ignoreWhitespaceEscapes = false,
			quote = "",
			json = false,
			unicodeOnly = false,
		} = opts;

		// Loop over each code unit in the string and escape it
		while (++index < str.length) {
			const char = str[index];

			// Handle surrogate pairs in non-JSON mode
			if (!json) {
				const charCode = str.charCodeAt(index);
				const isHighSurrogate = charCode >= 55_296 && charCode <= 56_319;
				const hasNextCodePoint = str.length > index + 1;
				const isSurrogatePairStart = isHighSurrogate && hasNextCodePoint;

				if (isSurrogatePairStart) {
					const nextCharCode = str.charCodeAt(index + 1);
					const isLowSurrogate =
						nextCharCode >= 56_320 && nextCharCode <= 57_343;
					if (isLowSurrogate) {
						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
						const codePoint =
							(charCode - 55_296) * 1_024 + nextCharCode - 56_320 + 65_536;
						const hex = codePoint.toString(16);
						result += "\\u{" + hex + "}";
						index++;
						continue;
					}
				}
			}

			//
			if (
				___R$$priv$project$rome$$romejs$string$escape$escapeString_ts$PRINTABLE_ASCII.test(
					char,
				)
			) {
				// It’s a printable ASCII character that is not `"`, `'` or `\`,
				// so don’t escape it.
				result += char;
				continue;
			}

			// Escape double quotes
			if (
				char ===
				___R$project$rome$$romejs$string$escape$constants_ts$DOUBLE_QUOTE
			) {
				result += quote === char ? '\\"' : char;
				continue;
			}

			// Escape single quotes
			if (
				char ===
				___R$project$rome$$romejs$string$escape$constants_ts$SINGLE_QUOTE
			) {
				result += quote === char ? "\\'" : char;
				continue;
			}

			// Escape back tick
			if (
				char ===
				___R$project$rome$$romejs$string$escape$constants_ts$TICK_QUOTE
			) {
				result += quote === char ? "\\`" : char;
				continue;
			}

			// Null escape
			if (
				char === "\0" &&
				!json &&
				!___R$project$rome$$romejs$parser$core$index_ts$isDigit(str[index + 1])
			) {
				result += "\\0";
				continue;
			}

			// Simple escapes
			if (!unicodeOnly) {
				const replacement = ___R$$priv$project$rome$$romejs$string$escape$escapeString_ts$escapeChar(
					char,
					ignoreWhitespaceEscapes,
				);
				if (replacement !== undefined) {
					result += replacement;
					continue;
				}
			}

			// Unicode escape
			const hex = char.charCodeAt(0).toString(16);
			const isLonghand = json || hex.length > 2;
			const modifier = isLonghand ? "u" : "x";
			const code = ("0000" + hex).slice(isLonghand ? -4 : -2);
			const escaped = "\\" + modifier + code;
			result += escaped;
			continue;
		}

		return "" + quote + result + quote;
	}


  // project-rome/@romejs/string-escape/unescapeString.ts
function ___R$$priv$project$rome$$romejs$string$escape$unescapeString_ts$unescapeChar(
		modifier,
	) {
		switch (modifier) {
			case "b":
				return "\b";

			case "f":
				return "\f";

			case "n":
				return "\n";

			case "r":
				return "\r";

			case "t":
				return "\t";

			case "v":
				return "\x0b";

			default:
				return modifier;
		}
	}



	const ___R$$priv$project$rome$$romejs$string$escape$unescapeString_ts$UNEXPECTED_DEFAULT_THROWER = (
		metadata,
		index,
	) => {
		throw new TypeError(metadata.message.value + " (" + String(index) + ")");
	};

	function ___R$project$rome$$romejs$string$escape$unescapeString_ts$default(
		input,
		unexpected = ___R$$priv$project$rome$$romejs$string$escape$unescapeString_ts$UNEXPECTED_DEFAULT_THROWER,
	) {
		let buffer = "";

		let index = 0;

		while (index < input.length) {
			const char = input[index];
			const prevChar = input[index - 1];
			const prevPrevChar = input[index - 2];
			const isEscaped = prevChar === "\\" && prevPrevChar !== "\\";

			// It's verbatim if it's an escaped backslash or not a backslash
			if ((isEscaped && char === "\\") || char !== "\\") {
				// Validate that this is a valid character
				const codePoint = char.codePointAt(0);
				if (codePoint === undefined) {
					throw new Error("Already validated that this index exists");
				}
				if (codePoint >= 0 && codePoint <= 31) {
					throw unexpected(
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_ESCAPE.INVALID_STRING_CHARACTER,
						index,
					);
				}

				// Add it verbatim
				buffer += char;
				index++;
				continue;
			}

			const modifierIndex = index + 1;
			const modifier = input[modifierIndex];

			if (modifier === "u") {
				// Get the next 4 characters as the code point
				const codeStartIndex = modifierIndex + 1;
				const rawCode = input.slice(codeStartIndex, codeStartIndex + 4);

				// Validate that we have at least 4 digits
				if (rawCode.length < 4) {
					// (index of the point start + total point digits)
					const lastDigitIndex = codeStartIndex + rawCode.length - 1;
					throw unexpected(
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_ESCAPE.NOT_ENOUGH_CODE_POINTS,
						lastDigitIndex,
					);
				}

				// Validate that each character is a valid hex digit
				for (let i = 0; i < rawCode.length; i++) {
					const char = rawCode[i];
					if (!___R$project$rome$$romejs$parser$core$index_ts$isHexDigit(char)) {
						// Get the current source index for this character
						// (code start index + digit index)
						const pos = codeStartIndex + i;
						throw unexpected(
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.STRING_ESCAPE.INVALID_HEX_DIGIT_FOR_ESCAPE,
							pos,
						);
					}
				}

				// Validate the code point
				const code = parseInt(rawCode, 16);

				// Get the character for this code point
				buffer += String.fromCodePoint(code);

				// Skip ahead six indexes (1 escape char +  1modifier + 4 hex digits)
				index += 6;
			} else {
				// Unescape a basic modifier like \t
				buffer += ___R$$priv$project$rome$$romejs$string$escape$unescapeString_ts$unescapeChar(
					modifier,
				);

				// Skip ahead two indexes to also take along the modifier
				index += 2;
			}
		}

		return buffer;
	}


  // project-rome/@romejs/string-escape/index.ts



  // project-rome/@romejs/pretty-format/index.ts






	const ___R$$priv$project$rome$$romejs$pretty$format$index_ts$DEFAULT_OPTIONS = {
		maxDepth: Infinity,
		markup: false,
		indent: "",
		depth: 0,
		stack: [],
		compact: false,
	};

	const ___R$$priv$project$rome$$romejs$pretty$format$index_ts$INDENT = "\t";

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(
		str,
		opts,
	) {
		if (opts.markup) {
			return ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(str);
		} else {
			return str;
		}
	}

	const ___R$project$rome$$romejs$pretty$format$index_ts$CUSTOM_PRETTY_FORMAT = Symbol();

	function ___R$project$rome$$romejs$pretty$format$index_ts$default(
		obj,
		rawOpts = {},
	) {
		const opts = Object.assign(
			{},
			___R$$priv$project$rome$$romejs$pretty$format$index_ts$DEFAULT_OPTIONS,
			rawOpts,
		);

		if (opts.maxDepth === opts.depth) {
			return "[depth exceeded]";
		}

		switch (typeof obj) {
			case "symbol": {
				const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(
					___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatSymbol(
						obj,
					),
					opts,
				);
				return opts.markup
					? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							val,
							{fg: "green"},
						)
					: val;
			}

			case "string": {
				const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(
					___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatString(
						obj,
					),
					opts,
				);
				return opts.markup
					? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							val,
							{fg: "green"},
						)
					: val;
			}

			case "bigint":
			case "number": {
				const val = ___R$project$rome$$romejs$pretty$format$index_ts$formatNumber(
					obj,
				);
				return opts.markup
					? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							val,
							{fg: "yellow"},
						)
					: val;
			}

			case "boolean": {
				const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatBoolean(
					obj,
				);
				return opts.markup
					? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							val,
							{fg: "yellow"},
						)
					: val;
			}

			case "undefined": {
				const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatUndefined();
				return opts.markup
					? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							val,
							{fg: "brightBlack"},
						)
					: val;
			}

			case "function":
				return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatFunction(
					obj,
					opts,
				);

			case "object":
				return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObjectish(
					(obj),
					opts,
				);

			default:
				throw new Error("Unknown type");
		}
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$joinList(
		items,
		opts,
	) {
		if (items.length === 0) {
			return "";
		}

		const lines = [];

		for (const item of items) {
			lines.push("" + opts.indent + item);
		}

		return lines.join("\n");
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$isNativeFunction(
		val,
	) {
		return val.toString().endsWith("{ [native code] }");
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatSymbol(
		val,
	) {
		return String(val);
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatString(
		val,
	) {
		return ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
			val,
			{
				quote: '"',
			},
		);
	}

	// This function is used by rome-json so make sure it can parse whatever you return here
	function ___R$project$rome$$romejs$pretty$format$index_ts$formatNumber(val) {
		if (typeof val === "bigint") {
			return ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
				val,
				"_",
			);
		} else if (isNaN(val)) {
			return "NaN";
		} else if (Object.is(val, -0)) {
			return "-0";
		} else if (isFinite(val)) {
			return ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
				val,
				"_",
			);
		} else if (Object.is(val, -Infinity)) {
			return "-Infinity";
		} else if (Object.is(val, +Infinity)) {
			return "Infinity";
		} else {
			throw new Error("Don't know how to format this number");
		}
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatUndefined() {
		return "undefined";
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatNull() {
		return "null";
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatBoolean(
		val,
	) {
		return val === true ? "true" : "false";
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatFunction(
		val,
		opts,
	) {
		const name =
			val.name === ""
				? "anonymous"
				: ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(
						val.name,
						opts,
					);
		let label = "Function " + name;

		if (
			___R$$priv$project$rome$$romejs$pretty$format$index_ts$isNativeFunction(
				val,
			)
		) {
			label = "Native" + label;
		}

		if (Object.keys(val).length === 0) {
			return label;
		}

		// rome-ignore lint/js/noExplicitAny
		return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObject(
			label,
			(val),
			opts,
			[],
		);
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$getExtraObjectProps(
		obj,
		opts,
	) {
		const props = [];
		const ignoreKeys = {};

		if (obj instanceof Map) {
			for (const [key, val] of obj) {
				const formattedKey =
					typeof key === "string"
						? ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatKey(
								key,
								opts,
							)
						: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								key,
								opts,
							);
				props.push(
					formattedKey +
					" => " +
					___R$project$rome$$romejs$pretty$format$index_ts$default(val, opts),
				);
			}
		} else if (
			___R$project$rome$$romejs$typescript$helpers$index_ts$isIterable(obj)
		) {
			let i = 0;
			for (const val of obj) {
				ignoreKeys[String(i++)] = val;
				props.push(
					___R$project$rome$$romejs$pretty$format$index_ts$default(val, opts),
				);
			}
		}

		return {ignoreKeys, props};
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatKey(
		rawKey,
		opts,
	) {
		const key = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(
			rawKey,
			opts,
		);

		// Format as a string if it contains any special characters
		if (/[^A-Za-z0-9_$]/g.test(key)) {
			return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatString(
				key,
			);
		} else {
			return key;
		}
	}

	// These are object keys that should always go at the top and ignore any alphabetization
	// This is fairly arbitrary but should include generic identifier keys
	const ___R$project$rome$$romejs$pretty$format$index_ts$PRIORITIZE_KEYS = [
		"id",
		"type",
		"kind",
		"key",
		"name",
		"value",
	];



	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$sortKeys(obj) {
		const sortedKeys = new Set(
			Object.keys(obj).sort(
				___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare,
			),
		);

		const priorityKeys = [];
		const otherKeys = [];
		const objectKeys = [];

		for (const key of ___R$project$rome$$romejs$pretty$format$index_ts$PRIORITIZE_KEYS) {
			if (sortedKeys.has(key)) {
				priorityKeys.push({key, object: false});
				sortedKeys.delete(key);
			}
		}

		for (const key of sortedKeys) {
			const val = obj[key];

			// Objects with properties should be at the bottom
			let isObject = false;
			if (typeof val === "object" && val != null && Object.keys(val).length > 0) {
				isObject = true;
			}
			if (Array.isArray(val) && val.length > 0) {
				isObject = true;
			}
			if (isObject) {
				objectKeys.push({key, object: true});
			} else {
				otherKeys.push({key, object: false});
			}
		}

		return [...priorityKeys, ...otherKeys, ...objectKeys];
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCount(str) {
		return str.split("\n").length;
		___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatKey;
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCountCompare(
		a,
		b,
	) {
		return (
			___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCount(a) -
			___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCount(b)
		);
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObject(
		label,
		obj,
		opts,
		labelKeys,
	) {
		// Detect circular references, and create a pointer to the specific value
		const {stack} = opts;
		if (stack.length > 0 && stack.includes(obj)) {
			label = "Circular " + label + " " + stack.indexOf(obj);
			return opts.markup
				? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
						"color",
						label,
						{fg: "cyan"},
					)
				: label;
		}

		//
		const nextOpts = Object.assign(
			{},
			opts,
			{
				stack: [...stack, obj],
				depth: opts.depth + 1,
				indent: opts.indent +
				___R$$priv$project$rome$$romejs$pretty$format$index_ts$INDENT,
			},
		);
		const {ignoreKeys, props} = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$getExtraObjectProps(
			obj,
			nextOpts,
		);

		// For props that have object values, we always put them at the end, sorted by line count
		const objProps = [];

		// Get string props
		for (const {key, object} of ___R$$priv$project$rome$$romejs$pretty$format$index_ts$sortKeys(
			obj,
		)) {
			const val = obj[key];
			if (key in ignoreKeys && ignoreKeys[key] === val) {
				continue;
			}

			if (opts.compact && val === undefined) {
				continue;
			}

			// Ignore any properties already displayed in the label
			if (labelKeys.includes(key)) {
				continue;
			}

			const prop =
				___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatKey(
					key,
					opts,
				) +
				": " +
				___R$project$rome$$romejs$pretty$format$index_ts$default(val, nextOpts);
			if (object) {
				objProps.push(prop);
			} else {
				props.push(prop);
			}
		}

		// Sort object props by line count and push them on
		for (const prop of objProps.sort(
			___R$$priv$project$rome$$romejs$pretty$format$index_ts$lineCountCompare,
		)) {
			props.push(prop);
		}

		// Get symbol props
		for (const sym of Object.getOwnPropertySymbols(obj)) {
			const val = Reflect.get(obj, sym);
			props.push(
				___R$project$rome$$romejs$pretty$format$index_ts$default(sym, opts) +
				": " +
				___R$project$rome$$romejs$pretty$format$index_ts$default(val, nextOpts),
			);
		}

		//
		let open = "{";
		let close = "}";
		if (___R$project$rome$$romejs$typescript$helpers$index_ts$isIterable(obj)) {
			open = "[";
			close = "]";
		}

		//
		let inner = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$joinList(
			props,
			nextOpts,
		);
		if (inner !== "") {
			if (props.length === 1 && !inner.includes("\n")) {
				// Single prop with no newlines shouldn't be indented
				inner = inner.trim();
			} else {
				inner = "\n" + inner + "\n" + opts.indent;
			}
		}

		label = opts.markup
			? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
					"color",
					label,
					{fg: "cyan"},
				)
			: label;
		return label + " " + open + inner + close;
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatRegExp(
		val,
	) {
		return String(val);
	}

	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatDate(
		val,
	) {
		return val.toISOString();
	}



	function ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObjectish(
		val,
		opts,
	) {
		if (val === null) {
			const val = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatNull();
			return opts.markup
				? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
						"emphasis",
						val,
					)
				: val;
		}

		if (val instanceof RegExp) {
			const str = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatRegExp(
				val,
			);
			return opts.markup
				? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
						"color",
						str,
						{fg: "red"},
					)
				: str;
		}

		if (val instanceof Date) {
			const str = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatDate(
				val,
			);
			return opts.markup
				? ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
						"color",
						str,
						{fg: "magenta"},
					)
				: str;
		}

		let label = "null";

		if (val.constructor !== undefined) {
			label = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(
				val.constructor.name,
				opts,
			);
		}

		let labelKeys = [];

		// If there's a string type or kind property then use it as the label
		if (typeof val.type === "string") {
			label = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(
				val.type,
				opts,
			);
			labelKeys.push("type");
		} else if (typeof val.kind === "string") {
			label = ___R$$priv$project$rome$$romejs$pretty$format$index_ts$maybeEscapeMarkup(
				val.kind,
				opts,
			);
			labelKeys.push("kind");
		}

		return ___R$$priv$project$rome$$romejs$pretty$format$index_ts$formatObject(
			label,
			val,
			opts,
			labelKeys,
		);
	}


  // project-rome/@romejs/events/Event.ts


	function ___R$$priv$project$rome$$romejs$events$Event_ts$noPromise(ret) {
		if (ret instanceof Promise) {
			throw new Error("Subscription returned promise for a callSync");
		} else {
			return ret;
		}
	}

	class ___R$project$rome$$romejs$events$Event_ts$default {
		constructor(opts) {
			this.subscriptions = new Set();
			this.rootSubscription = undefined;
			this.name = opts.name;
			this.options = opts;
		}

		onSubscriptionChange() {
			// Hook for BridgeEvent
		}

		onError(err) {
			const {onError} = this.options;
			if (onError !== undefined) {
				onError(err);
			}
		}

		clear() {
			this.subscriptions.clear();
		}

		hasSubscribers() {
			return this.hasSubscriptions();
		}

		hasSubscriptions() {
			return this.rootSubscription !== undefined;
		}

		// Dispatch the event without caring about the return values
		send(param) {
			const {rootSubscription} = this;
			if (rootSubscription === undefined) {
				return;
			}

			rootSubscription(param);

			for (const callback of this.subscriptions) {
				callback(param);
			}
		}

		callSync(param) {
			try {
				const {rootSubscription, subscriptions} = this;
				if (rootSubscription === undefined) {
					throw new Error("No subscription for event " + this.name);
				}

				const ret = ___R$$priv$project$rome$$romejs$events$Event_ts$noPromise(
					rootSubscription(param),
				);
				for (const callback of subscriptions) {
					___R$$priv$project$rome$$romejs$events$Event_ts$noPromise(
						callback(param),
					);
				}
				return ret;
			} catch (err) {
				this.onError(err);
				throw err;
			}
		}

		async call(param) {
			const {rootSubscription, subscriptions} = this;
			if (rootSubscription === undefined) {
				throw new Error("No subscription for event " + this.name);
			}

			try {
				if (this.options.serial === true) {
					const ret = await rootSubscription(param);
					for (const callback of subscriptions) {
						await callback(param);
					}
					return ret;
				} else {
					const res = await Promise.all([
						rootSubscription(param),
						...Array.from(subscriptions, (callback) => callback(param)),
					]);

					// Return the root subscription value
					return res[0];
				}
			} catch (err) {
				this.onError(err);
				throw err;
			}
		}

		wait(val, timeout) {
			return new Promise((resolve, reject) => {
				let timeoutId;
				let timedOut = false;

				if (timeout !== undefined) {
					timeoutId = setTimeout(
						() => {
							timedOut = true;
							listener.unsubscribe();
							reject(
								new Error(
									"Timed out after waiting " + timeout + "ms for " + this.name,
								),
							);
						},
						timeout,
					);
				}

				const listener = this.subscribe((param) => {
					if (timedOut) {
						return val;
					}

					if (timeoutId !== undefined) {
						clearTimeout(timeoutId);
					}

					listener.unsubscribe();
					resolve(param);
					return val;
				});
			});
		}

		async callOptional(param) {
			if (this.rootSubscription === undefined) {
				return undefined;
			} else {
				return this.call(param);
			}
		}

		subscribe(callback, makeRoot) {
			if (this.options.unique === true && this.subscriptions.size !== 0) {
				throw new Error(
					"Event " + this.name + " only allows a single subscription",
				);
			}

			if (this.rootSubscription === callback || this.subscriptions.has(callback)) {
				throw new Error("Cannot double subscribe a callback");
			}

			if (this.rootSubscription === undefined) {
				this.rootSubscription = callback;
			} else if (makeRoot === true) {
				this.subscriptions.add(this.rootSubscription);
				this.rootSubscription = callback;
			} else {
				this.subscriptions.add(callback);
			}

			this.onSubscriptionChange();

			return {
				unsubscribe: () => {
					this.unsubscribe(callback);
				},
			};
		}

		unsubscribe(callback) {
			if (this.subscriptions.has(callback)) {
				this.subscriptions.delete(callback);
				this.onSubscriptionChange();
				return;
			}

			// If this callback was the root subscription, then set it to the next one
			if (callback === this.rootSubscription) {
				this.rootSubscription = Array.from(this.subscriptions)[0];
				this.onSubscriptionChange();
				return;
			}
		}
	}


  // project-rome/@romejs/events/BridgeError.ts
class ___R$project$rome$$romejs$events$BridgeError_ts$default extends Error {
		constructor(message, bridge) {
			super(message);
			this.bridge = bridge;
		}
	}


  // project-rome/@romejs/events/BridgeEvent.ts






	function ___R$$priv$project$rome$$romejs$events$BridgeEvent_ts$validateDirection(
		// rome-ignore lint/js/noExplicitAny
		event,
		invalidDirections,
		verb,
	) {
		invalidDirections.push(["server<->client", "server&client"]);

		for (const [eventDirection, bridgeType] of invalidDirections) {
			if (event.direction === eventDirection && event.bridge.type === bridgeType) {
				throw new Error(
					"The " +
					eventDirection +
					' event "' +
					event.name +
					'" cannot be ' +
					verb +
					" by a " +
					bridgeType +
					" bridge",
				);
			}
		}
	}

	class ___R$project$rome$$romejs$events$BridgeEvent_ts$default
		extends ___R$project$rome$$romejs$events$Event_ts$default {
		constructor(opts, bridge) {
			super(opts);

			this.bridge = bridge;
			this.requestCallbacks = new Map();
			this.direction = opts.direction;
		}

		clear() {
			super.clear();
			this.requestCallbacks.clear();
		}

		end(err) {
			for (const {reject} of this.requestCallbacks.values()) {
				reject(err);
			}
		}

		onSubscriptionChange() {
			___R$$priv$project$rome$$romejs$events$BridgeEvent_ts$validateDirection(
				this,
				[["server->client", "client"], ["server<-client", "server"]],
				"subscribed",
			);
			this.bridge.sendSubscriptions();
		}

		dispatchRequest(param) {
			return super.call(param);
		}

		dispatchResponse(id, data) {
			const callbacks = this.requestCallbacks.get(id);
			if (!callbacks) {
				// ???
				return;
			}

			this.requestCallbacks.delete(id);

			if (data.responseStatus === "success") {
				// @ts-ignore
				callbacks.resolve(data.value);
			} else if (data.responseStatus === "error") {
				try {
					callbacks.reject(this.bridge.buildError(data.value, data.metadata));
				} catch (err) {
					callbacks.reject(err);
				}
			} else {
				// ???
			}

			if (callbacks.completed !== undefined) {
				callbacks.completed();
			}
		}

		hasSubscribers() {
			return this.bridge.listeners.has(this.name);
		}

		validateCanSend() {
			___R$$priv$project$rome$$romejs$events$BridgeEvent_ts$validateDirection(
				this,
				[["server<-client", "client"], ["server->client", "server"]],
				"called",
			);
		}

		send(param) {
			if (!this.hasSubscribers()) {
				// No point in sending over a subscription that doesn't have a listener
				return;
			}

			this.validateCanSend();
			this.bridge.assertAlive();
			this.bridge.sendMessage({
				type: "request",
				event: this.name,
				param,
				priority: false,
			});
		}

		async call(param, opts = {}) {
			const {priority = false, timeout} = opts;
			this.validateCanSend();

			try {
				return await new Promise((resolve, reject) => {
					this.bridge.assertAlive();

					const id = this.bridge.getNextMessageId();

					let completed;
					if (timeout !== undefined) {
						const timeoutId = setTimeout(
							() => {
								// Remove the request callback
								this.requestCallbacks.delete(id);

								// Reject the promise
								reject(
									new ___R$project$rome$$romejs$events$BridgeError_ts$default(
										"Timeout of " +
										String(timeout) +
										"ms for " +
										this.name +
										"(" +
										String(JSON.stringify(param)) +
										") event exceeded",
										this.bridge,
									),
								);
							},
							timeout,
						);

						// Cancel the timeout if the response returns before the timer
						completed = () => {
							clearTimeout(timeoutId);
						};
					}

					this.requestCallbacks.set(
						id,
						{
							completed,
							reject,
							resolve,
						},
					);

					this.bridge.sendMessage({
						id,
						event: this.name,
						param,
						type: "request",
						priority,
					});
				});
			} catch (err) {
				this.onError(err);
				throw err;
			}
		}
	}


  // project-rome/@romejs/codec-source-map/base64.ts
const ___R$project$rome$$romejs$codec$source$map$base64_ts = {
		encode: ___R$project$rome$$romejs$codec$source$map$base64_ts$encode,
		encodeVLQ: ___R$project$rome$$romejs$codec$source$map$base64_ts$encodeVLQ,
		decode: ___R$project$rome$$romejs$codec$source$map$base64_ts$decode,
		decodeVLQ: ___R$project$rome$$romejs$codec$source$map$base64_ts$decodeVLQ,
	};
	/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from 'this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

	const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$intToCharMap = Array.from(
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	);

	/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
	function ___R$project$rome$$romejs$codec$source$map$base64_ts$encode(number) {
		if (
			0 <= number &&
			number <
			___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$intToCharMap.length
		) {
			return ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$intToCharMap[number];
		} else {
			throw new TypeError("Must be between 0 and 63: " + number);
		}
	}

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011
	const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT = 5;

	// binary: 100000
	const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE =
		1 <<
		___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;

	// binary: 011111
	const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK =
		___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE - 1;

	// binary: 100000
	const ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT = ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE;

	/**
 * Converts from 'a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
	function ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$toVLQSigned(
		aValue,
	) {
		return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	}

	/**
 * Converts to a two-complement value from 'a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
	// eslint-disable-next-line no-unused-vars
	function ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$fromVLQSigned(
		value,
	) {
		const isNegative = (value & 1) === 1;
		const shifted = value >> 1;
		return isNegative ? -shifted : shifted;
	}

	/**
 * Returns the base 64 VLQ encoded value.
 */
	function ___R$project$rome$$romejs$codec$source$map$base64_ts$encodeVLQ(value) {
		let encoded = "";
		let vlq = ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$toVLQSigned(
			value,
		);

		do {
			let digit =
				vlq &
				___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK;
			vlq >>>= ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;
			if (vlq > 0) {
				// There are still more digits in this value, so we must make sure the
				// continuation bit is marked.
				digit |= ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT;
			}
			encoded += ___R$project$rome$$romejs$codec$source$map$base64_ts$encode(
				digit,
			);
		} while (vlq > 0);

		return encoded;
	}

	function ___R$project$rome$$romejs$codec$source$map$base64_ts$decode(charCode) {
		const uppercaseA = 65; // 'A'
		const uppercaseZ = 90; // 'Z'
		const lowercaseA = 97; // 'a'
		const lowercaseZ = 122; // 'z'
		const zero = 48; // '0'
		const nine = 57; // '9'
		const plus = 43; // '+'
		const slash = 47; // '/'
		const lowercaseOffset = 26;
		const numberOffset = 52;

		// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
		if (uppercaseA <= charCode && charCode <= uppercaseZ) {
			return charCode - uppercaseA;
		}

		// 26 - 51: abcdefghijklmnopqrstuvwxyz
		if (lowercaseA <= charCode && charCode <= lowercaseZ) {
			return charCode - lowercaseA + lowercaseOffset;
		}

		// 52 - 61: 0123456789
		if (zero <= charCode && charCode <= nine) {
			return charCode - zero + numberOffset;
		}

		// 62: +
		if (charCode === plus) {
			return 62;
		}

		// 63: /
		if (charCode === slash) {
			return 63;
		}

		// Invalid base64 digit.
		return -1;
	}

	function ___R$project$rome$$romejs$codec$source$map$base64_ts$decodeVLQ(
		aStr,
		aIndex,
	) {
		let strLen = aStr.length;
		let result = 0;
		let shift = 0;
		let continuation = false;

		do {
			if (aIndex >= strLen) {
				throw new Error("Expected more digits in base 64 VLQ value.");
			}

			let digit = ___R$project$rome$$romejs$codec$source$map$base64_ts$decode(
				aStr.charCodeAt(aIndex++),
			);
			if (digit === -1) {
				throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
			}

			continuation = !!(digit &
			___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_CONTINUATION_BIT);
			digit &= ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_MASK;
			result = result + (digit << shift);
			shift += ___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$VLQ_BASE_SHIFT;
		} while (continuation);

		return [
			___R$$priv$project$rome$$romejs$codec$source$map$base64_ts$fromVLQSigned(
				result,
			),
			aIndex,
		];
	}


  // project-rome/@romejs/codec-source-map/util.ts
function ___R$$priv$project$rome$$romejs$codec$source$map$util_ts$strcmp(a, b) {
		if (a === b) {
			return 0;
		}

		if (a === undefined) {
			return 1;
		}

		if (b === undefined) {
			return -1;
		}

		if (a > b) {
			return 1;
		}

		return -1;
	}

	/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
	function ___R$project$rome$$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(
		mappingA,
		mappingB,
	) {
		let cmp =
			___R$project$rome$$romejs$ob1$index_ts$ob1Get1(mappingA.generated.line) -
			___R$project$rome$$romejs$ob1$index_ts$ob1Get1(mappingB.generated.line);
		if (cmp !== 0) {
			return cmp;
		}

		cmp =
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(mappingA.generated.column) -
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(mappingB.generated.column);
		if (cmp !== 0) {
			return cmp;
		}

		cmp = ___R$$priv$project$rome$$romejs$codec$source$map$util_ts$strcmp(
			mappingA.source,
			mappingB.source,
		);
		if (cmp !== 0) {
			return cmp;
		}

		if (mappingA.original == null) {
			if (mappingB.original != null) {
				return 1;
			}
		} else if (mappingB.original == null) {
			return -1;
		} else {
			cmp =
				___R$project$rome$$romejs$ob1$index_ts$ob1Get1(mappingA.original.line) -
				___R$project$rome$$romejs$ob1$index_ts$ob1Get1(mappingB.original.line);
			if (cmp !== 0) {
				return cmp;
			}

			cmp =
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(mappingA.original.column) -
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(mappingB.original.column);
			if (cmp !== 0) {
				return cmp;
			}
		}

		return ___R$$priv$project$rome$$romejs$codec$source$map$util_ts$strcmp(
			mappingA.name,
			mappingB.name,
		);
	}

	function ___R$project$rome$$romejs$codec$source$map$util_ts$toRelativeUrl(
		root,
		path,
	) {
		if (root === "") {
			root = ".";
		}

		root = root.replace(/\/$/, "");

		// It is possible for the path to be above the root. In this case, simply

		// checking whether the root is a prefix of the path won't work. Instead, we

		// need to remove components from the root one by one, until either we find

		// a prefix that fits, or we run out of components to remove.
		let level = 0;
		while (path.indexOf(root + "/") !== 0) {
			const index = root.lastIndexOf("/");
			if (index < 0) {
				return path;
			}

			// If the only part of the root that is left is the scheme (i.e. http://,

			// file:///, etc.), one or more slashes (/), or simply nothing at all, we

			// have exhausted all components, so the path is not relative to the root.
			root = root.slice(0, index);
			if (root.match(/^([^\/]+:\/)?\/*$/)) {
				return path;
			}

			++level;
		}

		// Make sure we add a '../' for each component we removed from the root.

		return "../".repeat(level) + path.substr(root.length + 1);
	}


  // project-rome/@romejs/codec-source-map/ArraySet.ts
class ___R$project$rome$$romejs$codec$source$map$ArraySet_ts$default {
		constructor() {
			this.array = [];
			this.set = new Map();
		}

		/**
   * Static method for creating ArraySet instances from 'an existing array.
   */
		static fromArray(array, allowDuplicates) {
			const set = new ___R$project$rome$$romejs$codec$source$map$ArraySet_ts$default();
			for (const item of array) {
				set.add(item, allowDuplicates);
			}
			return set;
		}

		/**
   * Add the given string to this set.
   */
		add(str, allowDuplicates) {
			const isDuplicate = this.has(str);
			const idx = this.array.length;

			if (isDuplicate === false || allowDuplicates === true) {
				this.array.push(str);
			}

			if (isDuplicate === false) {
				this.set.set(str, idx);
			}
		}

		/**
   * Is the given string a member of this set?
   */
		has(str) {
			return this.set.has(str);
		}

		/**
   * What is the index of the given string in the array?
   */
		indexOf(str) {
			const idx = this.set.get(str);
			if (idx === undefined || idx < 0) {
				throw new Error(str + " is not in the set");
			}
			return idx;
		}

		/**
   * What is the element at the given index?
   */
		at(idx) {
			if (idx >= 0 && idx < this.array.length) {
				return this.array[idx];
			} else {
				throw new Error("No element indexed by " + idx);
			}
		}

		/**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
		toArray() {
			return this.array.slice();
		}
	}


  // project-rome/@romejs/codec-source-map/MappingList.ts
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
	function ___R$$priv$project$rome$$romejs$codec$source$map$MappingList_ts$generatedPositionAfter(
		mappingA,
		mappingB,
	) {
		// Optimized for most common case
		const lineA = mappingA.generated.line;
		const lineB = mappingB.generated.line;
		const columnA = mappingA.generated.column;
		const columnB = mappingB.generated.column;
		return (
			lineB > lineA ||
			(lineB === lineA && columnB >= columnA) ||
			___R$project$rome$$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(
				mappingA,
				mappingB,
			) <= 0
		);
	}

	/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a negligible overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
	class ___R$project$rome$$romejs$codec$source$map$MappingList_ts$default {
		constructor() {
			this.array = [];
			this.sorted = true;
			this.last = {
				generated: {
					index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
					line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1Neg1,
					column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
				},
				// TODO: original: undefined
				original: {
					line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1Neg1,
					column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
				},
				source: undefined,
				name: undefined,
			};
		}

		/**
   * Add the given source mapping.
   */
		add(mapping) {
			if (
				___R$$priv$project$rome$$romejs$codec$source$map$MappingList_ts$generatedPositionAfter(
					this.last,
					mapping,
				)
			) {
				this.last = mapping;
				this.array.push(mapping);
			} else {
				this.sorted = false;
				this.array.push(mapping);
			}
		}

		/**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
		toArray() {
			if (this.sorted === false) {
				this.array.sort(
					___R$project$rome$$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated,
				);
				this.sorted = true;
			}
			return this.array;
		}
	}


  // project-rome/@romejs/codec-source-map/SourceMapConsumer.ts
function ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$getParsedMappingKey(
		line,
		column,
	) {
		return String(line) + ":" + String(column);
	}



	class ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default {
		constructor(file, getMappings) {
			this.file = file;
			this._getMappings = getMappings;
			this.mappings = undefined;
		}

		static charIsMappingSeparator(str, index) {
			const c = str.charAt(index);
			return c === ";" || c === ",";
		}

		static fromJSON(sourceMap) {
			return new ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default(
				sourceMap.file,
				() =>
					___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default.parseMappings(
						sourceMap,
					)
				,
			);
		}

		static fromJSONLazy(file, getSourceMap) {
			return new ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default(
				file,
				() =>
					___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default.parseMappings(
						getSourceMap(),
					)
				,
			);
		}

		static parseMappings(sourceMap) {
			const rawStr = sourceMap.mappings;
			const map = new Map();

			let generatedLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Number1;
			let previousGeneratedColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
			let previousOriginalLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Number1;
			let previousOriginalColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
			let previousSource = 0;
			let previousName = 0;
			let length = rawStr.length;
			let index = 0;
			let cachedSegments = {};
			let value;

			while (index < length) {
				const char = rawStr[index];
				if (char === ";") {
					generatedLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
						generatedLine,
					);
					index++;
					previousGeneratedColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
				} else if (char === ",") {
					index++;
				} else {
					const mapping = {
						generated: {
							line: generatedLine,
							column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
						},
						original: {
							line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
							column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
						},
						source: undefined,
						name: undefined,
					};

					// Because each offset is encoded relative to the previous one,
					// many segments often have the same encoding. We can exploit this
					// fact by caching the parsed variable length fields of each segment,
					// allowing us to avoid a second parse if we encounter the same
					// segment again.
					let end = index;
					for (; end < length; end++) {
						if (
							___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default.charIsMappingSeparator(
								rawStr,
								end,
							)
						) {
							break;
						}
					}
					const str = rawStr.slice(index, end);

					let segment = cachedSegments[str];
					if (segment) {
						index += str.length;
					} else {
						segment = [];
						while (index < end) {
							[value, index] = ___R$project$rome$$romejs$codec$source$map$base64_ts$decodeVLQ(
								rawStr,
								index,
							);
							segment.push(value);
						}

						if (segment.length === 2) {
							throw new Error("Found a source, but no line and column");
						}

						if (segment.length === 3) {
							throw new Error("Found a source and line, but no column");
						}

						cachedSegments[str] = segment;
					}

					// Generated column
					mapping.generated.column = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
						previousGeneratedColumn,
						segment[0],
					);
					previousGeneratedColumn = mapping.generated.column;

					if (segment.length > 1) {
						// Original source
						mapping.source = sourceMap.sources[previousSource + segment[1]];
						previousSource += segment[1];

						// Original line
						const newOriginalLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							previousOriginalLine,
							segment[2],
						);
						previousOriginalLine = newOriginalLine;

						// Lines are stored 0-based
						mapping.original.line = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							newOriginalLine,
							1,
						);

						// Original column
						const newOriginalColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							previousOriginalColumn,
							segment[3],
						);
						mapping.original.column = newOriginalColumn;
						previousOriginalColumn = newOriginalColumn;

						if (segment.length > 4) {
							// Original name
							mapping.name = sourceMap.names[previousName + segment[4]];
							previousName += segment[4];
						}
					}

					map.set(
						___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$getParsedMappingKey(
							mapping.generated.line,
							mapping.generated.column,
						),
						mapping,
					);
				}
			}

			return map;
		}

		clearCache() {
			this.mappings = undefined;
		}

		getMappings() {
			if (this.mappings === undefined) {
				const mappings = this._getMappings();
				this.mappings = mappings;
				return mappings;
			} else {
				return this.mappings;
			}
		}

		approxOriginalPositionFor(line, column) {
			while (___R$project$rome$$romejs$ob1$index_ts$ob1Get0(column) >= 0) {
				const mapping = this.exactOriginalPositionFor(line, column);
				if (mapping === undefined) {
					column = ___R$project$rome$$romejs$ob1$index_ts$ob1Dec(column);
					continue;
				} else {
					return mapping;
				}
			}

			return undefined;
		}

		exactOriginalPositionFor(line, column) {
			const key = ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$getParsedMappingKey(
				line,
				column,
			);
			const mapping = this.getMappings().get(key);
			if (mapping === undefined) {
				return undefined;
			}

			const source = mapping.source === undefined ? this.file : mapping.source;
			if (source === undefined) {
				throw new Error("Mapping provided unknown source");
			}

			return {
				found: true,
				source,
				line: mapping.original.line,
				column: mapping.original.column,
				name: mapping.name,
			};
		}
	}


  // project-rome/@romejs/codec-source-map/SourceMapGenerator.ts


	class ___R$project$rome$$romejs$codec$source$map$SourceMapGenerator_ts$default {
		constructor(args) {
			this.file = args.file;
			this.sourceRoot = args.sourceRoot;

			this.sourcesContents = new Map();
			this.map = undefined;
			this.sources = new ___R$project$rome$$romejs$codec$source$map$ArraySet_ts$default();
			this.names = new ___R$project$rome$$romejs$codec$source$map$ArraySet_ts$default();
			this.mappings = new ___R$project$rome$$romejs$codec$source$map$MappingList_ts$default();
			this.materializeCallbacks = [];
		}

		assertUnlocked() {
			if (this.map !== undefined) {
				throw new Error(
					"Source map has already been materialized, serialize() should be your final call",
				);
			}
		}

		addMaterializer(fn) {
			this.materializeCallbacks.push(fn);
		}

		/**
   * Add a single mapping from 'original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
		addMapping(mapping) {
			this.assertUnlocked();

			const {name, source} = mapping;

			this.validatePosition(
				"generated",
				mapping.generated.line,
				mapping.generated.column,
			);

			if (mapping.original) {
				this.validatePosition(
					"original",
					mapping.original.line,
					mapping.original.column,
				);
			}

			if (source !== undefined) {
				this.sources.add(source);
			}

			if (name !== undefined) {
				this.names.add(name);
			}

			this.mappings.add(mapping);
		}

		/**
   * Set the source content for a source file.
   */
		setSourceContent(source, sourceContent) {
			this.assertUnlocked();

			if (this.sourceRoot !== undefined) {
				source = ___R$project$rome$$romejs$codec$source$map$util_ts$toRelativeUrl(
					this.sourceRoot,
					source,
				);
			}

			if (sourceContent !== undefined) {
				// Add the source content to the _sourcesContents map.
				this.sourcesContents.set(source, sourceContent);
			} else {
				// Remove the source file from the _sourcesContents map.
				this.sourcesContents.delete(source);
			}
		}

		validatePosition(key, line, column) {
			if (___R$project$rome$$romejs$ob1$index_ts$ob1Get1(line) <= 0) {
				throw new Error(key + " line should be >= 1 but is " + line);
			}

			if (___R$project$rome$$romejs$ob1$index_ts$ob1Get0(column) < 0) {
				throw new Error(key + " column should be >= 0 but is " + column);
			}
		}

		/**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
		serializeMappings() {
			let previousGeneratedColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
			let previousGeneratedLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Number1;
			let previousOriginalColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
			let previousOriginalLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Number1;
			let previousName = 0;
			let previousSource = 0;
			let result = "";

			const mappings = this.mappings.toArray();
			for (let i = 0; i < mappings.length; i++) {
				const mapping = mappings[i];
				let next = "";

				if (mapping.generated.line !== previousGeneratedLine) {
					previousGeneratedColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
					while (mapping.generated.line !== previousGeneratedLine) {
						next += ";";
						previousGeneratedLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
							previousGeneratedLine,
						);
					}
				} else if (i > 0) {
					if (
						!___R$project$rome$$romejs$codec$source$map$util_ts$compareByGeneratedPositionsInflated(
							mapping,
							mappings[i - 1],
						)
					) {
						continue;
					}
					next += ",";
				}

				next += ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						mapping.generated.column,
					) -
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						previousGeneratedColumn,
					),
				);
				previousGeneratedColumn = mapping.generated.column;

				if (mapping.source !== undefined) {
					const sourceIdx = this.sources.indexOf(mapping.source);
					next += ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(
						sourceIdx - previousSource,
					);
					previousSource = sourceIdx;

					if (mapping.original) {
						next += ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(
							___R$project$rome$$romejs$ob1$index_ts$ob1Get1(
								mapping.original.line,
							) -
							___R$project$rome$$romejs$ob1$index_ts$ob1Get1(
								previousOriginalLine,
							),
						);
						previousOriginalLine = mapping.original.line;

						next += ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(
							___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
								mapping.original.column,
							) -
							___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
								previousOriginalColumn,
							),
						);
						previousOriginalColumn = mapping.original.column;

						if (mapping.name !== undefined) {
							const nameIdx = this.names.indexOf(mapping.name);
							next += ___R$project$rome$$romejs$codec$source$map$base64_ts.encodeVLQ(
								nameIdx - previousName,
							);
							previousName = nameIdx;
						}
					}

					// TODO: else, assert mapping.name is undefined since it can't be encoded without an original position
				}

				// TODO: else, assert mapping.original is undefined since it can't be encoded without a source
				result += next;
			}

			return result;
		}

		generateSourcesContent(sources, sourceRoot) {
			return sources.map((source) => {
				if (sourceRoot !== undefined) {
					source = ___R$project$rome$$romejs$codec$source$map$util_ts$toRelativeUrl(
						sourceRoot,
						source,
					);
				}
				const content = this.sourcesContents.get(source);
				if (content === undefined) {
					throw new Error("Expected content");
				}
				return content;
			});
		}

		materialize() {
			for (const fn of this.materializeCallbacks) {
				fn();
			}
			this.materializeCallbacks = [];
		}

		/**
   * Externalize the source map.
   */
		serialize() {
			if (this.map !== undefined) {
				return this.map;
			}

			this.materialize();

			const sources = this.sources.toArray();
			this.map = {
				version: 3,
				file: this.file,
				names: this.names.toArray(),
				mappings: this.serializeMappings(),
				sourceRoot: this.sourceRoot,
				sources,
				sourcesContent: this.generateSourcesContent(sources, this.sourceRoot),
			};
			return this.map;
		}

		toComment() {
			const jsonMap = this.toJSON();
			const base64Map = new Buffer(jsonMap).toString("base64");
			const comment =
				"//# sourceMappingURL=data:application/json;charset=utf-8;base64," +
				base64Map;
			return comment;
		}

		toConsumer() {
			return new ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default(
				this.file,
				() => {
					const parsedMappings = new Map();

					for (const mapping of this.getMappings()) {
						parsedMappings.set(
							___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$getParsedMappingKey(
								mapping.generated.line,
								mapping.generated.column,
							),
							mapping,
						);
					}

					return parsedMappings;
				},
			);
		}

		getMappings() {
			this.materialize();
			return this.mappings.toArray();
		}

		toJSON() {
			return JSON.stringify(this.serialize());
		}
	}


  // project-rome/@romejs/codec-source-map/SourceMapConsumerCollection.ts
class ___R$project$rome$$romejs$codec$source$map$SourceMapConsumerCollection_ts$default {
		constructor() {
			this.maps = new Map();
		}

		hasAny() {
			return this.maps.size > 0;
		}

		has(file) {
			return file !== undefined && this.maps.has(file);
		}

		add(file, map) {
			this.maps.set(file, map);
		}

		get(file) {
			return this.maps.get(file);
		}

		normalizeResolved(source, line, column, loc) {
			if (loc === undefined) {
				return {
					found: false,
					source,
					line,
					column,
					name: undefined,
				};
			} else {
				return loc;
			}
		}

		assertApproxOriginalPositionFor(file, line, column) {
			return this.normalizeResolved(
				file,
				line,
				column,
				this.approxOriginalPositionFor(file, line, column),
			);
		}

		assertExactOriginalPositionFor(file, line, column) {
			return this.normalizeResolved(
				file,
				line,
				column,
				this.exactOriginalPositionFor(file, line, column),
			);
		}

		approxOriginalPositionFor(file, line, column) {
			const map = this.get(file);
			if (map === undefined) {
				return undefined;
			} else {
				return map.approxOriginalPositionFor(line, column);
			}
		}

		exactOriginalPositionFor(file, line, column) {
			const map = this.get(file);
			if (map === undefined) {
				return undefined;
			} else {
				return map.exactOriginalPositionFor(line, column);
			}
		}
	}


  // project-rome/@romejs/codec-source-map/types.ts















  // project-rome/@romejs/codec-source-map/index.ts



  // project-rome/@romejs/v8/types.ts
const ___R$project$rome$$romejs$v8$types_ts = {};
	const ___R$$priv$project$rome$$romejs$v8$types_ts$inspector = require(
		"inspector",
	);























  // project-rome/@romejs/v8/errors.ts
const ___R$project$rome$$romejs$v8$errors_ts = {
		get ERROR_FRAMES_PROP() {
			return ___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP;
		},
		getErrorStructure: ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure,
		getSourceLocationFromErrorFrame: ___R$project$rome$$romejs$v8$errors_ts$getSourceLocationFromErrorFrame,
	};
	Object.keys(___R$project$rome$$romejs$v8$types_ts).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$v8$errors_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$v8$types_ts[key];
				},
			},
		);
	});
	const ___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP = Symbol();



	function ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(
		err,
		framesToShift = 0,
	) {
		let name = "Error";
		let message = "Unknown message";
		let stack = undefined;
		let frames = [];
		let looksLikeValidError = false;

		if (___R$project$rome$$romejs$typescript$helpers$index_ts$isPlainObject(err)) {
			if (typeof err.name === "string") {
				looksLikeValidError = true;
				name = err.name;
			}

			if (typeof err.message === "string") {
				looksLikeValidError = true;
				message = err.message;
			}

			if (typeof err.stack === "string") {
				looksLikeValidError = true;
				stack = err.stack;
			}

			if (
				Array.isArray(
					err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP],
				)
			) {
				// @ts-ignore
				frames = err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP];
			}
		}

		frames = frames.slice(framesToShift);

		if (!looksLikeValidError) {
			message = "Not an error instance: " + String(err);
		}

		return {
			name,
			message,
			stack,
			frames,
		};
	}

	function ___R$project$rome$$romejs$v8$errors_ts$getSourceLocationFromErrorFrame(
		frame,
	) {
		const pos = {
			index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1,
			line: frame.lineNumber === undefined
				? ___R$project$rome$$romejs$ob1$index_ts$ob1Number1
				: frame.lineNumber,
			column: frame.columnNumber === undefined
				? ___R$project$rome$$romejs$ob1$index_ts$ob1Number0
				: frame.columnNumber,
		};

		return {
			filename: frame.filename === undefined ? "unknown" : frame.filename,
			start: pos,
			end: pos,
		};
	}


  // project-rome/@romejs/v8/sourceMapManager.ts
let ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$inited = false;

	function ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$prepareStackTrace(
		err,
		frames,
	) {
		try {
			___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$addErrorFrames(
				err,
				frames,
			);
			return ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$buildStackString(
				err,
			);
		} catch (err2) {
			return (
				err.name +
				": " +
				err.message +
				"\n  Failed to generate stacktrace: " +
				err2.message
			);
		}
	}

	function ___R$project$rome$$romejs$v8$sourceMapManager_ts$initErrorHooks() {
		if (!___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$inited) {
			___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$inited = true;
			Error.prepareStackTrace = ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$prepareStackTrace;
		}
	}

	function ___R$project$rome$$romejs$v8$sourceMapManager_ts$teardown() {
		Error.prepareStackTrace = undefined;
	}

	function ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$buildStackString(
		err,
	) {
		const {frames} = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(
			err,
		);
		const lines = [];

		lines.push(err.name + ": " + err.message);

		for (const frame of frames) {
			const {
				resolvedLocation,
				methodName,
				functionName,
				typeName,
				isNative,
				isAsync,
				isEval,
				isConstructor,
				filename,
				lineNumber,
				columnNumber,
			} = frame;
			const parts = [];

			if (isAsync) {
				parts.push("await");
			}

			if (isEval) {
				parts.push("eval");
			}

			if (isConstructor) {
				parts.push("new");
			}

			let name = "<anonymous>";
			if (functionName !== undefined) {
				name = functionName;
			}
			if (methodName !== undefined) {
				name = methodName;
			}
			if (typeName !== undefined) {
				parts.push(typeName + "." + name);
			} else {
				parts.push(name);
			}

			if (isNative) {
				parts.push("native");
			} else if (
				filename !== undefined &&
				lineNumber !== undefined &&
				columnNumber !== undefined
			) {
				parts.push("(" + filename + ":" + lineNumber + ":" + columnNumber + ")");
			}

			if (resolvedLocation === false) {
				parts.push("generated source location");
			}

			lines.push("  at " + parts.join(" "));
		}

		return lines.join("\n");
	}

	function ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(val) {
		if (val === null) {
			return undefined;
		} else {
			return val;
		}
	}

	function ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$addErrorFrames(
		err,
		frames,
	) {
		if (err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP]) {
			return;
		}

		let builtFrames = frames.map((frameApi) => {
			const filename = frameApi.getFileName();
			const lineNumber = frameApi.getLineNumber();
			const columnNumber = frameApi.getColumnNumber();

			const frame = {
				typeName: ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(
					frameApi.getTypeName(),
				),
				functionName: ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(
					frameApi.getFunctionName(),
				),
				methodName: ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(
					frameApi.getMethodName(),
				),
				isTopLevel: frameApi.isToplevel(),
				isEval: frameApi.isEval(),
				isNative: frameApi.isNative(),
				isConstructor: frameApi.isConstructor(),
				// TODO frameApi.isAsync
				isAsync: false,
				resolvedLocation: true,
				filename: ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$noNull(
					filename,
				),
				lineNumber: lineNumber == null
					? undefined
					: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(lineNumber),
				// Rome expects 0-indexed columns, V8 provides 1-indexed
				columnNumber: columnNumber == null
					? undefined
					: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1To0(columnNumber),
			};

			if (
				frame.filename !== undefined &&
				frame.lineNumber !== undefined &&
				frame.columnNumber !== undefined
			) {
				const {found, line, column, source, name} = ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$sourceMaps.assertApproxOriginalPositionFor(
					frame.filename,
					frame.lineNumber,
					frame.columnNumber,
				);

				return Object.assign(
					{},
					frame,
					{
						functionName: frame.functionName === undefined
							? name
							: frame.functionName,
						methodName: frame.methodName === undefined ? name : frame.methodName,
						resolvedLocation: found,
						lineNumber: line,
						columnNumber: column,
						filename: source,
					},
				);
			} else {
				return frame;
			}
		});

		err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP] = builtFrames;
	}

	const ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$sourceMaps = new ___R$project$rome$$romejs$codec$source$map$SourceMapConsumerCollection_ts$default();
	const ___R$project$rome$$romejs$v8$sourceMapManager_ts$default = ___R$$priv$project$rome$$romejs$v8$sourceMapManager_ts$sourceMaps;


  // project-rome/@romejs/v8/utils.ts
const ___R$project$rome$$romejs$v8$utils_ts = {
		hrTime: ___R$project$rome$$romejs$v8$utils_ts$hrTime,
		urlToFilename: ___R$project$rome$$romejs$v8$utils_ts$urlToFilename,
	};
	function ___R$project$rome$$romejs$v8$utils_ts$hrTime() {
		const hrtime = process.hrtime(); // [seconds, nanoseconds]
		const ts = hrtime[0] * 1_000_000 + Math.round(hrtime[1] / 1_000); // microseconds
		return ts;
	}

	const ___R$$priv$project$rome$$romejs$v8$utils_ts$FILE_PROTOCOL = "file://";

	function ___R$project$rome$$romejs$v8$utils_ts$urlToFilename(url) {
		if (
			url.startsWith(___R$$priv$project$rome$$romejs$v8$utils_ts$FILE_PROTOCOL)
		) {
			return url.slice(
				___R$$priv$project$rome$$romejs$v8$utils_ts$FILE_PROTOCOL.length,
			);
		} else {
			return url;
		}
	}


  // project-rome/@romejs/v8/Profiler.ts
const ___R$$priv$project$rome$$romejs$v8$Profiler_ts$inspector = require(
		"inspector",
	);
	class ___R$project$rome$$romejs$v8$Profiler_ts$default {
		constructor() {
			this.session = undefined;
			this.memoryInterval = undefined;
			this.memorySamples = [];
		}

		async startProfiling(samplingInterval) {
			this.session = new ___R$$priv$project$rome$$romejs$v8$Profiler_ts$inspector.Session();
			this.session.connect();

			this.memoryInterval = setInterval(
				() => {
					const time = ___R$project$rome$$romejs$v8$utils_ts$hrTime();
					const size = process.memoryUsage().heapUsed;
					this.memorySamples.push([time, size]);
				},
				100,
			);

			await Promise.all([
				this.sendCommand(
					"Profiler.setSamplingInterval",
					{
						interval: samplingInterval,
					},
				),
				this.sendCommand("Profiler.enable"),
				this.sendCommand("Profiler.start"),
			]);
		}

		async sendCommand(method, params) {
			const {session} = this;
			if (session === undefined) {
				return Promise.reject(new Error("No current profiler session"));
			} else {
				return new Promise((resolve, reject) => {
					session.post(
						method,
						params,
						(err) => {
							if (err === null) {
								resolve();
							} else {
								reject(err);
							}
						},
					);
				});
			}
		}

		destroy() {
			const {session} = this;
			if (session !== undefined) {
				if (this.memoryInterval !== undefined) {
					clearInterval(this.memoryInterval);
				}
				this.memorySamples = [];
				session.disconnect();
			}
		}

		async stopProfiling() {
			const {session} = this;
			if (session === undefined) {
				return Promise.reject(new Error("No current profiler session"));
			}

			const {memorySamples} = this;

			const res = await new Promise((resolve, reject) => {
				session.post(
					"Profiler.stop",
					(err, params) => {
						if (err === null) {
							resolve(params);
						} else {
							reject(err);
						}
					},
				);
			});

			this.destroy();

			return {
				pid: process.pid,
				cpuProfile: res.profile,
				memorySamples,
			};
		}
	}


  // project-rome/@romejs/v8/Trace.ts
class ___R$project$rome$$romejs$v8$Trace_ts$default {
		constructor() {
			this.tid = 0;
			this.eventId = 0;
			this.events = [];
		}

		getEventId() {
			const id = this.eventId;
			this.eventId++;
			return id;
		}

		decodeProfileSourceMap(profile) {
			// This method mutates the profile for performance/ergonomics
			// Nothing else should be relying on this so it doesn't really matter
			for (const node of profile.cpuProfile.nodes) {
				const {callFrame} = node;

				// Call frame line numbers are 0-index while Rome is 1-indexed
				const resolved = ___R$project$rome$$romejs$v8$sourceMapManager_ts$default.approxOriginalPositionFor(
					___R$project$rome$$romejs$v8$utils_ts$urlToFilename(callFrame.url),
					___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0To1(
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
							callFrame.lineNumber,
						),
					),
					___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
						callFrame.columnNumber,
					),
				);
				if (resolved !== undefined) {
					callFrame.url = resolved.source;
					callFrame.lineNumber = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1To0(resolved.line),
					);
					callFrame.columnNumber = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						resolved.column,
					);

					if (resolved.name !== undefined) {
						callFrame.functionName = resolved.name;
					}
				}
			}
		}

		addProfile(name, profile) {
			this.decodeProfileSourceMap(profile);

			const {startTime, endTime} = profile.cpuProfile;

			const common = {
				pid: 1,
				tid: profile.pid,
			};

			this.events.push(
				Object.assign(
					{},
					common,
					{ts: 0, ph: "M", cat: "__metadata", name: "thread_name", args: {name}},
				),
			);

			this.events.push(
				Object.assign(
					{},
					common,
					{
						ph: "P",
						name: "CpuProfile",
						id: this.getEventId(),
						cat: "disabled-by-default-v8.cpu_profiler",
						ts: endTime,
						args: {
							data: {
								cpuProfile: profile.cpuProfile,
							},
						},
					},
				),
			);

			this.events.push(
				Object.assign(
					{},
					common,
					{
						ph: "X",
						name: "EvaluateScript",
						id: this.getEventId(),
						cat: "devtools.timeline",
						ts: startTime,
						dur: endTime - startTime,
						args: {
							data: {
								url: "rome.js",
								lineNumber: 1,
								columnNumber: 1,
								frame: "0xFFF",
							},
						},
					},
				),
			);

			for (const [time, size] of profile.memorySamples) {
				this.events.push(
					Object.assign(
						{},
						common,
						{
							ts: time,
							ph: "I",
							cat: "disabled-by-default-devtools.timeline",
							name: "UpdateCounters",
							args: {
								data: {
									jsHeapSizeUsed: size,
								},
							},
							s: "t",
						},
					),
				);
			}
		}

		build() {
			return this.events;
		}
	}


  // project-rome/@romejs/codec-json/types.ts

























  // project-rome/@romejs/codec-json/parse.ts
// Words can't start with a digit
	function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordStartChar(
		char,
	) {
		return (
			___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char) ||
			char === "_" ||
			char === "$"
		);
	}

	// But a digit can appear inside of a word
	function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordChar(char) {
		return (
			___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordStartChar(char) ||
			___R$project$rome$$romejs$parser$core$index_ts$isDigit(char)
		);
	}

	// Check if an input string is a valid word, this is used by the stringifier to
	// determine if a property key should be quoted
	function ___R$project$rome$$romejs$codec$json$parse_ts$isValidWord(word) {
		if (
			word.length === 0 ||
			___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordStartChar(
				word[0],
			) === false
		) {
			return false;
		}

		for (const char of word) {
			if (
				___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordChar(char) ===
				false
			) {
				return false;
			}
		}

		return true;
	}

	// Check if a character is a part of a string, returning false for a newline or unescaped quote char
	function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isStringValueChar(
		char,
		index,
		input,
	) {
		if (char === "\n") {
			return false;
		}

		if (
			char === '"' &&
			!___R$project$rome$$romejs$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			)
		) {
			return false;
		}

		return true;
	}

	// Turn a path into a string key we can use
	function ___R$project$rome$$romejs$codec$json$parse_ts$toPathKey(parts) {
		// Right now this could conflict weirdly with properties with dots in them if they cause collisions
		// We have this method abstracted so we can make changes later if it's necessary (probably not worth it)
		return parts.join(".");
	}

	function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isntNewline(char) {
		return char !== "\n";
	}

	function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isntBlockCommentEnd(
		char,
		index,
		input,
	) {
		const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) +
		1];
		return char !== "*" && nextChar !== "/";
	}

	// Used for Number token validation, allow underscore as a separatore
	function ___R$$priv$project$rome$$romejs$codec$json$parse_ts$isNumberChar(
		char,
	) {
		return (
			___R$project$rome$$romejs$parser$core$index_ts$isDigit(char) ||
			char === "_"
		);
	}



	const ___R$project$rome$$romejs$codec$json$parse_ts$createJSONParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser((
		ParserCore,
	) =>
		(() => {
			class JSONParser extends ParserCore {
				constructor(opts) {
					super(
						Object.assign({}, opts, {retainCarriageReturn: true}),
						"parse/json",
					);

					this.options = opts;
					this.ignoreWhitespaceTokens = true;

					this.hasExtensions =
						this.path !== undefined &&
						this.path.getBasename().endsWith(".rjson");

					this.pathKeys = [];
					this.paths = new Map();
					this.pathToComments = new Map();
					this.consumeDiagnosticCategory =
						opts.consumeDiagnosticCategory === undefined
							? "parse/json"
							: opts.consumeDiagnosticCategory;
				}

				getPathInfo(path) {
					return this.paths.get(path.join("."));
				}

				setComments(pathComments) {
					const key = this.pathKeys.join(".");

					const existing = this.pathToComments.get(key);
					if (existing === undefined) {
						this.pathToComments.set(key, pathComments);
					} else {
						this.pathToComments.set(
							key,
							{
								inner: [...existing.inner, ...pathComments.inner],
								outer: [...existing.outer, ...pathComments.outer],
							},
						);
					}
				}

				setPath(info) {
					this.paths.set(this.pathKeys.join("."), info);
					this.pathKeys.pop();
				}

				tokenize(index, input) {
					const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					) + 1];
					const char = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					)];

					// Line comment
					if (char === "/" && nextChar === "/") {
						const commentValueIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							index,
							2,
						);
						const [value] = this.readInputFrom(
							commentValueIndex,
							___R$$priv$project$rome$$romejs$codec$json$parse_ts$isntNewline,
						);
						// (comment content start + comment content length)
						return this.finishValueToken(
							"LineComment",
							value,
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								commentValueIndex,
								value.length,
							),
						);
					}

					// BlockComment
					if (char === "/" && nextChar === "*") {
						const commentValueIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							index,
							2,
						);
						const [value] = this.readInputFrom(
							commentValueIndex,
							___R$$priv$project$rome$$romejs$codec$json$parse_ts$isntBlockCommentEnd,
						);

						// (comment content start + comment content length + 2 characters for comment end)
						const endIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								commentValueIndex,
								value.length,
							),
							2,
						);

						// Ensure the comment is closed
						if (
							this.input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
								endIndex,
							) - 2] !== "*" ||
							this.input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
								endIndex,
							) - 1] !== "/"
						) {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.UNCLOSED_BLOCK_COMMENT,
								start: this.getPositionFromIndex(endIndex),
							});
						}

						return this.finishValueToken("BlockComment", value, endIndex);
					}

					// Single character token starters
					switch (char) {
						case '"': {
							const [value] = this.readInputFrom(
								___R$project$rome$$romejs$ob1$index_ts$ob1Inc(index),
								___R$$priv$project$rome$$romejs$codec$json$parse_ts$isStringValueChar,
							);

							// Check for closed string (index is the current token index + string length + closing quote + 1 for the end char)
							const end = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								___R$project$rome$$romejs$ob1$index_ts$ob1Add(
									index,
									value.length,
								),
								2,
							);
							if (
								input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(end) - 1] !==
								'"'
							) {
								throw this.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.UNCLOSED_STRING,
									start: this.getPositionFromIndex(end),
								});
							}

							// Don't allow newlines in JSON
							for (let strIndex = 0; strIndex < value.length; strIndex++) {
								const char = value[strIndex];

								if (char === "\n") {
									throw this.unexpected({
										description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.STRING_NEWLINES_IN_JSON,
										start: this.getPositionFromIndex(
											___R$project$rome$$romejs$ob1$index_ts$ob1Add(
												index,
												strIndex,
											),
										),
									});
								}
							}

							// Unescape the string
							const unescaped = ___R$project$rome$$romejs$string$escape$unescapeString_ts$default(
								value,
								(metadata, strIndex) => {
									throw this.unexpected({
										description: metadata,
										start: this.getPositionFromIndex(
											___R$project$rome$$romejs$ob1$index_ts$ob1Add(
												index,
												strIndex,
											),
										),
									});
								},
							);

							return this.finishValueToken("String", unescaped, end);
						}

						case "'":
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.SINGLE_QUOTE_USAGE,
								start: this.getPositionFromIndex(index),
							});

						case "/":
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.REGEX_IN_JSON,
								start: this.getPositionFromIndex(index),
							});

						case ",":
							return this.finishToken("Comma");

						case ".":
							return this.finishToken("Dot");

						case "-":
							return this.finishToken("Minus");

						case "+":
							return this.finishToken("Plus");

						case ":":
							return this.finishToken("Colon");

						case "{":
							return this.finishToken("BraceOpen");

						case "}":
							return this.finishToken("BraceClose");

						case "[":
							return this.finishToken("BracketOpen");

						case "]":
							return this.finishToken("BracketClose");
					}

					// Numbers
					if (___R$project$rome$$romejs$parser$core$index_ts$isDigit(char)) {
						const value = this.removeUnderscores(
							index,
							this.readInputFrom(
								index,
								___R$$priv$project$rome$$romejs$codec$json$parse_ts$isNumberChar,
							)[0],
						);
						const num = Number(value);
						return this.finishValueToken(
							"Number",
							num,
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, value.length),
						);
					}

					// Word - boolean, undefined etc
					if (
						___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordStartChar(
							char,
						)
					) {
						const [value] = this.readInputFrom(
							index,
							___R$$priv$project$rome$$romejs$codec$json$parse_ts$isWordChar,
						);
						return this.finishValueToken(
							"Word",
							value,
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, value.length),
						);
					}

					// Unknown character
					return undefined;
				}

				parseObject(firstKeyStart, firstKey) {
					const obj = {};

					let innerComments = [];
					let isFirstProp = true;

					// These are comments that the next property should take in case the previous accidently took them
					let nextLeadingComments;

					do {
						if (this.matchToken("BraceClose")) {
							break;
						}

						// Eat all the comments that appeared before this property, it's the most common and natural place to put them,

						// and is where we'll print all comments for a property.
						let leadingComments = this.eatComments();

						// Take any leading comments that were left by the previous property
						if (nextLeadingComments !== undefined) {
							leadingComments = [...nextLeadingComments, ...leadingComments];
							nextLeadingComments = undefined;
						}

						// Throw a meainingful error for redundant commas
						if (this.matchToken("Comma")) {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.REDUNDANT_COMMA,
							});
						}

						// If there's no property key indicator then delegate any comments we have to object
						const hasKey = isFirstProp && firstKey !== undefined;
						if (
							!hasKey &&
							!this.matchToken("String") &&
							!this.matchToken("Word")
						) {
							innerComments = [...innerComments, ...leadingComments];
							break;
						}

						const keyStart =
							isFirstProp && firstKeyStart !== undefined
								? firstKeyStart
								: this.getPosition();

						// Parse the property key
						let key;
						if (isFirstProp && firstKey !== undefined) {
							// If this is the first property and we've been given a property key then use it instead
							key = firstKey;
						} else {
							key = this.parsePropertyKey();
						}
						isFirstProp = false;

						const keyEnd = this.getPosition();
						this.expectToken("Colon");

						// Having comments before the value is a really weird place to put them, but we'll handle it

						// anyway to avoid throwing a parser error. When stringified, the comments will all be before

						// the property.
						const leadingValueComments = this.eatComments();

						this.pathKeys.push(key);

						// Parse the value.
						const valueStart = this.getPosition();
						const value = this.parseExpression();
						const valueEnd = this.getLastEndPosition();

						// Eat the comments after the expression and associate the comments with them
						let trailingValueComments = this.eatComments();

						// If the next token isn't a comma or closing brace then we've just stolen

						// the leading comments of the next property
						if (!this.matchToken("Comma") && !this.matchToken("BraceClose")) {
							nextLeadingComments = trailingValueComments;
							trailingValueComments = [];
						}

						this.setComments({
							inner: [],
							outer: [
								...leadingComments,
								...leadingValueComments,
								...trailingValueComments,
							],
						});

						this.setPath({
							keyStart,
							keyEnd,
							valueStart,
							valueEnd,
							originalValue: value,
						});

						// Set the object correctly, accounting for JS weirdness
						if (key === "__proto__") {
							// Need to use defineProperty to avoid triggering the Object.prototype.__proto__ setter
							Object.defineProperty(
								obj,
								"__proto__",
								{
									value,
									configurable: true,
									writable: true,
									enumerable: true,
								},
							);
						} else {
							obj[key] = value;
						}
					} while (this.eatPropertySeparator());

					// Take any loose leading comments
					if (nextLeadingComments !== undefined) {
						innerComments = [...innerComments, ...nextLeadingComments];
					}

					// If we were passed a first key then this was an implicit object so there's no end token
					if (firstKey === undefined) {
						this.expectToken("BraceClose");
					}

					this.setComments({
						inner: innerComments,
						outer: [],
					});

					return obj;
				}

				// Remove underscores from 'a string, this is used for numeric separators eg. 100_000
				removeUnderscores(index, raw) {
					let str = "";

					for (let i = 0; i < raw.length; i++) {
						const char = raw[i];

						if (char === "_") {
							// Don't allow separators in JSON
							if (!this.hasExtensions) {
								throw this.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.NUMERIC_SEPARATORS_IN_JSON,
									start: this.getPositionFromIndex(
										___R$project$rome$$romejs$ob1$index_ts$ob1Inc(index),
									),
								});
							}
						} else {
							str += char;
						}
					}

					return str;
				}

				eatComments() {
					const comments = [];

					while (true) {
						const token = this.getToken();

						if (token.type === "LineComment") {
							comments.push({
								type: "LineComment",
								value: token.value,
							});
						} else if (token.type === "BlockComment") {
							comments.push({
								type: "BlockComment",
								value: token.value,
							});
						} else {
							break;
						}

						// Comments aren't allowed in regular JSON
						if (!this.hasExtensions) {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.COMMENTS_IN_JSON,
							});
						}

						this.nextToken();
					}

					return comments;
				}

				parseArray() {
					this.expectToken("BracketOpen");

					const arr = [];
					let innerComments = [];
					let i = 0;

					do {
						if (this.matchToken("BracketClose")) {
							break;
						}

						// Eat all the comments before an element
						const leadingComments = this.eatComments();

						if (this.matchToken("Comma")) {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.REDUNDANT_COMMA,
							});
						}

						// If we're at the end of the array then associate these comments with the array
						if (this.matchToken("BracketClose")) {
							innerComments = [...innerComments, ...leadingComments];
							break;
						}

						const start = this.getPosition();
						this.pathKeys.push(i);
						i++;

						// Parse the value
						const item = this.parseExpression();
						arr.push(item);
						const end = this.getLastEndPosition();

						// Trailing comments are really weird, but let's handle them just like object properties
						const trailingComments = this.eatComments();

						this.setComments({
							outer: [...leadingComments, ...trailingComments],
							inner: [],
						});

						this.setPath({
							originalValue: item,
							keyStart: start,
							keyEnd: end,
							valueStart: start,
							valueEnd: end,
						});

						// Have a meaningful error message when an object is incorrectly using brackets: ["foo": "bar"]
						if (this.matchToken("Colon")) {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.MISTAKEN_ARRAY_IDENTITY,
							});
						}
					} while (this.eatPropertySeparator());

					this.expectToken("BracketClose");

					this.setComments({
						inner: innerComments,
						outer: [],
					});

					return arr;
				}

				// Check if the current token is a property separator and eat it if necessary
				eatPropertySeparator() {
					const token = this.getToken();

					// Implicit commas are only allowed in rjson
					if (this.hasExtensions) {
						// Eat the token, don't care if we're in RJSON
						if (token.type === "Comma") {
							this.nextToken();
						}

						// An object or array close is an instant failure

						// Doesn't matter what we're parsing since the subsequent tokens will be validated
						if (token.type === "BraceClose" || token.type === "BracketClose") {
							return false;
						}

						return true;
					} else {
						if (token.type !== "Comma") {
							return false;
						}

						// Make sure this isn't a trailing comma
						const lookahead = this.lookaheadToken();
						if (
							lookahead.type === "BraceClose" ||
							lookahead.type === "BracketClose"
						) {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.TRAILING_COMMA_IN_JSON,
							});
						}

						this.nextToken();
						return true;
					}
				}

				parseWord(isStart) {
					const start = this.getPosition();
					const token = this.expectToken("Word");

					switch (token.value) {
						case "true":
							return true;

						case "false":
							return false;

						case "null":
							return null;

						case "undefined":
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.UNDEFINED_IN_JSON,
							});
					}

					if (isStart && this.matchToken("Colon")) {
						if (this.hasExtensions) {
							return this.parseObject(start, token.value);
						} else {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.IMPLICIT_OBJECT_IN_JSON,
							});
						}
					}

					throw this.unexpected({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.UNKNOWN_WORD_IN_JSON(
							token.value,
						),
					});
				}

				parseNumber() {
					const isNegative = this.eatToken("Minus") !== undefined;

					// Get a string of the current number that we'll parse later
					const token = this.expectToken("Number");
					let value = String(token.value);

					// Decimals
					if (this.eatToken("Dot")) {
						value += ".";

						const decimal = this.expectToken("Number");
						value += String(decimal.value);
					}

					// Scientific notation
					const nextToken = this.getToken();
					if (
						nextToken.type === "Word" &&
						(nextToken.value === "e" || nextToken.value === "E")
					) {
						value += "e";

						// Operator
						const operator = this.nextToken();
						if (operator.type === "Minus") {
							value += "-";
						} else if (operator.type === "Plus") {
							value += "+";
						} else {
							throw this.unexpected();
						}

						// Factor
						this.nextToken();
						const factor = this.expectToken("Number");
						value += String(factor.value);
					}

					// BigInt
					const nextToken2 = this.getToken();
					if (nextToken2.type === "Word" && nextToken2.value === "n") {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.BIGINT_IN_JSON,
						});
					}

					// Turn the string into an actual number
					let num = Number(value);
					if (isNegative) {
						num = -num;
					}
					return num;
				}

				parsePropertyKey() {
					const token = this.getToken();

					switch (token.type) {
						case "String": {
							this.nextToken();
							return token.value;
						}

						case "Word":
							if (this.hasExtensions) {
								this.nextToken();
								return token.value;
							} else {
								throw this.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.PROPERTY_KEY_UNQUOTED_IN_JSON,
								});
							}

						default:
							throw this.unexpected();
					}
				}

				parseString(isStart) {
					const start = this.getPosition();
					const token = this.expectToken("String");

					if (isStart && this.nextToken().type === "Colon") {
						if (this.hasExtensions) {
							return this.parseObject(start, token.value);
						} else {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.IMPLICIT_OBJECT_IN_JSON,
							});
						}
					} else {
						return token.value;
					}
				}

				parseExpression(isStart = false) {
					const token = this.getToken();

					switch (token.type) {
						case "String":
							return this.parseString(isStart);

						case "Minus":
						case "Number":
							return this.parseNumber();

						case "Word":
							return this.parseWord(isStart);

						case "BracketOpen":
							return this.parseArray();

						case "BraceOpen": {
							this.nextToken();
							return this.parseObject();
						}

						default:
							throw this.unexpected();
					}
				}

				parseEntry() {
					if (this.matchToken("EOF")) {
						if (this.hasExtensions) {
							// If we're in RJSON mode then an empty input is an implicit object
							return {};
						} else {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JSON.EMPTY_INPUT_IN_JSON,
							});
						}
					} else {
						return this.parseExpression(true);
					}
				}

				parse() {
					let expectSyntaxError = false;

					if (!this.hasExtensions) {
						// If we're in regular JSON, try the native JSON.parse
						try {
							const value = JSON.parse(this.input);

							// Lazy parse when we need location information
							let context;
							const getContext = () => {
								if (context === undefined) {
									const res = this._parse();
									context = res.context;
									return res.context;
								} else {
									return context;
								}
							};

							return {
								context: {
									category: this.consumeDiagnosticCategory,
									normalizeKey(path) {
										return getContext().normalizeKey(path);
									},
									getOriginalValue(path) {
										return getContext().getOriginalValue(path);
									},
									getDiagnosticPointer(keys, target) {
										return getContext().getDiagnosticPointer(keys, target);
									},
								},
								value,
							};
						} catch (err) {
							// On syntax errors we'll fall back to our parser which is slower, but produces more meaningful errors
							if (err instanceof SyntaxError) {
								expectSyntaxError = true;
							} else {
								throw err;
							}
						}
					}

					const res = this._parse();

					if (expectSyntaxError) {
						throw new Error(
							"JSON.parse failed but our custom JSON parser was successful... That doesn't smell right",
						);
					}

					return res;
				}

				_parse() {
					const leadingComments = this.eatComments();

					const expr = this.parseEntry();

					const trailingComments = this.eatComments();
					this.setComments({
						inner: [],
						outer: [...leadingComments, ...trailingComments],
					});

					this.finalize();

					const context = {
						category: this.consumeDiagnosticCategory,
						normalizeKey: (key) => key,
						getDiagnosticPointer: (keys, target) => {
							const info = this.getPathInfo(keys);
							if (info === undefined) {
								return {
									filename: this.filename,
								};
							}

							let start = info.keyStart;
							let end = info.valueEnd;

							if (target === "key") {
								end = info.keyEnd;
							}

							if (target === "value" || target === "inner-value") {
								start = info.valueStart;
							}

							let loc = {
								filename: this.filename,
								start,
								end,
							};

							if (target === "inner-value") {
								const originalValue = context.getOriginalValue(keys);

								// Remove quote marks for strings
								if (typeof originalValue === "string") {
									loc = Object.assign(
										{},
										loc,
										{
											start: Object.assign(
												{},
												loc.start,
												{
													column: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
														loc.start.column,
														1,
													),
												},
											),
											end: Object.assign(
												{},
												loc.end,
												{
													column: ___R$project$rome$$romejs$ob1$index_ts$ob1Sub(
														loc.end.column,
														1,
													),
												},
											),
										},
									);
								}
							}

							return Object.assign(
								{language: "json"},
								loc,
								{mtime: this.mtime, sourceText: undefined},
							);
						},
						getOriginalValue: (keys) => {
							const info = this.getPathInfo(keys);
							if (info !== undefined) {
								return info.originalValue;
							}
						},
					};

					return {
						value: expr,
						context,
					};
				}
			}
			return JSONParser;
		})()
	);


  // project-rome/@romejs/consume/types.ts
const ___R$project$rome$$romejs$consume$types_ts = {};





























  // project-rome/@romejs/js-ast-utils/assertMultipleNodes.ts
function ___R$project$rome$$romejs$js$ast$utils$assertMultipleNodes_ts$default(
		result,
	) {
		if (Array.isArray(result)) {
			return result;
		} else if (result === undefined) {
			return [];
		} else if (typeof result === "symbol") {
			throw new Error("No symbols expected here");
		} else {
			return [result];
		}
	}


  // project-rome/@romejs/js-ast-utils/assertSingleNode.ts
function ___R$project$rome$$romejs$js$ast$utils$assertSingleNode_ts$default(
		result,
	) {
		if (Array.isArray(result)) {
			if (result.length !== 1) {
				throw new Error(
					"Expected node list length of 1 but got " + result.length,
				);
			}
			return result[0];
		} else if (result === undefined) {
			throw new Error("Expected node or node list but got null");
		} else if (typeof result === "symbol") {
			throw new Error("No symbols expected here");
		} else {
			return result;
		}
	}


  // project-rome/@romejs/js-ast-utils/assertSingleOrMultipleNodes.ts
function ___R$project$rome$$romejs$js$ast$utils$assertSingleOrMultipleNodes_ts$default(
		result,
	) {
		if (result === undefined) {
			throw new Error("Expected node or node list but got null");
		} else if (typeof result === "symbol") {
			throw new Error("No symbols expected here");
		} else {
			return result;
		}
	}


  // project-rome/@romejs/js-ast-utils/isIdentifierish.ts
function ___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node) {
		return (
			node.type === "Identifier" ||
			node.type === "JSXIdentifier" ||
			node.type === "JSXReferenceIdentifier" ||
			node.type === "BindingIdentifier" ||
			node.type === "AssignmentIdentifier" ||
			node.type === "ReferenceIdentifier"
		);
	}


  // project-rome/@romejs/js-ast-utils/getNodeReferenceParts.ts




	const ___R$$priv$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$cache = new WeakMap();

	const ___R$$priv$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$EMPTY = {
		bailed: true,
		parts: [],
	};

	function ___R$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$default(
		node,
	) {
		if (node === undefined) {
			return ___R$$priv$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$EMPTY;
		}

		const cached = ___R$$priv$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$cache.get(
			node,
		);
		if (cached !== undefined) {
			return cached;
		}

		const parts = [];

		function add(node) {
			if (
				___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node)
			) {
				parts.push({node, value: node.name});
				return false;
			} else if (node.type === "ThisExpression") {
				parts.push({node, value: "this"});
				return false;
			} else if (node.type === "StringLiteral") {
				parts.push({node, value: node.value});
				return false;
			} else if (node.type === "MetaProperty") {
				parts.push({node, value: node.meta.name});
				parts.push({node, value: node.property.name});
				return false;
			} else if (node.type === "MemberExpression") {
				const stop = add(node.object);
				if (stop) {
					return true;
				} else {
					return add(node.property);
				}
			} else if (
				node.type === "ComputedMemberProperty" &&
				node.value.type === "StringLiteral"
			) {
				return add(node.value);
			} else if (node.type === "StaticMemberProperty") {
				return add(node.value);
			} else {
				return true;
			}
		}

		const bailed = add(node);
		const result = {bailed, parts};
		___R$$priv$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$cache.set(
			node,
			result,
		);
		return result;
	}


  // project-rome/@romejs/js-ast-utils/doesNodeMatchPattern.ts
const ___R$$priv$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$splitCache = new Map();



	function ___R$$priv$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$split(
		str,
	) {
		const cached = ___R$$priv$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$splitCache.get(
			str,
		);
		if (cached !== undefined) {
			return cached;
		}

		const parts = str.split(".");

		let hasDoubleStar = false;
		for (const part of parts) {
			if (part === "**") {
				hasDoubleStar = true;
				break;
			}
		}

		const result = {parts, hasDoubleStar};
		___R$$priv$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$splitCache.set(
			str,
			result,
		);
		return result;
	}

	function ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
		node,
		match,
	) {
		if (node === undefined) {
			return false;
		}

		// Not a member expression
		if (
			node.type !== "MemberExpression" &&
			!___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node)
		) {
			return false;
		}

		const {parts: expectedParts, hasDoubleStar} = ___R$$priv$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$split(
			match,
		);

		// Fast path for single part pattern matching
		if (expectedParts.length === 1 && expectedParts[0] !== "*" && !hasDoubleStar) {
			return (
				___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node) &&
				node.name === expectedParts[0]
			);
		}

		const {bailed, parts: actualParts} = ___R$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$default(
			node,
		);

		// Bailed will be true if we were unable to derive a name for one of the parts
		if (bailed && !hasDoubleStar) {
			return false;
		}

		// If there's less parts than the amount we expect then it's never going to match
		if (actualParts.length < expectedParts.length) {
			return false;
		}

		// I there's more parts than we expect then it's never going to match either
		if (!hasDoubleStar && actualParts.length > expectedParts.length) {
			return false;
		}

		let nextActualIndex = 0;
		let nextExpectedIndex = 0;

		// Loop over the parts we received and match them
		while (nextActualIndex < actualParts.length) {
			// If we have no more expected parts then we can't possibly match it
			if (nextActualIndex >= expectedParts.length) {
				return false;
			}

			const actual = actualParts[nextActualIndex].value;
			nextActualIndex++;

			const expected = expectedParts[nextExpectedIndex];
			nextExpectedIndex++;

			// A star part can accept anything
			if (expected === "*") {
				continue;
			}

			if (expected === "**") {
				// Ran out of matches but we've accepted the current part
				if (nextExpectedIndex >= expectedParts.length) {
					return true;
				}

				const next = expectedParts[nextExpectedIndex];
				nextExpectedIndex++;

				if (next === "*" || next === "**") {
					throw new Error(
						"The next expected part was " +
						next +
						" but this isn't allowed since we're processing a double star",
					);
				}

				let found = false;

				// Eat as many parts until we find the next expected part
				while (nextActualIndex < actualParts.length) {
					const actual = actualParts[nextActualIndex].value;
					nextActualIndex++;
					if (actual === next) {
						found = true;
						break;
					}
				}

				if (found) {
					continue;
				} else {
					return false;
				}
			}

			if (expected !== actual) {
				return false;
			}
		}

		return true;
	}


  // project-rome/@romejs/js-ast/utils.ts
const ___R$project$rome$$romejs$js$ast$utils_ts$bindingKeys = new Map();
	const ___R$project$rome$$romejs$js$ast$utils_ts$visitorKeys = new Map();
	const ___R$project$rome$$romejs$js$ast$utils_ts$nodeNames = new Set();













	function ___R$$priv$project$rome$$romejs$js$ast$utils_ts$declareBuilder(
		type,
		opts,
	) {
		___R$project$rome$$romejs$js$ast$utils_ts$nodeNames.add(type);

		if (opts.visitorKeys !== undefined) {
			___R$project$rome$$romejs$js$ast$utils_ts$visitorKeys.set(
				type,
				Object.keys(opts.visitorKeys),
			);
		}

		if (opts.bindingKeys !== undefined) {
			___R$project$rome$$romejs$js$ast$utils_ts$bindingKeys.set(
				type,
				Object.keys(opts.bindingKeys),
			);
		}
	}

	// TODO only allow this method to be called on a node with only one required property
	function ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		type,
		quickKey,
		opts,
	) {
		___R$$priv$project$rome$$romejs$js$ast$utils_ts$declareBuilder(type, opts);

		return new ___R$$priv$project$rome$$romejs$js$ast$utils_ts$QuickBuilder(
			type,
			opts.visitorKeys,
			quickKey,
		);
	}

	function ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(type, opts) {
		___R$$priv$project$rome$$romejs$js$ast$utils_ts$declareBuilder(type, opts);

		return new ___R$$priv$project$rome$$romejs$js$ast$utils_ts$Builder(
			type,
			opts.visitorKeys,
		);
	}

	class ___R$$priv$project$rome$$romejs$js$ast$utils_ts$Builder {
		constructor(type, visitorKeys) {
			this.type = type;
			this.visitorKeys = visitorKeys;
		}

		create(opts, inheritNode) {
			// @ts-ignore
			return Object.assign(
				{
					loc: inheritNode === undefined
						? undefined
						: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(
								inheritNode,
							),
				},
				opts,
				{type: this.type},
			);
		}

		is(node) {
			return node !== undefined && node.type === this.type;
		}

		normalize(node) {
			if (this.is(node)) {
				return node;
			} else {
				return undefined;
			}
		}

		assert(res) {
			if (res === undefined) {
				throw new Error("Expected " + this.type + " Node but got undefined");
			}

			const node = ___R$project$rome$$romejs$js$ast$utils$assertSingleNode_ts$default(
				res,
			);

			if (node.type !== this.type) {
				throw new Error("Expected " + this.type + " Node but got " + node.type);
			}

			// @ts-ignore
			return node;
		}
	}

	class ___R$$priv$project$rome$$romejs$js$ast$utils_ts$QuickBuilder
		extends ___R$$priv$project$rome$$romejs$js$ast$utils_ts$Builder {
		constructor(type, visitorKeys, quickKey) {
			super(type, visitorKeys);
			this.quickKey = quickKey;
		}

		quick(arg, opts, inheritNode) {
			const node = (Object.assign({}, opts, {[this.quickKey]: arg}));

			return this.create(node, inheritNode);
		}
	}


  // project-rome/@romejs/js-ast/base.ts
const ___R$project$rome$$romejs$js$ast$base_ts = {};



  // project-rome/@romejs/js-ast/constants.ts
const ___R$project$rome$$romejs$js$ast$constants_ts = {};













  // project-rome/@romejs/js-ast/unions.ts
const ___R$project$rome$$romejs$js$ast$unions_ts = {};















































































  // project-rome/@romejs/js-ast/temp/AmbiguousFlowTypeCastExpression.ts
const ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts = {
		get ambiguousFlowTypeCastExpression() {
			return ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"AmbiguousFlowTypeCastExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/ArrayExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts = {
		get arrayExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"ArrayExpression",
		"elements",
		{
			bindingKeys: {},
			visitorKeys: {
				elements: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/ArrayHole.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$ArrayHole_ts = {
		get arrayHole() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$ArrayHole_ts$arrayHole;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$ArrayHole_ts$arrayHole = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ArrayHole",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/expressions/ArrowFunctionExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts = {
		get arrowFunctionExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ArrowFunctionExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				head: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/AssignmentArrayPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts = {
		get assignmentArrayPattern() {
			return ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"AssignmentArrayPattern",
		{
			bindingKeys: {},
			visitorKeys: {
				elements: true,
				rest: true,
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/AssignmentAssignmentPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts = {
		get assignmentAssignmentPattern() {
			return ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"AssignmentAssignmentPattern",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/AssignmentExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts = {
		get assignmentExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression;
		},
	};




	const ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"AssignmentExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/AssignmentIdentifier.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts = {
		get assignmentIdentifier() {
			return ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"AssignmentIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/patterns/AssignmentObjectPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts = {
		get assignmentObjectPattern() {
			return ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"AssignmentObjectPattern",
		{
			bindingKeys: {},
			visitorKeys: {
				properties: true,
				rest: true,
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/AssignmentObjectPatternProperty.ts
const ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts = {
		get assignmentObjectPatternProperty() {
			return ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"AssignmentObjectPatternProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				value: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/AwaitExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts = {
		get awaitExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"AwaitExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/literals/BigIntLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts = {
		get bigIntLiteral() {
			return ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral;
		},
	};


	const ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"BigIntLiteral",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/expressions/BinaryExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts = {
		get binaryExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression;
		},
	};




	const ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"BinaryExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/BindingArrayPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts = {
		get bindingArrayPattern() {
			return ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"BindingArrayPattern",
		{
			bindingKeys: {
				elements: true,
				rest: true,
			},
			visitorKeys: {
				elements: true,
				rest: true,
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/BindingAssignmentPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts = {
		get bindingAssignmentPattern() {
			return ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"BindingAssignmentPattern",
		{
			bindingKeys: {
				left: true,
			},
			visitorKeys: {
				left: true,
				right: true,
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/BindingIdentifier.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts = {
		get bindingIdentifier() {
			return ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"BindingIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/BindingObjectPattern.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts = {
		get bindingObjectPattern() {
			return ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"BindingObjectPattern",
		{
			bindingKeys: {
				properties: true,
				rest: true,
			},
			visitorKeys: {
				properties: true,
				rest: true,
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/BindingObjectPatternProperty.ts
const ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts = {
		get bindingObjectPatternProperty() {
			return ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"BindingObjectPatternProperty",
		{
			bindingKeys: {
				value: true,
			},
			visitorKeys: {
				key: true,
				value: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/BlockStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts = {
		get blockStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"BlockStatement",
		"body",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
				directives: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/literals/BooleanLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts = {
		get booleanLiteral() {
			return ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral;
		},
	};


	const ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"BooleanLiteral",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/statements/BreakStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts = {
		get breakStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts$breakStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts$breakStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"BreakStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				label: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/CallExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts = {
		get callExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"CallExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				callee: true,
				arguments: true,
				typeArguments: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/CatchClause.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts = {
		get catchClause() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts$catchClause;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts$catchClause = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"CatchClause",
		{
			bindingKeys: {
				param: true,
			},
			visitorKeys: {
				param: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/ClassDeclaration.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts = {
		get classDeclaration() {
			return ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ClassDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/ClassExpression.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts = {
		get classExpression() {
			return ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts$classExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts$classExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ClassExpression",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/ClassHead.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts = {
		get classHead() {
			return ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts$classHead;
		},
	};


	const ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts$classHead = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"ClassHead",
		"body",
		{
			bindingKeys: {},
			visitorKeys: {
				superClass: true,
				body: true,
				typeParameters: true,
				superTypeParameters: true,
				implements: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/ClassMethod.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts = {
		get classMethod() {
			return ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod;
		},
	};




	const ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ClassMethod",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				head: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/ClassPrivateMethod.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts = {
		get classPrivateMethod() {
			return ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod;
		},
	};


	const ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ClassPrivateMethod",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				head: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/ClassPrivateProperty.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts = {
		get classPrivateProperty() {
			return ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ClassPrivateProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				value: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/ClassProperty.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts = {
		get classProperty() {
			return ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts$classProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts$classProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ClassProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				value: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/ClassPropertyMeta.ts
const ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts = {
		get classPropertyMeta() {
			return ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta;
		},
	};


	const ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ClassPropertyMeta",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/core/CommentBlock.ts
const ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts = {
		get commentBlock() {
			return ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts$commentBlock;
		},
	};


	const ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts$commentBlock = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"CommentBlock",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/core/CommentLine.ts
const ___R$project$rome$$romejs$js$ast$core$CommentLine_ts = {
		get commentLine() {
			return ___R$project$rome$$romejs$js$ast$core$CommentLine_ts$commentLine;
		},
	};


	const ___R$project$rome$$romejs$js$ast$core$CommentLine_ts$commentLine = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"CommentLine",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/ComputedMemberProperty.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts = {
		get computedMemberProperty() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"ComputedMemberProperty",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/objects/ComputedPropertyKey.ts
const ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts = {
		get computedPropertyKey() {
			return ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey;
		},
	};


	const ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"ComputedPropertyKey",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/ConditionalExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts = {
		get conditionalExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts$conditionalExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts$conditionalExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ConditionalExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				consequent: true,
				alternate: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/ContinueStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts = {
		get continueStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts$continueStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts$continueStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ContinueStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				label: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/DebuggerStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts = {
		get debuggerStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"DebuggerStatement",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/core/Directive.ts
const ___R$project$rome$$romejs$js$ast$core$Directive_ts = {
		get directive() {
			return ___R$project$rome$$romejs$js$ast$core$Directive_ts$directive;
		},
	};


	const ___R$project$rome$$romejs$js$ast$core$Directive_ts$directive = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"Directive",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/expressions/DoExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts = {
		get doExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts$doExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts$doExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"DoExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/DoWhileStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts = {
		get doWhileStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"DoWhileStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/EmptyStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts = {
		get emptyStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"EmptyStatement",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/modules/ExportAllDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts = {
		get exportAllDeclaration() {
			return ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExportAllDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				source: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ExportDefaultDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts = {
		get exportDefaultDeclaration() {
			return ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExportDefaultDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				declaration: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ExportDefaultSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts = {
		get exportDefaultSpecifier() {
			return ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExportDefaultSpecifier",
		{
			bindingKeys: {},
			visitorKeys: {
				exported: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ExportExternalDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts = {
		get exportExternalDeclaration() {
			return ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration;
		},
	};




	const ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExportExternalDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				defaultSpecifier: true,
				namespaceSpecifier: true,
				namedSpecifiers: true,
				source: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ExportExternalSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts = {
		get exportExternalSpecifier() {
			return ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExportExternalSpecifier",
		{
			bindingKeys: {},
			visitorKeys: {
				exported: true,
				local: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ExportLocalDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts = {
		get exportLocalDeclaration() {
			return ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExportLocalDeclaration",
		{
			bindingKeys: {
				declaration: true,
			},
			visitorKeys: {
				declaration: true,
				specifiers: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ExportLocalSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts = {
		get exportLocalSpecifier() {
			return ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExportLocalSpecifier",
		{
			bindingKeys: {},
			visitorKeys: {
				local: true,
				exported: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ExportNamespaceSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts = {
		get exportNamespaceSpecifier() {
			return ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExportNamespaceSpecifier",
		{
			bindingKeys: {},
			visitorKeys: {
				exported: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/ExpressionStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts = {
		get expressionStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ExpressionStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/ForInStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts = {
		get forInStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts$forInStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts$forInStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ForInStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/ForOfStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts = {
		get forOfStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ForOfStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/ForStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts = {
		get forStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts$forStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts$forStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ForStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				init: true,
				test: true,
				update: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/FunctionDeclaration.ts
const ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts = {
		get functionDeclaration() {
			return ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"FunctionDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				head: true,
				id: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/FunctionExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts = {
		get functionExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"FunctionExpression",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				head: true,
				id: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/FunctionHead.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts = {
		get functionHead() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"FunctionHead",
		"params",
		{
			bindingKeys: {
				params: true,
				rest: true,
			},
			visitorKeys: {
				params: true,
				thisType: true,
				rest: true,
				returnType: true,
				typeParameters: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/Identifier.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts = {
		get identifier() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"Identifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/statements/IfStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts = {
		get ifStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts$ifStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts$ifStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"IfStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				consequent: true,
				alternate: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ImportCall.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts = {
		get importCall() {
			return ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts$importCall;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts$importCall = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ImportCall",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ImportDeclaration.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts = {
		get importDeclaration() {
			return ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration;
		},
	};




	const ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ImportDeclaration",
		{
			bindingKeys: {
				defaultSpecifier: true,
				namespaceSpecifier: true,
				namedSpecifiers: true,
			},
			visitorKeys: {
				defaultSpecifier: true,
				namespaceSpecifier: true,
				namedSpecifiers: true,
				source: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ImportDefaultSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts = {
		get importDefaultSpecifier() {
			return ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ImportDefaultSpecifier",
		{
			bindingKeys: {
				local: true,
			},
			visitorKeys: {
				local: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ImportNamespaceSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts = {
		get importNamespaceSpecifier() {
			return ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ImportNamespaceSpecifier",
		{
			bindingKeys: {
				local: true,
			},
			visitorKeys: {
				local: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ImportSpecifier.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts = {
		get importSpecifier() {
			return ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ImportSpecifier",
		{
			bindingKeys: {
				local: true,
			},
			visitorKeys: {
				imported: true,
				local: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/modules/ImportSpecifierLocal.ts
const ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts = {
		get importSpecifierLocal() {
			return ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal;
		},
	};


	const ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"ImportSpecifierLocal",
		"name",
		{
			bindingKeys: {
				name: true,
			},
			visitorKeys: {
				name: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/core/InterpreterDirective.ts
const ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts = {
		get interpreterDirective() {
			return ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective;
		},
	};


	const ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"InterpreterDirective",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXAttribute.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts = {
		get jsxAttribute() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXAttribute",
		{
			bindingKeys: {},
			visitorKeys: {
				name: true,
				value: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXElement.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts = {
		get jsxElement() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXElement",
		{
			bindingKeys: {},
			visitorKeys: {
				name: true,
				typeArguments: true,
				attributes: true,
				children: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXEmptyExpression.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts = {
		get jsxEmptyExpression() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXEmptyExpression",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXExpressionContainer.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts = {
		get jsxExpressionContainer() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXExpressionContainer",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXFragment.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts = {
		get jsxFragment() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXFragment",
		{
			bindingKeys: {},
			visitorKeys: {
				children: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXIdentifier.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts = {
		get jsxIdentifier() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"JSXIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXMemberExpression.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts = {
		get jsxMemberExpression() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXMemberExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				object: true,
				property: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXNamespacedName.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts = {
		get jsxNamespacedName() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXNamespacedName",
		{
			bindingKeys: {},
			visitorKeys: {
				namespace: true,
				name: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXReferenceIdentifier.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts = {
		get jsxReferenceIdentifier() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXReferenceIdentifier",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXSpreadAttribute.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts = {
		get jsxSpreadAttribute() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXSpreadAttribute",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXSpreadChild.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts = {
		get jsxSpreadChild() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXSpreadChild",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/jsx/JSXText.ts
const ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts = {
		get jsxText() {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts$jsxText;
		},
	};


	const ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts$jsxText = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"JSXText",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/statements/LabeledStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts = {
		get labeledStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"LabeledStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				label: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/LogicalExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts = {
		get logicalExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression;
		},
	};




	const ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"LogicalExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/MemberExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts = {
		get memberExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"MemberExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				object: true,
				property: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/MetaProperty.ts
const ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts = {
		get metaProperty() {
			return ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts$metaProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts$metaProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"MetaProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				property: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/temp/MockParent.ts
const ___R$project$rome$$romejs$js$ast$temp$MockParent_ts = {
		get mockParent() {
			return ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$mockParent;
		},
		get MOCK_PARENT() {
			return ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT;
		},
	};


	const ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$mockParent = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"MockParent",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);

	const ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT = {
		type: "MockParent",
	};


  // project-rome/@romejs/js-ast/expressions/NewExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts = {
		get newExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts$newExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts$newExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"NewExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				callee: true,
				arguments: true,
				typeArguments: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/literals/NullLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts = {
		get nullLiteral() {
			return ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral;
		},
	};


	const ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"NullLiteral",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/literals/NumericLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts = {
		get numericLiteral() {
			return ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral;
		},
	};


	const ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"NumericLiteral",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/objects/ObjectExpression.ts
const ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts = {
		get objectExpression() {
			return ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"ObjectExpression",
		"properties",
		{
			bindingKeys: {},
			visitorKeys: {
				properties: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/objects/ObjectMethod.ts
const ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts = {
		get objectMethod() {
			return ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod;
		},
	};




	const ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ObjectMethod",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				head: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/objects/ObjectProperty.ts
const ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts = {
		get objectProperty() {
			return ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ObjectProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				value: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/OptionalCallExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts = {
		get optionalCallExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"OptionalCallExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				callee: true,
				arguments: true,
				typeArguments: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/patterns/PatternMeta.ts
const ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts = {
		get patternMeta() {
			return ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts$patternMeta;
		},
	};


	const ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts$patternMeta = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"PatternMeta",
		"typeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/classes/PrivateName.ts
const ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts = {
		get privateName() {
			return ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts$privateName;
		},
	};


	const ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts$privateName = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"PrivateName",
		{
			bindingKeys: {},
			visitorKeys: {
				id: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/core/Program.ts
const ___R$project$rome$$romejs$js$ast$core$Program_ts = {
		get MOCK_PROGRAM() {
			return ___R$project$rome$$romejs$js$ast$core$Program_ts$MOCK_PROGRAM;
		},
		get program() {
			return ___R$project$rome$$romejs$js$ast$core$Program_ts$program;
		},
	};


	const ___R$project$rome$$romejs$js$ast$core$Program_ts$MOCK_PROGRAM = {
		type: "Program",
		directives: [],
		body: [],
		filename: "unknown",
		mtime: undefined,
		interpreter: undefined,
		corrupt: false,
		sourceType: "module",
		diagnostics: [],
		comments: [],
		syntax: [],
		hasHoistedVars: false,
	};

	const ___R$project$rome$$romejs$js$ast$core$Program_ts$program = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"Program",
		{
			bindingKeys: {},
			visitorKeys: {
				interpreter: true,
				directives: true,
				body: true,
				comments: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/ReferenceIdentifier.ts
const ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts = {
		get referenceIdentifier() {
			return ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"ReferenceIdentifier",
		"name",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpAlternation.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts = {
		get regExpAlternation() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts$regExpAlternation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts$regExpAlternation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpAlternation",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpAnyCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts = {
		get regExpAnyCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts$regExpAnyCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts$regExpAnyCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpAnyCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts = {
		get regExpCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts$regExpCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts$regExpCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpCharSet.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts = {
		get regExpCharSet() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts$regExpCharSet;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts$regExpCharSet = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpCharSet",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpCharSetRange.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts = {
		get regExpCharSetRange() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts$regExpCharSetRange;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts$regExpCharSetRange = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpCharSetRange",
		{
			bindingKeys: {},
			visitorKeys: {
				start: true,
				end: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpControlCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts = {
		get regExpControlCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts$regExpControlCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts$regExpControlCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpControlCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpDigitCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts = {
		get regExpDigitCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts$regExpDigitCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts$regExpDigitCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpDigitCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpEndCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts = {
		get regExpEndCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts$regExpEndCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts$regExpEndCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpEndCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpGroupCapture.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts = {
		get regExpGroupCapture() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts$regExpGroupCapture;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts$regExpGroupCapture = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpGroupCapture",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpGroupNonCapture.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts = {
		get regExpGroupNonCapture() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts$regExpGroupNonCapture;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts$regExpGroupNonCapture = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpGroupNonCapture",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/literals/RegExpLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts = {
		get regExpLiteral() {
			return ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral;
		},
	};


	const ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpLiteral",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpNamedBackReference.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNamedBackReference_ts = {
		get regExpNamedBackReference() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpNamedBackReference_ts$regExpNamedBackReference;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpNamedBackReference_ts$regExpNamedBackReference = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpNamedBackReference",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpNonDigitCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts = {
		get regExpNonDigitCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts$regExpNonDigitCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts$regExpNonDigitCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpNonDigitCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpNonWhiteSpaceCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts = {
		get regExpNonWhiteSpaceCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts$regExpNonWhiteSpaceCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts$regExpNonWhiteSpaceCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpNonWhiteSpaceCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpNonWordBoundaryCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts = {
		get regExpNonWordBoundaryCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts$regExpNonWordBoundaryCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts$regExpNonWordBoundaryCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpNonWordBoundaryCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpNonWordCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts = {
		get regExpNonWordCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts$regExpNonWordCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts$regExpNonWordCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpNonWordCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpNumericBackReference.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpNumericBackReference_ts = {
		get regExpNumericBackReference() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpNumericBackReference_ts$regExpNumericBackReference;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpNumericBackReference_ts$regExpNumericBackReference = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpNumericBackReference",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpQuantified.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts = {
		get regExpQuantified() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpQuantified",
		{
			bindingKeys: {},
			visitorKeys: {
				target: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpStartCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts = {
		get regExpStartCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts$regExpStartCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts$regExpStartCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpStartCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpSubExpression.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts = {
		get regExpSubExpression() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts$regExpSubExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts$regExpSubExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpSubExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpWhiteSpaceCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts = {
		get regExpWhiteSpaceCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts$regExpWhiteSpaceCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts$regExpWhiteSpaceCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpWhiteSpaceCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpWordBoundaryCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts = {
		get regExpWordBoundaryCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts$regExpWordBoundaryCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts$regExpWordBoundaryCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpWordBoundaryCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/regex/RegExpWordCharacter.ts
const ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts = {
		get regExpWordCharacter() {
			return ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts$regExpWordCharacter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts$regExpWordCharacter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"RegExpWordCharacter",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/statements/ReturnStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts = {
		get returnStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"ReturnStatement",
		"argument",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/SequenceExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts = {
		get sequenceExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"SequenceExpression",
		{bindingKeys: {}, visitorKeys: {expressions: true}},
	);


  // project-rome/@romejs/js-ast/auxiliary/SpreadElement.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts = {
		get spreadElement() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"SpreadElement",
		"argument",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/objects/SpreadProperty.ts
const ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts = {
		get spreadProperty() {
			return ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"SpreadProperty",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/StaticMemberProperty.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts = {
		get staticMemberProperty() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"StaticMemberProperty",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/objects/StaticPropertyKey.ts
const ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts = {
		get staticPropertyKey() {
			return ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey;
		},
	};


	const ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"StaticPropertyKey",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {
				value: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/literals/StringLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts = {
		get stringLiteral() {
			return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral;
		},
	};


	const ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"StringLiteral",
		"value",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/expressions/Super.ts
const ___R$project$rome$$romejs$js$ast$expressions$Super_ts = {
		get _super() {
			return ___R$project$rome$$romejs$js$ast$expressions$Super_ts$_super;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$Super_ts$_super = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"Super",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/SwitchCase.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts = {
		get switchCase() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"SwitchCase",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				consequent: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/SwitchStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts = {
		get switchStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts$switchStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts$switchStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"SwitchStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				discriminant: true,
				cases: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/TaggedTemplateExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts = {
		get taggedTemplateExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TaggedTemplateExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				tag: true,
				quasi: true,
				typeArguments: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/TemplateElement.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts = {
		get templateElement() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TemplateElement",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/literals/TemplateLiteral.ts
const ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts = {
		get templateLiteral() {
			return ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral;
		},
	};


	const ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TemplateLiteral",
		{
			bindingKeys: {},
			visitorKeys: {
				quasis: true,
				expressions: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/ThisExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts = {
		get thisExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts$thisExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts$thisExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ThisExpression",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/statements/ThrowStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts = {
		get throwStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts$throwStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts$throwStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"ThrowStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/TryStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts = {
		get tryStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts$tryStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts$tryStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TryStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				block: true,
				handler: true,
				finalizer: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSAnyKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAnyKeywordTypeAnnotation_ts = {
		get tsAnyKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSAnyKeywordTypeAnnotation_ts$tsAnyKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSAnyKeywordTypeAnnotation_ts$tsAnyKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSAnyKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSArrayType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts = {
		get tsArrayType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSArrayType",
		{
			bindingKeys: {},
			visitorKeys: {elementType: true},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSAsExpression.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts = {
		get tsAsExpression() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSAsExpression",
		{
			bindingKeys: {},
			visitorKeys: {expression: true, typeAnnotation: true},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSAssignmentAsExpression.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts = {
		get tsAssignmentAsExpression() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSAssignmentAsExpression",
		{
			bindingKeys: {},
			visitorKeys: {expression: true, typeAnnotation: true},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSAssignmentNonNullExpression.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts = {
		get tsAssignmentNonNullExpression() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSAssignmentNonNullExpression",
		{
			bindingKeys: {},
			visitorKeys: {expression: true},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSAssignmentTypeAssertion.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts = {
		get tsAssignmentTypeAssertion() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSAssignmentTypeAssertion",
		{
			bindingKeys: {},
			visitorKeys: {expression: true, typeAnnotation: true},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSBigIntKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSBigIntKeywordTypeAnnotation_ts = {
		get tsBigIntKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSBigIntKeywordTypeAnnotation_ts$tsBigIntKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSBigIntKeywordTypeAnnotation_ts$tsBigIntKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSBigIntKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSBooleanKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSBooleanKeywordTypeAnnotation_ts = {
		get tsBooleanKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSBooleanKeywordTypeAnnotation_ts$tsBooleanKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSBooleanKeywordTypeAnnotation_ts$tsBooleanKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSBooleanKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSBooleanLiteralTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSBooleanLiteralTypeAnnotation_ts = {
		get tsBooleanLiteralTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSBooleanLiteralTypeAnnotation_ts$tsBooleanLiteralTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSBooleanLiteralTypeAnnotation_ts$tsBooleanLiteralTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSBooleanLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSCallSignatureDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts = {
		get tsCallSignatureDeclaration() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSCallSignatureDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSConditionalType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts = {
		get tsConditionalType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSConditionalType",
		{
			bindingKeys: {},
			visitorKeys: {
				checkType: true,
				extendsType: true,
				trueType: true,
				falseType: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSConstructorType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts = {
		get tsConstructorType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSConstructorType",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSConstructSignatureDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts = {
		get tsConstructSignatureDeclaration() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSConstructSignatureDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSDeclareFunction.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts = {
		get tsDeclareFunction() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSDeclareFunction",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				head: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSDeclareMethod.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts = {
		get tsDeclareMethod() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSDeclareMethod",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				key: true,
				head: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSEmptyKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSEmptyKeywordTypeAnnotation_ts = {
		get tsEmptyKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSEmptyKeywordTypeAnnotation_ts$tsEmptyKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSEmptyKeywordTypeAnnotation_ts$tsEmptyKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSEmptyKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSEnumDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts = {
		get tsEnumDeclaration() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSEnumDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				members: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSEnumMember.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts = {
		get tsEnumMember() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSEnumMember",
		{
			bindingKeys: {},
			visitorKeys: {
				id: true,
				initializer: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSExportAssignment.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts = {
		get tsExportAssignment() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSExportAssignment",
		{bindingKeys: {}, visitorKeys: {expression: true}},
	);


  // project-rome/@romejs/js-ast/typescript/TSExpressionWithTypeArguments.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts = {
		get tsExpressionWithTypeArguments() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSExpressionWithTypeArguments",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
				typeParameters: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSExternalModuleReference.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts = {
		get tsExternalModuleReference() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSExternalModuleReference",
		{
			bindingKeys: {},
			visitorKeys: {expression: true},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSFunctionType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts = {
		get tsFunctionType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSFunctionType",
		{
			bindingKeys: {},
			visitorKeys: {
				meta: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSImportEqualsDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts = {
		get tsImportEqualsDeclaration() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSImportEqualsDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {id: true, moduleReference: true},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSImportType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts = {
		get tsImportType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts$tsImportType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts$tsImportType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSImportType",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
				typeParameters: true,
				qualifier: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSIndexedAccessType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts = {
		get tsIndexedAccessType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSIndexedAccessType",
		{
			bindingKeys: {},
			visitorKeys: {
				objectType: true,
				indexType: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSIndexSignature.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts = {
		get tsIndexSignature() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSIndexSignature",
		{
			bindingKeys: {
				key: true,
			},
			visitorKeys: {
				typeAnnotation: true,
				key: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSInferType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts = {
		get tsInferType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts$tsInferType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts$tsInferType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSInferType",
		{
			bindingKeys: {},
			visitorKeys: {
				typeParameter: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSInterfaceBody.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts = {
		get tsInterfaceBody() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSInterfaceBody",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSInterfaceDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts = {
		get tsInterfaceDeclaration() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSInterfaceDeclaration",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				body: true,
				typeParameters: true,
				extends: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSIntersectionTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSIntersectionTypeAnnotation_ts = {
		get tsIntersectionTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSIntersectionTypeAnnotation_ts$tsIntersectionTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSIntersectionTypeAnnotation_ts$tsIntersectionTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSIntersectionTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {
				types: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSMappedType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts = {
		get tsMappedType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType;
		},
	};




	const ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSMappedType",
		{
			bindingKeys: {},
			visitorKeys: {
				typeParameter: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSMethodSignature.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts = {
		get tsMethodSignature() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSMethodSignature",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				meta: true,
				returnType: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSMixedKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSMixedKeywordTypeAnnotation_ts = {
		get tsMixedKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSMixedKeywordTypeAnnotation_ts$tsMixedKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSMixedKeywordTypeAnnotation_ts$tsMixedKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSMixedKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSModuleBlock.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts = {
		get tsModuleBlock() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSModuleBlock",
		{
			bindingKeys: {},
			visitorKeys: {
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSModuleDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts = {
		get tsModuleDeclaration() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSModuleDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				id: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSNamespaceExportDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts = {
		get tsNamespaceExportDeclaration() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSNamespaceExportDeclaration",
		{bindingKeys: {}, visitorKeys: {id: true}},
	);


  // project-rome/@romejs/js-ast/typescript/TSNeverKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSNeverKeywordTypeAnnotation_ts = {
		get tsNeverKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSNeverKeywordTypeAnnotation_ts$tsNeverKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSNeverKeywordTypeAnnotation_ts$tsNeverKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSNeverKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSNonNullExpression.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts = {
		get tsNonNullExpression() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSNonNullExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSNullKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSNullKeywordTypeAnnotation_ts = {
		get tsNullKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSNullKeywordTypeAnnotation_ts$tsNullKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSNullKeywordTypeAnnotation_ts$tsNullKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSNullKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSNumberKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSNumberKeywordTypeAnnotation_ts = {
		get tsNumberKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSNumberKeywordTypeAnnotation_ts$tsNumberKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSNumberKeywordTypeAnnotation_ts$tsNumberKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSNumberKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSNumericLiteralTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSNumericLiteralTypeAnnotation_ts = {
		get tsNumericLiteralTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSNumericLiteralTypeAnnotation_ts$tsNumericLiteralTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSNumericLiteralTypeAnnotation_ts$tsNumericLiteralTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSNumericLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSObjectKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSObjectKeywordTypeAnnotation_ts = {
		get tsObjectKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSObjectKeywordTypeAnnotation_ts$tsObjectKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSObjectKeywordTypeAnnotation_ts$tsObjectKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSObjectKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSOptionalType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts = {
		get tsOptionalType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSOptionalType",
		{
			bindingKeys: {},
			visitorKeys: {
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSParenthesizedType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts = {
		get tsParenthesizedType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSParenthesizedType",
		{
			bindingKeys: {},
			visitorKeys: {
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSPropertySignature.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts = {
		get tsPropertySignature() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSPropertySignature",
		{
			bindingKeys: {},
			visitorKeys: {
				key: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSQualifiedName.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts = {
		get tsQualifiedName() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSQualifiedName",
		{
			bindingKeys: {},
			visitorKeys: {
				left: true,
				right: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSSignatureDeclarationMeta.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts = {
		get tsSignatureDeclarationMeta() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSSignatureDeclarationMeta",
		{
			bindingKeys: {},
			visitorKeys: {
				parameters: true,
				rest: true,
				typeParameters: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSStringKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSStringKeywordTypeAnnotation_ts = {
		get tsStringKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSStringKeywordTypeAnnotation_ts$tsStringKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSStringKeywordTypeAnnotation_ts$tsStringKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSStringKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSStringLiteralTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSStringLiteralTypeAnnotation_ts = {
		get tsStringLiteralTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSStringLiteralTypeAnnotation_ts$tsStringLiteralTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSStringLiteralTypeAnnotation_ts$tsStringLiteralTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSStringLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSSymbolKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSSymbolKeywordTypeAnnotation_ts = {
		get tsSymbolKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSSymbolKeywordTypeAnnotation_ts$tsSymbolKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSSymbolKeywordTypeAnnotation_ts$tsSymbolKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSSymbolKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTemplateLiteralTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTemplateLiteralTypeAnnotation_ts = {
		get tsTemplateLiteralTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTemplateLiteralTypeAnnotation_ts$tsTemplateLiteralTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTemplateLiteralTypeAnnotation_ts$tsTemplateLiteralTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTemplateLiteralTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSThisType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts = {
		get tsThisType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts$tsThisType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts$tsThisType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSThisType",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTupleType.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts = {
		get tsTupleType() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTupleType",
		{
			bindingKeys: {},
			visitorKeys: {
				elementTypes: true,
				rest: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypeAssertion.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts = {
		get tsTypeAssertion() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypeAssertion",
		{
			bindingKeys: {},
			visitorKeys: {
				expression: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypeLiteral.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts = {
		get tsTypeLiteral() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypeLiteral",
		{
			bindingKeys: {},
			visitorKeys: {
				members: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypeOperator.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts = {
		get tsTypeOperator() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypeOperator",
		{
			bindingKeys: {},
			visitorKeys: {
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypeParameter.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts = {
		get tsTypeParameter() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypeParameter",
		{
			bindingKeys: {},
			visitorKeys: {
				default: true,
				constraint: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypeParameterDeclaration.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts = {
		get tsTypeParameterDeclaration() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypeParameterDeclaration",
		{
			bindingKeys: {},
			visitorKeys: {
				params: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypeParameterInstantiation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts = {
		get tsTypeParameterInstantiation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypeParameterInstantiation",
		{
			bindingKeys: {},
			visitorKeys: {
				params: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypePredicate.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts = {
		get tsTypePredicate() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypePredicate",
		{
			bindingKeys: {},
			visitorKeys: {
				parameterName: true,
				typeAnnotation: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypeQuery.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts = {
		get tsTypeQuery() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypeQuery",
		{
			bindingKeys: {},
			visitorKeys: {
				exprName: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TSTypeReference.ts
const ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts = {
		get tsTypeReference() {
			return ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TSTypeReference",
		{
			bindingKeys: {},
			visitorKeys: {
				typeName: true,
				typeParameters: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/TypeAliasTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$TypeAliasTypeAnnotation_ts = {
		get typeAliasTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"TypeAliasTypeAnnotation",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				typeParameters: true,
				right: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/UnaryExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts = {
		get unaryExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression;
		},
	};




	const ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"UnaryExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/UndefinedKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$UndefinedKeywordTypeAnnotation_ts = {
		get undefinedKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"UndefinedKeywordTypeAnnotation",
		{bindingKeys: {}, visitorKeys: {}},
	);


  // project-rome/@romejs/js-ast/typescript/UnionTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$UnionTypeAnnotation_ts = {
		get unionTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$UnionTypeAnnotation_ts$unionTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$UnionTypeAnnotation_ts$unionTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"UnionTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {
				types: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/UnknownKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$UnknownKeywordTypeAnnotation_ts = {
		get unknownKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"UnknownKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/expressions/UpdateExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts = {
		get updateExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression;
		},
	};




	const ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"UpdateExpression",
		{
			bindingKeys: {},
			visitorKeys: {
				argument: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/VariableDeclaration.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts = {
		get variableDeclaration() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration;
		},
	};




	const ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"VariableDeclaration",
		{
			bindingKeys: {
				declarations: true,
			},
			visitorKeys: {
				declarations: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/VariableDeclarationStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts = {
		get variableDeclarationStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createQuickBuilder(
		"VariableDeclarationStatement",
		"declaration",
		{
			bindingKeys: {
				declaration: true,
			},
			visitorKeys: {
				declaration: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/auxiliary/VariableDeclarator.ts
const ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts = {
		get variableDeclarator() {
			return ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator;
		},
	};


	const ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"VariableDeclarator",
		{
			bindingKeys: {
				id: true,
			},
			visitorKeys: {
				id: true,
				init: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/typescript/VoidKeywordTypeAnnotation.ts
const ___R$project$rome$$romejs$js$ast$typescript$VoidKeywordTypeAnnotation_ts = {
		get voidKeywordTypeAnnotation() {
			return ___R$project$rome$$romejs$js$ast$typescript$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation;
		},
	};


	const ___R$project$rome$$romejs$js$ast$typescript$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"VoidKeywordTypeAnnotation",
		{
			bindingKeys: {},
			visitorKeys: {},
		},
	);


  // project-rome/@romejs/js-ast/statements/WhileStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts = {
		get whileStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts$whileStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts$whileStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"WhileStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				test: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/statements/WithStatement.ts
const ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts = {
		get withStatement() {
			return ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts$withStatement;
		},
	};


	const ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts$withStatement = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"WithStatement",
		{
			bindingKeys: {},
			visitorKeys: {
				object: true,
				body: true,
			},
		},
	);


  // project-rome/@romejs/js-ast/expressions/YieldExpression.ts
const ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts = {
		get yieldExpression() {
			return ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression;
		},
	};


	const ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression = ___R$project$rome$$romejs$js$ast$utils_ts$createBuilder(
		"YieldExpression",
		{bindingKeys: {}, visitorKeys: {argument: true}},
	);


  // project-rome/@romejs/js-ast/index.ts
const ___R$project$rome$$romejs$js$ast$index_ts = {
		get bindingKeys() {
			return ___R$project$rome$$romejs$js$ast$utils_ts$bindingKeys;
		},
		get nodeNames() {
			return ___R$project$rome$$romejs$js$ast$utils_ts$nodeNames;
		},
		get visitorKeys() {
			return ___R$project$rome$$romejs$js$ast$utils_ts$visitorKeys;
		},
	};
	Object.keys(___R$project$rome$$romejs$js$ast$base_ts).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$base_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$constants_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$constants_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$unions_ts).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$unions_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$ArrayHole_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$ArrayHole_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$ClassHead_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$core$CommentBlock_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$core$CommentLine_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$core$CommentLine_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$ConditionalExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$core$Directive_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$core$Directive_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$ForStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$IfStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$modules$ImportCall_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$jsx$JSXText_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$temp$MockParent_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$temp$MockParent_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$classes$PrivateName_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$core$Program_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$core$Program_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$regex$RegExpNamedBackReference_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpNamedBackReference_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$regex$RegExpNumericBackReference_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpNumericBackReference_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$Super_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$Super_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$TryStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSAnyKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSAnyKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSBigIntKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSBigIntKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSBooleanKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSBooleanKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSBooleanLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSBooleanLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSEmptyKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSEmptyKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSIntersectionTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSIntersectionTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSMixedKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSMixedKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSNeverKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSNeverKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSNullKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSNullKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSNumberKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSNumberKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSNumericLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSNumericLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSObjectKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSObjectKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSStringKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSStringKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSStringLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSStringLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSSymbolKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSSymbolKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSTemplateLiteralTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTemplateLiteralTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$TypeAliasTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$TypeAliasTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$UndefinedKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$UndefinedKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$UnionTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$UnionTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$UnknownKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$UnknownKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts[key];
				},
			},
		);
	});
	Object.keys(
		___R$project$rome$$romejs$js$ast$typescript$VoidKeywordTypeAnnotation_ts,
	).forEach(function(key) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$typescript$VoidKeywordTypeAnnotation_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$statements$WithStatement_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$ast$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts[key];
				},
			},
		);
	});


  // project-rome/@romejs/js-ast-utils/getBindingIdentifiers.ts
function ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
		node,
	) {
		const ids = [];
		let queue = Array.isArray(node) ? [...node] : [node];

		while (queue.length) {
			const node = queue.pop();
			if (node === undefined) {
				continue;
			}

			if (node.type === "BindingIdentifier") {
				ids.push(node);
				continue;
			}

			const keys = ___R$project$rome$$romejs$js$ast$utils_ts$bindingKeys.get(
				node.type,
			);
			if (keys === undefined) {
				continue;
			}

			for (const key of keys) {
				// rome-ignore lint/js/noExplicitAny
				const val = (node)[key];
				if (val === undefined) {
					continue;
				} else if (Array.isArray(val)) {
					queue = queue.concat(val);
				} else {
					queue.push(val);
				}
			}
		}

		return ids;
	}


  // project-rome/@romejs/js-ast-utils/getCompletionRecords.ts






	function ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(
		node,
		parent,
		key,
	) {
		if (node === undefined) {
			return [
				{
					type: "INVALID",
					description: "empty " + key,
					node: parent,
				},
			];
		} else {
			return ___R$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$default(
				node,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(
		nodes,
	) {
		// Get the last node to produce records
		for (let i = nodes.length - 1; i >= 0; i--) {
			const node = nodes[i];
			const records = ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(
				node,
			);
			if (records !== undefined) {
				return records;
			}
		}
		return undefined;
	}

	function ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(
		node,
	) {
		if (node.type === "BlockStatement") {
			const records = ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(
				node.body,
			);
			if (records !== undefined) {
				return records;
			}

			return [
				{
					type: "INVALID",
					description: "empty block",
					node,
				},
			];
		}

		if (node.type === "SwitchStatement") {
			for (const caseNode of node.cases) {
				if (caseNode.test === undefined) {
					const records = ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getLastCompletionRecordFromNodes(
						caseNode.consequent,
					);
					if (records === undefined) {
						return [
							{
								type: "INVALID",
								description: "default switch clause with no completions",
								node: caseNode,
							},
						];
					} else {
						return records;
					}
				}
			}

			return [
				{
					type: "INVALID",
					description: "switch with no default clause",
					node,
				},
			];
		}

		if (node.type === "IfStatement") {
			return [
				...___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(
					node.consequent,
					node,
					"consequent",
				),
				...___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$getIfCompletionRecords(
					node.alternate,
					node,
					"alternate",
				),
			];
		}

		if (
			node.type === "ReturnStatement" ||
			node.type === "ContinueStatement" ||
			node.type === "BreakStatement" ||
			node.type === "ThrowStatement"
		) {
			return [
				{
					type: "COMPLETION",
					node,
				},
			];
		}

		return undefined;
	}

	function ___R$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$default(
		node,
	) {
		const records = ___R$$priv$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$_getCompletionRecords(
			node,
		);
		if (records === undefined) {
			return [
				{
					type: "INVALID",
					description: "invalid node",
					node,
				},
			];
		} else {
			return records;
		}
	}


  // project-rome/@romejs/js-ast-utils/getImportSpecifiers.ts
function ___R$project$rome$$romejs$js$ast$utils$getImportSpecifiers_ts$default(
		node,
	) {
		let specifiers = [];

		if (node.defaultSpecifier !== undefined) {
			specifiers.push(node.defaultSpecifier);
		}

		if (node.namespaceSpecifier !== undefined) {
			specifiers.push(node.namespaceSpecifier);
		}

		specifiers = specifiers.concat(node.namedSpecifiers);

		return specifiers;
	}


  // project-rome/@romejs/js-ast-utils/getPrecedence.ts
const ___R$$priv$project$rome$$romejs$js$ast$utils$getPrecedence_ts$PRECEDENCE = {
		"||": 0,
		"&&": 1,
		"??": 1,
		"|": 2,
		"^": 3,
		"&": 4,
		"==": 5,
		"===": 5,
		"!=": 5,
		"!==": 5,
		"<": 6,
		">": 6,
		"<=": 6,
		">=": 6,
		in: 6,
		instanceof: 6,
		">>": 7,
		"<<": 7,
		">>>": 7,
		"+": 8,
		"-": 8,
		"*": 9,
		"/": 9,
		"%": 9,
		"**": 10,
	};

	function ___R$project$rome$$romejs$js$ast$utils$getPrecedence_ts$default(
		operator,
	) {
		return ___R$$priv$project$rome$$romejs$js$ast$utils$getPrecedence_ts$PRECEDENCE[operator];
	}


  // project-rome/@romejs/js-ast-utils/getRequireSource.ts
function ___R$project$rome$$romejs$js$ast$utils$getRequireSource_ts$default(
		node,
		scope,
		allowStaticMember = false,
	) {
		if (node === undefined) {
			return undefined;
		}

		if (
			allowStaticMember &&
			node.type === "MemberExpression" &&
			node.property.type === "StaticMemberProperty"
		) {
			node = node.object;
		}

		if (node.type !== "CallExpression") {
			return undefined;
		}

		const {arguments: args, callee} = node;

		const [firstArg] = args;
		if (args.length !== 1 || firstArg.type !== "StringLiteral") {
			return undefined;
		}

		const validRequireCallee =
			callee.type === "ReferenceIdentifier" &&
			callee.name === "require" &&
			scope.getBinding("require") === undefined;

		const validRomeRequreCallee =
			(___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
				callee,
				"Rome.requireDefault",
			) ||
			___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
				callee,
				"Rome.requireNamespace",
			)) &&
			scope.getBinding("Rome") === undefined;

		if (validRequireCallee || validRomeRequreCallee) {
			return firstArg.value;
		}

		return undefined;
	}


  // project-rome/@romejs/js-ast-utils/hasPotentialSideEffects.ts
function ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
		node,
		scope,
	) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "ExportLocalDeclaration":
				if (node.declaration === undefined) {
					return false;
				} else {
					return ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
						node.declaration,
						scope,
					);
				}

			case "ExportExternalDeclaration":
				return true;

			case "FunctionExpression":
			case "FunctionDeclaration":
				return false;

			case "ClassDeclaration":
				return (
					node.meta.superClass !== undefined ||
					!___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
						node.meta.superClass,
						scope,
					)
				);

			case "ReferenceIdentifier":
				// Variables that aren't in scope and aren't registered globals could trigger a getter
				// Unlikely but let's aim for 100% correctness
				return (
					scope.getRootScope().isGlobal(node.name) ||
					scope.hasBinding(node.name)
				);

			case "VariableDeclaration": {
				for (const declarator of node.declarations) {
					if (
						___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
							declarator,
							scope,
						)
					) {
						return true;
					}
				}
				return false;
			}

			case "VariableDeclarator":
				return (
					___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
						node.id,
						scope,
					) ||
					___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
						node.init,
						scope,
					)
				);

			case "SpreadProperty":
			case "SpreadElement":
				return ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
					node.argument,
					scope,
				);

			case "BindingAssignmentPattern":
				return ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
					node.right,
					scope,
				);

			case "ObjectExpression":
			case "BindingObjectPattern": {
				for (const prop of node.properties) {
					if (
						___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
							prop,
							scope,
						)
					) {
						return true;
					}
				}
				return false;
			}

			case "StaticPropertyKey":
				return false;

			case "ComputedPropertyKey":
				return ___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
					node.value,
					scope,
				);

			case "BindingObjectPatternProperty":
			case "ObjectProperty":
				return (
					___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
						node.key,
						scope,
					) ||
					___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
						node.value,
						scope,
					)
				);

			case "BindingArrayPattern":
			case "ArrayExpression": {
				for (const elem of node.elements) {
					if (
						___R$project$rome$$romejs$js$ast$utils$hasPotentialSideEffects_ts$default(
							elem,
							scope,
						)
					) {
						return true;
					}
				}
				return false;
			}

			case "StringLiteral":
			case "NumericLiteral":
			case "BooleanLiteral":
			case "NullLiteral":
				return false;
		}

		return true;
	}


  // project-rome/@romejs/js-ast-utils/inheritLoc.ts
function ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(
		node,
		name,
	) {
		const {loc} = node;
		if (loc === undefined) {
			return undefined;
		}

		// Inherit new name if specified
		if (name !== undefined) {
			return Object.assign({}, loc, {identifierName: name});
		}

		// Don't infer a name if it already has one
		if (loc.identifierName !== undefined) {
			return loc;
		}

		// If this location has no identifierName and we're an Identifier then inherit it

		// TODO maybe handle other identifier types? JSXIdentifier etc?
		if (node.type === "Identifier") {
			return Object.assign({}, loc, {identifierName: node.name});
		}

		return loc;
	}


  // project-rome/@romejs/js-ast-utils/isBinary.ts
function ___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(node) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "BinaryExpression":
			case "LogicalExpression":
				return true;

			default:
				return false;
		}
	}


  // project-rome/@romejs/js-ast-utils/isConditional.ts
function ___R$project$rome$$romejs$js$ast$utils$isConditional_ts$default(node) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "ConditionalExpression":
			case "IfStatement":
				return true;

			default:
				return false;
		}
	}


  // project-rome/@romejs/js-ast-utils/isDeclaration.ts
function ___R$project$rome$$romejs$js$ast$utils$isDeclaration_ts$default(node) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "FunctionDeclaration":
			case "ClassDeclaration":
			case "ExportAllDeclaration":
			case "ExportDefaultDeclaration":
			case "ExportLocalDeclaration":
			case "ImportDeclaration":
			case "TypeAliasTypeAnnotation":
			case "VariableDeclarationStatement":
			case "ExportExternalDeclaration":
			case "TSDeclareFunction":
			case "TSEnumDeclaration":
			case "TSExportAssignment":
			case "TSImportEqualsDeclaration":
			case "TSInterfaceDeclaration":
			case "TSModuleDeclaration":
			case "TSNamespaceExportDeclaration": {
				const declaration = node;
				declaration;
				return true;
			}

			default: {
				const notDeclaration = node;
				notDeclaration;
				return false;
			}
		}
	}


  // project-rome/@romejs/js-ast-utils/isFor.ts
function ___R$project$rome$$romejs$js$ast$utils$isFor_ts$default(node) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "ForStatement":
			case "ForInStatement":
			case "ForOfStatement":
				return true;

			default:
				return false;
		}
	}


  // project-rome/@romejs/js-ast-utils/isFunctionNode.ts
function ___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(node) {
		return (
			node.type === "FunctionDeclaration" ||
			node.type === "FunctionExpression" ||
			node.type === "ObjectMethod" ||
			node.type === "ArrowFunctionExpression" ||
			node.type === "ClassMethod"
		);
	}


  // project-rome/@romejs/js-ast-utils/isTypeNode.ts
function ___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(node) {
		if (
			node.type.startsWith("Flow") ||
			node.type.startsWith("TS") ||
			node.type.endsWith("TypeAnnotation")
		) {
			return true;
		} else if (node.type === "ImportDeclaration") {
			return node.importKind === "type" || node.importKind === "typeof";
		} else if (
			node.type === "ExportDefaultDeclaration" ||
			node.type === "ExportLocalDeclaration" ||
			node.type === "ExportAllDeclaration"
		) {
			return node.exportKind === "type";
		} else {
			return false;
		}
	}


  // project-rome/@romejs/js-ast-utils/isTypeExpressionWrapperNode.ts
function ___R$project$rome$$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(
		node,
	) {
		return (
			node.type === "TSAsExpression" ||
			node.type === "TSTypeAssertion" ||
			node.type === "TSNonNullExpression"
		);
	}


  // project-rome/@romejs/js-ast-utils/isInTypeAnnotation.ts
// Is this honestly the best heuristics?
	function ___R$$priv$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$getTypeNode(
		path,
	) {
		const {parent, parentPath} = path;
		if (parent === undefined || parentPath === undefined) {
			return undefined;
		}

		if (___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(parent)) {
			return parent;
		}

		if (
			___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(
				parentPath.parent,
			)
		) {
			return parentPath.parent;
		}

		return undefined;
	}

	function ___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(
		path,
	) {
		const match = ___R$$priv$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$getTypeNode(
			path,
		);
		if (match === undefined) {
			return false;
		}

		if (
			___R$project$rome$$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(
				match,
			)
		) {
			return false;
		} else {
			return true;
		}
	}


  // project-rome/@romejs/js-ast-utils/isNodeLike.ts
function ___R$project$rome$$romejs$js$ast$utils$isNodeLike_ts$default(node) {
		if (node == null) {
			return false;
		} else {
			return (
				___R$project$rome$$romejs$typescript$helpers$index_ts$isPlainObject(
					node,
				) && typeof node.type === "string"
			);
		}
	}


  // project-rome/@romejs/js-ast-utils/isStatement.ts
function ___R$project$rome$$romejs$js$ast$utils$isStatement_ts$default(node) {
		if (node === undefined) {
			return false;
		}

		if (___R$project$rome$$romejs$js$ast$utils$isDeclaration_ts$default(node)) {
			return true;
		}

		switch (node.type) {
			case "BlockStatement":
			case "BreakStatement":
			case "ContinueStatement":
			case "DebuggerStatement":
			case "DoWhileStatement":
			case "EmptyStatement":
			case "ExpressionStatement":
			case "ForInStatement":
			case "ForStatement":
			case "IfStatement":
			case "LabeledStatement":
			case "ReturnStatement":
			case "SwitchStatement":
			case "ThrowStatement":
			case "TryStatement":
			case "WhileStatement":
			case "WithStatement":
			case "ForOfStatement": {
				const statement = node;
				statement;
				return true;
			}

			default: {
				// Assert that all statements were handled
				const notStatement = node;
				notStatement;
				return false;
			}
		}
	}


  // project-rome/@romejs/js-ast-utils/isUnaryLike.ts
function ___R$project$rome$$romejs$js$ast$utils$isUnaryLike_ts$default(node) {
		if (node === undefined) {
			return false;
		}

		switch (node.type) {
			case "UnaryExpression":
			case "SpreadElement":
			case "SpreadProperty":
				return true;

			default:
				return false;
		}
	}


  // project-rome/@romejs/js-parser-utils/identifier.ts
const ___R$project$rome$$romejs$js$parser$utils$identifier_ts = {
		get keywordRelationalOperator() {
			return ___R$project$rome$$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator;
		},
		isES2015ReservedWord: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord,
		isReservedWord: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isReservedWord,
		isStrictReservedWord: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord,
		isStrictBindReservedWord: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord,
		isKeyword: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isKeyword,
		getFullCharCodeAt: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt,
		isIdentifierStart: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart,
		isIdentifierChar: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar,
	};
	const ___R$project$rome$$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator = /^in(stanceof)?$/;

	function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord(
		word,
	) {
		return word === "enum" || word === "await";
	}

	function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isReservedWord(
		word,
		inModule,
	) {
		return (inModule && word === "await") || word === "enum";
	}

	const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$reservedWordsStrict = new Set([
		"implements",
		"interface",
		"let",
		"package",
		"private",
		"protected",
		"public",
		"static",
		"yield",
	]);
	function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(
		word,
		inModule,
	) {
		return (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isReservedWord(
				word,
				inModule,
			) ||
			___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$reservedWordsStrict.has(
				word,
			)
		);
	}

	function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(
		word,
		inModule,
	) {
		return (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(
				word,
				inModule,
			) ||
			word === "eval" ||
			word === "arguments"
		);
	}

	const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$keywords = new Set([
		"break",
		"case",
		"catch",
		"continue",
		"debugger",
		"default",
		"do",
		"else",
		"finally",
		"for",
		"function",
		"if",
		"return",
		"switch",
		"throw",
		"try",
		"var",
		"const",
		"while",
		"with",
		"new",
		"this",
		"super",
		"class",
		"extends",
		"export",
		"import",
		"null",
		"true",
		"false",
		"in",
		"instanceof",
		"typeof",
		"void",
		"delete",
	]);

	function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isKeyword(
		word,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$keywords.has(
			word,
		);
	}

	// ## Character categories
	// Big ugly regular expressions that match characters in the
	// whitespace, identifier, and identifier-start categories. These
	// are only applied when a character is found to actually have a
	// code point above 128.
	// Generated by `bin/generate-identifier-regex.js`.
	let ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312e\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fea\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

	let ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

	const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStart = new RegExp(
		"[" +
		___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars +
		"]",
	);
	const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifier = new RegExp(
		"[" +
		___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStartChars +
		___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierChars +
		"]",
	);

	// These are a run-length and offset encoded representation of the
	// >0xffff code points that are a valid part of identifiers. The
	// offset starts at 0x10000, and each pair of numbers represents an
	// offset to the next range, and then a size of the range. They were
	// generated by `bin/generate-identifier-regex.js`.

	/* prettier-ignore */
	const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes = [
		0,
		11,
		2,
		25,
		2,
		18,
		2,
		1,
		2,
		14,
		3,
		13,
		35,
		122,
		70,
		52,
		268,
		28,
		4,
		48,
		48,
		31,
		14,
		29,
		6,
		37,
		11,
		29,
		3,
		35,
		5,
		7,
		2,
		4,
		43,
		157,
		19,
		35,
		5,
		35,
		5,
		39,
		9,
		51,
		157,
		310,
		10,
		21,
		11,
		7,
		153,
		5,
		3,
		0,
		2,
		43,
		2,
		1,
		4,
		0,
		3,
		22,
		11,
		22,
		10,
		30,
		66,
		18,
		2,
		1,
		11,
		21,
		11,
		25,
		71,
		55,
		7,
		1,
		65,
		0,
		16,
		3,
		2,
		2,
		2,
		26,
		45,
		28,
		4,
		28,
		36,
		7,
		2,
		27,
		28,
		53,
		11,
		21,
		11,
		18,
		14,
		17,
		111,
		72,
		56,
		50,
		14,
		50,
		785,
		52,
		76,
		44,
		33,
		24,
		27,
		35,
		42,
		34,
		4,
		0,
		13,
		47,
		15,
		3,
		22,
		0,
		2,
		0,
		36,
		17,
		2,
		24,
		85,
		6,
		2,
		0,
		2,
		3,
		2,
		14,
		2,
		9,
		8,
		46,
		39,
		7,
		3,
		1,
		3,
		21,
		2,
		6,
		2,
		1,
		2,
		4,
		4,
		0,
		19,
		0,
		13,
		4,
		159,
		52,
		19,
		3,
		54,
		47,
		21,
		1,
		2,
		0,
		185,
		46,
		42,
		3,
		37,
		47,
		21,
		0,
		60,
		42,
		86,
		25,
		391,
		63,
		32,
		0,
		257,
		0,
		11,
		39,
		8,
		0,
		22,
		0,
		12,
		39,
		3,
		3,
		55,
		56,
		264,
		8,
		2,
		36,
		18,
		0,
		50,
		29,
		113,
		6,
		2,
		1,
		2,
		37,
		22,
		0,
		698,
		921,
		103,
		110,
		18,
		195,
		2_749,
		1_070,
		4_050,
		582,
		8_634,
		568,
		8,
		30,
		114,
		29,
		19,
		47,
		17,
		3,
		32,
		20,
		6,
		18,
		881,
		68,
		12,
		0,
		67,
		12,
		65,
		1,
		31,
		6_124,
		20,
		754,
		9_486,
		286,
		82,
		395,
		2_309,
		106,
		6,
		12,
		4,
		8,
		8,
		9,
		5_991,
		84,
		2,
		70,
		2,
		1,
		3,
		0,
		3,
		1,
		3,
		3,
		2,
		11,
		2,
		0,
		2,
		6,
		2,
		64,
		2,
		3,
		3,
		7,
		2,
		6,
		2,
		27,
		2,
		3,
		2,
		4,
		2,
		0,
		4,
		6,
		2,
		339,
		3,
		24,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		7,
		4_149,
		196,
		60,
		67,
		1_213,
		3,
		2,
		26,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		9,
		2,
		3,
		2,
		0,
		2,
		0,
		7,
		0,
		5,
		0,
		2,
		0,
		2,
		0,
		2,
		2,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		1,
		2,
		0,
		3,
		3,
		2,
		6,
		2,
		3,
		2,
		3,
		2,
		0,
		2,
		9,
		2,
		16,
		6,
		2,
		2,
		4,
		2,
		16,
		4_421,
		42_710,
		42,
		4_148,
		12,
		221,
		3,
		5_761,
		15,
		7_472,
		3_104,
		541,
	];
	/* prettier-ignore */
	const ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierCodes = [
		509,
		0,
		227,
		0,
		150,
		4,
		294,
		9,
		1_368,
		2,
		2,
		1,
		6,
		3,
		41,
		2,
		5,
		0,
		166,
		1,
		1_306,
		2,
		54,
		14,
		32,
		9,
		16,
		3,
		46,
		10,
		54,
		9,
		7,
		2,
		37,
		13,
		2,
		9,
		52,
		0,
		13,
		2,
		49,
		13,
		10,
		2,
		4,
		9,
		83,
		11,
		7,
		0,
		161,
		11,
		6,
		9,
		7,
		3,
		57,
		0,
		2,
		6,
		3,
		1,
		3,
		2,
		10,
		0,
		11,
		1,
		3,
		6,
		4,
		4,
		193,
		17,
		10,
		9,
		87,
		19,
		13,
		9,
		214,
		6,
		3,
		8,
		28,
		1,
		83,
		16,
		16,
		9,
		82,
		12,
		9,
		9,
		84,
		14,
		5,
		9,
		423,
		9,
		280,
		9,
		41,
		6,
		2,
		3,
		9,
		0,
		10,
		10,
		47,
		15,
		406,
		7,
		2,
		7,
		17,
		9,
		57,
		21,
		2,
		13,
		123,
		5,
		4,
		0,
		2,
		1,
		2,
		6,
		2,
		0,
		9,
		9,
		19_719,
		9,
		135,
		4,
		60,
		6,
		26,
		9,
		1_016,
		45,
		17,
		3,
		19_723,
		1,
		5_319,
		4,
		4,
		5,
		9,
		7,
		3,
		6,
		31,
		3,
		149,
		2,
		1_418,
		49,
		513,
		54,
		5,
		49,
		9,
		0,
		15,
		0,
		23,
		4,
		2,
		14,
		1_361,
		6,
		2,
		16,
		3,
		6,
		2,
		1,
		2,
		4,
		2_214,
		6,
		110,
		6,
		6,
		9,
		792_487,
		239,
	];

	// Get the full char code at a certain position
	function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(
		str,
		offset,
	) {
		const code = str.charCodeAt(offset);
		if (code <= 55_295 || code >= 57_344) {
			return code;
		}

		const next = str.charCodeAt(offset + 1);
		return (code << 10) + next - 56_613_888;
	}

	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$isInAstralSet(
		code,
		set,
	) {
		let pos = 65_536;
		for (let i = 0; i < set.length; i += 2) {
			pos += set[i];
			if (pos > code) {
				return false;
			}

			pos += set[i + 1];
			if (pos >= code) {
				return true;
			}
		}
		return false;
	}

	// Test whether a given character code starts an identifier.
	function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(
		code,
	) {
		if (code === undefined) {
			return false;
		}

		if (code < 65) {
			return code === 36;
		}

		if (code < 91) {
			return true;
		}

		if (code < 97) {
			return code === 95;
		}

		if (code < 123) {
			return true;
		}

		if (code <= 65_535) {
			return (
				code >= 170 &&
				___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifierStart.test(
					String.fromCharCode(code),
				)
			);
		}

		return ___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$isInAstralSet(
			code,
			___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes,
		);
	}

	function ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(
		code,
	) {
		if (code < 48) {
			return code === 36;
		}

		if (code < 58) {
			return true;
		}

		if (code < 65) {
			return false;
		}

		if (code < 91) {
			return true;
		}

		if (code < 97) {
			return code === 95;
		}

		if (code < 123) {
			return true;
		}

		if (code <= 65_535) {
			return (
				code >= 170 &&
				___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$nonASCIIidentifier.test(
					String.fromCharCode(code),
				)
			);
		}

		return (
			___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$isInAstralSet(
				code,
				___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierStartCodes,
			) ||
			___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$isInAstralSet(
				code,
				___R$$priv$project$rome$$romejs$js$parser$utils$identifier_ts$astralIdentifierCodes,
			)
		);
	}


  // project-rome/@romejs/js-parser-utils/location.ts
const ___R$project$rome$$romejs$js$parser$utils$location_ts = {
		createIndexTracker: ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker,
	};
	function ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker() {
		return {index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0};
	}




  // project-rome/@romejs/js-parser-utils/regex.ts
const ___R$project$rome$$romejs$js$parser$utils$regex_ts = {
		validateRegexFlags: ___R$project$rome$$romejs$js$parser$utils$regex_ts$validateRegexFlags,
	};
	const ___R$$priv$project$rome$$romejs$js$parser$utils$regex_ts$VALID_REGEX_FLAGS = "gmsiyu".split(
		"",
	);

	// This is used by both rome-json and rome-js-parser to validate regex flags
	function ___R$project$rome$$romejs$js$parser$utils$regex_ts$validateRegexFlags(
		flags,
		onUnexpected,
	) {
		const foundFlags = new Set();
		for (let i = 0; i < flags.length; i++) {
			const flag = flags[i];

			if (
				___R$$priv$project$rome$$romejs$js$parser$utils$regex_ts$VALID_REGEX_FLAGS.includes(
					flag,
				)
			) {
				if (foundFlags.has(flag)) {
					onUnexpected(
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.DUPLICATE_FLAG,
						i,
					);
				} else {
					foundFlags.add(flag);
				}
			} else {
				onUnexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.INVALID_FLAG,
					i,
				);
			}
		}

		return foundFlags;
	}


  // project-rome/@romejs/js-parser-utils/whitespace.ts
const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts = {
		get lineBreak() {
			return ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak;
		},
		get lineBreakG() {
			return ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreakG;
		},
		isNewLine: ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine,
		get nonASCIIwhitespace() {
			return ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace;
		},
		get skipWhiteSpace() {
			return ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace;
		},
		get NEWLINE() {
			return ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$NEWLINE;
		},
	};
	const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak = /\r\n?|\n|u2028|u2029/;
	const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreakG = new RegExp(
		___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.source,
		"g",
	);

	function ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(
		code,
	) {
		return code === 10 || code === 13 || code === 8_232 || code === 8_233;
	}

	const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

	const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

	const ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$NEWLINE = /\r\n|[\n\r\u2028\u2029]/;


  // project-rome/@romejs/js-parser-utils/index.ts



  // project-rome/@romejs/js-ast-utils/isValidIdentifierName.ts
function ___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(
		name,
	) {
		if (name.length === 0) {
			return false;
		}

		if (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(
				name,
				true,
			)
		) {
			return false;
		}

		if (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(
				name,
				true,
			)
		) {
			return false;
		}

		if (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isES2015ReservedWord(
				name,
			)
		) {
			return false;
		}

		if (___R$project$rome$$romejs$js$parser$utils$identifier_ts$isKeyword(name)) {
			return false;
		}

		if (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(
				___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(
					name,
					0,
				),
			) ===
			false
		) {
			return false;
		}

		let i = 1;
		while (i < name.length) {
			const code = ___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(
				name,
				i,
			);
			if (
				___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(
					code,
				)
			) {
				i += code <= 65_535 ? 1 : 2;
			} else {
				return false;
			}
		}

		return true;
	}


  // project-rome/@romejs/js-ast-utils/isVariableIdentifier.ts
function ___R$project$rome$$romejs$js$ast$utils$isVariableIdentifier_ts$default(
		node,
	) {
		return (
			node.type === "BindingIdentifier" ||
			node.type === "AssignmentIdentifier" ||
			node.type === "ReferenceIdentifier" ||
			node.type === "JSXReferenceIdentifier"
		);
	}


  // project-rome/@romejs/project/types.ts
const ___R$project$rome$$romejs$project$types_ts = {
		get DEFAULT_PROJECT_CONFIG_META() {
			return ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META;
		},
		get DEFAULT_PROJECT_CONFIG() {
			return ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG;
		},
	};

























	const ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META = {
		projectFolder: undefined,
		configPath: undefined,
		configHashes: [],
		configDependencies: new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(),
		consumer: undefined,
		configSourceSubKey: undefined,
		consumersChain: [],
	};

	const ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG = {
		name: "unknown",
		root: false,
		version: undefined,
		cache: {},
		develop: {
			serveStatic: true,
		},
		bundler: {
			mode: "modern",
		},
		compiler: {},
		resolver: {},
		typeCheck: {
			enabled: false,
			// Maybe this needs to be cloned...?
			libs: new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(),
		},
		dependencies: {
			enabled: false,
		},
		lint: {
			ignore: [],
			globals: [],
		},
		tests: {
			ignore: [],
		},
		vcs: {
			root: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath("/"),
		},
		files: {
			vendorPath: ___R$project$rome$$romejs$path$index_ts$TEMP_PATH.append(
				"rome-remote",
			),
			assetExtensions: [],
			maxSize: 40_000_000, // 40 megabytes
		},
		targets: new Map(),
	};


  // project-rome/@romejs/path-match/parse.ts




	const ___R$$priv$project$rome$$romejs$path$match$parse_ts$createPathMatchParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser((
		ParserCore,
	) =>
		(() => {
			class PathMatchParser extends ParserCore {
				constructor(opts, mode) {
					super(opts, "parse/patchMatch");
					this.mode = mode;
				}

				isWordCharacter(char, index, input) {
					const prevChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					) - 1];
					const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					) + 1];

					// Windows separator
					if (char === "\\" && nextChar === "\\") {
						return false;
					}

					// Any escaped character is a word character
					if (prevChar === "\\") {
						return true;
					}

					// Unix separator and wildcard
					if (char === "/") {
						return false;
					}

					if (this.mode === "pattern") {
						// Wildcard
						if (char === "*") {
							return false;
						}

						// Comment
						if (char === "#") {
							return false;
						}
					}

					return true;
				}

				tokenize(index, input) {
					const char = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					)];
					const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					) + 1];

					if (this.mode === "pattern") {
						if (char === "*") {
							if (nextChar === "*") {
								return this.finishToken(
									"DoubleStar",
									___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 2),
								);
							} else {
								return this.finishToken("Star");
							}
						} else if (
							index === ___R$project$rome$$romejs$ob1$index_ts$ob1Number0 &&
							char === "!"
						) {
							return this.finishToken("Exclamation");
						} else if (char === "#") {
							return this.finishToken("Hash");
						}
					}

					if (char === "/") {
						return this.finishToken("Separator");
					} else if (char === "\\" && nextChar === "\\") {
						return this.finishToken(
							"Separator",
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 2),
						);
					}

					const [value, end] = this.readInputFrom(
						index,
						this.isWordCharacter.bind(this),
					);
					return this.finishValueToken("Word", value, end);
				}

				eatSeparators() {
					let ate = false;
					while (this.eatToken("Separator") !== undefined) {
						ate = true;
					}
					return ate;
				}

				//# Pattern parsing
				parsePatternSegmentPart() {
					const startPos = this.getPosition();
					const token = this.getToken();
					this.nextToken();

					switch (token.type) {
						case "Star":
							return {
								type: "Wildcard",
								loc: this.finishLoc(startPos),
							};

						case "Word":
							return {
								type: "Word",
								loc: this.finishLoc(startPos),
								value: token.value,
							};

						default:
							throw this.unexpected({
								start: startPos,
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PATH_MATCH.INVALID_PATTERN_SEGMENT_PART,
							});
					}
				}

				parseSegment() {
					const startPos = this.getPosition();
					const parts = [];

					// A ** token is only allowed as the only part of a segment
					if (this.matchToken("DoubleStar")) {
						const lookahead = this.lookaheadToken();
						if (lookahead.type === "Separator" || lookahead.type === "EOF") {
							this.eatToken("DoubleStar");
							this.eatSeparators();
							return {
								type: "WildcardSegment",
								loc: this.finishLoc(startPos),
							};
						}
					}

					// Keep consuming tokens until we hit a separator or a comment
					while (
						!this.matchToken("Hash") &&
						!this.matchToken("EOF") &&
						!this.eatSeparators()
					) {
						parts.push(this.parsePatternSegmentPart());
					}

					return {
						loc: this.finishLoc(startPos),
						type: "Segment",
						parts,
					};
				}

				isWildcardOnlySegment(segment) {
					if (segment === undefined) {
						return false;
					}

					if (segment.type === "WildcardSegment") {
						return true;
					}

					if (segment.parts.length === 1 && segment.parts[0].type === "Wildcard") {
						return true;
					}

					return false;
				}

				// Normalize all path segments, removing empty segments and wildcards from the start and end

				// These could also be parse errors but let's allow them
				normalizePatternSegments(segments) {
					const normalized = [];

					// Never normalize it if there's a single segment. This is to support writing a pattern that's just "*"
					if (segments.length === 1) {
						return segments;
					}

					for (const seg of segments) {
						// Remove all wildcard-only segments from 'beginning
						if (normalized.length === 0 && this.isWildcardOnlySegment(seg)) {
							continue;
						}

						// Remove all empty segments
						if (seg.type === "Segment" && seg.parts.length === 0) {
							continue;
						}

						normalized.push(seg);
					}

					// TODO Remove duplicate wildcard segments
					// - Multiple WildcardSegment
					// - Wildcard next to a WildcardSegment
					// Remove all wildcard-only segments from end
					while (this.isWildcardOnlySegment(normalized[normalized.length - 1])) {
						normalized.pop();
					}

					return normalized;
				}

				parsePatternsFile() {
					const patterns = [];
					while (!this.matchToken("EOF")) {
						patterns.push(this.parsePattern());
					}
					return patterns;
				}

				parsePattern() {
					const startPos = this.getPosition();
					const segments = [];
					const negate = this.eatToken("Exclamation") !== undefined;

					// Keep parsing segments until we hit the end of the input or a comment
					while (!this.matchToken("Hash") && !this.matchToken("EOF")) {
						segments.push(this.parseSegment());
					}

					// Get a trailing comment
					let comment = "";
					if (this.eatToken("Hash")) {
						comment = this.getRawInput(
							this.getToken().start,
							___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
								this.input.length,
							),
						);
					}

					let root = false;
					if (segments.length > 0) {
						const firstSeg = segments[0];
						root = firstSeg.type === "Segment" && firstSeg.parts.length === 0;
					}

					return {
						type: "PathPattern",
						loc: this.finishLoc(startPos),
						root,
						comment,
						negate,
						segments: this.normalizePatternSegments(segments),
					};
				}

				//# Path parsing
				parsePath() {
					const segments = [];

					this.eatSeparators();

					while (!this.matchToken("EOF")) {
						segments.push(this.parsePathSegment());
					}

					return segments;
				}

				parsePathSegment() {
					let segment = "";

					while (!this.eatSeparators() && !this.matchToken("EOF")) {
						segment += this.normalizePathSegmentToken();
					}

					return segment;
				}

				normalizePathSegmentToken() {
					const token = this.getToken();
					this.nextToken();

					if (token.type === "Word") {
						return token.value;
					} else {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PATH_MATCH.INVALID_PATH_SEGMENT,
						});
					}
				}
			}
			return PathMatchParser;
		})()
	);

	function ___R$project$rome$$romejs$path$match$parse_ts$parsePattern(opts) {
		const parser = ___R$$priv$project$rome$$romejs$path$match$parse_ts$createPathMatchParser(
			opts,
			"pattern",
		);
		return parser.parsePattern();
	}

	function ___R$project$rome$$romejs$path$match$parse_ts$parsePatternsFile(opts) {
		const parser = ___R$$priv$project$rome$$romejs$path$match$parse_ts$createPathMatchParser(
			opts,
			"pattern",
		);
		return parser.parsePatternsFile();
	}


  // project-rome/@romejs/path-match/match.ts
function ___R$$priv$project$rome$$romejs$path$match$match_ts$matchSegment(
		path,
		patternSeg,
	) {
		if (patternSeg.type !== "Segment") {
			throw new Error("Expected only plain segment");
		}

		const parts = [...patternSeg.parts];
		let buffer = path;

		function matchPart(part) {
			// If the buffer is empty then it's impossible for anything to match
			if (buffer.length === 0) {
				return false;
			}

			if (part.type === "Word") {
				if (buffer.startsWith(part.value)) {
					buffer = buffer.slice(part.value.length);
				} else {
					return false;
				}
			} else if (part.type === "Wildcard") {
				const nextPart = parts.shift();

				// If there's no other parts then a wildcard matches any buffer
				if (nextPart === undefined) {
					return buffer.length > 0;
				}

				// Keep removing characters until we match the next part
				while (buffer.length > 0) {
					if (matchPart(nextPart)) {
						return true;
					}

					buffer = buffer.slice(1);
				}

				// We consumed the whole buffer and nothing matched
				return false;
			}

			return true;
		}

		while (parts.length > 0) {
			const part = parts.shift();
			if (part === undefined) {
				throw new Error("parts.length checked above");
			}

			if (matchPart(part) === false) {
				return false;
			}
		}

		return true;
	}

	function ___R$project$rome$$romejs$path$match$match_ts$default(
		pathSegs,
		pattern,
		cwdSegs,
	) {
		// Clone so we can freely mutate
		const patternSegs = [...pattern.segments];
		pathSegs = [...pathSegs];

		// Check if the pattern is empty
		if (patternSegs.length === 0 || pathSegs.length === 0) {
			return false;
		}

		// Quick optimization, check if the path contains all of the absolute names in the pattern
		for (const seg of patternSegs) {
			if (seg.type !== "Segment" || seg.parts.length !== 1) {
				continue;
			}

			const part = seg.parts[0];
			if (part.type === "Word" && !pathSegs.includes(part.value)) {
				return false;
			}
		}

		if (pattern.root && cwdSegs !== undefined) {
			cwdSegs = [...cwdSegs];

			// If this is a root pattern, then remove all the starting path segments that match the cwd
			for (const cwdSeg of cwdSegs) {
				const pathSeg = pathSegs.shift();
				if (cwdSeg === pathSeg) {
					continue;
				} else {
					return false;
				}
			}
		} else {
			// Start removing all the path segments until we find one that matches the first pattern segment
			const firstPatternSeg = patternSegs.shift();
			if (firstPatternSeg === undefined) {
				throw new Error("patternSegs.length already validated above");
			}

			while (pathSegs.length > 0) {
				const pathSeg = pathSegs.shift();
				if (pathSeg === undefined) {
					throw new Error("pathSegs.length already validated above");
				}

				if (
					___R$$priv$project$rome$$romejs$path$match$match_ts$matchSegment(
						pathSeg,
						firstPatternSeg,
					)
				) {
					if (pathSegs.length === 0 && patternSegs.length === 0) {
						// If there's no more path or pattern segments then this was a successfully match!
						return true;
					} else {
						// Make sure the rest match
						break;
					}
				}
			}
		}

		// If we consumed all the path segments then we didn't match anything
		if (pathSegs.length === 0) {
			return false;
		}

		// Match the rest of the path segments
		for (let i = 0; i < patternSegs.length; i++) {
			const patternSeg = patternSegs[i];

			// If we have no more path segments then it's impossible for this to match
			if (pathSegs.length === 0) {
				return false;
			}

			// When given a wildcard segment, keep popping off all the path segments until we find one that matches the next pattern segment
			if (patternSeg.type === "WildcardSegment") {
				const nextPattern = patternSegs[i + 1];
				while (
					pathSegs.length > 0 &&
					!___R$$priv$project$rome$$romejs$path$match$match_ts$matchSegment(
						pathSegs[0],
						nextPattern,
					)
				) {
					pathSegs.shift();
				}
				continue;
			}

			// Basic match
			const pathSeg = pathSegs.shift();
			if (pathSeg === undefined) {
				throw new Error("pathSegs.length already validated above");
			}
			if (
				___R$$priv$project$rome$$romejs$path$match$match_ts$matchSegment(
					pathSeg,
					patternSeg,
				)
			) {
				continue;
			} else {
				return false;
			}
		}

		return true;
	}


  // project-rome/@romejs/path-match/stringify.ts
function ___R$project$rome$$romejs$path$match$stringify_ts$stringifyPathPattern(
		node,
	) {
		switch (node.type) {
			case "PathPattern":
				return node.segments.map((segment) =>
					___R$project$rome$$romejs$path$match$stringify_ts$stringifyPathPattern(
						segment,
					)
				).join("/");

			case "Segment":
				return node.parts.map((part) =>
					___R$project$rome$$romejs$path$match$stringify_ts$stringifyPathPattern(
						part,
					)
				).join("");

			case "WildcardSegment":
				return "**";

			case "Wildcard":
				return "*";

			case "Word":
				return node.value;
		}
	}


  // project-rome/@romejs/path-match/index.ts




	function ___R$project$rome$$romejs$path$match$index_ts$flipPathPatterns(
		patterns,
	) {
		return patterns.map((pattern) => {
			return Object.assign({}, pattern, {negate: !pattern.negate});
		});
	}

	function ___R$project$rome$$romejs$path$match$index_ts$matchPath(
		path,
		patternNode,
		cwdSegs,
	) {
		const matches = ___R$project$rome$$romejs$path$match$match_ts$default(
			path.getSegments(),
			patternNode,
			cwdSegs,
		);

		if (patternNode.negate) {
			return !matches;
		} else {
			return matches;
		}
	}

	function ___R$$priv$project$rome$$romejs$path$match$index_ts$getGreater(
		pattern,
		num,
	) {
		if (pattern.segments.length > num) {
			return pattern.segments.length;
		} else {
			return num;
		}
	}



	function ___R$project$rome$$romejs$path$match$index_ts$matchPathPatterns(
		path,
		patterns,
		cwd,
	) {
		// Bail out if there are no patterns
		if (patterns.length === 0) {
			return "NO_MATCH";
		}

		let matches = 0;
		let notMatches = 0;

		let hasNegate = false;

		const pathSegments = path.getSegments();
		const cwdSegs = cwd === undefined ? undefined : cwd.getSegments();

		for (const pattern of patterns) {
			// No point in matching an empty pattern, could just contain a comment
			if (pattern.segments.length === 0) {
				continue;
			}

			if (pattern.negate) {
				hasNegate = true;
				if (
					___R$project$rome$$romejs$path$match$match_ts$default(
						pathSegments,
						Object.assign({}, pattern, {negate: false}),
						cwdSegs,
					)
				) {
					notMatches = ___R$$priv$project$rome$$romejs$path$match$index_ts$getGreater(
						pattern,
						notMatches,
					);
				}
			} else {
				if (
					___R$project$rome$$romejs$path$match$match_ts$default(
						pathSegments,
						pattern,
						cwdSegs,
					)
				) {
					matches = ___R$$priv$project$rome$$romejs$path$match$index_ts$getGreater(
						pattern,
						matches,
					);
				}
			}
		}

		// If we have a negate pattern, then we need to match more segments than it in order to qualify as a match
		if (hasNegate) {
			if (notMatches > matches) {
				return "NO_MATCH";
			} else if (matches > notMatches) {
				return "EXPLICIT_MATCH";
			} else {
				return "IMPLICIT_MATCH";
			}
		}

		if (matches > 0) {
			return "EXPLICIT_MATCH";
		}

		return "NO_MATCH";
	}


  // project-rome/@romejs/project/constants.ts
const ___R$project$rome$$romejs$project$constants_ts = {
		get ROME_CONFIG_PACKAGE_JSON_FIELD() {
			return ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD;
		},
		get ROME_CONFIG_FILENAMES() {
			return ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES;
		},
		get ROME_CONFIG_WARN_FILENAMES() {
			return ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES;
		},
	};
	const ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD = "rome";

	const ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES = [
		"rome.json",
		"rome.rjson",
	];

	const ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES = [
		"romeconfig",
		"romerc",
		"rome.son",
		"rome.config.ts",
		"rome.config.js",
		"rome.config.json",
		"rome.config.rjson",
		"rome.config.son",
	];

	// Add dot versions
	for (const basename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES) {
		if (basename[0] !== ".") {
			___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES.push(
				"." + basename,
			);
		}
	}
	for (const filename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.slice()) {
		___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.push(
			"." + filename,
		);
	}


  // project-rome/@romejs/project/utils.ts
const ___R$project$rome$$romejs$project$utils_ts = {
		assertHardMeta: ___R$project$rome$$romejs$project$utils_ts$assertHardMeta,
		arrayOfStrings: ___R$project$rome$$romejs$project$utils_ts$arrayOfStrings,
		arrayOfPatterns: ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns,
		mergeArrays: ___R$project$rome$$romejs$project$utils_ts$mergeArrays,
		mergeAbsoluteFilePathSets: ___R$project$rome$$romejs$project$utils_ts$mergeAbsoluteFilePathSets,
		getParentConfigDependencies: ___R$project$rome$$romejs$project$utils_ts$getParentConfigDependencies,
	};
	function ___R$project$rome$$romejs$project$utils_ts$assertHardMeta(meta) {
		const {configPath, projectFolder: folder, consumer} = meta;
		if (
			configPath === undefined ||
			folder === undefined ||
			consumer === undefined
		) {
			throw new Error("This is not a disk project");
		}

		return Object.assign(
			{},
			meta,
			{configPath, consumer, projectFolder: folder},
		);
	}

	function ___R$project$rome$$romejs$project$utils_ts$arrayOfStrings(consumer) {
		if (consumer.exists()) {
			return consumer.asArray().map((item) => item.asString());
		} else {
			return [];
		}
	}

	function ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns(consumer) {
		// TODO consumer.handleThrownDiagnostics
		return consumer.asArray().map((item) => {
			return ___R$project$rome$$romejs$path$match$parse_ts$parsePattern({
				path: consumer.filename,
				input: item.asString(),
				offsetPosition: item.getLocation("inner-value").start,
			});
		});
	}

	function ___R$project$rome$$romejs$project$utils_ts$mergeArrays(a, b) {
		if (a === undefined) {
			return a;
		}

		if (b === undefined) {
			return a;
		}

		return [...a, ...b];
	}

	function ___R$project$rome$$romejs$project$utils_ts$mergeAbsoluteFilePathSets(
		a,
		b,
	) {
		if (a === undefined) {
			return a;
		}

		if (b === undefined) {
			return a;
		}

		return new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet([
			...a,
			...b,
		]);
	}

	function ___R$project$rome$$romejs$project$utils_ts$getParentConfigDependencies(
		path,
	) {
		const deps = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

		for (const folder of path.getChain()) {
			deps.add(folder.append("package.json"));

			for (const configFilename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES) {
				deps.add(folder.append(configFilename));
			}
		}

		return deps;
	}


  // project-rome/@romejs/fs/index.ts
const ___R$$priv$project$rome$$romejs$fs$index_ts$fs = require("fs");


	function ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyData(
		path,
		factory,
	) {
		return new Promise((resolve, reject) => {
			factory(
				path.join(),
				(err, data) => {
					if (err === null) {
						resolve(data);
					} else {
						reject(err);
					}
				},
			);
		});
	}



	function ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyVoid(
		path,
		factory,
	) {
		return new Promise((resolve, reject) => {
			factory(
				path.join(),
				(err) => {
					if (err === null) {
						resolve();
					} else {
						reject(err);
					}
				},
			);
		});
	}

	// watch
	function ___R$project$rome$$romejs$fs$index_ts$watch(path, options, listener) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.watch(
			path.join(),
			options,
			listener,
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$readFile(path) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyData(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$romejs$fs$index_ts$fs.readFile(
					filename,
					callback,
				)
			,
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$readFileSync(path) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.readFileSync(
			path.join(),
		);
	}

	async function ___R$project$rome$$romejs$fs$index_ts$readFileText(path) {
		return (await ___R$project$rome$$romejs$fs$index_ts$readFile(path)).toString();
	}

	function ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(path) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.readFileSync(
			path.join(),
			"utf8",
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$writeFile(path, content) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyVoid(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$romejs$fs$index_ts$fs.writeFile(
					filename,
					content,
					callback,
				)
			,
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$writeFileSync(path, content) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.writeFileSync(
			path.join(),
			content,
		);
	}

	// readdir
	function ___R$$priv$project$rome$$romejs$fs$index_ts$createReaddirReturn(
		folder,
		files,
	) {
		return new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(
			files.map((basename) => {
				return folder.append(basename);
			}),
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$readdir(path) {
		return new Promise((resolve, reject) => {
			___R$$priv$project$rome$$romejs$fs$index_ts$fs.readdir(
				path.join(),
				(err, files) => {
					if (err === null) {
						resolve(
							___R$$priv$project$rome$$romejs$fs$index_ts$createReaddirReturn(
								path,
								files,
							),
						);
					} else {
						reject(err);
					}
				},
			);
		});
	}

	function ___R$project$rome$$romejs$fs$index_ts$readdirSync(path) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$createReaddirReturn(
			path,
			___R$$priv$project$rome$$romejs$fs$index_ts$fs.readdirSync(path.join()),
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$lstat(path) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyData(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$romejs$fs$index_ts$fs.lstat(filename, callback)
			,
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$lstatSync(path) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.lstatSync(path.join());
	}

	function ___R$project$rome$$romejs$fs$index_ts$exists(path) {
		return new Promise((resolve) => {
			___R$$priv$project$rome$$romejs$fs$index_ts$fs.exists(
				path.join(),
				(exists) => {
					resolve(exists);
				},
			);
		});
	}

	function ___R$project$rome$$romejs$fs$index_ts$existsSync(path) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$fs.existsSync(
			path.join(),
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$unlink(path) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyVoid(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$romejs$fs$index_ts$fs.unlink(
					filename,
					(err) => {
						if (err != null && err.code !== "ENOENT") {
							callback(err);
						} else {
							callback(null);
						}
					},
				)
			,
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$unlinkSync(path) {
		try {
			___R$$priv$project$rome$$romejs$fs$index_ts$fs.unlinkSync(path.join());
		} catch (err) {
			if (err.code !== "ENOENT") {
				throw err;
			}
		}
	}

	function ___R$project$rome$$romejs$fs$index_ts$createDirectory(
		path,
		opts = {},
	) {
		return ___R$$priv$project$rome$$romejs$fs$index_ts$promisifyVoid(
			path,
			(filename, callback) =>
				___R$$priv$project$rome$$romejs$fs$index_ts$fs.mkdir(
					filename,
					{
						recursive: opts.recursive,
					},
					callback,
				)
			,
		);
	}

	function ___R$project$rome$$romejs$fs$index_ts$createDirectorySync(
		path,
		opts = {},
	) {
		___R$$priv$project$rome$$romejs$fs$index_ts$fs.mkdirSync(
			path.join(),
			{recursive: opts.recursive},
		);
	}




  // project-rome/@romejs/codec-semver/compare.ts


	function ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(
		a,
		b,
	) {
		// Equal
		if (b === undefined) {
			return 0;
		}

		if (typeof a === "string" || typeof b === "string") {
			// @ts-ignore: built-in def is not restrictive enough
			return String(a).localeCompare(String(b));
		}

		// Less than
		if (a < b) {
			return -1;
		}

		// Greater than
		if (a > b) {
			return 1;
		}

		// Equal
		return 0;
	}

	function ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareMain(
		version,
		range,
	) {
		return (
			___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(
				version.major,
				range.major,
			) ||
			___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(
				version.minor,
				range.minor,
			) ||
			___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(
				version.patch,
				range.patch,
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$comparePre(
		version,
		range,
	) {
		// NOT having a prerelease is > having one
		if (version.prerelease.length > 0 && range.prerelease.length === 0) {
			return -1;
		} else if (version.prerelease.length === 0 && range.prerelease.length > 0) {
			return 1;
		} else if (version.prerelease.length === 0 && range.prerelease.length === 0) {
			return 0;
		}

		let i = 0;
		do {
			const a = version.prerelease[i];
			const b = range.prerelease[i];

			if (a === undefined && b === undefined) {
				return 0;
			} else if (b === undefined) {
				return 1;
			} else if (a === undefined) {
				return -1;
			} else if (a === b) {
				continue;
			} else {
				return ___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareIdentifiers(
					a,
					b,
				);
			}
		} while (++i);

		throw new Error("Unreachable");
	}

	function ___R$project$rome$$romejs$codec$semver$compare_ts$compareFromAst(
		version,
		range,
	) {
		return (
			___R$$priv$project$rome$$romejs$codec$semver$compare_ts$compareMain(
				version,
				range,
			) ||
			___R$$priv$project$rome$$romejs$codec$semver$compare_ts$comparePre(
				version,
				range,
			)
		);
	}


  // project-rome/@romejs/codec-semver/satisfies.ts
function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(
		major,
		minor,
		patch,
	) {
		return {
			type: "WildcardVersion",
			major,
			minor,
			patch,
			prerelease: [],
			build: [],
		};
	}

	function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
		op,
		version,
		range,
	) {
		if (range.type === "Wildcard") {
			return true;
		}

		switch (op) {
			case "=":
				return (
					___R$project$rome$$romejs$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) === 0
				);

			case "<":
				return (
					___R$project$rome$$romejs$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) < 0
				);

			case ">":
				return (
					___R$project$rome$$romejs$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) > 0
				);

			case ">=":
				return (
					___R$project$rome$$romejs$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) >= 0
				);

			case "<=":
				return (
					___R$project$rome$$romejs$codec$semver$compare_ts$compareFromAst(
						version,
						range,
					) <= 0
				);

			case "^": {
				// Make sure that the version isn't less than the range
				if (
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
						">=",
						version,
						range,
					) ===
					false
				) {
					return false;
				}

				// Deconstruct the range
				const {major, minor, patch} = range;

				if (major === 0) {
					if (minor === 0) {
						// ^0.0.3 := >=0.0.3 <0.0.4
						// @ts-ignore
						return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
							"<",
							version,
							___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(
								0,
								0,
								patch + 1,
							),
						);
					} else {
						// ^0.2.3 := >=0.2.3 <0.3.0
						// @ts-ignore
						return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
							"<",
							version,
							___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(
								0,
								minor + 1,
								0,
							),
						);
					}
				}

				// ^1.2.3 := >=1.2.3 <2.0.0

				// @ts-ignore
				return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
					"<",
					version,
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(
						major + 1,
						0,
						0,
					),
				);
			}

			case "~>":
			case "~": {
				// Make sure that the version isn't less than the range
				if (
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
						">=",
						version,
						range,
					) ===
					false
				) {
					return false;
				}

				// Deconstruct the range
				const {major, minor} = range;

				if (minor === undefined) {
					// ~1 := >=1.0.0 <(1+1).0.0 := >=1.0.0 <2.0.0 (Same as 1.x)
					// @ts-ignore
					return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
						"<",
						version,
						___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(
							major + 1,
							minor,
							0,
						),
					);
				}

				// ~1.2.3 := >=1.2.3 <1.(2+1).0 := >=1.2.3 <1.3.0
				return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
					"<",
					version,
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$buildVersion(
						major,
						minor + 1,
						0,
					),
				);
			}

			default:
				throw new Error("Unknown operator " + op);
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$inRange(
		version,
		left,
		right,
	) {
		if (left.type === "Wildcard" || right.type === "Wildcard") {
			return true;
		}

		return (
			___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
				">=",
				version,
				left,
			) &&
			___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
				"<=",
				version,
				right,
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(
		range,
	) {
		switch (range.type) {
			case "AbsoluteVersion":
			case "WildcardVersion":
				return [range];

			case "Wildcard":
				return [];

			case "Comparator":
				return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(
					range.version,
				);

			case "LogicalAnd":
			case "LogicalOr":
			case "VersionRange":
				return [
					...___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(
						range.left,
					),
					...___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(
						range.right,
					),
				];

			default:
				throw new Error("Unknown range type");
		}
	}

	function ___R$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesFromAst(
		version,
		range,
	) {
		const res = ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(
			version,
			range,
		);
		if (res === false) {
			return false;
		}

		if (version.prerelease.length > 0) {
			// Find the set of versions that are allowed to have prereleases
			// For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
			// That should allow `1.2.3-pr.2` to pass.
			// However, `1.2.4-alpha.notready` should NOT be allowed,
			// even though it's within the range set by the comparators.
			const versions = ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$collectVersions(
				range,
			);

			for (const comparator of versions) {
				if (comparator.prerelease.length > 0) {
					if (
						comparator.major === version.major &&
						comparator.minor === version.minor &&
						comparator.patch === version.patch
					) {
						return true;
					}
				}
			}

			// Version has a -pre, but it's not one of the ones we like.
			return false;
		}

		return true;
	}

	function ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(
		version,
		range,
	) {
		switch (range.type) {
			case "AbsoluteVersion":
			case "WildcardVersion":
				return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
					"=",
					version,
					range,
				);

			case "Wildcard":
				return true;

			case "Comparator":
				return ___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$compareOp(
					range.operator,
					version,
					range.version,
				);

			case "LogicalAnd":
				return (
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(
						version,
						range.left,
					) &&
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(
						version,
						range.right,
					)
				);

			case "LogicalOr":
				return (
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(
						version,
						range.left,
					) ||
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesSub(
						version,
						range.right,
					)
				);

			case "VersionRange":
				return (
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$inRange(
						version,
						range.left,
						range.right,
					) ||
					___R$$priv$project$rome$$romejs$codec$semver$satisfies_ts$inRange(
						version,
						range.right,
						range.left,
					)
				);
		}
	}


  // project-rome/@romejs/codec-semver/parse.ts




	const ___R$$priv$project$rome$$romejs$codec$semver$parse_ts$createSemverParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser((
		ParserCore,
	) =>
		(() => {
			class SemverParser extends ParserCore {
				constructor({loose, ...opts}, mode) {
					super(opts, "parse/semver");
					this.input = this.input.trimRight();
					this.mode = mode;
					this.loose = loose === undefined ? false : loose;
				}

				// For some reason Flow will throw an error without the type casts...
				tokenize(index, input) {
					const char = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					)];
					const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					) + 1];

					if (
						(char === "<" && nextChar === "=") ||
						(char === ">" && nextChar === "=") ||
						(char === "~" && nextChar === ">")
					) {
						// @ts-ignore: TS doesn't infer the possible combinations
						const value = char + nextChar;
						return this.finishValueToken(
							"Operator",
							value,
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 2),
						);
					}

					if (
						char === "^" ||
						char === "<" ||
						char === ">" ||
						char === "~" ||
						char === "="
					) {
						const op = char;
						return this.finishValueToken("Operator", op);
					}

					if (char === "|" && nextChar === "|") {
						return this.finishToken(
							"Pipe",
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 2),
						);
					}

					if (char === "*") {
						return this.finishToken("Star");
					}

					if (
						input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) - 1] ===
						" " &&
						char === "-" &&
						nextChar === " "
					) {
						return this.finishToken("RangeDash");
					}

					if (char === "-") {
						return this.finishToken("Dash");
					}

					if (char === "+") {
						return this.finishToken("Plus");
					}

					if (char === ".") {
						return this.finishToken("Dot");
					}

					if (___R$project$rome$$romejs$parser$core$index_ts$isDigit(char)) {
						const [value] = this.readInputFrom(
							index,
							___R$project$rome$$romejs$parser$core$index_ts$isDigit,
						);
						return this.finishValueToken(
							"Number",
							Number(value),
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, value.length),
						);
					}

					if (___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char)) {
						const [value] = this.readInputFrom(
							index,
							___R$project$rome$$romejs$parser$core$index_ts$isAlpha,
						);
						return this.finishValueToken(
							"Word",
							value,
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, value.length),
						);
					}

					if (char === " " || char === "\t") {
						return this.finishToken("Space");
					}

					// Unknown character
					return undefined;
				}

				// Remove all subsequent space tokens
				eatSpaceToken() {
					while (this.eatToken("Space") !== undefined) {
						// empty
					}
				}

				parseVersionOrWildcard() {
					const startPos = this.getPosition();
					const startToken = this.getToken();
					const version = this.parseVersion();

					// We should return a bare wildcard when parsed in a version position if there was nothing else attached
					if (
						this.isWildcardToken(startToken) &&
						version.minor === undefined &&
						version.patch === undefined &&
						version.prerelease.length === 0 &&
						version.build.length === 0
					) {
						return {
							type: "Wildcard",
							loc: this.finishLoc(startPos),
						};
					}

					return version;
				}

				parseVersion() {
					const startPos = this.getPosition();
					const startToken = this.getToken();

					if (this.isVersionCharacter(startToken)) {
						this.nextToken();
					}

					const major = this.parseVersionNumber();
					let minor = undefined;
					let patch = undefined;

					if (this.eatToken("Dot")) {
						minor = this.parseVersionNumber();
					} else if (this.mode === "version") {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.MISSING_MINOR_VERSION,
						});
					}

					if (this.eatToken("Dot")) {
						patch = this.parseVersionNumber();
					} else if (this.mode === "version") {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.MISSING_PATCH_VERSION,
						});
					}

					if (this.matchToken("Dot")) {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.EXCESSIVE_VERSION_PARTS,
						});
					}

					// The dash is optional in loose mode. eg. 1.2.3pre
					let prerelease = [];
					if (this.eatToken("Dash") || (this.loose && this.matchToken("Word"))) {
						prerelease = this.parseVersionQualifierParts();
					}

					let build = [];
					if (this.eatToken("Plus")) {
						build = this.parseVersionQualifierParts();
					}

					if (major !== undefined && minor !== undefined && patch !== undefined) {
						return {
							type: "AbsoluteVersion",
							loc: this.finishLoc(startPos),
							major,
							minor,
							patch,
							prerelease,
							build,
						};
					} else {
						return {
							type: "WildcardVersion",
							loc: this.finishLoc(startPos),
							major,
							minor,
							patch,
							prerelease,
							build,
						};
					}
				}

				parseVersionQualifierParts() {
					const parts = [];
					do {
						parts.push(this.parseVersionQualifierPart());
					} while (this.eatToken("Dot") !== undefined);
					return parts;
				}

				parseVersionQualifierPart() {
					const parts = [];

					do {
						const token = this.getToken();

						if (token.type === "Number" || token.type === "Word") {
							this.nextToken();
							parts.push(token.value);
						} else if (token.type === "Dash") {
							this.nextToken();
							parts.push("-");
						} else {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.INVALID_QUANTIFIER_PART,
							});
						}
					} while (
						this.matchToken("Number") ||
						this.matchToken("Word") ||
						this.matchToken("Dash")
					);

					if (parts.length === 1 && typeof parts[0] === "number") {
						return parts[0];
					} else {
						return parts.join("");
					}
				}

				isWildcardToken(token) {
					if (token.type === "Star") {
						return true;
					}

					if (token.type === "Word") {
						return token.value === "x" || token.value === "X";
					}

					return false;
				}

				parseVersionNumber() {
					const token = this.getToken();

					if (token.type === "Number") {
						this.nextToken();
						return token.value;
					}

					if (this.isWildcardToken(token)) {
						if (this.mode === "version") {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.WILDCARD_IN_VERSION,
							});
						}

						this.nextToken();
					} else {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.INVALID_VERSION_NUMBER,
						});
					}

					return undefined;
				}

				parseLogicalOr(left) {
					this.nextToken();
					this.eatSpaceToken();

					const right = this.parseExpression();
					return {
						loc: this.finishLoc(this.getLoc(left).start),
						type: "LogicalOr",
						left,
						right,
					};
				}

				validateRangeSide(node) {
					// In loose mode, we allow ranges to be a bare wildcard instead of a version
					// eg. * - 1.2.3
					if (node.type === "WildcardVersion" || node.type === "AbsoluteVersion") {
						return node;
					}

					if (node.type === "Wildcard" && this.loose) {
						return node;
					}

					throw this.unexpected(
						Object.assign(
							{},
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.INVALID_RANGE,
							{start: this.getLoc(node).start},
						),
					);
				}

				parseVersionRange(left) {
					this.nextToken();
					this.eatSpaceToken();

					const right = this.parseVersionOrWildcard();

					return {
						type: "VersionRange",
						loc: this.finishLoc(this.getLoc(left).start),
						left: this.validateRangeSide(left),
						right: this.validateRangeSide(right),
					};
				}

				parseWildcard() {
					const startPos = this.getPosition();
					this.nextToken();
					return {type: "Wildcard", loc: this.finishLoc(startPos)};
				}

				parseAtomOperator(token) {
					const startPos = this.getPosition();
					this.nextToken();
					this.eatSpaceToken();

					const version = this.parseVersionOrWildcard();

					return {
						type: "Comparator",
						loc: this.finishLoc(startPos),
						operator: token.value,
						version,
					};
				}

				isVersionCharacter(token) {
					if (this.loose && token.type === "Word") {
						return token.value === "v";
					}

					return false;
				}

				parseAtomStartPipe() {
					if (this.loose) {
						// A bare pipe in an atom start position is treated the same as a wildcard...
						// Why...? Because node-semver allows it lol
						// > satisfies('1.2.3', '||') === true
						return this.parseWildcard();
					} else {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.BARE_PIPE_WITHOUT_LOOSE,
						});
					}
				}

				parseAtomStartWord(token) {
					if (this.isWildcardToken(token)) {
						return this.parseWildcard();
					} else if (this.isVersionCharacter(token)) {
						return this.parseVersion();
					} else {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.UNEXPECTED_WORD(
								token.value,
							),
						});
					}
				}

				parseAtom() {
					const token = this.getToken();

					switch (token.type) {
						case "Number":
							return this.parseVersion();

						case "Operator":
							return this.parseAtomOperator(token);

						case "Star":
							return this.parseWildcard();

						case "Pipe":
							return this.parseAtomStartPipe();

						case "Word":
							return this.parseAtomStartWord(token);

						default:
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.UNKNOWN_START,
							});
					}
				}

				parseLogicalAnd(left) {
					const right = this.parseExpression();

					return {
						type: "LogicalAnd",
						left,
						right,
						loc: {
							filename: this.filename,
							start: this.getLoc(left).start,
							end: this.getLoc(right).end,
						},
					};
				}

				parseExpression() {
					const left = this.parseAtom();
					this.eatSpaceToken();

					if (this.matchToken("RangeDash")) {
						return this.parseVersionRange(left);
					}

					if (this.matchToken("Pipe")) {
						return this.parseLogicalOr(left);
					}

					if (!this.matchToken("EOF")) {
						return this.parseLogicalAnd(left);
					}

					return left;
				}

				parseInitialRange() {
					// Allow spaces at the beginning, spaces at the end have been removed by the trimRight in the constructor
					this.eatSpaceToken();

					// Empty string is an implicit wildcard in loose mode
					if (this.matchToken("EOF") && this.loose) {
						return this.parseWildcard();
					}

					const expr = this.parseExpression();
					this.finalize();

					return expr;
				}

				parseInitialVersion() {
					const node = this.parseInitialRange();

					// Verify the return value in version mode
					if (node.type !== "AbsoluteVersion") {
						throw this.unexpected(
							Object.assign(
								{},
								___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SEMVER.EXPECTED_VERSION,
								{start: this.getLoc(node).start},
							),
						);
					}

					return node;
				}
			}
			return SemverParser;
		})()
	);

	function ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(
		opts,
	) {
		return ___R$$priv$project$rome$$romejs$codec$semver$parse_ts$createSemverParser(
			opts,
			"range",
		).parseInitialRange();
	}

	function ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverVersion(
		opts,
	) {
		return ___R$$priv$project$rome$$romejs$codec$semver$parse_ts$createSemverParser(
			opts,
			"version",
		).parseInitialVersion();
	}


  // project-rome/@romejs/codec-semver/utils.ts
function ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserVersion(
		ver,
		opts,
	) {
		if (typeof ver === "string") {
			return ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverVersion(
				Object.assign({}, opts, {input: ver}),
			);
		} else if (ver.type === "AbsoluteVersion") {
			return ver;
		} else {
			throw new Error("Not a valid version: " + ver.type);
		}
	}

	function ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserRange(
		range,
		opts,
	) {
		if (typeof range === "string") {
			return ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(
				Object.assign({}, opts, {input: range}),
			);
		} else {
			return range;
		}
	}


  // project-rome/@romejs/codec-semver/stringify.ts
// Remove all
	function ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$compactRight(
		parts,
	) {
		for (let i = parts.length - 1; i >= 0; i--) {
			const part = parts[i];
			if (part !== undefined) {
				return parts.slice(0, i + 1);
			}
		}

		return [];
	}

	const ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$WILDCARD = "*";

	function ___R$project$rome$$romejs$codec$semver$stringify_ts$default(node) {
		switch (node.type) {
			case "WildcardVersion":
			case "AbsoluteVersion": {
				// Build up x.x.x format
				let str = ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$compactRight([
					node.major,
					node.minor,
					node.patch,
				]).map((part) =>
					part === undefined
						? ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$WILDCARD
						: part
				).join(".");

				// add on qualifiers
				if (node.prerelease.length > 0) {
					str += "-" + node.prerelease.join(".");
				}
				if (node.build.length > 0) {
					str += "+" + node.build.join(".");
				}
				return str;
			}

			case "Wildcard":
				return ___R$$priv$project$rome$$romejs$codec$semver$stringify_ts$WILDCARD;

			case "Comparator":
				return (
					"" +
					node.operator +
					___R$project$rome$$romejs$codec$semver$stringify_ts$default(
						node.version,
					)
				);

			case "LogicalAnd":
				return (
					___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.left) +
					" " +
					___R$project$rome$$romejs$codec$semver$stringify_ts$default(
						node.right,
					)
				);

			case "LogicalOr":
				return (
					___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.left) +
					" || " +
					___R$project$rome$$romejs$codec$semver$stringify_ts$default(
						node.right,
					)
				);

			case "VersionRange":
				return (
					___R$project$rome$$romejs$codec$semver$stringify_ts$default(node.left) +
					" - " +
					___R$project$rome$$romejs$codec$semver$stringify_ts$default(
						node.right,
					)
				);
		}
	}


  // project-rome/@romejs/codec-semver/index.ts




	function ___R$project$rome$$romejs$codec$semver$index_ts$sortSemverVersions(
		rawVersions,
		opts,
	) {
		const versions = rawVersions.map((ver) =>
			___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserVersion(
				ver,
				opts,
			)
		);
		return versions.sort((a, b) =>
			___R$project$rome$$romejs$codec$semver$compare_ts$compareFromAst(a, b)
		);
	}

	function ___R$project$rome$$romejs$codec$semver$index_ts$maxSatisfyingSemver(
		rawVersions,
		rawRange,
		opts,
	) {
		const versions = ___R$project$rome$$romejs$codec$semver$index_ts$sortSemverVersions(
			rawVersions,
			opts,
		).reverse();
		const range = ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserRange(
			rawRange,
			opts,
		);

		for (const version of versions) {
			if (
				___R$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesFromAst(
					version,
					range,
				)
			) {
				return version;
			}
		}

		return undefined;
	}

	function ___R$project$rome$$romejs$codec$semver$index_ts$minSatisfyingSemver(
		rawVersions,
		rawRange,
		opts,
	) {
		const versions = ___R$project$rome$$romejs$codec$semver$index_ts$sortSemverVersions(
			rawVersions,
			opts,
		);
		const range = ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserRange(
			rawRange,
			opts,
		);

		for (const version of versions) {
			if (
				___R$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesFromAst(
					version,
					range,
				)
			) {
				return version;
			}
		}

		return undefined;
	}

	function ___R$project$rome$$romejs$codec$semver$index_ts$satisfiesSemver(
		rawVersion,
		rawRange,
		opts,
	) {
		try {
			const version = ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserVersion(
				rawVersion,
				opts,
			);
			const range = ___R$project$rome$$romejs$codec$semver$utils_ts$normalizeUserRange(
				rawRange,
				opts,
			);
			return ___R$project$rome$$romejs$codec$semver$satisfies_ts$satisfiesFromAst(
				version,
				range,
			);
		} catch (err) {
			if (
				err instanceof
				___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError
			) {
				return false;
			} else {
				throw err;
			}
		}
	}


  // project-rome/@romejs/project/load.ts
const ___R$project$rome$$romejs$project$load_ts = {
		loadCompleteProjectConfig: ___R$project$rome$$romejs$project$load_ts$loadCompleteProjectConfig,
		normalizeProjectConfig: ___R$project$rome$$romejs$project$load_ts$normalizeProjectConfig,
	};
	const ___R$$priv$project$rome$$romejs$project$load_ts$crypto = require(
		"crypto",
	);
	const ___R$$priv$project$rome$$romejs$project$load_ts$IGNORE_FILENAMES = [
		".gitignore",
		".hgignore",
	];

	function ___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(
		consumer,
	) {
		if (!consumer.exists()) {
			return false;
		}

		const value = consumer.asUnknown();
		if (typeof value === "boolean") {
			consumer.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PROJECT_CONFIG.BOOLEAN_CATEGORY(
					value,
				),
			);
			return false;
		}

		return true;
	}

	function ___R$project$rome$$romejs$project$load_ts$loadCompleteProjectConfig(
		projectFolder,
		configPath,
	) {
		// TODO use consumer.capture somehow here to aggregate errors
		const {partial, meta} = ___R$$priv$project$rome$$romejs$project$load_ts$loadPartialProjectConfig(
			projectFolder,
			configPath,
		);
		const {consumer} = meta;

		// Produce a defaultConfig with some folder specific values
		const defaultConfig = Object.assign(
			{},
			___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
			{
				vcs: Object.assign(
					{},
					___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG.vcs,
					{root: projectFolder},
				),
			},
		);

		const name = consumer.get("name").asString(
			"project-" + projectFolder.getBasename(),
		);

		const config = Object.assign(
			{},
			___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
			{
				name,
				root: partial.root === undefined
					? ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG.root
					: partial.root,
			},
			___R$$priv$project$rome$$romejs$project$load_ts$mergePartialConfig(
				defaultConfig,
				partial,
			),
		);

		// Infer VCS ignore files as lint ignore rules
		for (const filename of ___R$$priv$project$rome$$romejs$project$load_ts$IGNORE_FILENAMES) {
			const possiblePath = config.vcs.root.append(filename);
			meta.configDependencies.add(possiblePath);

			if (___R$project$rome$$romejs$fs$index_ts$existsSync(possiblePath)) {
				const file = ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(
					possiblePath,
				);

				consumer.handleThrownDiagnostics(() => {
					const patterns = ___R$project$rome$$romejs$path$match$parse_ts$parsePatternsFile({
						input: file,
						path: possiblePath,
					});

					// TODO: Maybe these are useful in other places?
					config.lint.ignore = [...config.lint.ignore, ...patterns];
				});
			}
		}

		return {
			config,
			meta,
		};
	}

	function ___R$$priv$project$rome$$romejs$project$load_ts$loadPartialProjectConfig(
		projectFolder,
		configPath,
	) {
		const configFile = ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(
			configPath,
		);
		const res = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra({
			path: configPath,
			input: configFile,
		});

		return ___R$project$rome$$romejs$project$load_ts$normalizeProjectConfig(
			res,
			configPath,
			configFile,
			projectFolder,
		);
	}

	function ___R$project$rome$$romejs$project$load_ts$normalizeProjectConfig(
		res,
		configPath,
		configFile,
		projectFolder,
	) {
		let {consumer} = res;

		let configSourceSubKey;
		let name;
		const isInPackageJson = configPath.getBasename() === "package.json";
		if (isInPackageJson) {
			// Infer name from package.json
			name = consumer.get("name").asStringOrVoid();

			consumer = consumer.get(
				___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD,
			);
			configSourceSubKey = ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD;
		}

		const hash = ___R$$priv$project$rome$$romejs$project$load_ts$crypto.createHash(
			"sha256",
		).update(configFile).digest("hex");

		const config = {
			compiler: {},
			bundler: {},
			cache: {},
			lint: {},
			resolver: {},
			develop: {},
			typeCheck: {},
			tests: {},
			files: {},
			vcs: {},
			dependencies: {},
			targets: new Map(),
		};

		if (name !== undefined) {
			config.name = name;
		}

		const meta = {
			projectFolder,
			configPath,
			consumer,
			consumersChain: [consumer],
			configHashes: [hash],
			configSourceSubKey,
			configDependencies: ___R$project$rome$$romejs$project$utils_ts$getParentConfigDependencies(
				projectFolder,
			),
		};

		// We never use `name` here but it's used in `loadCompleteProjectConfig`
		consumer.markUsedProperty("name");

		if (consumer.has("version")) {
			const version = consumer.get("version");

			consumer.handleThrownDiagnostics(() => {
				config.version = ___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange({
					path: consumer.filename,
					input: version.asString(),
					offsetPosition: version.getLocation("inner-value").start,
				});

				// TODO verify that config.version range satisfies current version
			});
		}

		if (consumer.has("root")) {
			config.root = consumer.get("root").asBoolean();
		}

		const cache = consumer.get("cache");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(cache)) {
			// TODO
		}

		const resolver = consumer.get("resolver");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(resolver)) {
			// TODO
		}

		const bundler = consumer.get("bundler");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(bundler)) {
			if (bundler.has("mode")) {
				config.bundler.mode = bundler.get("mode").asStringSetOrVoid([
					"modern",
					"legacy",
				]);
			}
		}

		const typeChecking = consumer.get("typeChecking");
		if (
			___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(
				typeChecking,
			)
		) {
			if (typeChecking.has("enabled")) {
				config.typeCheck.enabled = typeChecking.get("enabled").asBoolean();
			}

			if (typeChecking.has("libs")) {
				const libs = ___R$$priv$project$rome$$romejs$project$load_ts$normalizeTypeCheckingLibs(
					projectFolder,
					typeChecking.get("libs"),
				);
				config.typeCheck.libs = libs.files;
				meta.configDependencies = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet([
					...meta.configDependencies,
					...libs.folders,
					...libs.files,
				]);
			}
		}

		const dependencies = consumer.get("dependencies");
		if (
			___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(
				dependencies,
			)
		) {
			if (dependencies.has("enabled")) {
				config.dependencies.enabled = dependencies.get("dependencies").asBoolean();
			}
		}

		const lint = consumer.get("lint");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(lint)) {
			if (lint.has("ignore")) {
				config.lint.ignore = ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns(
					lint.get("ignore"),
				);
			}

			if (lint.has("globals")) {
				config.lint.globals = ___R$project$rome$$romejs$project$utils_ts$arrayOfStrings(
					lint.get("globals"),
				);
			}
		}

		const tests = consumer.get("tests");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(tests)) {
			if (tests.has("ignore")) {
				config.tests.ignore = ___R$project$rome$$romejs$project$utils_ts$arrayOfPatterns(
					tests.get("ignore"),
				);
			}
		}

		const develop = consumer.get("develop");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(develop)) {
			if (develop.has("serveStatic")) {
				config.develop.serveStatic = develop.get("serveStatic").asBoolean();
			}
		}

		const files = consumer.get("files");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(files)) {
			if (files.has("vendorPath")) {
				config.files.vendorPath = projectFolder.resolve(
					files.get("vendorPath").asString(),
				);
			}

			if (files.has("maxSize")) {
				config.files.maxSize = files.get("maxSize").asNumber();
			}

			if (files.has("assetExtensions")) {
				config.files.assetExtensions = files.get("assetExtensions").asArray().map((
					item,
				) => item.asString());
			}
		}

		const vcs = consumer.get("vcs");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(vcs)) {
			if (vcs.has("root")) {
				config.vcs.root = projectFolder.resolve(vcs.get("root").asString());
			}
		}

		const compiler = consumer.get("compiler");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(compiler)) {
			// TODO
		}

		const targets = consumer.get("targets");
		if (___R$$priv$project$rome$$romejs$project$load_ts$categoryExists(targets)) {
			for (const [name, object] of targets.asMap()) {
				const target = {
					constraints: object.get("constraints").asImplicitArray().map((item) =>
						item.asString()
					),
				};
				object.enforceUsedProperties("config target property");
				config.targets.set(name, target);
			}
		}

		// Need to get this before enforceUsedProperties so it will be flagged
		const _extends = consumer.get("extends");

		// Flag unknown properties
		consumer.enforceUsedProperties("config property");

		if (_extends.exists()) {
			return ___R$$priv$project$rome$$romejs$project$load_ts$extendProjectConfig(
				projectFolder,
				_extends,
				config,
				meta,
			);
		}

		return {
			partial: config,
			meta,
		};
	}

	function ___R$$priv$project$rome$$romejs$project$load_ts$normalizeTypeCheckingLibs(
		projectFolder,
		consumer,
	) {
		const libFiles = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

		// Normalize library folders
		const folders = ___R$project$rome$$romejs$project$utils_ts$arrayOfStrings(
			consumer,
		).map((libFolder) => projectFolder.resolve(libFolder));

		// Crawl library folders and add their files
		for (const folder of folders) {
			const files = ___R$project$rome$$romejs$fs$index_ts$readdirSync(folder);
			for (const file of files) {
				const stats = ___R$project$rome$$romejs$fs$index_ts$lstatSync(file);
				if (stats.isFile()) {
					libFiles.add(file);
				} else if (stats.isDirectory()) {
					folders.push(file);
				}
			}
		}

		return {
			files: libFiles,
			folders,
		};
	}

	function ___R$$priv$project$rome$$romejs$project$load_ts$extendProjectConfig(
		projectFolder,
		extendsStrConsumer,
		config,
		meta,
	) {
		const extendsRelative = extendsStrConsumer.asString();

		if (extendsRelative === "parent") {
			// TODO maybe do some magic here?
		}

		const extendsPath = projectFolder.resolve(extendsRelative);
		const {partial: extendsObj, meta: extendsMeta} = ___R$$priv$project$rome$$romejs$project$load_ts$loadPartialProjectConfig(
			extendsPath.getParent(),
			extendsPath,
		);

		// Check for recursive config
		for (const path of extendsMeta.configDependencies) {
			if (path.equal(extendsPath)) {
				throw extendsStrConsumer.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PROJECT_CONFIG.RECURSIVE_CONFIG,
				);
			}
		}

		const merged = ___R$$priv$project$rome$$romejs$project$load_ts$mergePartialConfig(
			extendsObj,
			config,
		);

		const lintIgnore = ___R$project$rome$$romejs$project$utils_ts$mergeArrays(
			extendsObj.lint.ignore,
			config.lint.ignore,
		);
		if (lintIgnore !== undefined) {
			merged.lint.ignore = lintIgnore;
		}

		const lintGlobals = ___R$project$rome$$romejs$project$utils_ts$mergeArrays(
			extendsObj.lint.globals,
			config.lint.globals,
		);
		if (lintGlobals !== undefined) {
			merged.lint.globals = lintGlobals;
		}

		const testingIgnore = ___R$project$rome$$romejs$project$utils_ts$mergeArrays(
			extendsObj.tests.ignore,
			config.tests.ignore,
		);
		if (testingIgnore !== undefined) {
			merged.tests.ignore = testingIgnore;
		}

		const typeCheckingLibs = ___R$project$rome$$romejs$project$utils_ts$mergeAbsoluteFilePathSets(
			extendsObj.typeCheck.libs,
			config.typeCheck.libs,
		);
		if (typeCheckingLibs !== undefined) {
			merged.typeCheck.libs = typeCheckingLibs;
		}

		return {
			partial: merged,
			meta: Object.assign(
				{},
				meta,
				{
					consumersChain: [
						...meta.consumersChain,
						...extendsMeta.consumersChain,
					],
					configDependencies: new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet([
						...meta.configDependencies,
						...extendsMeta.configDependencies,
						extendsPath,
					]),
					configHashes: [...meta.configHashes, ...extendsMeta.configHashes],
				},
			),
		};
	}



	function ___R$$priv$project$rome$$romejs$project$load_ts$mergePartialConfig(
		a,
		b,
	) {
		return {
			cache: Object.assign({}, a.cache, b.cache),
			compiler: Object.assign({}, a.compiler, b.compiler),
			lint: Object.assign({}, a.lint, b.lint),
			develop: Object.assign({}, a.develop, b.develop),
			bundler: Object.assign({}, a.bundler, b.bundler),
			dependencies: Object.assign({}, a.dependencies, b.dependencies),
			resolver: Object.assign({}, a.resolver, b.resolver),
			typeCheck: Object.assign({}, a.typeCheck, b.typeCheck),
			tests: Object.assign({}, a.tests, b.tests),
			files: Object.assign({}, a.files, b.files),
			vcs: Object.assign({}, a.vcs, b.vcs),
			targets: new Map([...a.targets.entries(), ...b.targets.entries()]),
		};
	}


  // project-rome/@romejs/project/save.ts
const ___R$project$rome$$romejs$project$save_ts = {
		modifyProjectConfig: ___R$project$rome$$romejs$project$save_ts$modifyProjectConfig,
	};
	async function ___R$project$rome$$romejs$project$save_ts$modifyProjectConfig(
		softMeta,
		callbacks,
	) {
		const meta = ___R$project$rome$$romejs$project$utils_ts$assertHardMeta(
			softMeta,
		);
		const {configPath, configSourceSubKey: consumerSubKey} = meta;

		await callbacks.pre(meta);

		// Load the config file again
		const configFile = await ___R$project$rome$$romejs$fs$index_ts$readFileText(
			configPath,
		);
		const res = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra({
			path: configPath,
			input: configFile,
		});

		const {consumer} = res;
		if (consumerSubKey === undefined) {
			await callbacks.modify(consumer);
		} else {
			await callbacks.modify(consumer.get(consumerSubKey));
		}

		// Stringify the config
		let stringified;
		if (res.hasExtensions) {
			stringified = ___R$project$rome$$romejs$codec$json$index_ts$stringifyRJSONFromConsumer(
				res,
			);
		} else {
			stringified = ___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
				consumer.asUnknown(),
			);
		}

		// Test if this project config doesn't result in errors
		let {diagnostics} = ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnosticsSync(() => {
			// Reconsume with new stringified config
			const res = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra({
				path: configPath,
				input: stringified,
			});

			// Validate the new config
			___R$project$rome$$romejs$project$load_ts$normalizeProjectConfig(
				res,
				configPath,
				stringified,
				meta.projectFolder,
			);
		});

		if (diagnostics !== undefined) {
			// Set the `code` property on relevant diagnostics since our changes don't exist on disk
			diagnostics = diagnostics.map((diag) => {
				return diag.location.filename === configPath.join()
					? Object.assign(
							{},
							diag,
							{
								location: Object.assign(
									{},
									diag.location,
									{sourceText: stringified},
								),
							},
						)
					: diag;
			});

			throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
				"Diagnostics produced while testing new project config",
				diagnostics,
			);
		}

		// Write it out
		await ___R$project$rome$$romejs$fs$index_ts$writeFile(
			configPath,
			stringified,
		);
	}


  // project-rome/@romejs/project/transport.ts
const ___R$project$rome$$romejs$project$transport_ts = {
		serializeJSONProjectConfig: ___R$project$rome$$romejs$project$transport_ts$serializeJSONProjectConfig,
		hydrateJSONProjectConfig: ___R$project$rome$$romejs$project$transport_ts$hydrateJSONProjectConfig,
	};
	function ___R$project$rome$$romejs$project$transport_ts$serializeJSONProjectConfig(
		config,
	) {
		const targets = {};
		for (const [name, target] of config.targets) {
			targets[name] = target;
		}

		return Object.assign(
			{},
			config,
			{
				vcs: Object.assign({}, config.vcs, {root: config.vcs.root.join()}),
				typeCheck: Object.assign(
					{},
					config.typeCheck,
					{libs: Array.from(config.typeCheck.libs, (path) => path.join())},
				),
				files: Object.assign(
					{},
					config.files,
					{vendorPath: config.files.vendorPath.join()},
				),
				targets,
			},
		);
	}

	function ___R$project$rome$$romejs$project$transport_ts$hydrateJSONProjectConfig(
		config,
	) {
		return Object.assign(
			{},
			config,
			{
				files: Object.assign(
					{},
					config.files,
					{
						vendorPath: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
							config.files.vendorPath,
						),
					},
				),
				vcs: Object.assign(
					{},
					config.vcs,
					{
						root: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
							config.vcs.root,
						),
					},
				),
				typeCheck: Object.assign(
					{},
					config.typeCheck,
					{
						libs: new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet(
							config.typeCheck.libs.map((str) =>
								___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
									str,
								)
							),
						),
					},
				),
				targets: new Map(Object.entries(config.targets)),
			},
		);
	}


  // project-rome/@romejs/project/index.ts



  // project-rome/@romejs/js-compiler/constants.ts
const ___R$project$rome$$romejs$js$compiler$constants_ts = {
		get SCOPE_PRIVATE_PREFIX() {
			return ___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX;
		},
		get REDUCE_SKIP_SUBTREE() {
			return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE;
		},
		get REDUCE_REMOVE() {
			return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
		},
	};
	const ___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX = "___R$";
	const ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE = Symbol();
	const ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE = Symbol();


  // project-rome/@romejs/js-compiler/scope/evaluators/ClassExpression.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default = {
		creator: true,
		build(node, parent, scope) {
			const newScope = scope.fork("class", node);
			newScope.evaluate(node.meta.typeParameters);
			return newScope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/ClassDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassDeclaration_ts$default = {
		creator: false,
		build(node, parent, scope) {
			if (node.id !== undefined) {
				scope.addBinding(
					new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ClassBinding({
						name: node.id.name,
						node: node.id,
						scope,
					}),
				);
			}
			return ___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default.build(
				node,
				parent,
				scope,
			);
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/FunctionDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FunctionDeclaration_ts$default = {
		creator: false,
		build(node, parent, scope) {
			if (node.id !== undefined) {
				scope.addBinding(
					new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding({
						node: node.id,
						name: node.id.name,
						scope,
					}),
				);
			}
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/VariableDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$VariableDeclaration_ts$default = {
		creator: false,
		build(node, parent, scope) {
			for (const decl of node.declarations) {
				for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
					decl,
				)) {
					if (node.kind === "let") {
						scope.addBinding(
							new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding({
								node: id,
								name: id.name,
								scope,
							}),
						);
					}

					if (node.kind === "const") {
						// Only set the value for simple declarations
						let valueNode = id === decl.id ? decl.init : undefined;
						scope.addBinding(
							new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding(
								{
									node: id,
									name: id.name,
									scope,
								},
								valueNode,
							),
						);
					}

					if (
						node.kind === "var" &&
						(scope.kind === "program" || scope.kind === "function")
					) {
						if (!scope.hasHoistedVars) {
							throw new Error(
								"This scope does not allow `var`iables. This is probably because `var`iables were injected into a scope that did not contain `var` in the original source." +
								scope.kind,
							);
						}

						scope.addBinding(
							new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$VarBinding({
								node: id,
								name: id.name,
								scope,
							}),
						);
					}
				}
			}
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/TypeAliasTypeAnnotation.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default = {
		creator: false,
		build(node, parent, scope) {
			scope.evaluate(node.typeParameters);
			scope.addBinding(
				new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
					{
						node: node.id,
						name: node.id.name,
						scope,
					},
					node,
					"typealias",
				),
			);
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/ExportDefaultDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ExportDefaultDeclaration_ts$default = {
		creator: false,
		build(node, parent, scope) {
			const {declaration} = node;
			const newScope = scope.evaluate(declaration, node);
			if (
				declaration.type === "ClassDeclaration" ||
				declaration.type === "FunctionDeclaration"
			) {
				const id = declaration.id;
				if (id !== undefined) {
					newScope.getBindingAssert(id.name).setExported(true);
				}
			}
			return newScope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/ExportLocalDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ExportLocalDeclaration_ts$default = {
		creator: false,
		build(node, parent, scope) {
			const newScope = scope.evaluate(node.declaration, node);
			for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
				node,
			)) {
				newScope.getBindingAssert(id.name).setExported(true);
			}
			return newScope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/ImportDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ImportDeclaration_ts$default = {
		creator: false,
		build(node, parent, scope) {
			const source = node.source.value;

			for (const specifier of ___R$project$rome$$romejs$js$ast$utils$getImportSpecifiers_ts$default(
				node,
			)) {
				let kind = node.importKind || "value";
				let meta;

				if (specifier.type === "ImportNamespaceSpecifier") {
					meta = {
						kind,
						type: "namespace",
						source,
					};
				} else if (specifier.type === "ImportDefaultSpecifier") {
					meta = {
						kind,
						type: "name",
						imported: "default",
						source,
					};
				} else if (specifier.type === "ImportSpecifier") {
					meta = {
						kind,
						type: "name",
						imported: specifier.imported.name,
						source,
					};
				}

				if (meta === undefined) {
					return;
				}

				scope.addBinding(
					new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding(
						{
							node: specifier.local.name,
							name: specifier.local.name.name,
							scope,
						},
						meta,
					),
				);
			}
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/SwitchCase.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$SwitchCase_ts$default = {
		creator: false,
		build(node, parent, scope) {
			for (const child of node.consequent) {
				scope.evaluate(child, node);
			}
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/SwitchStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$SwitchStatement_ts$default = {
		creator: false,
		build(node, parent, scope) {
			for (const child of node.cases) {
				scope.evaluate(child, node);
			}
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/TSImportEqualsDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSImportEqualsDeclaration_ts$default = {
		creator: false,
		build(node, parent, scope) {
			const {moduleReference, id} = node;

			if (moduleReference.type === "TSExternalModuleReference") {
				scope.addBinding(
					new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding(
						{
							node: id,
							name: id.name,
							scope,
						},
						{
							type: "namespace",
							kind: "value",
							source: moduleReference.expression.value,
						},
					),
				);
			} else {
				// TODO
			}
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/ArrowFunctionExpression.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ArrowFunctionExpression_ts$default = {
		creator: true,
		build(node, parent, scope) {
			return scope.evaluate(node.head, node, true);
		},
	};


  // project-rome/@romejs/js-compiler/scope/utils.ts
function ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addFunctionBindings(
		scope,
		node,
		hasArguments = true,
	) {
		const {head} = node;

		// Add type parameters
		scope.evaluate(head.typeParameters);

		const params =
			head.rest === undefined ? head.params : [...head.params, head.rest];

		// Add parameters
		for (const param of params) {
			for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
				param,
			)) {
				// TODO maybe add a `param` binding type?
				scope.addBinding(
					new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding({
						node: id,
						name: id.name,
						scope,
						kind: "parameter",
					}),
				);
			}
		}

		// Add `arguments` binding
		if (hasArguments) {
			scope.addBinding(
				new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding({
					name: "arguments",
					node,
					scope,
				}),
			);
		}

		if (head.hasHoistedVars) {
			___R$project$rome$$romejs$js$compiler$scope$utils_ts$addVarBindings(
				scope,
				node,
			);
		}
	}

	function ___R$project$rome$$romejs$js$compiler$scope$utils_ts$addVarBindings(
		scope,
		topNode,
	) {
		const {context} = scope.getRootScope();
		scope.setHoistedVars();

		context.reduce(
			topNode,
			[
				{
					name: "scopeVarFunc",
					enter: (path) => {
						const {node, parent} = path;

						if (
							___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(
								node,
							) &&
							node !== topNode
						) {
							return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE;
						}

						if (node.type === "VariableDeclaration" && node.kind === "var") {
							scope.evaluate(node, parent);
						}

						return node;
					},
				},
			],
			{
				scope,
				noScopeCreation: true,
			},
		);
	}


  // project-rome/@romejs/js-compiler/scope/evaluators/BlockStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$BlockStatement_ts$default = {
		creator: true,
		build(node, parent, scope) {
			if (
				___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(parent) &&
				scope.node !== parent
			) {
				scope = scope.evaluate(parent.head, parent, true);
			}

			const newScope = scope.fork("block", node);

			if (
				___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(parent) &&
				parent.head.hasHoistedVars
			) {
				___R$project$rome$$romejs$js$compiler$scope$utils_ts$addVarBindings(
					newScope,
					parent,
				);
			}

			for (const child of node.body) {
				newScope.evaluate(child, node);
			}

			return newScope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/CatchClause.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$CatchClause_ts$default = {
		creator: true,
		build(node, parent, scope) {
			const newScope = scope.fork("block", node);
			if (node.param !== undefined) {
				for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
					node.param,
				)) {
					newScope.addBinding(
						new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding(
							{
								node: id,
								name: id.name,
								scope: newScope,
							},
							"catch",
						),
					);
				}
			}
			return newScope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/Program.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$Program_ts$default = {
		creator: true,
		build(node, parent, scope) {
			const newScope = scope.fork("program", node);
			if (node.hasHoistedVars) {
				___R$project$rome$$romejs$js$compiler$scope$utils_ts$addVarBindings(
					newScope,
					node,
				);
			}
			for (const child of node.body) {
				newScope.evaluate(child, node);
			}
			return newScope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/ForStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ForStatement_ts$default = {
		creator: true,
		build(node, parent, scope) {
			const newScope = scope.fork("loop", node);
			newScope.evaluate(node.init, node);
			return newScope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/ForOfStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default = {
		creator: true,
		build(node, parent, scope) {
			const newScope = scope.fork("loop", node);
			newScope.evaluate(node.left, node);
			return newScope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/VariableDeclarationStatement.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$VariableDeclarationStatement_ts$default = {
		creator: false,
		build(node, parent, scope) {
			if (node.declare) {
				for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
					node,
				)) {
					scope.addGlobal(name);
				}
			} else {
				scope.evaluate(node.declaration, node);
			}
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/TSInterfaceDeclaration.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSInterfaceDeclaration_ts$default = {
		creator: false,
		build(node, parent, scope) {
			scope.addBinding(
				new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding(
					{
						node: node.id,
						name: node.id.name,
						scope,
					},
					node,
					"interface",
				),
			);
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/TSDeclareFunction.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$TSDeclareFunction_ts$default = {
		creator: false,
		build(node, parent, scope) {
			scope.addBinding(
				new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding({
					node: node.id,
					name: node.id.name,
					scope,
				}),
			);
		},
	};


  // project-rome/@romejs/js-compiler/scope/bindings.ts
const ___R$project$rome$$romejs$js$compiler$scope$bindings_ts = {
		get Binding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding;
		},
		get ConstBinding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding;
		},
		get LetBinding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding;
		},
		get VarBinding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$VarBinding;
		},
		get ImportBinding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding;
		},
		get ArgumentsBinding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding;
		},
		get FunctionBinding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding;
		},
		get TypeBinding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding;
		},
		get ClassBinding() {
			return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ClassBinding;
		},
	};
	let ___R$$priv$project$rome$$romejs$js$compiler$scope$bindings_ts$id = 0;



	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
		constructor(opts, defaultKind = "variable") {
			this.isExported = false;
			this.scope = opts.scope;
			this.name = opts.name;
			this.node = opts.node;
			this.kind = opts.kind === undefined ? defaultKind : opts.kind;
			this.id = ___R$$priv$project$rome$$romejs$js$compiler$scope$bindings_ts$id++;
		}

		setExported(isExported) {
			this.isExported = isExported;
		}
	}



	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding
		extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
		constructor(opts, value, kind = "constant") {
			super(opts, kind);
			this.value = value;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding
		extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {}

	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$VarBinding
		extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {}

	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding
		extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
		constructor(opts, meta) {
			super(opts, "import");
			this.meta = meta;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding
		extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
		constructor(opts) {
			super(opts, "arguments");
		}
	}

	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding
		extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
		constructor(opts) {
			super(opts, "function");
		}
	}



	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding
		extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding {
		constructor(opts, valueNode, kind) {
			super(opts, valueNode, "type");
			this.typeKind = kind;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ClassBinding
		extends ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$Binding {
		constructor(opts) {
			super(opts, "class");
		}
	}


  // project-rome/@romejs/js-compiler/scope/evaluators/FunctionHead.ts
const ___R$project$rome$$romejs$js$compiler$scope$evaluators$FunctionHead_ts$default = {
		creator: true,
		build(node, parent, parentScope) {
			// We already evaluated ourselves
			if (parentScope.node === node) {
				return parentScope;
			}

			const scope = parentScope.fork("function", parent);

			if (parent.type === "FunctionExpression") {
				const {id} = parent;
				if (id !== undefined) {
					scope.addBinding(
						new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding({
							node: id,
							name: id.name,
							scope,
						}),
					);
				}
			}

			// Add type parameters
			scope.evaluate(node.typeParameters, node);

			const params =
				node.rest === undefined ? node.params : [...node.params, node.rest];

			// Add parameters
			for (const param of params) {
				for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
					param,
				)) {
					scope.addBinding(
						new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$LetBinding({
							node: id,
							name: id.name,
							scope,
							kind: "parameter",
						}),
					);
				}
			}

			// Add `arguments` binding
			if (parent.type !== "ArrowFunctionExpression") {
				scope.addBinding(
					new ___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding({
						name: "arguments",
						node,
						scope,
					}),
				);
			}

			return scope;
		},
	};


  // project-rome/@romejs/js-compiler/scope/evaluators/index.ts


	const ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators = new Map();

	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"FunctionHead",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$FunctionHead_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSDeclareFunction",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$TSDeclareFunction_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ClassDeclaration",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassDeclaration_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"FunctionDeclaration",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$FunctionDeclaration_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"VariableDeclarationStatement",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$VariableDeclarationStatement_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"VariableDeclaration",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$VariableDeclaration_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"TypeAliasTypeAnnotation",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ExportDefaultDeclaration",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ExportDefaultDeclaration_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ExportLocalDeclaration",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ExportLocalDeclaration_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ImportDeclaration",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ImportDeclaration_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"SwitchCase",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$SwitchCase_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"SwitchStatement",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$SwitchStatement_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"TypeAliasTypeAnnotation",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$TypeAliasTypeAnnotation_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSImportEqualsDeclaration",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$TSImportEqualsDeclaration_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ArrowFunctionExpression",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ArrowFunctionExpression_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"BlockStatement",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$BlockStatement_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ClassExpression",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ClassExpression_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"CatchClause",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$CatchClause_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"Program",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$Program_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ForStatement",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ForStatement_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ForOfStatement",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"ForInStatement",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$ForOfStatement_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators.set(
		"TSInterfaceDeclaration",
		___R$project$rome$$romejs$js$compiler$scope$evaluators$TSInterfaceDeclaration_ts$default,
	);
	const ___R$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$default = ___R$$priv$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$evaluators;


  // project-rome/@romejs/js-compiler/scope/globals.ts
const ___R$project$rome$$romejs$js$compiler$scope$globals_ts = {
		get builtin() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$builtin;
		},
		get es5() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es5;
		},
		get es2015() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2015;
		},
		get es2017() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2017;
		},
		get browser() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$browser;
		},
		get worker() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$worker;
		},
		get node() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$node;
		},
		get commonjs() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$commonjs;
		},
		get serviceworker() {
			return ___R$project$rome$$romejs$js$compiler$scope$globals_ts$serviceworker;
		},
	};
	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$builtin = [
		"Array",
		"ArrayBuffer",
		"Atomics",
		"BigInt",
		"BigInt64Array",
		"BigUint64Array",
		"Boolean",
		"constructor",
		"DataView",
		"Date",
		"decodeURI",
		"decodeURIComponent",
		"encodeURI",
		"encodeURIComponent",
		"Error",
		"escape",
		"eval",
		"EvalError",
		"Float32Array",
		"Float64Array",
		"Function",
		"globalThis",
		"hasOwnProperty",
		"Infinity",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"isFinite",
		"isNaN",
		"isPrototypeOf",
		"JSON",
		"Map",
		"Math",
		"NaN",
		"Number",
		"Object",
		"parseFloat",
		"parseInt",
		"Promise",
		"propertyIsEnumerable",
		"Proxy",
		"RangeError",
		"ReferenceError",
		"Reflect",
		"RegExp",
		"Set",
		"SharedArrayBuffer",
		"String",
		"Symbol",
		"SyntaxError",
		"toLocaleString",
		"toString",
		"TypeError",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"undefined",
		"unescape",
		"URIError",
		"valueOf",
		"WeakMap",
		"WeakSet",
	];

	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es5 = [
		"Array",
		"Boolean",
		"constructor",
		"Date",
		"decodeURI",
		"decodeURIComponent",
		"encodeURI",
		"encodeURIComponent",
		"Error",
		"escape",
		"eval",
		"EvalError",
		"Function",
		"hasOwnProperty",
		"Infinity",
		"isFinite",
		"isNaN",
		"isPrototypeOf",
		"JSON",
		"Math",
		"NaN",
		"Number",
		"Object",
		"parseFloat",
		"parseInt",
		"propertyIsEnumerable",
		"RangeError",
		"ReferenceError",
		"RegExp",
		"String",
		"SyntaxError",
		"toLocaleString",
		"toString",
		"TypeError",
		"undefined",
		"unescape",
		"URIError",
		"valueOf",
	];

	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2015 = [
		"Array",
		"ArrayBuffer",
		"Boolean",
		"constructor",
		"DataView",
		"Date",
		"decodeURI",
		"decodeURIComponent",
		"encodeURI",
		"encodeURIComponent",
		"Error",
		"escape",
		"eval",
		"EvalError",
		"Float32Array",
		"Float64Array",
		"Function",
		"hasOwnProperty",
		"Infinity",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"isFinite",
		"isNaN",
		"isPrototypeOf",
		"JSON",
		"Map",
		"Math",
		"NaN",
		"Number",
		"Object",
		"parseFloat",
		"parseInt",
		"Promise",
		"propertyIsEnumerable",
		"Proxy",
		"RangeError",
		"ReferenceError",
		"Reflect",
		"RegExp",
		"Set",
		"String",
		"Symbol",
		"SyntaxError",
		"toLocaleString",
		"toString",
		"TypeError",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"undefined",
		"unescape",
		"URIError",
		"valueOf",
		"WeakMap",
		"WeakSet",
	];

	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2017 = [
		"Array",
		"ArrayBuffer",
		"Atomics",
		"Boolean",
		"constructor",
		"DataView",
		"Date",
		"decodeURI",
		"decodeURIComponent",
		"encodeURI",
		"encodeURIComponent",
		"Error",
		"escape",
		"eval",
		"EvalError",
		"Float32Array",
		"Float64Array",
		"Function",
		"hasOwnProperty",
		"Infinity",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"isFinite",
		"isNaN",
		"isPrototypeOf",
		"JSON",
		"Map",
		"Math",
		"NaN",
		"Number",
		"Object",
		"parseFloat",
		"parseInt",
		"Promise",
		"propertyIsEnumerable",
		"Proxy",
		"RangeError",
		"ReferenceError",
		"Reflect",
		"RegExp",
		"Set",
		"SharedArrayBuffer",
		"String",
		"Symbol",
		"SyntaxError",
		"toLocaleString",
		"toString",
		"TypeError",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray",
		"undefined",
		"unescape",
		"URIError",
		"valueOf",
		"WeakMap",
		"WeakSet",
	];

	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$browser = [
		"AbortController",
		"AbortSignal",
		"addEventListener",
		"alert",
		"AnalyserNode",
		"Animation",
		"AnimationEffectReadOnly",
		"AnimationEffectTiming",
		"AnimationEffectTimingReadOnly",
		"AnimationEvent",
		"AnimationPlaybackEvent",
		"AnimationTimeline",
		"applicationCache",
		"ApplicationCache",
		"ApplicationCacheErrorEvent",
		"atob",
		"Attr",
		"Audio",
		"AudioBuffer",
		"AudioBufferSourceNode",
		"AudioContext",
		"AudioDestinationNode",
		"AudioListener",
		"AudioNode",
		"AudioParam",
		"AudioProcessingEvent",
		"AudioScheduledSourceNode",
		"AudioWorkletGlobalScope ",
		"AudioWorkletNode",
		"AudioWorkletProcessor",
		"BarProp",
		"BaseAudioContext",
		"BatteryManager",
		"BeforeUnloadEvent",
		"BiquadFilterNode",
		"Blob",
		"BlobEvent",
		"blur",
		"BroadcastChannel",
		"btoa",
		"BudgetService",
		"ByteLengthQueuingStrategy",
		"Cache",
		"caches",
		"CacheStorage",
		"cancelAnimationFrame",
		"cancelIdleCallback",
		"CanvasCaptureMediaStreamTrack",
		"CanvasGradient",
		"CanvasPattern",
		"CanvasRenderingContext2D",
		"ChannelMergerNode",
		"ChannelSplitterNode",
		"CharacterData",
		"clearInterval",
		"clearTimeout",
		"clientInformation",
		"ClipboardEvent",
		"close",
		"closed",
		"CloseEvent",
		"Comment",
		"CompositionEvent",
		"confirm",
		"console",
		"ConstantSourceNode",
		"ConvolverNode",
		"CountQueuingStrategy",
		"createImageBitmap",
		"Credential",
		"CredentialsContainer",
		"crypto",
		"Crypto",
		"CryptoKey",
		"CSS",
		"CSSConditionRule",
		"CSSFontFaceRule",
		"CSSGroupingRule",
		"CSSImportRule",
		"CSSKeyframeRule",
		"CSSKeyframesRule",
		"CSSMediaRule",
		"CSSNamespaceRule",
		"CSSPageRule",
		"CSSRule",
		"CSSRuleList",
		"CSSStyleDeclaration",
		"CSSStyleRule",
		"CSSStyleSheet",
		"CSSSupportsRule",
		"CustomElementRegistry",
		"customElements",
		"CustomEvent",
		"DataTransfer",
		"DataTransferItem",
		"DataTransferItemList",
		"defaultstatus",
		"defaultStatus",
		"DelayNode",
		"DeviceMotionEvent",
		"DeviceOrientationEvent",
		"devicePixelRatio",
		"dispatchEvent",
		"document",
		"Document",
		"DocumentFragment",
		"DocumentType",
		"DOMError",
		"DOMException",
		"DOMImplementation",
		"DOMMatrix",
		"DOMMatrixReadOnly",
		"DOMParser",
		"DOMPoint",
		"DOMPointReadOnly",
		"DOMQuad",
		"DOMRect",
		"DOMRectReadOnly",
		"DOMStringList",
		"DOMStringMap",
		"DOMTokenList",
		"DragEvent",
		"DynamicsCompressorNode",
		"Element",
		"ErrorEvent",
		"event",
		"Event",
		"EventSource",
		"EventTarget",
		"external",
		"fetch",
		"File",
		"FileList",
		"FileReader",
		"find",
		"focus",
		"FocusEvent",
		"FontFace",
		"FontFaceSetLoadEvent",
		"FormData",
		"frameElement",
		"frames",
		"GainNode",
		"Gamepad",
		"GamepadButton",
		"GamepadEvent",
		"getComputedStyle",
		"getSelection",
		"HashChangeEvent",
		"Headers",
		"history",
		"History",
		"HTMLAllCollection",
		"HTMLAnchorElement",
		"HTMLAreaElement",
		"HTMLAudioElement",
		"HTMLBaseElement",
		"HTMLBodyElement",
		"HTMLBRElement",
		"HTMLButtonElement",
		"HTMLCanvasElement",
		"HTMLCollection",
		"HTMLContentElement",
		"HTMLDataElement",
		"HTMLDataListElement",
		"HTMLDetailsElement",
		"HTMLDialogElement",
		"HTMLDirectoryElement",
		"HTMLDivElement",
		"HTMLDListElement",
		"HTMLDocument",
		"HTMLElement",
		"HTMLEmbedElement",
		"HTMLFieldSetElement",
		"HTMLFontElement",
		"HTMLFormControlsCollection",
		"HTMLFormElement",
		"HTMLFrameElement",
		"HTMLFrameSetElement",
		"HTMLHeadElement",
		"HTMLHeadingElement",
		"HTMLHRElement",
		"HTMLHtmlElement",
		"HTMLIFrameElement",
		"HTMLImageElement",
		"HTMLInputElement",
		"HTMLLabelElement",
		"HTMLLegendElement",
		"HTMLLIElement",
		"HTMLLinkElement",
		"HTMLMapElement",
		"HTMLMarqueeElement",
		"HTMLMediaElement",
		"HTMLMenuElement",
		"HTMLMetaElement",
		"HTMLMeterElement",
		"HTMLModElement",
		"HTMLObjectElement",
		"HTMLOListElement",
		"HTMLOptGroupElement",
		"HTMLOptionElement",
		"HTMLOptionsCollection",
		"HTMLOutputElement",
		"HTMLParagraphElement",
		"HTMLParamElement",
		"HTMLPictureElement",
		"HTMLPreElement",
		"HTMLProgressElement",
		"HTMLQuoteElement",
		"HTMLScriptElement",
		"HTMLSelectElement",
		"HTMLShadowElement",
		"HTMLSlotElement",
		"HTMLSourceElement",
		"HTMLSpanElement",
		"HTMLStyleElement",
		"HTMLTableCaptionElement",
		"HTMLTableCellElement",
		"HTMLTableColElement",
		"HTMLTableElement",
		"HTMLTableRowElement",
		"HTMLTableSectionElement",
		"HTMLTemplateElement",
		"HTMLTextAreaElement",
		"HTMLTimeElement",
		"HTMLTitleElement",
		"HTMLTrackElement",
		"HTMLUListElement",
		"HTMLUnknownElement",
		"HTMLVideoElement",
		"IDBCursor",
		"IDBCursorWithValue",
		"IDBDatabase",
		"IDBFactory",
		"IDBIndex",
		"IDBKeyRange",
		"IDBObjectStore",
		"IDBOpenDBRequest",
		"IDBRequest",
		"IDBTransaction",
		"IDBVersionChangeEvent",
		"IdleDeadline",
		"IIRFilterNode",
		"Image",
		"ImageBitmap",
		"ImageBitmapRenderingContext",
		"ImageCapture",
		"ImageData",
		"indexedDB",
		"innerHeight",
		"innerWidth",
		"InputEvent",
		"IntersectionObserver",
		"IntersectionObserverEntry",
		"Intl",
		"isSecureContext",
		"KeyboardEvent",
		"KeyframeEffect",
		"KeyframeEffectReadOnly",
		"length",
		"localStorage",
		"location",
		"Location",
		"locationbar",
		"matchMedia",
		"MediaDeviceInfo",
		"MediaDevices",
		"MediaElementAudioSourceNode",
		"MediaEncryptedEvent",
		"MediaError",
		"MediaKeyMessageEvent",
		"MediaKeySession",
		"MediaKeyStatusMap",
		"MediaKeySystemAccess",
		"MediaList",
		"MediaQueryList",
		"MediaQueryListEvent",
		"MediaRecorder",
		"MediaSettingsRange",
		"MediaSource",
		"MediaStream",
		"MediaStreamAudioDestinationNode",
		"MediaStreamAudioSourceNode",
		"MediaStreamEvent",
		"MediaStreamTrack",
		"MediaStreamTrackEvent",
		"menubar",
		"MessageChannel",
		"MessageEvent",
		"MessagePort",
		"MIDIAccess",
		"MIDIConnectionEvent",
		"MIDIInput",
		"MIDIInputMap",
		"MIDIMessageEvent",
		"MIDIOutput",
		"MIDIOutputMap",
		"MIDIPort",
		"MimeType",
		"MimeTypeArray",
		"MouseEvent",
		"moveBy",
		"moveTo",
		"MutationEvent",
		"MutationObserver",
		"MutationRecord",
		"name",
		"NamedNodeMap",
		"NavigationPreloadManager",
		"navigator",
		"Navigator",
		"NetworkInformation",
		"Node",
		"NodeFilter",
		"NodeIterator",
		"NodeList",
		"Notification",
		"OfflineAudioCompletionEvent",
		"OfflineAudioContext",
		"offscreenBuffering",
		"OffscreenCanvas",
		"onabort",
		"onafterprint",
		"onanimationend",
		"onanimationiteration",
		"onanimationstart",
		"onappinstalled",
		"onauxclick",
		"onbeforeinstallprompt",
		"onbeforeprint",
		"onbeforeunload",
		"onblur",
		"oncancel",
		"oncanplay",
		"oncanplaythrough",
		"onchange",
		"onclick",
		"onclose",
		"oncontextmenu",
		"oncuechange",
		"ondblclick",
		"ondevicemotion",
		"ondeviceorientation",
		"ondeviceorientationabsolute",
		"ondrag",
		"ondragend",
		"ondragenter",
		"ondragleave",
		"ondragover",
		"ondragstart",
		"ondrop",
		"ondurationchange",
		"onemptied",
		"onended",
		"onerror",
		"onfocus",
		"ongotpointercapture",
		"onhashchange",
		"oninput",
		"oninvalid",
		"onkeydown",
		"onkeypress",
		"onkeyup",
		"onlanguagechange",
		"onload",
		"onloadeddata",
		"onloadedmetadata",
		"onloadstart",
		"onlostpointercapture",
		"onmessage",
		"onmessageerror",
		"onmousedown",
		"onmouseenter",
		"onmouseleave",
		"onmousemove",
		"onmouseout",
		"onmouseover",
		"onmouseup",
		"onmousewheel",
		"onoffline",
		"ononline",
		"onpagehide",
		"onpageshow",
		"onpause",
		"onplay",
		"onplaying",
		"onpointercancel",
		"onpointerdown",
		"onpointerenter",
		"onpointerleave",
		"onpointermove",
		"onpointerout",
		"onpointerover",
		"onpointerup",
		"onpopstate",
		"onprogress",
		"onratechange",
		"onrejectionhandled",
		"onreset",
		"onresize",
		"onscroll",
		"onsearch",
		"onseeked",
		"onseeking",
		"onselect",
		"onstalled",
		"onstorage",
		"onsubmit",
		"onsuspend",
		"ontimeupdate",
		"ontoggle",
		"ontransitionend",
		"onunhandledrejection",
		"onunload",
		"onvolumechange",
		"onwaiting",
		"onwheel",
		"open",
		"openDatabase",
		"opener",
		"Option",
		"origin",
		"OscillatorNode",
		"outerHeight",
		"outerWidth",
		"PageTransitionEvent",
		"pageXOffset",
		"pageYOffset",
		"PannerNode",
		"parent",
		"Path2D",
		"PaymentAddress",
		"PaymentRequest",
		"PaymentRequestUpdateEvent",
		"PaymentResponse",
		"performance",
		"Performance",
		"PerformanceEntry",
		"PerformanceLongTaskTiming",
		"PerformanceMark",
		"PerformanceMeasure",
		"PerformanceNavigation",
		"PerformanceNavigationTiming",
		"PerformanceObserver",
		"PerformanceObserverEntryList",
		"PerformancePaintTiming",
		"PerformanceResourceTiming",
		"PerformanceTiming",
		"PeriodicWave",
		"Permissions",
		"PermissionStatus",
		"personalbar",
		"PhotoCapabilities",
		"Plugin",
		"PluginArray",
		"PointerEvent",
		"PopStateEvent",
		"postMessage",
		"Presentation",
		"PresentationAvailability",
		"PresentationConnection",
		"PresentationConnectionAvailableEvent",
		"PresentationConnectionCloseEvent",
		"PresentationConnectionList",
		"PresentationReceiver",
		"PresentationRequest",
		"print",
		"ProcessingInstruction",
		"ProgressEvent",
		"PromiseRejectionEvent",
		"prompt",
		"PushManager",
		"PushSubscription",
		"PushSubscriptionOptions",
		"queueMicrotask",
		"RadioNodeList",
		"Range",
		"ReadableStream",
		"registerProcessor",
		"RemotePlayback",
		"removeEventListener",
		"Request",
		"requestAnimationFrame",
		"requestIdleCallback",
		"resizeBy",
		"ResizeObserver",
		"ResizeObserverEntry",
		"resizeTo",
		"Response",
		"RTCCertificate",
		"RTCDataChannel",
		"RTCDataChannelEvent",
		"RTCDtlsTransport",
		"RTCIceCandidate",
		"RTCIceGatherer",
		"RTCIceTransport",
		"RTCPeerConnection",
		"RTCPeerConnectionIceEvent",
		"RTCRtpContributingSource",
		"RTCRtpReceiver",
		"RTCRtpSender",
		"RTCSctpTransport",
		"RTCSessionDescription",
		"RTCStatsReport",
		"RTCTrackEvent",
		"screen",
		"Screen",
		"screenLeft",
		"ScreenOrientation",
		"screenTop",
		"screenX",
		"screenY",
		"ScriptProcessorNode",
		"scroll",
		"scrollbars",
		"scrollBy",
		"scrollTo",
		"scrollX",
		"scrollY",
		"SecurityPolicyViolationEvent",
		"Selection",
		"self",
		"ServiceWorker",
		"ServiceWorkerContainer",
		"ServiceWorkerRegistration",
		"sessionStorage",
		"setInterval",
		"setTimeout",
		"ShadowRoot",
		"SharedWorker",
		"SourceBuffer",
		"SourceBufferList",
		"speechSynthesis",
		"SpeechSynthesisEvent",
		"SpeechSynthesisUtterance",
		"StaticRange",
		"status",
		"statusbar",
		"StereoPannerNode",
		"stop",
		"Storage",
		"StorageEvent",
		"StorageManager",
		"styleMedia",
		"StyleSheet",
		"StyleSheetList",
		"SubtleCrypto",
		"SVGAElement",
		"SVGAngle",
		"SVGAnimatedAngle",
		"SVGAnimatedBoolean",
		"SVGAnimatedEnumeration",
		"SVGAnimatedInteger",
		"SVGAnimatedLength",
		"SVGAnimatedLengthList",
		"SVGAnimatedNumber",
		"SVGAnimatedNumberList",
		"SVGAnimatedPreserveAspectRatio",
		"SVGAnimatedRect",
		"SVGAnimatedString",
		"SVGAnimatedTransformList",
		"SVGAnimateElement",
		"SVGAnimateMotionElement",
		"SVGAnimateTransformElement",
		"SVGAnimationElement",
		"SVGCircleElement",
		"SVGClipPathElement",
		"SVGComponentTransferFunctionElement",
		"SVGDefsElement",
		"SVGDescElement",
		"SVGDiscardElement",
		"SVGElement",
		"SVGEllipseElement",
		"SVGFEBlendElement",
		"SVGFEColorMatrixElement",
		"SVGFEComponentTransferElement",
		"SVGFECompositeElement",
		"SVGFEConvolveMatrixElement",
		"SVGFEDiffuseLightingElement",
		"SVGFEDisplacementMapElement",
		"SVGFEDistantLightElement",
		"SVGFEDropShadowElement",
		"SVGFEFloodElement",
		"SVGFEFuncAElement",
		"SVGFEFuncBElement",
		"SVGFEFuncGElement",
		"SVGFEFuncRElement",
		"SVGFEGaussianBlurElement",
		"SVGFEImageElement",
		"SVGFEMergeElement",
		"SVGFEMergeNodeElement",
		"SVGFEMorphologyElement",
		"SVGFEOffsetElement",
		"SVGFEPointLightElement",
		"SVGFESpecularLightingElement",
		"SVGFESpotLightElement",
		"SVGFETileElement",
		"SVGFETurbulenceElement",
		"SVGFilterElement",
		"SVGForeignObjectElement",
		"SVGGElement",
		"SVGGeometryElement",
		"SVGGradientElement",
		"SVGGraphicsElement",
		"SVGImageElement",
		"SVGLength",
		"SVGLengthList",
		"SVGLinearGradientElement",
		"SVGLineElement",
		"SVGMarkerElement",
		"SVGMaskElement",
		"SVGMatrix",
		"SVGMetadataElement",
		"SVGMPathElement",
		"SVGNumber",
		"SVGNumberList",
		"SVGPathElement",
		"SVGPatternElement",
		"SVGPoint",
		"SVGPointList",
		"SVGPolygonElement",
		"SVGPolylineElement",
		"SVGPreserveAspectRatio",
		"SVGRadialGradientElement",
		"SVGRect",
		"SVGRectElement",
		"SVGScriptElement",
		"SVGSetElement",
		"SVGStopElement",
		"SVGStringList",
		"SVGStyleElement",
		"SVGSVGElement",
		"SVGSwitchElement",
		"SVGSymbolElement",
		"SVGTextContentElement",
		"SVGTextElement",
		"SVGTextPathElement",
		"SVGTextPositioningElement",
		"SVGTitleElement",
		"SVGTransform",
		"SVGTransformList",
		"SVGTSpanElement",
		"SVGUnitTypes",
		"SVGUseElement",
		"SVGViewElement",
		"TaskAttributionTiming",
		"Text",
		"TextDecoder",
		"TextEncoder",
		"TextEvent",
		"TextMetrics",
		"TextTrack",
		"TextTrackCue",
		"TextTrackCueList",
		"TextTrackList",
		"TimeRanges",
		"toolbar",
		"top",
		"Touch",
		"TouchEvent",
		"TouchList",
		"TrackEvent",
		"TransitionEvent",
		"TreeWalker",
		"UIEvent",
		"URL",
		"URLSearchParams",
		"ValidityState",
		"visualViewport",
		"VisualViewport",
		"VTTCue",
		"WaveShaperNode",
		"WebAssembly",
		"WebGL2RenderingContext",
		"WebGLActiveInfo",
		"WebGLBuffer",
		"WebGLContextEvent",
		"WebGLFramebuffer",
		"WebGLProgram",
		"WebGLQuery",
		"WebGLRenderbuffer",
		"WebGLRenderingContext",
		"WebGLSampler",
		"WebGLShader",
		"WebGLShaderPrecisionFormat",
		"WebGLSync",
		"WebGLTexture",
		"WebGLTransformFeedback",
		"WebGLUniformLocation",
		"WebGLVertexArrayObject",
		"WebSocket",
		"WheelEvent",
		"window",
		"Window",
		"Worker",
		"WritableStream",
		"XMLDocument",
		"XMLHttpRequest",
		"XMLHttpRequestEventTarget",
		"XMLHttpRequestUpload",
		"XMLSerializer",
		"XPathEvaluator",
		"XPathExpression",
		"XPathResult",
		"XSLTProcessor",
	];

	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$worker = [
		"addEventListener",
		"applicationCache",
		"atob",
		"Blob",
		"BroadcastChannel",
		"btoa",
		"Cache",
		"caches",
		"clearInterval",
		"clearTimeout",
		"close",
		"console",
		"fetch",
		"FileReaderSync",
		"FormData",
		"Headers",
		"IDBCursor",
		"IDBCursorWithValue",
		"IDBDatabase",
		"IDBFactory",
		"IDBIndex",
		"IDBKeyRange",
		"IDBObjectStore",
		"IDBOpenDBRequest",
		"IDBRequest",
		"IDBTransaction",
		"IDBVersionChangeEvent",
		"ImageData",
		"importScripts",
		"indexedDB",
		"location",
		"MessageChannel",
		"MessagePort",
		"name",
		"navigator",
		"Notification",
		"onclose",
		"onconnect",
		"onerror",
		"onlanguagechange",
		"onmessage",
		"onoffline",
		"ononline",
		"onrejectionhandled",
		"onunhandledrejection",
		"performance",
		"Performance",
		"PerformanceEntry",
		"PerformanceMark",
		"PerformanceMeasure",
		"PerformanceNavigation",
		"PerformanceResourceTiming",
		"PerformanceTiming",
		"postMessage",
		"Promise",
		"queueMicrotask",
		"removeEventListener",
		"Request",
		"Response",
		"self",
		"ServiceWorkerRegistration",
		"setInterval",
		"setTimeout",
		"TextDecoder",
		"TextEncoder",
		"URL",
		"URLSearchParams",
		"WebSocket",
		"Worker",
		"WorkerGlobalScope",
		"XMLHttpRequest",
	];

	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$node = [
		"__dirname",
		"__filename",
		"Buffer",
		"clearImmediate",
		"clearInterval",
		"clearTimeout",
		"console",
		"exports",
		"global",
		"Intl",
		"module",
		"process",
		"queueMicrotask",
		"require",
		"setImmediate",
		"setInterval",
		"setTimeout",
		"TextDecoder",
		"TextEncoder",
		"URL",
		"URLSearchParams",
	];

	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$commonjs = [
		"exports",
		"global",
		"module",
		"require",
	];

	const ___R$project$rome$$romejs$js$compiler$scope$globals_ts$serviceworker = [
		"addEventListener",
		"applicationCache",
		"atob",
		"Blob",
		"BroadcastChannel",
		"btoa",
		"Cache",
		"caches",
		"CacheStorage",
		"clearInterval",
		"clearTimeout",
		"Client",
		"clients",
		"Clients",
		"close",
		"console",
		"ExtendableEvent",
		"ExtendableMessageEvent",
		"fetch",
		"FetchEvent",
		"FileReaderSync",
		"FormData",
		"Headers",
		"IDBCursor",
		"IDBCursorWithValue",
		"IDBDatabase",
		"IDBFactory",
		"IDBIndex",
		"IDBKeyRange",
		"IDBObjectStore",
		"IDBOpenDBRequest",
		"IDBRequest",
		"IDBTransaction",
		"IDBVersionChangeEvent",
		"ImageData",
		"importScripts",
		"indexedDB",
		"location",
		"MessageChannel",
		"MessagePort",
		"name",
		"navigator",
		"Notification",
		"onclose",
		"onconnect",
		"onerror",
		"onfetch",
		"oninstall",
		"onlanguagechange",
		"onmessage",
		"onmessageerror",
		"onnotificationclick",
		"onnotificationclose",
		"onoffline",
		"ononline",
		"onpush",
		"onpushsubscriptionchange",
		"onrejectionhandled",
		"onsync",
		"onunhandledrejection",
		"performance",
		"Performance",
		"PerformanceEntry",
		"PerformanceMark",
		"PerformanceMeasure",
		"PerformanceNavigation",
		"PerformanceResourceTiming",
		"PerformanceTiming",
		"postMessage",
		"Promise",
		"queueMicrotask",
		"registration",
		"removeEventListener",
		"Request",
		"Response",
		"self",
		"ServiceWorker",
		"ServiceWorkerContainer",
		"ServiceWorkerGlobalScope",
		"ServiceWorkerMessageEvent",
		"ServiceWorkerRegistration",
		"setInterval",
		"setTimeout",
		"skipWaiting",
		"TextDecoder",
		"TextEncoder",
		"URL",
		"URLSearchParams",
		"WebSocket",
		"WindowClient",
		"Worker",
		"WorkerGlobalScope",
		"XMLHttpRequest",
	];


  // project-rome/@romejs/js-compiler/scope/Scope.ts
let ___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$scopeCounter = 0;

	Error.stackTraceLimit = Infinity;





	class ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$default {
		constructor(
			{
				kind,
				node,
				parentScope,
				rootScope,
			},
		) {
			this.parentScope = parentScope;
			this.rootScope = rootScope;
			this.node = node;
			this.kind = kind;
			this.bindings = new Map();
			this.id = ___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$scopeCounter++;
			this.hasHoistedVars = false;
			this.globals = new Set();

			this.childScopeCache = new WeakMap();
		}

		setHoistedVars() {
			this.hasHoistedVars = true;
		}

		hasBindings() {
			return this.bindings.size > 0;
		}

		getOwnBindings() {
			return this.bindings;
		}

		getOwnBindingNames() {
			return Array.from(this.bindings.keys());
		}

		findScope(kind) {
			let scope = this;
			while (scope !== undefined) {
				if (scope.kind === kind) {
					return scope;
				} else {
					scope = scope.parentScope;
				}
			}
			return undefined;
		}

		getRootScope() {
			const {rootScope} = this;
			if (rootScope === undefined) {
				throw new Error("Expected rootScope");
			}
			return rootScope;
		}

		evaluate(
			node,
			parent = ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT,
			creatorOnly = false,
			force = false,
		) {
			if (node === undefined) {
				return this;
			}

			if (!force && node === this.node) {
				return this;
			}
			const cached = this.childScopeCache.get(node);
			if (cached !== undefined) {
				return cached;
			}

			let evaluator = ___R$project$rome$$romejs$js$compiler$scope$evaluators$index_ts$default.get(
				node.type,
			);

			if (!creatorOnly && evaluator !== undefined && evaluator.creator) {
				evaluator = undefined;
			}

			if (evaluator === undefined) {
				return this;
			}

			let scope = evaluator.build(node, parent, this);

			if (scope === undefined) {
				scope = this;
			}

			this.childScopeCache.set(node, scope);
			return scope;
		}

		fork(kind, node) {
			const rootScope = this.getRootScope();
			return new ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$default({
				kind,
				node,
				parentScope: this,
				rootScope,
			});
		}

		dump(root = true) {
			if (root) {
				console.log("START");
			}
			console.log("------", this.id, this.kind);
			for (const [name, binding] of this.bindings) {
				console.log(" ", binding.id, "-", binding.constructor.name, name);
			}
			if (this.parentScope !== undefined) {
				this.parentScope.dump(false);
			}
			if (root) {
				console.log("END");
			}
		}

		getOwnBinding(name) {
			return this.bindings.get(name);
		}

		getBindingFromPath(path) {
			const {node} = path;
			if (
				___R$project$rome$$romejs$js$ast$utils$isVariableIdentifier_ts$default(
					node,
				)
			) {
				// TODO we can do some isInTypeAnnotation magic to get the proper "type" binding
				return this.getBinding(node.name);
			} else {
				return undefined;
			}
		}

		getBinding(name) {
			const binding = this.bindings.get(name);
			if (binding !== undefined) {
				return binding;
			}

			const {parentScope} = this;
			if (parentScope !== undefined) {
				return parentScope.getBinding(name);
			}

			return undefined;
		}

		getBindingAssert(name) {
			const binding = this.getBinding(name);
			if (binding === undefined) {
				this.dump();
				throw new Error("Expected " + name + " binding");
			}
			return binding;
		}

		addBinding(binding) {
			this.bindings.set(binding.name, binding);
			return binding;
		}

		hasBinding(name) {
			return this.getBinding(name) !== undefined;
		}

		generateUid(name) {
			return this.getRootScope().generateUid(name);
		}

		addGlobal(name) {
			this.globals.add(name);
		}

		isGlobal(name) {
			if (this.globals.has(name)) {
				return true;
			}

			if (this.parentScope !== undefined) {
				return this.parentScope.isGlobal(name);
			}

			return false;
		}
	}

	const ___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START = /^([\s+]|)global /;
	const ___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON = /:(.*?)$/;

	class ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$RootScope
		extends ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$default {
		constructor(context, ast) {
			super({
				kind: "root",
				parentScope: undefined,
				rootScope: undefined,
				node: undefined,
			});
			this.uids = new Set();
			this.context = context;

			this.globals = new Set([
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.builtin,
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.es5,
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.es2015,
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.es2017,
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.browser,
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.worker,
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.node,
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.commonjs,
				...___R$project$rome$$romejs$js$compiler$scope$globals_ts.serviceworker,
				...context.project.config.lint.globals,
				...this.parseGlobalComments(ast),
			]);
		}

		parseGlobalComments(ast) {
			const globals = [];

			for (const {value} of ast.comments) {
				// Check if comment starts with "global ", ignoring any leading whitespace
				if (
					!___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START.test(
						value,
					)
				) {
					continue;
				}

				// Remove prefix
				const clean = value.replace(
					___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_START,
					"",
				);

				// Split by commas, supports comments like "foo, bar"
				const parts = clean.split(",");

				for (const part of parts) {
					let name = part.trim();

					// Support comments like "foo: true" amd "bar: false"
					if (
						___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON.test(
							name,
						)
					) {
						const match = part.match(
							___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON,
						);
						if (match == null) {
							throw new Error(
								"Used RegExp.test already so know this will always match",
							);
						}

						// Remove everything after the colon
						name = name.replace(
							___R$$priv$project$rome$$romejs$js$compiler$scope$Scope_ts$GLOBAL_COMMENT_COLON,
							"",
						);

						const value = match[1].trim();

						// Other tools would flag these as unavailable and remove them from the master set

						// We don't do that, we might want to later though?

						// Also, we should maybe validate the value to only true/false
						if (value === "false") {
							break;
						}
					}

					globals.push(name);
				}
			}

			return globals;
		}

		getRootScope() {
			return this;
		}

		generateUid(name) {
			const prefixed =
				"" +
				___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
				(name === undefined ? "" : name);

			// Check for invalid names
			if (
				name !== undefined &&
				!___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(
					name,
				)
			) {
				throw new Error(name + " is not a valid identifier name");
			}

			// TODO find some way to remove the possibility of user bindings colliding with our private prefix
			let counter = 0;

			while (true) {
				const suffix = counter === 0 ? "" : String(counter);
				const name = prefixed + suffix;

				if (this.uids.has(name)) {
					counter++;
				} else {
					this.uids.add(name);
					return name;
				}
			}

			throw new Error("Unreachable");
		}
	}


  // project-rome/@romejs/js-compiler/methods/reduce.ts
const ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT = "BAIL";
	const ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$KEEP_EXIT = "KEEP";

	/**
 * Validate the return value of an enter or exit transform
 */
	function ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(
		transformName,
		node,
		path,
	) {
		// Ignore some constants that will be handled later
		if (
			node ===
			___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE
		) {
			return;
		}

		// If this function hits a symbol then it's invalid as we would have dealt with it before if it were a valid constant
		if (typeof node === "symbol") {
			throw new Error(
				"Returned a symbol from transform " +
				transformName +
				" that doesn't correspond to any reduce constant",
			);
		}

		// Verify common mistake of forgetting to return something
		if (typeof node === "undefined") {
			throw new Error(
				"Returned `undefined` from transform " +
				transformName +
				". If you meant to delete this node then use `return" +
				" REDUCE_REMOVE`, otherwise if you want to keep it then use `return path.node;`",
			);
		}

		// Handle returning an array of nodes
		if (Array.isArray(node)) {
			// keyed nodes cannot be replaced with an array of nodes
			if (path.opts.noArrays === true) {
				throw new Error(
					"Cannot replace this keyed node " +
					path.parent.type +
					"[" +
					path.opts.nodeKey +
					"] with an array of nodes - originated from transform " +
					transformName,
				);
			}
			return;
		}

		// Verify that it's a valid node
		if (!___R$project$rome$$romejs$js$ast$utils$isNodeLike_ts$default(node)) {
			throw new Error(
				"Expected a return value of a plain object with a `type` property or a reduce constant - originated from 'transform " +
				transformName,
			);
		}
	}

	/**
 * Given a return value from a transform, determine if we should bail out.
 * Bailing out means returning the actual node and making the parent reduce
 * call handle it (if any).
 */
	function ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(
		node,
	) {
		if (Array.isArray(node)) {
			// We just return the array of nodes, without transforming them
			// reduce() calls higher in the chain will splice this array and do it's
			// own transform call so when the transform is performed on the node it's
			// in it's correct place in the tree
			return true;
		}

		// This node is being removed, no point recursing into it
		if (
			node ===
			___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE
		) {
			return true;
		}

		return false;
	}

	/**
 * Run an exit handler. We will return a tuple marking whether we should bail
 * with the returned value.
 */
	function ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$runExit(
		path,
		name,
		callback,
		state,
	) {
		// Call transformer
		let transformedNode = callback(path, state);

		// Validate the node
		___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(
			name,
			transformedNode,
			path,
		);

		// Check if we need to bail out
		if (
			___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(
				transformedNode,
			)
		) {
			return [
				___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT,
				transformedNode,
			];
		}

		// create new path if node has been changed
		if (transformedNode !== path.node) {
			path = path.fork(transformedNode);
		}

		return [
			___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$KEEP_EXIT,
			path,
		];
	}

	function ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
		origNode,
		visitors,
		context,
		pathOpts = {},
	) {
		// Initialize first path
		let path = new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(
			origNode,
			context,
			pathOpts,
		);

		// Perform enter transforms
		for (const visitor of visitors) {
			const {enter} = visitor;
			if (enter === undefined) {
				continue;
			}

			// Call transformer
			let transformedNode = enter(path);

			// When returning this symbol, it indicates we should skip the subtree
			if (
				transformedNode ===
				___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_SKIP_SUBTREE
			) {
				return origNode;
			}

			// Validate the return value
			___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$validateTransformReturn(
				visitor.name,
				transformedNode,
				path,
			);

			// Check if we need to bail out. See the comment for shouldBailReduce on what that means
			if (
				___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$shouldBailReduce(
					transformedNode,
				)
			) {
				return transformedNode;
			}

			// Create new path if node has been changed
			if (transformedNode !== path.node) {
				path = path.fork(transformedNode);
			}
		}

		// Reduce the children
		let {node} = path;
		const visitorKeys = ___R$project$rome$$romejs$js$ast$utils_ts$visitorKeys.get(
			node.type,
		);
		if (visitorKeys !== undefined) {
			// Build the ancestry paths that we'll pass to each child path
			const ancestryPaths = pathOpts.ancestryPaths || [];
			let childAncestryPaths = [path].concat(ancestryPaths);

			// Reduce the children
			for (const key of visitorKeys) {
				// rome-ignore lint/js/noExplicitAny
				const oldVal = (node)[key];

				if (Array.isArray(oldVal)) {
					let children = oldVal;

					// When removing items from the children array, we decrement this offset and subtract it
					// whenever looking up to get the correct position
					let childrenOffset = 0;

					// This needs to be calculated beforehand as the length of the array may change when removing
					// items
					let length = children.length;

					for (let i = 0; i < length; i++) {
						// Calculate the correct index that this children can be found at
						const correctedIndex = childrenOffset + i;

						// Get the child
						const child = children[correctedIndex];

						// An array may be mixed containing [undefined, Node] etc so check that it's actually a valid node
						// An example of a property with empty elements is an ArrayExpression with holes
						if (
							___R$project$rome$$romejs$js$ast$utils$isNodeLike_ts$default(
								child,
							)
						) {
							// Run transforms on this node
							const newChild = ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
								child,
								visitors,
								context,
								{
									noScopeCreation: pathOpts.noScopeCreation,
									parentScope: path.scope,
									ancestryPaths: childAncestryPaths,
									listKey: correctedIndex,
									nodeKey: key,
								},
							);

							// If this item has been changed then...
							if (newChild !== child && !context.frozen) {
								// Clone the children array
								children = children.slice();

								// Check if the item is to be deleted
								// REDUCE_REMOVE or an empty array are considered equivalent
								if (
									newChild ===
									___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE ||
									(Array.isArray(newChild) && newChild.length === 0)
								) {
									// Remove the item from the array
									children.splice(correctedIndex, 1);

									// Since the array now has one less item, change the offset so all
									// future indices will be correct
									childrenOffset--;
								} else if (Array.isArray(newChild)) {
									var ___R$;
									// Remove the previous, and add the new items to the array
									___R$ = children,
										___R$.splice.apply(___R$, [correctedIndex, 1, ...newChild]);

									// We increase the length of the array so that this loop covers
									// the newly inserted nodes
									// `childrenOffset` is not used here because that's just used to
									// skip elements
									length += newChild.length;

									// Revisit the current index, this is necessary as there's now a
									// new node at this position
									i--;
								} else {
									// Otherwise it's a valid node so set it
									children[correctedIndex] = newChild;

									// Revisit the current index, the node has changed and some
									// transforms may care about it
									i--;
								}

								// Mutate the original node - funky typing since Flow doesn't understand the mutation
								node = (Object.assign({}, node, {[key]: children}));

								// Create a new node path
								path = path.fork(node);

								// And create a new ancestry array for subsequent children
								childAncestryPaths = [path].concat(ancestryPaths);
							}
						}
					}
				} else if (
					___R$project$rome$$romejs$js$ast$utils$isNodeLike_ts$default(oldVal)
				) {
					// Run transforms on this node
					let newVal = ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
						oldVal,
						visitors,
						context,
						{
							noScopeCreation: pathOpts.noScopeCreation,
							parentScope: path.scope,
							ancestryPaths: childAncestryPaths,
							noArrays: true,
							nodeKey: key,
						},
					);

					// If this value has been changed then...
					if (newVal !== oldVal && !context.frozen) {
						// When replacing a key value, we cannot replace it with an array
						if (Array.isArray(newVal)) {
							throw new Error(
								"Cannot replace a key value node with an array of nodes",
							);
						}

						// If the node is deleted then use `void` instead
						if (
							newVal ===
							___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE
						) {
							newVal = undefined;
						}

						// Mutate the original object - funky typing since Flow doesn't understand the mutation
						node = (Object.assign({}, node, {[key]: newVal}));

						// Create a new node path for it
						path = path.fork(node);

						// And create a new ancestry array for subsequent children
						childAncestryPaths = [path].concat(ancestryPaths);
					}
				} else {
					// not sure what this is...
					continue;
				}
			}
		}

		// Run all exit hooks
		for (const ref of path.hooks) {
			const {exit} = ref.descriptor;
			if (exit === undefined) {
				// A hook exit method is optional
				continue;
			}

			const res = ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$runExit(
				path,
				ref.descriptor.name,
				exit,
				ref.state,
			);
			if (
				res[0] ===
				___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT
			) {
				return res[1];
			} else {
				path = res[1];
			}
		}

		// Run exit transforms
		for (const visitor of visitors) {
			if (visitor.exit !== undefined) {
				const res = ___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$runExit(
					path,
					visitor.name,
					visitor.exit,
					undefined,
				);
				if (
					res[0] ===
					___R$$priv$project$rome$$romejs$js$compiler$methods$reduce_ts$BAIL_EXIT
				) {
					return res[1];
				} else {
					path = res[1];
				}
			}
		}

		return path.node;
	}


  // project-rome/@romejs/js-compiler/suppressions.ts
const ___R$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START = "rome-ignore";





	function ___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromComment(
		context,
		comment,
		nodeToComment,
	) {
		const commentLocation = comment.loc;
		if (commentLocation === undefined) {
			return undefined;
		}

		const suppressedCategories = new Set();
		const diagnostics = [];
		const suppressions = [];

		const lines = comment.value.split("\n");
		const cleanLines = lines.map((line) => {
			// Trim line and remove leading star
			return line.trim().replace(/\*[\s]/, "");
		});

		for (const line of cleanLines) {
			if (
				!line.startsWith(
					___R$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START,
				)
			) {
				continue;
			}

			const nextNode = nodeToComment.get(comment);
			if (nextNode === undefined || nextNode.loc === undefined) {
				diagnostics.push({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SUPPRESSIONS.MISSING_TARGET,
					location: commentLocation,
				});
				continue;
			}

			const startLine = nextNode.loc.start.line;
			const endLine = nextNode.loc.end.line;

			const lineWithoutPrefix = line.slice(
				___R$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START.length,
			);
			if (lineWithoutPrefix[0] !== " ") {
				diagnostics.push({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SUPPRESSIONS.MISSING_SPACE,
					location: commentLocation,
				});
				continue;
			}

			const categories = lineWithoutPrefix.trim().split(" ");
			const cleanCategories = categories.map((category) => category.trim());

			for (let category of cleanCategories) {
				if (category === "") {
					continue;
				}

				// If a category ends with a colon then all the things that follow it are an explanation
				let shouldBreak = false;
				if (category[category.length - 1] === ":") {
					shouldBreak = true;
					category = category.slice(-1);
				}

				if (suppressedCategories.has(category)) {
					diagnostics.push({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SUPPRESSIONS.DUPLICATE(
							category,
						),
						location: commentLocation,
					});
				} else {
					suppressedCategories.add(category);

					suppressions.push({
						filename: context.filename,
						category,
						commentLocation,
						startLine,
						endLine,
					});
				}

				if (shouldBreak) {
					break;
				}
			}
		}

		if (suppressions.length === 0 && diagnostics.length === 0) {
			return undefined;
		} else {
			return {diagnostics, suppressions};
		}
	}

	function ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromProgram(
		context,
		ast,
	) {
		const {comments} = ast;

		let diagnostics = [];
		let suppressions = [];

		const nodeToComment = new Map();
		context.reduce(
			ast,
			{
				name: "extractSuppressions",
				enter(path) {
					const {node} = path;

					for (const comment of context.comments.getCommentsFromIds(
						node.leadingComments,
					)) {
						nodeToComment.set(comment, node);
					}

					return node;
				},
			},
			{
				noScopeCreation: true,
			},
		);

		for (const comment of comments) {
			const result = ___R$$priv$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromComment(
				context,
				comment,
				nodeToComment,
			);
			if (result !== undefined) {
				diagnostics = diagnostics.concat(result.diagnostics);
				suppressions = suppressions.concat(result.suppressions);
			}
		}

		return {suppressions, diagnostics};
	}

	function ___R$project$rome$$romejs$js$compiler$suppressions_ts$matchesSuppression(
		{filename, start, end},
		suppression,
	) {
		return (
			filename === suppression.filename &&
			start !== undefined &&
			end !== undefined &&
			start.line >= suppression.startLine &&
			end.line <= suppression.endLine
		);
	}


  // project-rome/@romejs/js-parser/CommentsConsumer.ts
class ___R$project$rome$$romejs$js$parser$CommentsConsumer_ts$default {
		constructor(seedComments = []) {
			this.idToComment = new Map();
			this.counter = seedComments.length;
			this.setComments(seedComments);
		}

		setComments(comments) {
			this.idToComment.clear();

			for (const comment of comments) {
				this.idToComment.set(comment.id, comment);
			}
		}

		getCommentsFromIds(ids) {
			if (ids === undefined) {
				return [];
			}

			const comments = [];

			for (const id of ids) {
				const comment = this.getCommentFromId(id);
				if (comment !== undefined) {
					comments.push(comment);
				}
			}

			return comments;
		}

		getIdsFromComments(comments) {
			return comments.map((comment) => comment.id);
		}

		getAllComments() {
			return Array.from(this.idToComment.values());
		}

		getCommentFromId(id) {
			return this.idToComment.get(id);
		}

		assertGetCommentFromId(id) {
			const comment = this.getCommentFromId(id);
			if (comment === undefined) {
				throw new Error("No comment found for id " + id);
			}
			return comment;
		}

		getNextId() {
			return String(this.counter++);
		}

		updateComment(comment) {
			this.idToComment.set(comment.id, comment);
		}

		removeComment(id) {
			this.idToComment.delete(id);
		}

		addComment(withoutId) {
			const withId = Object.assign({}, withoutId, {id: this.getNextId()});
			this.idToComment.set(withId.id, withId);
			return withId;
		}
	}


  // project-rome/@romejs/js-compiler/transforms/compile/transpile/classProperties.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
		node,
	) {
		for (const bodyNode of node.meta.body) {
			if (bodyNode.type === "ClassProperty") {
				return true;
			}
		}

		return false;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
		rest,
		body,
	) {
		return ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod.create({
			kind: "constructor",
			key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(
				___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
					"constructor",
				),
			),
			meta: ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta.create({

			}),
			head: ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.create({
				params: [],
				rest,
			}),
			body: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
				body,
			}),
		});
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
		expressions,
	) {
		return expressions.map((expr) => {
			return ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement.create({
				expression: expr,
			});
		});
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(
		node,
	) {
		return node.type === "CallExpression" && node.callee.type === "Super";
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$transformClass(
		node,
		scope,
		context,
	) {
		const bodyReplacements = [];
		const constructorAssignments = [];
		const className =
			node.id === undefined ? scope.generateUid("class") : node.id.name;

		let _constructor = undefined;
		const filteredClassBody = [];
		for (const bodyNode of node.meta.body) {
			if (bodyNode.type === "ClassMethod" && bodyNode.kind === "constructor") {
				_constructor = bodyNode;
				continue;
			}

			if (bodyNode.type === "ClassProperty") {
				if (bodyNode.value === undefined) {
					continue;
				}

				if (bodyNode.key.type === "ComputedPropertyKey") {
					if (bodyNode.meta.static === true) {
						bodyReplacements.push(
							___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`${className}[${bodyNode.key.value}] = ${bodyNode.value};`,
						);
					} else {
						constructorAssignments.push(
							___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`this[${bodyNode.key.value}] = ${bodyNode.value};`,
						);
					}
				} else {
					if (bodyNode.meta.static === true) {
						bodyReplacements.push(
							___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`${className}.${bodyNode.key.value} = ${bodyNode.value};`,
						);
					} else {
						constructorAssignments.push(
							___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`this.${bodyNode.key.value} = ${bodyNode.value};`,
						);
					}
				}
			} else {
				filteredClassBody.push(bodyNode);
			}
		}

		if (constructorAssignments.length) {
			if (node.meta.superClass !== undefined) {
				if (_constructor) {
					const visited = new Set();

					// find super() and insert assignments
					const reducedConstructor = context.reduce(
						_constructor,
						[
							{
								name: "classPropertiesInjector",
								enter(path) {
									const {node} = path;

									if (visited.has(node)) {
										return node;
									}

									if (
										___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(
											node,
										) &&
										path.parent.type !== "ExpressionStatement"
									) {
										visited.add(node);

										// TODO retain proper value of super()
										return ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.create({
											expressions: [node, ...constructorAssignments],
										});
									}

									if (
										node.type === "ExpressionStatement" &&
										___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$isSuperCall(
											node.expression,
										)
									) {
										visited.add(node);

										return ([
											node,
											...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
												constructorAssignments,
											),
										]);
									}

									return node;
								},
							},
						],
					);
					_constructor = ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(
						reducedConstructor,
					);
				} else {
					// create new constructor with a super() call and assignments
					_constructor = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
						___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(
							"args",
						),
						[
							___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`super(...args);`,
							...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
								constructorAssignments,
							),
						],
					);
				}
			} else {
				if (_constructor) {
					// add assignments to end of constructor
					_constructor = Object.assign(
						{},
						_constructor,
						{
							body: Object.assign(
								{},
								_constructor.body,
								{
									body: [
										...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
											constructorAssignments,
										),
										..._constructor.body.body,
									],
								},
							),
						},
					);
				} else {
					// create new constructor with just the assignments
					_constructor = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$createConstructor(
						undefined,
						___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$toExpressionStatements(
							constructorAssignments,
						),
					);
				}
			}
		}

		if (_constructor !== undefined) {
			filteredClassBody.unshift(_constructor);
		}

		const newClass = Object.assign(
			{},
			node,
			{
				id: node.id !== undefined && node.id.name === className
					? node.id
					: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
							name: className,
						}),
				meta: Object.assign({}, node.meta, {body: filteredClassBody}),
			},
		);

		return {
			newClass,
			className,
			declarations: bodyReplacements,
		};
	}
	const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$default = {
		name: "classProperties",
		enter(path) {
			const {node, scope, context} = path;

			// correctly replace an export class with the class node then append the declarations
			if (
				(node.type === "ExportLocalDeclaration" ||
				node.type === "ExportDefaultDeclaration") &&
				node.declaration !== undefined &&
				node.declaration.type === "ClassDeclaration" &&
				___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
					node.declaration,
				)
			) {
				const {newClass, declarations} = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$transformClass(
					node.declaration,
					scope,
					context,
				);
				return ([
					Object.assign({}, node, {declaration: newClass}),
					...declarations,
				]);
			}

			// turn a class expression into an IIFE that returns a class declaration
			if (
				node.type === "ClassExpression" &&
				___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
					node,
				)
			) {
				const className =
					node.id === undefined ? scope.generateUid("class") : node.id.name;

				return ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
					callee: ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression.create({
						head: ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.quick([]),
						body: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
							body: [
								Object.assign(
									{},
									node,
									{
										type: "ClassDeclaration",
										id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(
											className,
										),
									},
								),
								___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.create({
									argument: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
										className,
									),
								}),
							],
						}),
					}),
					arguments: [],
				});
			}

			if (
				node.type === "ClassDeclaration" &&
				___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$hasClassProps(
					node,
				)
			) {
				const {newClass, declarations} = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$transformClass(
					node,
					scope,
					context,
				);
				return ([newClass, ...declarations]);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/transpile/paramlessCatch.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$paramlessCatch_ts$default = {
		name: "paramlessCatch",
		enter(path) {
			const {node} = path;

			if (node.type === "CatchClause" && node.param === undefined) {
				return Object.assign(
					{},
					node,
					{
						param: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
							name: path.scope.generateUid(),
						}),
					},
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/transpile/optionalChaining.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$optionalChaining_ts$default = {
		name: "optionalChaining",
		enter(path) {
			const {node} = path;

			if (node.type === "MemberExpression" && node.property.optional) {
				// TODO assign `node.object` to a variable and use it as a reference
				if (node.property.type === "ComputedMemberProperty") {
					return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${node.object} == null ? undefined : ${node.object}[${node.property.value}]`;
				} else {
					return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${node.object} == null ? undefined : ${node.object}.${node.property.value}`;
				}
			}

			if (node.type === "OptionalCallExpression") {
				// TODO assign `node.callee` to a variable and use it as a reference
				return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${node.callee} == null ? undefined : ${___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
					callee: node.callee,
					arguments: node.arguments,
				})}`;
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/transpile/nullishCoalescing.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$nullishCoalescing_ts$default = {
		name: "nullishCoalescing",
		enter(path) {
			const {node} = path;

			if (node.type === "LogicalExpression" && node.operator === "??") {
				// TODO assign `node.left` to a variable and use it as a reference
				return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${node.left} == null ? ${node.right} : ${node.left}`;
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/defaultHooks/index.ts




	const ___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$bindingInjector = ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default({
		name: "bindingInjectorHook",
		initialState: {
			bindings: [],
		},
		call(path, state, opts = {}) {
			const name =
				opts.name === undefined ? path.scope.generateUid() : opts.name;

			const ref = ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
				name,
			);

			// lol
			const ass = ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.quick(
				name,
			);

			return {
				value: [ref, ass],
				state: {
					bindings: [...state.bindings, [name, opts.init]],
				},
			};
		},
		exit(path, state) {
			const {node} = path;

			if (node.type !== "BlockStatement" && node.type !== "Program") {
				throw new Error("Never should have been used as a provider");
			}

			const {bindings} = state;
			if (bindings.length === 0) {
				return node;
			}

			return Object.assign(
				{},
				node,
				{
					body: [
						___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
							___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
								kind: "var",
								declarations: bindings.map(([name, init]) => {
									return ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
										id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(
											name,
										),
										init,
									});
								}),
							}),
						),
						...node.body,
					],
				},
			);
		},
	});

	const ___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$variableInjectorVisitor = {
		name: "variableInjector",
		enter(path) {
			const {node} = path;

			if (node.type === "BlockStatement" || node.type === "Program") {
				path.provideHook(
					___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$bindingInjector,
				);
			}

			return node;
		},
	};





	const ___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$commentInjector = ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default({
		name: "commentInjectorHook",
		initialState: {
			comments: [],
		},
		call(path, state, comment) {
			let commentWithId;
			let comments = state.comments;

			const {id} = comment;
			if (id === undefined) {
				commentWithId = path.context.comments.addComment(comment);
			} else {
				// This comment already has an id so update it
				commentWithId = Object.assign({}, comment, {id});
				path.context.comments.updateComment(commentWithId);

				// Remove from existing comments
				comments = comments.filter((comment) => comment.id !== id);
			}

			return {
				value: commentWithId.id,
				state: {
					comments: [...comments, commentWithId],
				},
			};
		},
		exit(path, state) {
			const {node} = path;

			if (node.type !== "Program") {
				throw new Error("Never should have been used as a provider");
			}

			return Object.assign(
				{},
				node,
				{comments: [...node.comments, ...state.comments]},
			);
		},
	});

	const ___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$commentInjectorVisitor = {
		name: "commentInjector",
		enter(path) {
			const {node, context} = path;

			if (node.type === "CommentBlock" || node.type === "CommentLine") {
				context.comments.updateComment(node);
			}

			if (node.type === "Program") {
				context.comments.setComments(node.comments);
				return path.provideHook(
					___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$commentInjector,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/transpile/callSpread.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$callSpread_ts$default = {
		name: "callSpread",
		enter(path) {
			const {node} = path;

			if (node.type === "CallExpression") {
				let func = node.callee;

				// Impossible to transform a bare super call
				if (func.type === "Super") {
					return node;
				}

				let hasSpread = false;
				for (const arg of node.arguments) {
					if (arg.type === "SpreadElement") {
						hasSpread = true;
						break;
					}
				}
				if (hasSpread) {
					let prepend;

					let object;
					if (func.type === "MemberExpression") {
						const injection = path.callHook(
							___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$bindingInjector,
							{},
						);
						object = injection[0];

						prepend = ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.create({
							operator: "=",
							left: injection[1],
							right: func.object,
						});

						func = ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create({
							object,
							property: func.property,
						});
					} else {
						object = ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.create({

						});
					}

					let call = {
						type: "CallExpression",
						loc: node.loc,
						callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`${func}.apply`,
						arguments: [
							object,
							___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.create({
								elements: node.arguments,
							}),
						],
					};

					if (prepend === undefined) {
						return call;
					} else {
						return ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.create({
							expressions: [prepend, call],
						});
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/transpile/templateLiterals.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$templateLiterals_ts$default = {
		name: "templateLiterals",
		enter(path) {
			const {node, parent} = path;

			if (node.type === "TaggedTemplateExpression") {
				// TODO
			}

			if (
				node.type === "TemplateLiteral" &&
				parent.type !== "TaggedTemplateExpression"
			) {
				const nodes = [];
				const {expressions, quasis} = node;

				let index = 0;
				for (const elem of quasis) {
					if (elem.cooked) {
						nodes.push(
							___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
								value: elem.cooked,
							}),
						);
					}

					if (index < expressions.length) {
						const expr = expressions[index++];
						if (expr.type !== "StringLiteral" || expr.value !== "") {
							nodes.push(expr);
						}
					}
				}

				if (nodes.length === 1) {
					return nodes[0];
				}

				// Since `+` is left-to-right associative, nsure the first node is a string if first/second isn't
				if (
					nodes[0].type !== "StringLiteral" &&
					nodes[1].type !== "StringLiteral"
				) {
					nodes.unshift(
						___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(
							"",
						),
					);
				}

				// Build the final expression
				let root = nodes[0];
				for (let i = 1; i < nodes.length; i++) {
					root = ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression.create({
						operator: "+",
						left: root,
						right: nodes[i],
					});
				}
				return root;
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/transpile/objectSpread.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$hasSpreadProperty(
		props,
	) {
		for (const prop of props) {
			if (prop.type === "SpreadProperty") {
				return true;
			}
		}
		return false;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
		node,
	) {
		if (node === undefined) {
			return undefined;
		}

		switch (node.type) {
			case "VariableDeclarator":
				return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
					node.id,
				);

			case "VariableDeclarationStatement":
				return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
					node.declaration,
				);

			case "VariableDeclaration": {
				for (const declarator of node.declarations) {
					const rest = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
						declarator,
					);
					if (rest !== undefined) {
						return rest;
					}
				}
				return undefined;
			}

			case "BindingObjectPattern":
				return node.rest;
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$transformSpreadProperty(
		path,
		node,
	) {
		let props = [];
		const assignArgs = [];

		function pushProps() {
			if (props.length === 0 && assignArgs.length > 0) {
				return;
			}

			assignArgs.push(
				___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({
					properties: props,
				}),
			);

			props = [];
		}

		for (const prop of node.properties) {
			if (prop.type === "SpreadProperty") {
				pushProps();
				assignArgs.push(prop.argument);
			} else {
				props.push(prop);
			}
		}

		pushProps();

		return ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
			callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Object.assign`,
			arguments: assignArgs,
		});
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$transformRestProperty(
		path,
		node,
	) {
		const nodes = [];

		for (const declarator of node.declarations) {
			const restElem = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
				declarator,
			);

			if (
				restElem === undefined ||
				declarator.id.type !== "BindingObjectPattern"
			) {
				nodes.push(
					___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
						___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
							kind: node.kind,
							declarations: [declarator],
						}),
					),
				);
				continue;
			}

			const uid = path.scope.generateUid();

			// push on the initial declaration so we can reference it later
			nodes.push(
				___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
					___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
						kind: node.kind,
						declarations: [
							___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
								id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
									name: uid,
								}),
								init: declarator.init,
							}),
						],
					}),
				),
			);

			// fetch all the previous prop names
			const removeProps = [];
			for (const prop of declarator.id.properties) {
				if (prop.type === "BindingObjectPatternProperty") {
					if (
						prop.key.type === "ComputedPropertyKey" ||
						prop.key.value.type !== "Identifier"
					) {
						throw new Error("unimplemented");
					} else {
						removeProps.push(prop.key.value.name);
					}
				}
			}

			// clone the init to the rest element
			const restName = restElem.name;
			nodes.push(
				___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
					___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
						kind: node.kind,
						declarations: [
							___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
								id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(
									restName,
								),
								init: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Object.assign({}, ${uid})`,
							}),
						],
					}),
				),
			);

			// `delete` the properties
			for (const name of removeProps) {
				nodes.push(
					___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`delete ${restName}.${name};`,
				);
			}

			// push on the initial destructuring without the rest element
			nodes.push(
				___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
					___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
						kind: node.kind,
						declarations: [
							___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
								id: ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern.create({
									properties: declarator.id.properties,
									rest: undefined,
								}),
								init: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
									uid,
								),
							}),
						],
					}),
				),
			);
		}

		return nodes;
	}
	const ___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$default = {
		name: "objectSpread",
		enter(path) {
			const {node} = path;

			if (
				node.type === "VariableDeclarationStatement" &&
				___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$getRestProperty(
					node,
				) !== undefined
			) {
				return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$transformRestProperty(
					path,
					node.declaration,
				);
			}

			if (
				node.type === "ObjectExpression" &&
				___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$hasSpreadProperty(
					node.properties,
				)
			) {
				return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$transformSpreadProperty(
					path,
					node,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/validation/optimizeImports.ts
// TODO: Remove this. This contains React for the following reason:
	//   A user may write: import * as React from 'react';
	//   We will remove the namespace and have only the used specifiers
	//   But the JSX plugin inserts `React.createElement`. Oh no.
	const ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$IGNORED_NAMES = [
		"React",
		"react",
	];

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$getName(
		node,
	) {
		if (node.type !== "MemberExpression" && node.type !== "JSXMemberExpression") {
			return undefined;
		}

		const {property} = node;

		if (property.type === "ComputedMemberProperty") {
			if (property.value.type === "StringLiteral") {
				return property.value.value;
			}
		} else {
			if (
				___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(
					property,
				)
			) {
				return property.name;
			}
		}

		return undefined;
	}
	const ___R$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$default = {
		name: "optimizeImports",
		enter(path) {
			const {node} = path;

			if (node.type !== "Program") {
				return node;
			}

			// Check if we have any wildcard imports
			const wildcardImports = new Map();
			const wildcardImportNodeToLocal = new Map();
			for (const child of node.body) {
				if (
					child.type === "ImportDeclaration" &&
					!___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$IGNORED_NAMES.includes(
						child.source.value,
					) &&
					child.namespaceSpecifier !== undefined
				) {
					const specifier = child.namespaceSpecifier;
					wildcardImports.set(
						specifier.local.name.name,
						{
							binding: path.scope.getBindingAssert(specifier.local.name.name),
							names: new Set(),
							mappings: new Map(),
							references: new Set(),
						},
					);
					wildcardImportNodeToLocal.set(child, specifier.local.name.name);
				}
			}
			if (wildcardImports.size === 0) {
				return node;
			}

			// - Find all imported names from this namespace

			// - Remove the namespaces that have computed property access
			path.traverse(
				"optimizeImportsWildcardCollector",
				(path) => {
					const {node, parent} = path;
					if (node.type !== "ReferenceIdentifier") {
						return;
					}

					// Ensure we're referencing a wildcard import
					const wildcardInfo = wildcardImports.get(node.name);
					if (wildcardInfo === undefined) {
						return;
					}

					// Ensure that the binding hasn't been shadowed
					if (path.scope.getBinding(node.name) !== wildcardInfo.binding) {
						return;
					}

					const isComputed =
						parent.type === "MemberExpression" &&
						parent.object === node &&
						___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$getName(
							parent,
						) === undefined;
					const isUnboxed =
						parent.type !== "MemberExpression" &&
						parent.type !== "JSXMemberExpression";

					if (isComputed || isUnboxed) {
						// Deopt as we can't follow this
						wildcardImports.delete(node.name);
					} else {
						const name = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$getName(
							parent,
						);
						if (name === undefined) {
							throw new Error("Expected name");
						}
						wildcardInfo.names.add(name);
						wildcardInfo.references.add(parent);
					}
				},
			);
			if (wildcardImports.size === 0) {
				return node;
			}

			// Populate the `mappings` field with a uid
			for (const info of wildcardImports.values()) {
				for (const name of info.names) {
					info.mappings.set(name, path.scope.generateUid(name));
				}
			}

			return path.reduce({
				name: "optimizeImportWilcards",
				enter(path) {
					const {node} = path;

					// Replace all member expressions with their uids
					if (
						(node.type === "MemberExpression" ||
						node.type === "JSXMemberExpression") &&
						___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(
							node.object,
						)
					) {
						const wildcardInfo = wildcardImports.get(node.object.name);
						if (wildcardInfo !== undefined && wildcardInfo.references.has(node)) {
							const name = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$getName(
								node,
							);
							if (name === undefined) {
								throw new Error("Expected name");
							}

							const newName = wildcardInfo.mappings.get(name);
							if (newName === undefined) {
								throw new Error("Expected newName");
							}

							if (node.type === "JSXMemberExpression") {
								return ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.quick(
									newName,
								);
							} else {
								return ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
									newName,
								);
							}
						}
					}

					// Add new specifiers to wildcard import declarations
					if (
						node.type === "ImportDeclaration" &&
						wildcardImportNodeToLocal.has(node)
					) {
						const local = wildcardImportNodeToLocal.get(node);
						if (local === undefined) {
							throw new Error("Expected local");
						}

						const wildcardInfo = wildcardImports.get(local);
						if (wildcardInfo === undefined) {
							// We would have deopted earlier
							return node;
						}

						// Remove wildcard specifier
						let namedSpecifiers = [...(node.namedSpecifiers || [])];

						// Add on our new mappings
						for (const [imported, local] of wildcardInfo.mappings) {
							namedSpecifiers.push(
								___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier.create({
									imported: ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
										imported,
									),
									local: ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal.quick(
										___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.quick(
											local,
										),
									),
								}),
							);
						}

						return ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration.create(
							Object.assign(
								{},
								node,
								{namespaceSpecifier: undefined, namedSpecifiers},
							),
						);
					}

					return node;
				},
			});
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/validation/optimizeExports.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeExports_ts$default = {
		name: "optimizeExports",
		enter(path) {
			const {node} = path;

			// turn `import {a} from 'b'; export {a}`; to `export {a} from 'b';`';
			if (
				node.type === "ExportLocalDeclaration" &&
				node.exportKind === "value" &&
				node.declaration === undefined &&
				node.specifiers !== undefined
			) {
				const nodes = [];
				const specifiers = [];

				for (const specifier of node.specifiers) {
					if (specifier.type === "ExportLocalSpecifier") {
						const binding = path.scope.getBinding(specifier.local.name);
						if (
							binding !== undefined &&
							binding instanceof
							___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding &&
							binding.meta.type === "name"
						) {
							nodes.push(
								___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration.create({
									namedSpecifiers: [
										___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier.create({
											local: ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
												binding.meta.imported,
											),
											exported: specifier.exported,
											loc: specifier.loc,
										}),
									],
									source: ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(
										binding.meta.source,
									),
								}),
							);
						} else {
							specifiers.push(specifier);
						}
					} else {
						// TODO ???
						specifiers.push(specifier);
					}
				}

				if (specifiers.length === node.specifiers.length && nodes.length === 0) {
					return node;
				}

				if (specifiers.length !== 0) {
					nodes.push(
						___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.create({
							specifiers,
						}),
					);
				}

				return nodes;
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compile/jsx.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
		path,
	) {
		const {node} = path;

		if (node.type === "JSXReferenceIdentifier") {
			if (node.name === "this") {
				return ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts$thisExpression.create({

				});
			} else {
				return ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create(
					{
						name: node.name,
					},
					node,
				);
			}
		} else if (node.type === "JSXIdentifier") {
			return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(
				node.name,
			);
		} else if (node.type === "JSXMemberExpression") {
			let prop = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
				path.getChildPath("property"),
			);

			if (prop.type === "ReferenceIdentifier") {
				return ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create({
					object: ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
						path.getChildPath("object"),
					),
					property: ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.quick(
						___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
							prop.name,
						),
					),
				});
			} else {
				return ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create({
					object: ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
						path.getChildPath("object"),
					),
					property: ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.quick(
						prop,
					),
				});
			}
		} else {
			throw new Error(
				"Received a node of type " +
				node.type +
				", the only node types that should be in this position are JSXIdentifier and JSXMemberExpression",
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertAttributeValue(
		node,
	) {
		if (node.type === "JSXExpressionContainer") {
			return node.expression;
		} else {
			return node;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$extractName(
		node,
	) {
		if (node.type === "JSXNamespacedName") {
			throw new Error("JSX is not XML blah blah blah");
		} else {
			return ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.assert(
				node,
			).name;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertAttribute(
		node,
	) {
		let valueNode = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertAttributeValue(
			node.value ||
			___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.create({
				value: true,
			}),
		);
		if (
			valueNode.type === "StringLiteral" &&
			(!node.value || node.value.type !== "JSXExpressionContainer")
		) {
			valueNode = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
				value: valueNode.value.replace(/\n\s+/g, " "),
			});
		}

		const name = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$extractName(
			node.name,
		);

		if (
			___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(
				name,
			)
		) {
			const nameNode = ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.create({
				name,
				loc: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(node),
			});

			return ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create({
				key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(
					nameNode,
				),
				value: valueNode,
			});
		} else {
			return ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create({
				key: ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey.quick(
					___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(
						name,
					),
				),
				value: valueNode,
			});
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$pushProps(
		_props,
		objs,
	) {
		if (!_props.length) {
			return _props;
		}

		objs.push(
			___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({
				properties: _props,
			}),
		);
		return [];
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildOpeningElementAttributes(
		attribs,
	) {
		let _props = [];
		const objs = [];

		while (attribs.length > 0) {
			const prop = attribs.shift();

			if (prop.type === "JSXSpreadAttribute") {
				_props = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$pushProps(
					_props,
					objs,
				);
				objs.push(prop.argument);
			} else {
				_props.push(
					___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertAttribute(
						prop,
					),
				);
			}
		}

		___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$pushProps(
			_props,
			objs,
		);

		let ret;
		if (objs.length === 1) {
			// only one object
			ret = objs[0];
		} else {
			// looks like we have multiple objects
			if (objs[0].type !== "ObjectExpression") {
				objs.unshift(
					___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({
						properties: [],
					}),
				);
			}

			// spread it
			ret = ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
				callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Object.assign`,
				arguments: objs,
			});
		}

		return ret;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$cleanJSXElementLiteralChild(
		value,
	) {
		const lines = value.split(/\r\n|\n|\r/);

		let lastNonEmptyLine = 0;

		for (let i = 0; i < lines.length; i++) {
			if (lines[i].match(/[^ \t]/)) {
				lastNonEmptyLine = i;
			}
		}

		let str = "";

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];

			const isFirstLine = i === 0;
			const isLastLine = i === lines.length - 1;
			const isLastNonEmptyLine = i === lastNonEmptyLine;

			// replace rendered whitespace tabs with spaces
			let trimmedLine = line.replace(/\t/g, " ");

			// trim whitespace touching a newline
			if (!isFirstLine) {
				trimmedLine = trimmedLine.replace(/^[ ]+/, "");
			}

			// trim whitespace touching an endline
			if (!isLastLine) {
				trimmedLine = trimmedLine.replace(/[ ]+$/, "");
			}

			if (trimmedLine) {
				if (!isLastNonEmptyLine) {
					trimmedLine += " ";
				}

				str += trimmedLine;
			}
		}

		if (str !== "") {
			return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(
				str,
			);
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildChildren(
		children,
	) {
		const elems = [];

		for (let child of children) {
			if (child.type === "JSXText") {
				const node = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$cleanJSXElementLiteralChild(
					child.value,
				);
				if (node !== undefined) {
					elems.push(node);
				}
				continue;
			}

			if (child.type === "JSXExpressionContainer") {
				const {expression} = child;
				if (expression.type !== "JSXEmptyExpression") {
					elems.push(child.expression);
				}
				continue;
			}

			if (child.type === "JSXSpreadChild") {
				elems.push(
					___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement.quick(
						child.expression,
					),
				);
				continue;
			}

			elems.push(child);
		}

		return elems;
	}
	const ___R$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$default = {
		name: "jsx",
		enter(path) {
			const {node, context, parent} = path;

			if (___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement.is(node)) {
				let type = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$convertJSXIdentifier(
					path.getChildPath("name"),
				);

				if (
					___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.is(
						node.name,
					)
				) {
					// TODO better handle this
					context.addNodeDiagnostic(
						type,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.COMPILER.JSX_NOT_XML,
					);
				}

				let attribs;
				if (node.attributes.length > 0) {
					attribs = ___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildOpeningElementAttributes(
						node.attributes,
					);
				} else {
					attribs = ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.create({

					});
				}

				const call = ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
					callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`React.createElement`,
					arguments: [
						type,
						attribs,
						...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildChildren(
							node.children,
						),
					],
				});

				// If we're a JSX element child then we need to be wrapped
				if (
					___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement.is(
						parent,
					)
				) {
					return ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.create({
						expression: call,
					});
				} else {
					return call;
				}
			}

			if (node.type === "JSXFragment") {
				const type = ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`React.Fragment`;
				const attribs = ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`null`;
				return ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.create({
					callee: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`React.createElement`,
					arguments: [
						type,
						attribs,
						...___R$$priv$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$buildChildren(
							node.children,
						),
					],
				});
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/_utils.ts
function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(
		context,
	) {
		const opts = context.options.bundle;
		if (opts === undefined) {
			throw new Error("No bundle options found");
		}
		return opts;
	}

	function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(
		name,
		moduleId,
	) {
		return (
			___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
			"$priv$" +
			___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(
				moduleId,
			) +
			"$" +
			name
		);
	}

	function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(
		id,
	) {
		// TODO probably need more stuff in this
		return id.replace(/[\\\/@\-]/g, "$").replace(/[\-.]/g, "_");
	}

	function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
		name,
		moduleId,
		opts,
	) {
		const forwarded = opts.resolvedImports[moduleId + ":" + name];
		if (forwarded !== undefined) {
			moduleId = forwarded.id;
			name = forwarded.name;
		}

		return (
			___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
				___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(
					moduleId,
				),
			) +
			"$" +
			name
		);
	}

	function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
		moduleId,
	) {
		return (
			"" +
			___R$project$rome$$romejs$js$compiler$constants_ts$SCOPE_PRIVATE_PREFIX +
			___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$normalizeModuleId(
				moduleId,
			)
		);
	}

	function ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
		source,
		opts,
	) {
		return opts.relativeSourcesToModuleId[source];
	}


  // project-rome/@romejs/js-analysis/Graph.ts


	class ___R$project$rome$$romejs$js$analysis$Graph_ts$default {
		constructor() {
			this.nodes = [];
			this.nodesByValue = new Map();
		}

		addNode(value) {
			if (this.find(value)) {
				return;
			}

			const node = {lines: [], value};
			this.nodesByValue.set(value, node);
			this.nodes.push(node);
		}

		find(value) {
			return this.nodesByValue.get(value);
		}

		hasConnections(value) {
			const node = this.nodesByValue.get(value);
			return (
				node !== undefined && (node == null ? undefined : node.lines).length > 0
			);
		}

		addLine(startValue, endValue) {
			const startNode = this.find(startValue);
			const endNode = this.find(endValue);

			if (!startNode || !endNode) {
				throw new Error("Both nodes need to exist");
			}

			startNode.lines.push(endNode);
		}
	}


  // project-rome/@romejs/js-analysis/types/T.ts
let ___R$$priv$project$rome$$romejs$js$analysis$types$T_ts$counter = 0;





	class ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode) {
			this.human = undefined;
			this.scope = scope;

			const {hub} = scope;
			this.hub = hub;
			this.utils = hub.utils;
			this.evaluator = hub.evaluator;
			this.originEvaluator = scope.evaluator.evaluatingType;

			// setup graph
			this.graph = scope.evaluator.graph;
			this.graph.addNode(this);

			this.originNode = originNode;
			this.originLoc = originNode === undefined ? undefined : originNode.loc;
			this.id =
				String(process.pid) +
				":" +
				String(___R$$priv$project$rome$$romejs$js$analysis$types$T_ts$counter++);

			this.compatibilityCache = new Map();
		}

		getConstructor() {
			// @ts-ignore
			return this.constructor;
		}

		setHuman(human) {
			this.human = human;
		}

		shouldMatch(type) {
			this.hub.assertOpen();
			this.graph.addLine(this, type);
		}

		hasConnections() {
			return this.graph.hasConnections(this);
		}

		explodeUnion() {
			return [this];
		}

		compatibleWith(otherType) {
			return otherType instanceof this.constructor;
		}

		clone() {
			const idsToType = new Map();

			const addType = (type) => {
				const reduced = this.utils.reduce(type);
				idsToType.set(type.id, type);
				return reduced.id;
			};

			const data = this.serialize(addType);

			const getType = (id) => {
				if (typeof id !== "string") {
					throw new Error("Expected id to be a string");
				}

				const type = idsToType.get(id);
				if (type === undefined) {
					throw new Error("Expected type");
				}
				return type;
			};

			return this.getConstructor().hydrate(
				this.scope,
				this.originNode,
				data,
				getType,
			);
		}

		static hydrate(scope, originNode, data, getType) {
			throw new Error("Unimplemented " + this.type + ".hydrate");
		}

		serialize(addType) {
			throw new Error(
				"Unimplemented " + this.getConstructor().type + ".prototype.serialize",
			);
		}

		reduce() {
			return this;
		}

		humanize(builder) {
			const reduced = this.utils.reduce(this);
			if (reduced === this) {
				throw new Error("unimplemented");
			} else {
				return builder.humanize(reduced);
			}
		}

		inspect() {
			return this.utils.inspect(this);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$T_ts$default.type = "T";


  // project-rome/@romejs/js-analysis/types/UnknownT.ts
class ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return "unknown";
		}

		compatibleWith() {
			return false;
		}
	}
	___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default.type = "UnknownT";


  // project-rome/@romejs/js-analysis/types/OpenT.ts
class ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		humanize(builder) {
			const type = this.utils.reduce(this);
			if (type === this) {
				return "open";
			} else {
				return builder.humanize(type);
			}
		}

		reduce() {
			const node = this.graph.find(this);
			if (node === undefined) {
				return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(
					this.scope,
					this.originNode,
				);
			}

			const values = node.lines.map((line) => this.utils.reduce(line.value));
			return this.scope.createUnion(values, this.originNode);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default.type = "OpenT";


  // project-rome/@romejs/js-analysis/types/OpenIntrinsicT.ts
class ___R$project$rome$$romejs$js$analysis$types$OpenIntrinsicT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default {
		constructor(scope, originNode, name) {
			super(scope, originNode);
			this.name = name;
		}

		serialize() {
			return {
				name: this.name,
			};
		}

		static hydrate(scope, originNode, data) {
			return scope.intrinsics.get(String(data.name));
		}

		humanize() {
			return "open intrinsic";
		}
	}
	___R$project$rome$$romejs$js$analysis$types$OpenIntrinsicT_ts$default.type = "OpenIntrinsicT";


  // project-rome/@romejs/js-analysis/Intrinsics.ts
class ___R$project$rome$$romejs$js$analysis$Intrinsics_ts$default {
		constructor(scope) {
			this.scope = scope;

			this.intrinsicByName = new Map();

			this.NumberPrototype = this.createOpenT("NumberPrototype");
			this.Number = this.createOpenT("Number");

			this.StringPrototype = this.createOpenT("StringPrototype");
			this.String = this.createOpenT("String");

			this.ObjectPrototype = this.createOpenT("ObjectPrototype");
			this.Object = this.createOpenT("Object");

			this.ArrayPrototype = this.createOpenT("ArrayPrototype");
			this.Array = this.createOpenT("Array");

			this.RegExpPrototype = this.createOpenT("RegExpPrototype");
			this.RegExp = this.createOpenT("RegExp");
		}

		get(name) {
			const t = this.intrinsicByName.get(name);
			if (t === undefined) {
				throw new Error("No intrinsic found for " + name);
			}
			return t;
		}

		createOpenT(name) {
			const t = new ___R$project$rome$$romejs$js$analysis$types$OpenIntrinsicT_ts$default(
				this.scope,
				undefined,
				name,
			);
			this.intrinsicByName.set(name, t);
			return t;
		}

		link() {
			this.String.shouldMatch(this.scope.query(["String"]));
			this.StringPrototype.shouldMatch(
				this.scope.query(["String", "prototype"]),
			);

			this.Object.shouldMatch(this.scope.query(["Object"]));
			this.ObjectPrototype.shouldMatch(
				this.scope.query(["Object", "prototype"]),
			);

			this.Array.shouldMatch(this.scope.query(["Array"]));
			this.ArrayPrototype.shouldMatch(this.scope.query(["Array", "prototype"]));

			this.RegExp.shouldMatch(this.scope.query(["RegExp"]));
			this.RegExpPrototype.shouldMatch(
				this.scope.query(["RegExp", "prototype"]),
			);

			this.Number.shouldMatch(this.scope.query(["Number"]));
			this.NumberPrototype.shouldMatch(
				this.scope.query(["Number", "prototype"]),
			);
		}
	}


  // project-rome/@romejs/js-analysis/types/ObjPropT.ts
class ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, key, value) {
			super(scope, originNode);
			this.key = key;
			this.value = value;
		}

		serialize(addType) {
			return {
				key: this.key,
				value: addType(this.value),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(
				scope,
				originNode,
				String(data.key),
				getType(data.value),
			);
		}

		compatibleWith(otherType) {
			if (
				otherType instanceof
				___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default &&
				otherType.key === this.key
			) {
				return this.utils.checkCompability(this.value, otherType.value);
			} else {
				return false;
			}
		}

		humanize(builder) {
			return this.key + ": " + builder.humanize(this.value);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default.type = "ObjPropT";


  // project-rome/@romejs/js-analysis/types/ObjT.ts
class ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, opts) {
			super(scope, originNode);
			this.calls = opts.calls === undefined ? [] : opts.calls;
			this.props = opts.props === undefined ? [] : opts.props;
			this.proto = opts.proto;
		}

		serialize(addType) {
			if (
				this.constructor !==
				___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default
			) {
				throw new Error(
					"Expected ObjT to be constructor, youve likely forgot to define this method in the type subclass",
				);
			}

			return {
				calls: this.calls.map((type) => addType(type)),
				proto: this.proto === undefined ? undefined : addType(this.proto),
				props: this.props.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default(
				scope,
				originNode,
				{
					props: Array(data.props).map((id) => getType(id)),
					proto: data.proto === undefined ? undefined : getType(data.proto),
					calls: Array(data.calls).map((id) => getType(id)),
				},
			);
		}

		compatibleWith(otherType) {
			if (
				!(otherType instanceof
				___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default)
			) {
				return false;
			}

			const ourProps = this.props;
			const theirProps = otherType.props;

			// check that the other type has all of our props
			for (const ourPropRaw of ourProps) {
				// reduce and get the key of this prop
				const ourProp = this.utils.reduce(ourPropRaw);
				let key;
				if (
					ourProp instanceof
					___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default
				) {
					key = ourProp.key;
				} else {
					// should probably do something here
					continue;
				}

				// try and find a prop of the same key in the other object
				let theirProp;
				for (const theirPropRaw of theirProps) {
					const maybeTheirProp = this.utils.reduce(theirPropRaw);
					if (
						maybeTheirProp instanceof
						___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default &&
						maybeTheirProp.key === key
					) {
						theirProp = maybeTheirProp;
						break;
					}
				}

				if (!ourProp || !theirProp) {
					return false;
				}

				const compatibility = this.utils.checkCompability(ourProp, theirProp);
				if (compatibility.type === "incompatible") {
					return compatibility;
				}
			}

			return true;
		}

		humanize(builder) {
			if (this.props.length === 0) {
				return "{}";
			} else {
				return [
					"{",
					...this.props.map((prop) => {
						const val = builder.humanize(prop);
						let lines = val.split("\n");
						lines = lines.map((line) => "  " + line);
						return lines.join("\n") + ",";
					}),
					"}",
				].join("\n");
			}
		}
	}
	___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default.type = "ObjT";


  // project-rome/@romejs/js-analysis/types/StringLiteralT.ts
class ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, value) {
			super(
				scope,
				originNode,
				{
					props: [],
					proto: scope.intrinsics.StringPrototype,
					calls: [],
				},
			);
			this.value = value;
		}

		serialize() {
			return {value: this.value};
		}

		static hydrate(scope, originNode, data) {
			return new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
				scope,
				originNode,
				String(data.value),
			);
		}

		humanize() {
			let str = JSON.stringify(this.value);
			if (this.value.includes("'")) {
				return str;
			} else {
				return "'" + str.slice(1, -1) + "'";
			}
		}

		compatibleWith(type) {
			return (
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default &&
				type.value === this.value
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default.type = "StringLiteralT";


  // project-rome/@romejs/js-analysis/types/AnyT.ts
class ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(
				scope,
				originNode,
			);
		}

		compatibleWith() {
			return true;
		}

		humanize() {
			return "any";
		}
	}
	___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default.type = "AnyT";


  // project-rome/@romejs/js-analysis/types/errors/E.ts


	class ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return this.getError().description.message.value;
		}

		getError() {
			throw new Error("unimplemented");
		}

		compatibleWith() {
			return false;
		}
	}
	___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default.type = "E";


  // project-rome/@romejs/js-analysis/types/errors/UnknownPropE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$UnknownPropE_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, opts) {
			super(scope, originNode);
			this.thisKeys = opts.thisKeys;
			this.protoKeys = opts.protoKeys;
			this.allProps = [...this.thisKeys, ...this.protoKeys];
			this.key = opts.key;
			this.object = opts.object;
			this.property = opts.property;
		}

		sortProps(props) {
			if (props.length === 0) {
				return props;
			}

			const ratings = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
				this.key,
				props,
			);
			const sortedProps = ratings.map((prop) => prop.target);
			return sortedProps;
		}

		getError() {
			return {
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TYPE_CHECK.UNKNOWN_PROP(
					this.key,
					this.allProps,
				),
				lowerTarget: this.property,
				upperTarget: this.object,
			};
		}
	}
	___R$project$rome$$romejs$js$analysis$types$errors$UnknownPropE_ts$default.type = "UnknownPropE";


  // project-rome/@romejs/js-analysis/types/ObjIndexPropT.ts
class ___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, key, value) {
			super(scope, originNode);
			this.key = key;
			this.value = value;
		}

		serialize(addType) {
			return {
				key: addType(this.key),
				value: addType(this.value),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default(
				scope,
				originNode,
				getType(data.key),
				getType(data.value),
			);
		}

		humanize(builder) {
			return (
				"[" + builder.humanize(this.key) + "]: " + builder.humanize(this.value)
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default.type = "ObjIndexPropT";


  // project-rome/@romejs/js-analysis/types/GetPropT.ts
class ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, object, property) {
			super(scope, originNode);
			this.object = object;
			this.property = property;
		}

		serialize(addType) {
			return {
				object: addType(this.object),
				property: addType(this.property),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
				scope,
				originNode,
				getType(data.object),
				getType(data.property),
			);
		}

		lookup(object, property, opts = {}) {
			object = this.utils.reduce(object);
			property = this.utils.reduce(property);

			const thisKeys = new Set();

			//
			const protoKeys = opts.protoKeys === undefined ? [] : opts.protoKeys;
			const topObject = opts.topObject === undefined ? object : opts.topObject;

			// turn property into string key
			let key;
			if (
				property instanceof
				___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default
			) {
				key = property.value;
			}

			// look up on object
			if (
				key !== undefined &&
				object instanceof
				___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default
			) {
				//
				const indexers = [];
				for (const maybePropRaw of object.props) {
					const maybeProp = this.utils.reduce(maybePropRaw);
					if (
						maybeProp instanceof
						___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default
					) {
						if (maybeProp.key === key) {
							// TODO collate these in case there's multiple properties of this name
							return this.utils.reduce(maybeProp.value);
						} else {
							thisKeys.add(maybeProp.key);
						}
					} else if (
						maybeProp instanceof
						___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default
					) {
						indexers.push(maybeProp);
					}
				}

				//
				for (const indexer of indexers) {
					if (this.utils.isCompatibleWith(indexer.key, property)) {
						return this.utils.reduce(indexer.value);
					}
				}

				//
				if (object.proto) {
					return this.lookup(
						object.proto,
						property,
						{
							topObject,
							protoKeys: [...protoKeys, ...thisKeys],
						},
					);
				}
			}

			// property lookups on an `any` return `any`!
			if (
				object instanceof
				___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default ||
				object instanceof
				___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default
			) {
				return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(
					this.scope,
					this.originNode,
				);
			}

			//
			if (typeof key === "string") {
				return new ___R$project$rome$$romejs$js$analysis$types$errors$UnknownPropE_ts$default(
					this.scope,
					this.originNode,
					{
						object: topObject,
						property,
						key,
						thisKeys: Array.from(thisKeys),
						protoKeys,
					},
				);
			} else {
				return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(
					this.scope,
					this.originNode,
				);
			}
		}

		reduce() {
			return this.lookup(this.object, this.property);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default.type = "GetPropT";


  // project-rome/@romejs/js-analysis/types/UnionT.ts
class ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, types) {
			super(scope, originNode);
			this.types = [...new Set(types)];
		}

		serialize(addType) {
			return {
				types: this.types.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
				scope,
				originNode,
				Array(data.types).map((id) => getType(id)),
			);
		}

		reduce() {
			const uniqTypes = [];
			const types = this.explodeUnion();

			for (const type of types) {
				let foundMatch = false;
				for (const compareType of uniqTypes) {
					const isCompatible = this.utils.isCompatibleWith(compareType, type);
					if (isCompatible) {
						foundMatch = true;
						break;
					}
				}
				if (foundMatch === false) {
					uniqTypes.push(type);
				}
			}

			if (uniqTypes.length === types.length) {
				return this;
			} else if (uniqTypes.length === 1) {
				return uniqTypes[0];
			} else {
				return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
					this.scope,
					this.originNode,
					uniqTypes,
				);
			}
		}

		explodeUnion() {
			let types = [];
			const visited = new Set([this]);

			for (const type of this.types) {
				const reduced = this.utils.reduce(type);
				if (visited.has(reduced)) {
					continue;
				} else {
					visited.add(reduced);
				}

				types = types.concat(this.utils.explodeUnion(type));
			}

			return types;
		}

		compatibleWith(otherType) {
			const ourTypes = this.utils.explodeUnion(this);

			// fast path to check if a union contains a type
			if (ourTypes.includes(otherType)) {
				return true;
			}

			const otherTypes = this.utils.explodeUnion(otherType);
			const missing = [];

			for (const type of ourTypes) {
				let compatible = false;

				for (const otherType of otherTypes) {
					if (this.utils.isCompatibleWith(type, otherType)) {
						compatible = true;
					}
				}

				if (compatible === false) {
					missing.push(type);
				}
			}

			if (missing.length === 0) {
				return true;
			} else {
				// create custom error with the types that weren't in the opposing one
				//return new MissingUnionE(this.scope, otherType.originNode, otherType, this, missing);
				return false;
			}
		}

		humanize(builder) {
			return this.types.map((type) => builder.humanize(type)).join(" | ");
		}
	}
	___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default.type = "UnionT";


  // project-rome/@romejs/js-analysis/scopes.ts






	class ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope {
		constructor(opts) {
			let {evaluator, parentScope} = opts;
			if (evaluator === undefined && parentScope !== undefined) {
				evaluator = parentScope.evaluator;
			}

			if (evaluator === undefined) {
				throw new Error("No evaluator was passed or inferred");
			}

			this.intrinsics = evaluator.intrinsics;
			this.evaluator = evaluator;
			this.hub = evaluator.hub;
			this.parentScope = parentScope;

			this.bindings = new Map();
		}

		getBinding(name) {
			let scope = this;
			while (scope) {
				const binding = scope.bindings.get(name);
				if (binding) {
					return binding.type;
				}
				scope = scope.parentScope;
			}
			return undefined;
		}

		getBindingAssert(name) {
			const binding = this.getBinding(name);
			if (binding === undefined) {
				throw new Error("Expected binding " + name);
			}
			return binding;
		}

		query(paths) {
			let initial = this.getBinding(paths[0]);
			if (initial === undefined) {
				throw new Error(
					'Expected "' +
					paths[0] +
					'" binding, found ' +
					JSON.stringify(this.getBindingNames()) +
					" " +
					this.evaluator.filename,
				);
			}

			//invariant(initial !== undefined, `Expected "${paths[0]}" binding`);
			for (let i = 1; i < paths.length; i++) {
				initial = new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
					this,
					undefined,
					initial,
					new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
						this,
						undefined,
						paths[i],
					),
				);
			}

			return initial;
		}

		declareBinding(name, originNode) {
			if (name === undefined) {
				throw new Error("Expected name");
			}
			this.bindings.set(
				name,
				{
					type: new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
						this,
						originNode,
					),
					status: "declared",
				},
			);
		}

		addBinding(name, type) {
			if (name === undefined) {
				throw new Error("Expected name");
			}

			const existingBinding = this.bindings.get(name);
			if (existingBinding !== undefined && existingBinding.status === "declared") {
				if (
					!(existingBinding.type instanceof
					___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default)
				) {
					throw new Error("expected OpenT");
				}

				existingBinding.type.shouldMatch(type);
			}

			this.bindings.set(
				name,
				{
					type,
					status: "initialized",
				},
			);
		}

		getBindingNames() {
			const names = new Set(
				this.parentScope ? this.parentScope.getBindingNames() : [],
			);

			for (const [name] of this.bindings) {
				names.add(name);
			}

			return Array.from(names);
		}

		getOwnBindingNames() {
			return Array.from(this.bindings.keys());
		}

		createUnion(types, originNode) {
			if (types.length === 0) {
				return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(
					this,
					originNode,
				);
			} else if (types.length === 1) {
				return types[0];
			} else {
				return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
					this,
					originNode,
					types,
				);
			}
		}

		fork() {
			return new ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope({
				evaluator: this.evaluator,
				parentScope: this,
			});
		}

		find(klass) {
			const scope = this.findOptional(klass);
			if (scope === undefined) {
				throw new Error("Failed to find class");
			} else {
				return scope;
			}
		}

		findOptional(klass) {
			let scope = this;

			do {
				if (scope instanceof klass) {
					return scope;
				}

				scope = scope.parentScope;
			} while (scope !== undefined);

			return undefined;
		}

		refine() {
			return new ___R$project$rome$$romejs$js$analysis$scopes_ts$RefineScope({
				evaluator: this.evaluator,
				parentScope: this,
			});
		}

		evaluate(node) {
			return this.evaluator.evaluate(node, this);
		}
	}

	class ___R$project$rome$$romejs$js$analysis$scopes_ts$RefineScope
		extends ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope {}



	class ___R$project$rome$$romejs$js$analysis$scopes_ts$ClassScope
		extends ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope {
		constructor(opts, meta) {
			super(opts);
			this.meta = meta;
		}
	}

	class ___R$project$rome$$romejs$js$analysis$scopes_ts$ThisScope
		extends ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope {
		constructor(opts, context) {
			super(opts);
			this.context = context;
		}
	}



	class ___R$project$rome$$romejs$js$analysis$scopes_ts$FunctionScope
		extends ___R$project$rome$$romejs$js$analysis$scopes_ts$ThisScope {
		constructor(opts, meta) {
			super(opts, meta.thisContext);
			this.meta = meta;
		}
	}


  // project-rome/@romejs/js-analysis/types/errors/UnknownImportE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$UnknownImportE_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, opts) {
			super(scope, originNode);
			this.possibleNames = opts.possibleNames;
			this.importedName = opts.importedName;
			this.source = opts.source;
		}

		getError() {
			return {
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TYPE_CHECK.UNKNOWN_IMPORT(
					this.importedName,
					this.source,
					this.possibleNames,
				),
				lowerTarget: this,
			};
		}
	}
	___R$project$rome$$romejs$js$analysis$types$errors$UnknownImportE_ts$default.type = "UnknownImportE";


  // project-rome/@romejs/js-analysis/types/VoidT.ts
class ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return "void";
		}
	}
	___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default.type = "VoidT";


  // project-rome/@romejs/js-analysis/types/EmptyT.ts
class ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return "empty";
		}

		compatibleWith(otherType) {
			return (
				otherType instanceof
				___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default ||
				otherType instanceof
				___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default.type = "EmptyT";


  // project-rome/@romejs/js-analysis/types/BooleanLiteralT.ts
class ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, value) {
			super(scope, originNode);
			this.value = value;
		}

		serialize() {
			return {value: this.value};
		}

		static hydrate(scope, originNode, data) {
			return new ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default(
				scope,
				originNode,
				Boolean(data.value),
			);
		}

		humanize() {
			if (this.value === true) {
				return "true";
			} else {
				return "false";
			}
		}

		compatibleWith(type) {
			return (
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default &&
				type.value === this.value
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default.type = "BooleanLiteralT";


  // project-rome/@romejs/js-analysis/types/BooleanT.ts
class ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return "boolean";
		}

		compatibleWith(type) {
			// A boolean literal can flow into a generic boolean
			return (
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default ||
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default.type = "BooleanT";


  // project-rome/@romejs/js-analysis/types/errors/NotCallableE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$NotCallableE_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, callee) {
			super(scope, originNode);
			this.callee = callee;
		}

		getError() {
			return {
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TYPE_CHECK.NOT_CALLABLE,
				lowerTarget: this.callee,
			};
		}
	}
	___R$project$rome$$romejs$js$analysis$types$errors$NotCallableE_ts$default.type = "NotCallableE";


  // project-rome/@romejs/js-analysis/types/FunctionT.ts
class ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, opts) {
			super(
				scope,
				originNode,
				{
					props: opts.props,
					proto: opts.proto,
					calls: [],
				},
			);
			this.params = opts.params;
			this.rest = opts.rest;
			this.returns = opts.returns;
			this.body = opts.body;
		}

		serialize(addType) {
			return {
				params: this.params.map((type) => addType(type)),
				rest: this.rest ? addType(this.rest) : undefined,
				returns: addType(this.returns),
				proto: this.proto === undefined ? undefined : addType(this.proto),
				body: this.body === undefined ? undefined : addType(this.body),
				props: this.props.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default(
				scope,
				originNode,
				{
					params: Array(data.params).map((id) => getType(id)),
					rest: data.rest === undefined ? undefined : getType(data.rest),
					returns: getType(data.returns),
					props: Array(data.props).map((id) => getType(id)),
					proto: data.proto === undefined ? undefined : getType(data.proto),
					body: data.body === undefined ? undefined : getType(data.body),
				},
			);
		}

		humanize(builder) {
			return (
				"(" +
				this.params.map((param) => builder.humanize(param)).join(", ") +
				") => " +
				builder.humanize(this.returns)
			);
		}

		reduce() {
			// No body, just a type signature
			const {body} = this;
			if (body === undefined) {
				return this;
			}

			// Reduce the body and create a new function
			const reducedBody = this.utils.reduce(body);
			if (reducedBody !== body) {
				return new ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default(
					this.scope,
					this.originNode,
					{
						params: this.params,
						rest: this.rest,
						returns: this.returns,
						props: this.props,
						proto: this.proto,
						body: reducedBody,
					},
				);
			}

			// Already been reduced
			return this;
		}
	}
	___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default.type = "FunctionT";


  // project-rome/@romejs/js-analysis/types/CallT.ts
class ___R$project$rome$$romejs$js$analysis$types$CallT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, callee, args) {
			super(scope, originNode);
			this.callee = callee;
			this.args = args;
		}

		reduce() {
			let callee = this.utils.reduce(this.callee);
			if (
				callee instanceof
				___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default &&
				callee.calls.length
			) {
				callee = this.utils.reduce(callee.calls[0]);
			}

			if (
				callee instanceof
				___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default ||
				callee instanceof
				___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default
			) {
				return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(
					this.scope,
					this.originNode,
				);
			} else if (
				callee instanceof
				___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default
			) {
				return this.utils.reduce(callee.returns);
			} else {
				return new ___R$project$rome$$romejs$js$analysis$types$errors$NotCallableE_ts$default(
					this.scope,
					this.originNode,
					this.callee,
				);
			}
		}
	}
	___R$project$rome$$romejs$js$analysis$types$CallT_ts$default.type = "CallT";


  // project-rome/@romejs/js-analysis/types/ClassT.ts
class ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, opts) {
			// point `class.prototype.__proto__` to `superClass.prototype`
			let protoProp = undefined;
			if (opts.extends) {
				const originNode = opts.extends.originNode;
				protoProp = new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
					scope,
					originNode,
					opts.extends,
					new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
						scope,
						originNode,
						"prototype",
					),
				);
			}

			// create `class.prototype.constructor`
			const constructorOpen = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
				scope,
				undefined,
			);
			const constructorProp = new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(
				scope,
				undefined,
				"constructor",
				constructorOpen,
			);
			const instances = [...opts.instances, constructorProp];

			// create `class.prototype`
			const protoObj = new ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default(
				scope,
				originNode,
				{
					props: instances,
					proto: protoProp,
					calls: [],
				},
			);

			super(
				scope,
				originNode,
				{
					props: [
						...opts.statics,
						new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(
							scope,
							originNode,
							"prototype",
							protoObj,
						),
					],
					proto: opts.extends,
					calls: opts.calls === undefined ? [] : opts.calls,
				},
			);

			constructorOpen.shouldMatch(this);

			this._constructor = opts._constructor;
			this._statics = opts.statics;
			this._instances = opts.instances;
			this._extends = opts.extends;
		}

		serialize(addType) {
			return {
				constructor: this._constructor === undefined
					? undefined
					: addType(this._constructor),
				statics: this._statics.map((type) => addType(type)),
				instances: this._instances.map((type) => addType(type)),
				extends: this._extends === undefined
					? undefined
					: addType(this._extends),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default(
				scope,
				originNode,
				{
					_constructor: data.constructor === undefined
						? undefined
						: getType(data.constructor),
					statics: Array(data.statics).map((id) => getType(id)),
					instances: Array(data.instances).map((id) => getType(id)),
					extends: data.extends === undefined
						? undefined
						: getType(data.extends),
				},
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default.type = "ClassT";


  // project-rome/@romejs/js-analysis/types/IntersectionT.ts
class ___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, types) {
			super(scope, originNode);
			this.types = types;
		}

		serialize(addType) {
			return {
				types: this.types.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default(
				scope,
				originNode,
				Array(data.types).map((id) => getType(id)),
			);
		}

		compatibleWith(otherType) {
			for (const type of this.types) {
				const compatibility = this.utils.checkCompability(type, otherType);
				if (compatibility.type === "incompatible") {
					return compatibility;
				}
			}
			return true;
		}

		humanize(builder) {
			return this.types.map((type) => builder.humanize(type)).join(" & ");
		}
	}
	___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default.type = "IntersectionT";


  // project-rome/@romejs/js-analysis/types/NullT.ts
class ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return "null";
		}
	}
	___R$project$rome$$romejs$js$analysis$types$NullT_ts$default.type = "NullT";


  // project-rome/@romejs/js-analysis/types/MaybeT.ts
class ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, parent) {
			super(scope, originNode);
			this.parent = parent;
		}

		serialize(addType) {
			return {
				parent: addType(this.parent),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default(
				scope,
				originNode,
				getType(data.parent),
			);
		}

		humanize(builder) {
			return "?" + builder.humanize(this.parent);
		}

		explodeUnion() {
			return [
				new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(
					this.scope,
					this.originNode,
				),
				new ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default(
					this.scope,
					this.originNode,
				),
				...this.utils.explodeUnion(this.parent),
			];
		}

		compatibleWith(otherType) {
			if (
				otherType instanceof
				___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default
			) {
				return this.utils.checkCompability(this.parent, otherType.parent);
			} else {
				return (
					otherType instanceof
					___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default ||
					otherType instanceof
					___R$project$rome$$romejs$js$analysis$types$NullT_ts$default ||
					this.utils.checkCompability(this.parent, otherType)
				);
			}
		}
	}
	___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default.type = "MaybeT";


  // project-rome/@romejs/js-analysis/types/MixedT.ts
class ___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default(
				scope,
				originNode,
			);
		}

		compatibleWith() {
			return false;
		}

		humanize() {
			return "mixed";
		}
	}
	___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default.type = "MixedT";


  // project-rome/@romejs/js-analysis/types/NumericT.ts
class ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode) {
			super(
				scope,
				originNode,
				{
					props: [],
					proto: scope.intrinsics.NumberPrototype,
					calls: [],
				},
			);
		}

		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return "number";
		}

		compatibleWith(type) {
			// a numeric literal can flow into a generic number
			return (
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default ||
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default.type = "NumericT";


  // project-rome/@romejs/js-analysis/types/NumericLiteralT.ts
class ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, value) {
			super(
				scope,
				originNode,
				{
					props: [],
					proto: scope.intrinsics.NumberPrototype,
					calls: [],
				},
			);
			this.value = value;
		}

		serialize() {
			return {value: this.value};
		}

		static hydrate(scope, originNode, data) {
			return new ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default(
				scope,
				originNode,
				Number(data.value),
			);
		}

		humanize() {
			return String(this.value);
		}

		compatibleWith(type) {
			return (
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default ||
				(type instanceof
				___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default &&
				type.value === this.value)
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default.type = "NumericLiteralT";


  // project-rome/@romejs/js-analysis/types/ImportT.ts
class ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, opts) {
			super(scope, originNode);
			this.importedName = opts.importedName;
			this.relative =
				opts.relative === undefined ? scope.evaluator.filename : opts.relative;
			this.source = opts.source;
			this.absolute = undefined;
			this.resolvedType = undefined;
			scope.evaluator.addImport(
				this,
				{
					importedName: this.importedName,
					relative: this.relative,
					source: this.source,
				},
			);
		}

		setAbsolute(absolute) {
			this.absolute = absolute;
		}

		setResolvedType(resolvedType) {
			this.resolvedType = resolvedType;
		}

		serialize() {
			return {
				importedName: this.importedName,
				relative: this.relative,
				source: this.source,
			};
		}

		static hydrate(scope, originNode, data) {
			return new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
				scope,
				originNode,
				{
					importedName: String(data.importedName),
					source: String(data.source),
					relative: String(data.relative),
				},
			);
		}

		humanize(builder) {
			let object;
			if (this.resolvedType !== undefined) {
				object = builder.humanize(this.resolvedType);
			} else if (this.absolute === undefined) {
				object = '$Exports<"' + this.source + '", "' + this.relative + '">';
			} else {
				object = '$Exports<"' + this.absolute + '">';
			}

			if (this.importedName === undefined) {
				return object;
			} else {
				return object + "." + this.importedName;
			}
		}

		reduce() {
			if (this.resolvedType === undefined) {
				return this;
			} else {
				return this.resolvedType;
			}
		}
	}
	___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default.type = "ImportT";


  // project-rome/@romejs/js-analysis/types/StringT.ts
class ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode) {
			super(
				scope,
				originNode,
				{
					props: [],
					proto: scope.intrinsics.StringPrototype,
					calls: [],
				},
			);
		}

		serialize() {
			return {};
		}

		static hydrate(scope, originNode) {
			return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(
				scope,
				originNode,
			);
		}

		humanize() {
			return "string";
		}

		compatibleWith(type) {
			// a string literal can flow into a generic string
			return (
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$StringT_ts$default ||
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$StringT_ts$default.type = "StringT";


  // project-rome/@romejs/js-analysis/types/ExhaustiveT.ts
class ___R$$priv$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive
		extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, target, only, extraenous) {
			super(scope, originNode);
			this.target = target;
			this.only = only;
			this.extraenous = extraenous;
		}

		getError() {
			return {
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TYPE_CHECK.NOT_EXHAUSTIVE(
					this.utils.humanize(this.only),
					this.utils.humanize(this.target),
				),
				lowerTarget: this.target,
			};
		}
	}
	___R$$priv$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive.type = "ENotExhaustive";
	class ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, target, only) {
			super(scope, originNode);
			this.target = target;
			this.only = only;
		}

		serialize(addType) {
			return {
				target: addType(this.target),
				only: addType(this.only),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(
				scope,
				originNode,
				getType(data.target),
				getType(data.only),
			);
		}

		reduce() {
			const target = this.utils.reduce(this.target);
			const only = this.utils.reduce(this.only);
			if (
				target instanceof
				___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default ||
				only instanceof
				___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default
			) {
				return this.only;
			}

			const targetCandidates = this.utils.explodeUnion(target);
			const onlyCandidates = this.utils.explodeUnion(only);

			const extraneous = [];
			for (const possible of targetCandidates) {
				let compatible = false;

				for (const otherType of onlyCandidates) {
					if (this.utils.isCompatibleWith(possible, otherType)) {
						compatible = true;
					}
				}

				if (compatible === false) {
					extraneous.push(possible);
				}
			}

			if (extraneous.length === 0) {
				return target;
			} else {
				return new ___R$$priv$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$ENotExhaustive(
					this.scope,
					this.originNode,
					this.target,
					this.only,
					extraneous,
				);
			}
		}

		humanize(builder) {
			return (
				"exhaustive " +
				builder.humanize(this.target) +
				" should only match " +
				builder.humanize(this.target)
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default.type = "ExhaustiveT";


  // project-rome/@romejs/js-analysis/types/InstanceT.ts
class ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default {
		constructor(scope, originNode, target, typeParameters) {
			const prototype = new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
				scope,
				originNode,
				target,
				new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
					scope,
					originNode,
					"prototype",
				),
			);
			super(
				scope,
				originNode,
				{
					props: [],
					proto: prototype,
					calls: [],
				},
			);

			this.typeParameters = typeParameters;
			this.target = target;
		}

		serialize(addType) {
			return {
				target: addType(this.target),
				params: this.typeParameters.map((type) => addType(type)),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(
				scope,
				originNode,
				getType(data.target),
				Array(data.params).map((id) => getType(id)),
			);
		}

		humanize(builder) {
			const name = builder.humanize(this.target);
			const typeParams = this.typeParameters;
			if (typeParams.length === 0) {
				return name;
			} else {
				return (
					name +
					"<" +
					typeParams.map((param) => builder.humanize(param)).join(", ") +
					">"
				);
			}
		}

		compatibleWith(otherType) {
			return (
				otherType instanceof
				___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default &&
				this.utils.checkCompability(this.target, otherType.target)
			);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default.type = "InstanceT";


  // project-rome/@romejs/js-analysis/types/GenericT.ts
class ___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, name, type) {
			super(scope, originNode);
			this.name = name;
			this.type = type;
		}

		serialize(addType) {
			return {
				name: this.name,
				type: addType(this.type),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default(
				scope,
				originNode,
				String(data.name),
				getType(data.type),
			);
		}

		humanize() {
			return this.name;
		}

		reduce() {
			const type = this.utils.reduce(this.type);
			if (
				type instanceof
				___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default
			) {
				return new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(
					this.scope,
					this.originNode,
					this.type,
					[],
				);
			} else {
				return type;
			}
		}
	}
	___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default.type = "GenericT";


  // project-rome/@romejs/js-analysis/types/BinaryOpT.ts
function ___R$$priv$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$isNumber(
		t,
	) {
		return (
			t instanceof
			___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default ||
			t instanceof
			___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default
		);
	}

	class ___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, left, operator, right) {
			super(scope, originNode);
			this.operator = operator;
			this.left = left;
			this.right = right;
		}

		serialize(addType) {
			return {
				left: addType(this.left),
				right: addType(this.right),
			};
		}

		static hydrate(scope, originNode, data, getType) {
			return new ___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default(
				scope,
				originNode,
				getType(data.left),
				String(data.operator),
				getType(data.right),
			);
		}

		reduce() {
			const left = this.utils.reduce(this.left);
			const right = this.utils.reduce(this.right);
			const {scope, originNode, operator} = this;

			// return type
			switch (operator) {
				case // returns booleans
				"===":
				case "==":
				case "!=":
				case "!==":
				case "<":
				case "<=":
				case ">":
				case ">=":
				case "in":
				case "instanceof":
					// TODO return BooleanLiteralT in the cases whe we have all the info
					return new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(
						scope,
						originNode,
					);

				// Returns a string or a number
				case "+":
					if (
						left instanceof
						___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default ||
						right instanceof
						___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default
					) {
						return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(
							scope,
							originNode,
						);
					} else if (
						left instanceof
						___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default &&
						right instanceof
						___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default
					) {
						return new ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default(
							scope,
							originNode,
							left.value + right.value,
						);
					} else if (
						___R$$priv$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$isNumber(
							left,
						) &&
						___R$$priv$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$isNumber(
							right,
						)
					) {
						return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(
							scope,
							originNode,
						);
					} else if (
						left instanceof
						___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default &&
						right instanceof
						___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default
					) {
						return new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
							scope,
							originNode,
							left.value + right.value,
						);
					} else {
						return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(
							scope,
							originNode,
						);
					}

				// returns a number
				case "<<":
				case ">>":
				case ">>>":
				case "-":
				case "*":
				case "/":
				case "%":
				case "**":
				case "|":
				case "^":
				case "&":
					// TODO return NumericLiteralT if left/right are literals too
					return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(
						scope,
						originNode,
					);

				default:
					throw new Error("Unknown operator");
			}
		}
	}
	___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default.type = "BinaryOpT";


  // project-rome/@romejs/js-analysis/types/errors/MissingUnionE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$MissingUnionE_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, target, union, missing) {
			super(scope, originNode);
			this.target = target;
			this.union = union;
			this.missing = missing;
		}

		getError() {
			return {
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TYPE_CHECK.MISSING_CONDITION(
					this.missing.map((type) => this.utils.humanize(type)),
				),
				lowerTarget: this.target,
			};
		}
	}
	___R$project$rome$$romejs$js$analysis$types$errors$MissingUnionE_ts$default.type = "MissingUnionE";


  // project-rome/@romejs/js-analysis/types/RefinedT.ts
class ___R$project$rome$$romejs$js$analysis$types$RefinedT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, root, remove) {
			super(scope, originNode);
			this.root = root;
			this.remove = remove;
		}

		reduce() {
			const {root} = this;

			const exploded = this.utils.explodeUnion(root);
			const removeTypes = this.utils.explodeUnion(this.remove);

			const clean = [];
			const removed = [];

			// remove any possible derived types from the root that are compatible with the removed type
			for (const type of exploded) {
				let compatible = false;

				// check if any of the removed types are compatible, if every removed type is incompatible then

				// we've refined away the type
				for (const remove of removeTypes) {
					if (this.utils.isCompatibleWith(type, remove)) {
						compatible = true;
					}
				}

				if (compatible === false) {
					clean.push(type);
				} else {
					removed.push(type);
				}
			}

			if (removed.length === 0) {
				// return an error here because the removed type doesn't exist in the root
				return new ___R$project$rome$$romejs$js$analysis$types$errors$MissingUnionE_ts$default(
					root.scope,
					root.originNode,
					root,
					this.remove,
					removed,
				);
			} else {
				return root.scope.createUnion(clean, root.originNode);
			}
		}
	}
	___R$project$rome$$romejs$js$analysis$types$RefinedT_ts$default.type = "RefinedT";


  // project-rome/@romejs/js-analysis/types/RefineTypeofT.ts
class ___R$project$rome$$romejs$js$analysis$types$RefineTypeofT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, node, str, fallback) {
			super(scope, node);
			this.str = str;
			this.fallback = fallback;
		}

		reduce() {
			const {fallback, utils} = this;
			const str = utils.reduce(this.str);

			if (
				str instanceof
				___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default
			) {
				let val;

				switch (str.value) {
					case "string": {
						val = new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(
							this.scope,
							undefined,
						);
						break;
					}

					case "number": {
						val = new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(
							this.scope,
							undefined,
						);
						break;
					}

					case "undefined": {
						val = new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(
							this.scope,
							undefined,
						);
						break;
					}

					case "boolean": {
						val = new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(
							this.scope,
							undefined,
						);
						break;
					}

					case "symbol":
					case "function":
					case "object":
						// TODO
						return utils.reduce(fallback);

					default:
						// TODO complain about unknown value
						return utils.reduce(fallback);
				}

				// make sure our refinement is actually possible and matches a value in `fallback`

				// then pluck the matching type
				const types = utils.explodeUnion(fallback);
				for (const type of types) {
					if (utils.isCompatibleWith(type, val)) {
						return utils.reduce(type);
					}
				}

				// TODO complain of a missing condition
				return utils.reduce(fallback);
			}

			return utils.reduce(fallback);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$RefineTypeofT_ts$default.type = "RefineTypeofT";


  // project-rome/@romejs/js-analysis/types/TypeofT.ts
class ___R$project$rome$$romejs$js$analysis$types$TypeofT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, node, obj) {
			super(scope, node);
			this.obj = obj;
		}

		reduce() {
			const types = this.utils.explodeUnion(this.obj);

			const possibleTypes = [];
			for (const rawType of types) {
				const type = this.utils.reduce(rawType);
				let typeStr;

				if (
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$StringT_ts$default ||
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default
				) {
					typeStr = "string";
				}

				if (
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default ||
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default
				) {
					typeStr = "number";
				}

				if (
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default ||
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default
				) {
					typeStr = "boolean";
				}

				if (
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default
				) {
					typeStr = "undefined";
				}

				if (
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default
				) {
					if (type.calls.length === 0) {
						typeStr = "object";
					} else {
						typeStr = "function";
					}
				}

				if (
					type instanceof
					___R$project$rome$$romejs$js$analysis$types$NullT_ts$default
				) {
					typeStr = "object";
				}

				// TODO symbol

				// TODO bigint
				if (typeStr !== undefined) {
					possibleTypes.push(
						new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
							this.scope,
							this.originNode,
							typeStr,
						),
					);
				}
			}

			if (possibleTypes.length === 0) {
				return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(
					this.scope,
					this.originNode,
				);
			} else {
				return this.scope.createUnion(possibleTypes, this.originNode);
			}
		}
	}
	___R$project$rome$$romejs$js$analysis$types$TypeofT_ts$default.type = "TypeofT";


  // project-rome/@romejs/js-analysis/types/SideEffectT.ts
class ___R$project$rome$$romejs$js$analysis$types$SideEffectT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, actualType) {
			super(scope, originNode);
			this.actualType = actualType;
		}

		reduce() {
			return this.utils.reduce(this.actualType);
		}
	}
	___R$project$rome$$romejs$js$analysis$types$SideEffectT_ts$default.type = "SideEffectT";


  // project-rome/@romejs/js-analysis/types/BlockT.ts
class ___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$T_ts$default {
		constructor(scope, originNode, body) {
			super(scope, originNode);
			this.body = body;
		}

		reduce() {
			const body = [];
			let changed = false;

			for (const type of this.body) {
				const reduced = this.utils.reduce(type);
				body.push(reduced);
				if (reduced !== type) {
					changed = true;
				}
			}

			if (changed) {
				return new ___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default(
					this.scope,
					this.originNode,
					body,
				);
			} else {
				return this;
			}
		}

		humanize() {
			return "{}";
		}
	}
	___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default.type = "BlockT";


  // project-rome/@romejs/js-analysis/types/errors/UndeclaredVarE.ts
class ___R$project$rome$$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default
		extends ___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default {
		constructor(scope, originNode, name) {
			super(scope, originNode);
			this.name = name;
		}

		getError() {
			const possibleNames = this.scope.getBindingNames();
			return {
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TYPE_CHECK.UNDECLARED_VARIABLE(
					this.name,
					possibleNames,
				),
				lowerTarget: this,
			};
		}
	}
	___R$project$rome$$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default.type = "UndeclaredVarE";


  // project-rome/@romejs/js-analysis/types/index.ts
const ___R$project$rome$$romejs$js$analysis$types$index_ts = {
		get default() {
			return ___R$project$rome$$romejs$js$analysis$types$index_ts$default;
		},
	};
	const ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types = new Map();
	const ___R$project$rome$$romejs$js$analysis$types$index_ts$default = ___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types;
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"AnyT",
		___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"BooleanLiteralT",
		___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"BooleanT",
		___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"CallT",
		___R$project$rome$$romejs$js$analysis$types$CallT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"ClassT",
		___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"EmptyT",
		___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"FunctionT",
		___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"GetPropT",
		___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"IntersectionT",
		___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"MaybeT",
		___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"MixedT",
		___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"NullT",
		___R$project$rome$$romejs$js$analysis$types$NullT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"NumericLiteralT",
		___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"NumericT",
		___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"ObjPropT",
		___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"ObjT",
		___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"OpenIntrinsicT",
		___R$project$rome$$romejs$js$analysis$types$OpenIntrinsicT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"ImportT",
		___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"OpenT",
		___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"StringLiteralT",
		___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"StringT",
		___R$project$rome$$romejs$js$analysis$types$StringT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"UnionT",
		___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"UnknownT",
		___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"VoidT",
		___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"ExhaustiveT",
		___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"InstanceT",
		___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"GenericT",
		___R$project$rome$$romejs$js$analysis$types$GenericT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"ObjIndexPropT",
		___R$project$rome$$romejs$js$analysis$types$ObjIndexPropT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"BinaryOpT",
		___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"RefinedT",
		___R$project$rome$$romejs$js$analysis$types$RefinedT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"RefineTypeofT",
		___R$project$rome$$romejs$js$analysis$types$RefineTypeofT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"TypeofT",
		___R$project$rome$$romejs$js$analysis$types$TypeofT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"SideEffectT",
		___R$project$rome$$romejs$js$analysis$types$SideEffectT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"BlockT",
		___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"E",
		___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"NotCallableE",
		___R$project$rome$$romejs$js$analysis$types$errors$NotCallableE_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"UndeclaredVarE",
		___R$project$rome$$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"UnknownPropE",
		___R$project$rome$$romejs$js$analysis$types$errors$UnknownPropE_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"UnknownImportE",
		___R$project$rome$$romejs$js$analysis$types$errors$UnknownImportE_ts$default,
	);
	___R$$priv$project$rome$$romejs$js$analysis$types$index_ts$types.set(
		"MissingUnionE",
		___R$project$rome$$romejs$js$analysis$types$errors$MissingUnionE_ts$default,
	);


  // project-rome/@romejs/js-analysis/evaluators/temp/AmbiguousFlowTypeCastExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$temp$AmbiguousFlowTypeCastExpression_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$temp$AmbiguousFlowTypeCastExpression_ts$ambiguousFlowTypeCastExpression.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/ArrayExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ArrayExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.assert(
			node,
		);
		const elems = [];

		for (const expr of node.elements) {
			if (expr === undefined) {
				// TODO array hole, add undefined here
			} else {
				elems.push(scope.evaluate(expr));
			}
		}

		let value;
		if (elems.length === 0) {
			value = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
				scope,
				node,
			);
		} else {
			value = scope.createUnion(elems, node);
		}
		return new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(
			scope,
			node,
			scope.intrinsics.Array,
			[value],
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/ArrayHole.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$ArrayHole_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$ArrayHole_ts$arrayHole.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/utils/executeAtom.ts
function ___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(
		leftNode,
		rightType,
		scope,
	) {
		switch (leftNode.type) {
			case "BindingIdentifier": {
				scope.addBinding(leftNode.name, rightType);
				break;
			}

			case "BindingObjectPattern": {
				for (const prop of leftNode.properties) {
					___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(
						prop,
						rightType,
						scope,
					);
				}
				break;
			}

			case "BindingObjectPatternProperty": {
				const {key} = leftNode;
				if (
					key.type === "ComputedPropertyKey" ||
					key.value.type !== "Identifier"
				) {
					throw new Error("unimplemented");
				}

				const propKey = new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
					scope,
					key,
					key.value.name,
				);
				const getProp = new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
					scope,
					leftNode,
					rightType,
					propKey,
				);
				___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(
					leftNode.value,
					getProp,
					scope,
				);
				break;
			}

			case "BindingArrayPattern": {
				for (let i = 0; i < leftNode.elements.length; i++) {
					const elem = leftNode.elements[i];
					if (elem === undefined) {
						continue;
					}

					const propKey = new ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default(
						scope,
						elem,
						i,
					);
					const getProp = new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
						scope,
						leftNode,
						rightType,
						propKey,
					);
					___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(
						elem,
						getProp,
						scope,
					);
				}
				break;
			}

			case "BindingAssignmentPattern": {
				___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(
					leftNode.left,
					rightType,
					scope,
				);
				break;
			}
		}
	}


  // project-rome/@romejs/js-analysis/utils/executeFunction.ts
function ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(
		node,
		scope,
		bindId,
		thisContext,
	) {
		const {head} = node;

		// build return type
		const returns = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
			scope,
			head.returnType ? head.returnType : node,
		);

		// type check the body
		const bodyScope = new ___R$project$rome$$romejs$js$analysis$scopes_ts$FunctionScope(
			{
				parentScope: scope,
			},
			{
				thisContext: thisContext
					? thisContext
					: new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(
							scope,
							undefined,
						),
				returnType: returns,
			},
		);
		if (head.typeParameters) {
			bodyScope.evaluate(head.typeParameters);
		}

		// build param types
		const params = [];
		let rest;
		for (let paramNode of head.params) {
			let optional =
				paramNode.meta !== undefined && paramNode.meta.optional === true;
			if (paramNode.type === "BindingAssignmentPattern") {
				optional = false;
				paramNode = paramNode.left;
			}

			let paramType;
			if (
				paramNode.meta !== undefined &&
				paramNode.meta.typeAnnotation !== undefined
			) {
				paramType = scope.evaluate(paramNode.meta.typeAnnotation);
			} else {
				paramType = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
					scope,
					paramNode,
				);
			}

			if (optional) {
				paramType = new ___R$project$rome$$romejs$js$analysis$types$MaybeT_ts$default(
					scope,
					paramNode,
					paramType,
				);
			}

			params.push(paramType);
		}

		for (let i = 0; i < head.params.length; i++) {
			___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(
				head.params[i],
				params[i],
				scope,
			);
		}
		const block = bodyScope.evaluate(node.body);

		// if no types have flowed into the return type then it'll return undefined
		if (returns.hasConnections() === false) {
			//const ret = new VoidT(scope, node);
			//returns.shouldMatch(ret);
		}

		if (head.returnType) {
			returns.shouldMatch(scope.evaluate(head.returnType));
		}

		// create the function
		const func = new ___R$project$rome$$romejs$js$analysis$types$FunctionT_ts$default(
			scope,
			node,
			{params, rest, returns, body: block},
		);
		return func;
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/ArrowFunctionExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ArrowFunctionExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$ArrowFunctionExpression_ts$arrowFunctionExpression.assert(
			node,
		);

		let thisContext;
		const funcScope = scope.findOptional(
			___R$project$rome$$romejs$js$analysis$scopes_ts$FunctionScope,
		);
		if (funcScope !== undefined) {
			thisContext = funcScope.meta.thisContext;
		}

		return ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(
			node,
			scope,
			true,
			thisContext,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentArrayPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentArrayPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentArrayPattern_ts$assignmentArrayPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentAssignmentPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentAssignmentPattern_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentAssignmentPattern_ts$assignmentAssignmentPattern.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/AssignmentExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$AssignmentExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.assert(
			node,
		);

		const {left, right, operator} = node;

		if (operator === "=") {
			const rightType = scope.evaluate(right);
			const leftType = scope.evaluate(left);
			leftType.shouldMatch(rightType);
			return new ___R$project$rome$$romejs$js$analysis$types$SideEffectT_ts$default(
				scope,
				node,
				rightType,
			);
		} else {
			// TODO!
			return undefined;
		}
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentObjectPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentObjectPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPattern_ts$assignmentObjectPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/AssignmentObjectPatternProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentObjectPatternProperty_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$AssignmentObjectPatternProperty_ts$assignmentObjectPatternProperty.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/AwaitExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$AwaitExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$AwaitExpression_ts$awaitExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/literals/BigIntLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$BigIntLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$literals$BigIntLiteral_ts$bigIntLiteral.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/BinaryExpression.ts
function ___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(
		node,
		left,
		right,
		scope,
	) {
		const evaluator = scope.evaluator;

		if (left.type === "Identifier") {
			scope.addBinding(left.name, evaluator.getTypeFromEvaluatedNode(right));
			return true;
		}

		if (
			left.type === "UnaryExpression" &&
			left.operator === "typeof" &&
			left.argument.type === "ReferenceIdentifier"
		) {
			const name = left.argument.name;
			const binding = scope.getBinding(name);
			if (binding !== undefined) {
				const type = new ___R$project$rome$$romejs$js$analysis$types$RefineTypeofT_ts$default(
					scope,
					node,
					evaluator.getTypeFromEvaluatedNode(right),
					binding,
				);
				scope.addBinding(name, type);
				return true;
			}
		}

		return false;
	}

	function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$BinaryExpression_ts$binaryExpression.assert(
			node,
		);

		const left = scope.evaluate(node.left);
		const right = scope.evaluate(node.right);

		// Enforce that the left and right sides of these operators are numbers
		switch (node.operator) {
			case "<<":
			case ">>":
			case ">>>":
			case "-":
			case "*":
			case "/":
			case "%":
			case "**":
			case "|":
			case "^":
			case "&":
			case "<":
			case "<=":
			case ">":
			case ">=": {
				const num = new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(
					scope,
					undefined,
				);
				new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(
					scope,
					node,
					left,
					num,
				);
				new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(
					scope,
					node,
					right,
					num,
				);
				break;
			}
		}

		// Refinements
		let refinedScope = scope;
		if (node.operator === "===") {
			refinedScope = scope.refine();
			___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(
				node,
				node.left,
				node.right,
				refinedScope,
			) ||
			___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$maybeRefine(
				node,
				node.right,
				node.left,
				refinedScope,
			);
		}

		return new ___R$project$rome$$romejs$js$analysis$types$BinaryOpT_ts$default(
			refinedScope,
			node,
			left,
			node.operator,
			right,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingArrayPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingArrayPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$BindingArrayPattern_ts$bindingArrayPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingAssignmentPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingAssignmentPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$BindingAssignmentPattern_ts$bindingAssignmentPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingObjectPattern.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingObjectPattern_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPattern_ts$bindingObjectPattern.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/BindingObjectPatternProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingObjectPatternProperty_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$BindingObjectPatternProperty_ts$bindingObjectPatternProperty.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/BlockStatement.ts
function ___R$$priv$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(
		node,
	) {
		if (node === undefined) {
			return false;
		}

		if (
			node.type === "FunctionDeclaration" ||
			___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(node)
		) {
			return true;
		}

		if (
			node.type === "ExportLocalDeclaration" ||
			node.type === "ExportDefaultDeclaration"
		) {
			return ___R$$priv$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(
				node.declaration,
			);
		}

		return false;
	}

	function ___R$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default(
		node,
		scope,
	) {
		node =
			node.type === "Program"
				? node
				: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.assert(
						node,
					);

		// Declare variables
		for (const child of node.body) {
			if (child.type === "ImportDeclaration") {
				scope.evaluate(child);
			}

			const declarations = ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
				child,
			);
			for (const id of declarations) {
				scope.declareBinding(id.name, id);
			}
		}

		const types = [];

		// Execute hoisted nodes
		const body = [];
		for (const child of node.body) {
			if (child.type === "ImportDeclaration") {
				// already executed
			} else if (
				___R$$priv$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$shouldHoistExecute(
					child,
				)
			) {
				types.push(scope.evaluate(child));
			} else {
				body.push(child);
			}
		}

		// Execute rest
		for (const child of body) {
			types.push(scope.evaluate(child));
		}

		return new ___R$project$rome$$romejs$js$analysis$types$BlockT_ts$default(
			scope,
			node,
			types,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/literals/BooleanLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$BooleanLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$BooleanLiteralT_ts$default(
			scope,
			node,
			node.value,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/BreakStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$BreakStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$BreakStatement_ts$breakStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/CallExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$CallExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$CallExpression_ts$callExpression.assert(
			node,
		);

		return new ___R$project$rome$$romejs$js$analysis$types$CallT_ts$default(
			scope,
			node,
			scope.evaluate(node.callee),
			node.arguments.map((arg) => {
				return scope.evaluate(arg);
			}),
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/CatchClause.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$CatchClause_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$CatchClause_ts$catchClause.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/ClassExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default(
		node,
		scope,
	) {
		node =
			node.type === "ClassDeclaration"
				? node
				: ___R$project$rome$$romejs$js$ast$classes$ClassExpression_ts$classExpression.assert(
						node,
					);

		const instances = [];
		const statics = [];

		//
		const classInstance = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
			scope,
			node,
		);
		const classId = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
			scope,
			node,
		);

		//
		const bodyScope = new ___R$project$rome$$romejs$js$analysis$scopes_ts$ClassScope(
			{parentScope: scope},
			{
				instance: classInstance,
				static: classId,
			},
		);

		if (node.id !== undefined) {
			bodyScope.addBinding(node.id.name, classId);
		}

		if (node.meta.typeParameters !== undefined) {
			bodyScope.evaluate(node.meta.typeParameters);
		}

		let _constructor = undefined;

		for (const bodyNode of node.meta.body) {
			const type = bodyScope.evaluate(bodyNode);

			if (bodyNode.type === "ClassMethod" && bodyNode.kind === "constructor") {
				_constructor = type;
			} else {
				if (
					bodyNode.type !== "TSIndexSignature" &&
					bodyNode.meta.static === true
				) {
					statics.push(type);
				} else {
					instances.push(type);
				}
			}
		}

		//
		const classOrigin = node.id ? node.id : node;
		let type = new ___R$project$rome$$romejs$js$analysis$types$ClassT_ts$default(
			scope,
			classOrigin,
			{
				_constructor,
				instances,
				statics,
				extends: node.meta.superClass
					? scope.evaluate(node.meta.superClass)
					: undefined,
			},
		);
		if (node.id) {
			type.setHuman(node.id.name);
		}

		//
		classId.shouldMatch(type);

		//
		const instance = new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(
			scope,
			classOrigin,
			type,
			[],
		);
		classInstance.shouldMatch(instance);

		return type;
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/ClassDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$classes$ClassDeclaration_ts$classDeclaration.assert(
			node,
		);
		const type = ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default(
			node,
			scope,
		);
		if (node.id) {
			scope.addBinding(node.id.name, type);
		}
		return type;
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/ClassHead.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassHead_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$classes$ClassHead_ts$classHead.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/ClassMethod.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassMethod_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$classes$ClassMethod_ts$classMethod.assert(
			node,
		);
		if (node.key.type === "ComputedPropertyKey" === true) {
			// TODO
			return undefined;
		}

		const classScope = scope.find(
			___R$project$rome$$romejs$js$analysis$scopes_ts$ClassScope,
		);
		const thisContext =
			node.meta.static === true
				? classScope.meta.static
				: classScope.meta.instance;
		const func = ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(
			node,
			scope,
			false,
			thisContext,
		);

		if (node.key.value.type !== "Identifier") {
			throw new Error("Expected only an identifier key");
		}
		return new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(
			scope,
			node,
			node.key.value.name,
			func,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/ClassPrivateMethod.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPrivateMethod_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$classes$ClassPrivateMethod_ts$classPrivateMethod.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/ClassPrivateProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPrivateProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$classes$ClassPrivateProperty_ts$classPrivateProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/ClassProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$classes$ClassProperty_ts$classProperty.assert(
			node,
		);

		if (node.key.type === "ComputedPropertyKey") {
			// TODO
			return undefined;
		}

		const classScope = scope.find(
			___R$project$rome$$romejs$js$analysis$scopes_ts$ClassScope,
		);
		const funcScope = new ___R$project$rome$$romejs$js$analysis$scopes_ts$ThisScope(
			{parentScope: scope},
			classScope.meta.instance,
		);

		let annotatedType;
		let inferredType;

		if (node.typeAnnotation) {
			annotatedType = funcScope.evaluate(node.typeAnnotation);
		}

		if (node.value) {
			inferredType = funcScope.evaluate(node.value);

			if (annotatedType !== undefined) {
				inferredType.shouldMatch(annotatedType);
			}
		}

		if (annotatedType === undefined && inferredType === undefined) {
			// TODO what do we do here?
			inferredType = new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(
				scope,
				node,
			);
		}

		const actualValue =
			annotatedType === undefined ? inferredType : annotatedType;
		if (actualValue === undefined) {
			throw new Error("Expected actual value");
		}

		if (node.key.value.type !== "Identifier") {
			throw new Error("Expected only an identifier key");
		}

		return new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(
			scope,
			node,
			node.key.value.name,
			actualValue,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/ClassPropertyMeta.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPropertyMeta_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$classes$ClassPropertyMeta_ts$classPropertyMeta.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/core/CommentBlock.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$CommentBlock_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$core$CommentBlock_ts$commentBlock.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/core/CommentLine.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$CommentLine_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$core$CommentLine_ts$commentLine.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/ComputedMemberProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$ComputedMemberProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/objects/ComputedPropertyKey.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$ComputedPropertyKey_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$objects$ComputedPropertyKey_ts$computedPropertyKey.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/IfStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$IfStatement_ts$default(
		node,
		scope,
	) {
		node =
			node.type === "ConditionalExpression"
				? node
				: ___R$project$rome$$romejs$js$ast$statements$IfStatement_ts$ifStatement.assert(
						node,
					);

		const test = scope.evaluate(node.test);
		new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(
			scope,
			node,
			test,
			new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(
				scope,
				undefined,
			),
		);

		const hasRefinedTest =
			test.scope instanceof
			___R$project$rome$$romejs$js$analysis$scopes_ts$RefineScope;

		const consequentScope = hasRefinedTest ? test.scope : scope;
		const consequent = consequentScope.evaluate(node.consequent);

		if (node.alternate === undefined) {
			return consequent;
		} else {
			const alternateScope = scope.fork();

			/*if (hasRefinedTest) {
      // get bindings from 'test.scope and flip them
      for (const name of test.scope.getOwnBindingNames()) {
        const outerBinding = scope.getBinding(name);
        invariant(outerBinding !== undefined, 'expected outerBinding for %s', name);

        const refinedBinding = test.scope.getBinding(name);
        invariant(refinedBinding !== undefined, 'expected refinedBinding for %s', name);

        const opposite = new RefinedT(alternateScope, refinedBinding.originNode, outerBinding, refinedBinding);
        alternateScope.addBinding(name, opposite);
      }
    }*/
			return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
				scope,
				undefined,
				[consequent, alternateScope.evaluate(node.alternate)],
			);
		}
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/ConditionalExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ConditionalExpression_ts$default(
		node,
		scope,
	) {
		return ___R$project$rome$$romejs$js$analysis$evaluators$statements$IfStatement_ts$default(
			node,
			scope,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/ContinueStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ContinueStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$ContinueStatement_ts$continueStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/DebuggerStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$DebuggerStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$DebuggerStatement_ts$debuggerStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/core/Directive.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$Directive_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$core$Directive_ts$directive.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/DoExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$DoExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$DoExpression_ts$doExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/DoWhileStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$DoWhileStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$DoWhileStatement_ts$doWhileStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/EmptyStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$EmptyStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$EmptyStatement_ts$emptyStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ExportAllDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportAllDeclaration_ts$default(
		node,
		scope,
		{evaluator},
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ExportAllDeclaration_ts$exportAllDeclaration.assert(
			node,
		);
		evaluator.addExportAll(node.source.value);
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ExportDefaultDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportDefaultDeclaration_ts$default(
		node,
		scope,
		{evaluator},
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ExportDefaultDeclaration_ts$exportDefaultDeclaration.assert(
			node,
		);

		const decl = node.declaration;
		const declType = scope.evaluate(decl);
		evaluator.addExport("default", declType);
		return declType;
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ExportDefaultSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportDefaultSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ExportDefaultSpecifier_ts$exportDefaultSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ExportExternalDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportExternalDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ExportExternalDeclaration_ts$exportExternalDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ExportExternalSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportExternalSpecifier_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ExportExternalSpecifier_ts$exportExternalSpecifier.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ExportLocalDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportLocalDeclaration_ts$default(
		node,
		scope,
		{evaluator},
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.assert(
			node,
		);

		// export const foo = 'bar';

		// export default function foo() {}
		const decl = node.declaration;
		if (decl !== undefined) {
			const declType = scope.evaluate(decl);

			switch (decl.type) {
				case "FunctionDeclaration":
				case "ClassDeclaration": {
					const id = decl.id;
					if (id === undefined) {
						throw new Error("Expected id");
					}
					evaluator.addExport(id.name, declType);
					break;
				}

				case "VariableDeclarationStatement": {
					for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
						decl,
					)) {
						const type = scope.getBinding(id.name);
						if (type === undefined) {
							throw new Error("Couldn't find binding type for " + id.name);
						}
						evaluator.addExport(id.name, type);
					}
					break;
				}

				case "TypeAliasTypeAnnotation": {
					const type = scope.getBinding(decl.id.name);
					if (type === undefined) {
						throw new Error("Couldn't find binding type for " + decl.id.name);
					}
					evaluator.addExport(decl.id.name, type);
					break;
				}
			}

			return declType;
		}

		// export {foo, bar};

		// export {foo, bar} from './foo';
		const source = undefined; // TODO node.source === undefined ? undefined : node.source.value;
		const {specifiers} = node;
		if (specifiers !== undefined) {
			for (const specifier of specifiers) {
				if (
					specifier.type === "ExportLocalSpecifier" ||
					specifier.type === "ExportExternalSpecifier"
				) {
					let type;
					if (source === undefined) {
						type = scope.evaluate(specifier.local);
					} else {
						type = new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
							scope,
							node,
							{
								importedName: specifier.local.name,
								source,
							},
						);
					}
					evaluator.addExport(specifier.exported.name, type);
				}
			}
		}

		return undefined;
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ExportLocalSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportLocalSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ExportNamespaceSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportNamespaceSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ExportNamespaceSpecifier_ts$exportNamespaceSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/ExpressionStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ExpressionStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$ExpressionStatement_ts$expressionStatement.assert(
			node,
		);

		return scope.evaluate(node.expression);
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/ForInStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForInStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$ForInStatement_ts$forInStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/ForOfStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForOfStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$ForOfStatement_ts$forOfStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/ForStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ForStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$ForStatement_ts$forStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/FunctionDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$FunctionDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration.assert(
			node,
		);

		const func = ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(
			node,
			scope,
			false,
		);
		if (node.id !== undefined) {
			scope.addBinding(node.id.name, func);
		}
		return func;
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/FunctionExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$FunctionExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression.assert(
			node,
		);
		return ___R$project$rome$$romejs$js$analysis$utils$executeFunction_ts$default(
			node,
			scope,
			true,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/FunctionHead.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$FunctionHead_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/Identifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$Identifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.assert(
			node,
		);

		const binding = scope.getBinding(node.name);
		if (binding) {
			const type = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
				scope,
				node,
			);
			type.shouldMatch(binding);
			return type;
		} else {
			switch (node.name) {
				case "React$PropType$Primitive":
				case "React$PropType$ArrayOf":
				case "React$PropType$InstanceOf":
				case "React$PropType$ObjectOf":
				case "React$PropType$OneOf":
				case "React$PropType$OneOfType":
				case "React$PropTypePartial":
				case "React$ElementProps":
				case "React$ElementRef":
				case "$Exact":
				case "Partial":
				case "$Keys":
				case "Object$Assign":
				case "Object$GetPrototypeOf":
				case "Object$SetPrototypeOf":
				case "$CharSet":
				case "Class":
				case "$Compose":
				case "$ComposeReverse":
				case "$Subtype":
				case "Function$Prototype$Apply":
				case "Function$Prototype$Bind":
				case "Function$Prototype$Call":
				case "$Exports":
					return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(
						scope,
						node,
					);

				default:
					return new ___R$project$rome$$romejs$js$analysis$types$errors$UndeclaredVarE_ts$default(
						scope,
						node,
						node.name,
					);
			}
		}
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ImportCall.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportCall_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ImportCall_ts$importCall.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ImportDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ImportDeclaration_ts$importDeclaration.assert(
			node,
		);

		const source = node.source.value;

		for (const specifier of ___R$project$rome$$romejs$js$ast$utils$getImportSpecifiers_ts$default(
			node,
		)) {
			if (specifier.type === "ImportSpecifier") {
				const localName = specifier.local.name.name;
				const importedName = specifier.imported.name;

				const open = new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
					scope,
					specifier,
					{
						importedName,
						source,
					},
				);
				scope.addBinding(localName, open);
			} else if (specifier.type === "ImportDefaultSpecifier") {
				const localName = specifier.local.name.name;
				const open = new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
					scope,
					specifier,
					{
						importedName: "default",
						source,
					},
				);
				scope.addBinding(localName, open);
			} else if (specifier.type === "ImportNamespaceSpecifier") {
				const localName = specifier.local.name.name;
				const open = new ___R$project$rome$$romejs$js$analysis$types$ImportT_ts$default(
					scope,
					specifier,
					{
						importedName: undefined,
						source,
					},
				);
				scope.addBinding(localName, open);
			} else {
				// TODO error
			}
		}
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ImportDefaultSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportDefaultSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ImportDefaultSpecifier_ts$importDefaultSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ImportNamespaceSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportNamespaceSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ImportNamespaceSpecifier_ts$importNamespaceSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ImportSpecifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportSpecifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ImportSpecifier_ts$importSpecifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/modules/ImportSpecifierLocal.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportSpecifierLocal_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$modules$ImportSpecifierLocal_ts$importSpecifierLocal.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/core/InterpreterDirective.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$InterpreterDirective_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$core$InterpreterDirective_ts$interpreterDirective.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXAttribute.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXAttribute_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXAttribute_ts$jsxAttribute.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXElement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXElement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXElement_ts$jsxElement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXEmptyExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXEmptyExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXEmptyExpression_ts$jsxEmptyExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXExpressionContainer.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXExpressionContainer_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXExpressionContainer_ts$jsxExpressionContainer.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXFragment.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXFragment_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXFragment_ts$jsxFragment.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXIdentifier_ts$jsxIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXMemberExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXMemberExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXMemberExpression_ts$jsxMemberExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXNamespacedName.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXNamespacedName_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXNamespacedName_ts$jsxNamespacedName.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXReferenceIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXReferenceIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXReferenceIdentifier_ts$jsxReferenceIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXSpreadAttribute.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXSpreadAttribute_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadAttribute_ts$jsxSpreadAttribute.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXSpreadChild.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXSpreadChild_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXSpreadChild_ts$jsxSpreadChild.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/jsx/JSXText.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXText_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$jsx$JSXText_ts$jsxText.assert(node);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/LabeledStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$LabeledStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$LabeledStatement_ts$labeledStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/LogicalExpression.ts
function ___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$uniq(
		args,
	) {
		return [...new Set(args)];
	}

	function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$LogicalExpression_ts$logicalExpression.assert(
			node,
		);

		switch (node.operator) {
			case "||": {
				const left = scope.refine().evaluate(node.left);
				const right = scope.refine().evaluate(node.right);

				// create a new scope that has unions of all the refined bindings
				const refinedScope = scope.refine();
				const refinedNames = ___R$$priv$project$rome$$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$uniq([
					...left.scope.getOwnBindingNames(),
					...right.scope.getOwnBindingNames(),
				]);
				const mergeScopes = [left.scope, right.scope];
				for (const name of refinedNames) {
					const rawTypes = new Set();
					for (const scope of mergeScopes) {
						const binding = scope.getBinding(name);
						if (binding !== undefined) {
							rawTypes.add(binding);
						}
					}

					const types = Array.from(rawTypes);
					refinedScope.addBinding(name, refinedScope.createUnion(types));
				}

				return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
					refinedScope,
					node,
					[left, right],
				);
			}

			case "&&": {
				const left = scope.evaluate(node.left);
				const right = left.scope.evaluate(node.right);
				return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
					right.scope,
					node,
					[left, right],
				);
			}

			default:
				throw new Error("Unknown operator");
		}
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/MemberExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$MemberExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.assert(
			node,
		);
		if (node.property.type === "ComputedMemberProperty") {
			throw new Error("Computed properties not supportd yet");
		}

		if (node.property.value.type === "PrivateName") {
			throw new Error("PrivateName in static member not supported yet");
		}

		const prop = new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
			scope,
			node.property.value,
			node.property.value.name,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$GetPropT_ts$default(
			scope,
			node,
			scope.evaluate(node.object),
			prop,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/MetaProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$MetaProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$MetaProperty_ts$metaProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/temp/MockParent.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$temp$MockParent_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$temp$MockParent_ts$mockParent.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/NewExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$NewExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$NewExpression_ts$newExpression.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$InstanceT_ts$default(
			scope,
			node,
			scope.evaluate(node.callee),
			[],
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/literals/NullLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$NullLiteral_ts$default(
		node,
		scope,
	) {
		node = node = ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/literals/NumericLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$NumericLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$NumericLiteralT_ts$default(
			scope,
			node,
			node.value,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/objects/ObjectExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.assert(
			node,
		);
		const props = [];

		for (const prop of node.properties) {
			if (prop.type === "SpreadProperty") {
				// TODO
			} else if (prop.type === "ObjectProperty") {
				if (prop.key.type === "ComputedPropertyKey") {
					// TODO
				} else {
					const {
						key: {value: key},
						value,
					} = prop;

					let keyStr;
					if (key.type === "Identifier") {
						keyStr = key.name;
					} else {
						// TODO
						continue;
					}

					if (keyStr === undefined) {
						throw new Error("Expected keyStr");
					}

					props.push(
						new ___R$project$rome$$romejs$js$analysis$types$ObjPropT_ts$default(
							scope,
							prop,
							keyStr,
							scope.evaluate(value),
						),
					);
				}
			} else {
				// TODO
			}
		}

		return new ___R$project$rome$$romejs$js$analysis$types$ObjT_ts$default(
			scope,
			node,
			{
				calls: [],
				props,
				proto: scope.intrinsics.ObjectPrototype,
			},
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/objects/ObjectMethod.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectMethod_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/objects/ObjectProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/OptionalCallExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$OptionalCallExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$OptionalCallExpression_ts$optionalCallExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/patterns/PatternMeta.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$patterns$PatternMeta_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$patterns$PatternMeta_ts$patternMeta.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/classes/PrivateName.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$classes$PrivateName_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$classes$PrivateName_ts$privateName.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/core/Program.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$core$Program_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(node);
		___R$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default(
			node,
			scope,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/ReferenceIdentifier.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ReferenceIdentifier_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpAlternation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpAlternation_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpAlternation_ts$regExpAlternation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpAnyCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpAnyCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpAnyCharacter_ts$regExpAnyCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharacter_ts$regExpCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpCharSet.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharSet_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharSet_ts$regExpCharSet.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpCharSetRange.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharSetRange_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpCharSetRange_ts$regExpCharSetRange.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpControlCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpControlCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpControlCharacter_ts$regExpControlCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpDigitCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpDigitCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpDigitCharacter_ts$regExpDigitCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpEndCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpEndCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpEndCharacter_ts$regExpEndCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpGroupCapture.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpGroupCapture_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpGroupCapture_ts$regExpGroupCapture.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpGroupNonCapture.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpGroupNonCapture_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpGroupNonCapture_ts$regExpGroupNonCapture.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/literals/RegExpLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$RegExpLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$literals$RegExpLiteral_ts$regExpLiteral.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNamedBackReference.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNamedBackReference_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpNamedBackReference_ts$regExpNamedBackReference.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNonDigitCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonDigitCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpNonDigitCharacter_ts$regExpNonDigitCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNonWhiteSpaceCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWhiteSpaceCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpNonWhiteSpaceCharacter_ts$regExpNonWhiteSpaceCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNonWordBoundaryCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWordBoundaryCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordBoundaryCharacter_ts$regExpNonWordBoundaryCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNonWordCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWordCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpNonWordCharacter_ts$regExpNonWordCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpNumericBackReference.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNumericBackReference_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpNumericBackReference_ts$regExpNumericBackReference.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpQuantified.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpQuantified_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpStartCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpStartCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpStartCharacter_ts$regExpStartCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpSubExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpSubExpression_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpSubExpression_ts$regExpSubExpression.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpWhiteSpaceCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWhiteSpaceCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpWhiteSpaceCharacter_ts$regExpWhiteSpaceCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpWordBoundaryCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWordBoundaryCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpWordBoundaryCharacter_ts$regExpWordBoundaryCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/regex/RegExpWordCharacter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWordCharacter_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$regex$RegExpWordCharacter_ts$regExpWordCharacter.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/ReturnStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ReturnStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.assert(
			node,
		);
		const funcScope = scope.find(
			___R$project$rome$$romejs$js$analysis$scopes_ts$FunctionScope,
		);
		if (node.argument === undefined) {
			// TODO connect to undefined
		} else {
			const type = scope.evaluate(node.argument);
			funcScope.meta.returnType.shouldMatch(type);
		}
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/SequenceExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$SequenceExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$SequenceExpression_ts$sequenceExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/SpreadElement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$SpreadElement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$SpreadElement_ts$spreadElement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/objects/SpreadProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$SpreadProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$objects$SpreadProperty_ts$spreadProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/StaticMemberProperty.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$StaticMemberProperty_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/objects/StaticPropertyKey.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$objects$StaticPropertyKey_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/literals/StringLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$StringLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$StringLiteralT_ts$default(
			scope,
			node,
			node.value,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/Super.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$Super_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$Super_ts$_super.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/SwitchCase.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$SwitchCase_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$SwitchCase_ts$switchCase.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/SwitchStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$SwitchStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$SwitchStatement_ts$switchStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/TaggedTemplateExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$TaggedTemplateExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$TaggedTemplateExpression_ts$taggedTemplateExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/TemplateElement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$TemplateElement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/literals/TemplateLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$literals$TemplateLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.assert(
			node,
		);
		for (const expr of node.expressions) {
			new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(
				scope,
				expr,
				scope.evaluate(expr),
				new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(
					scope,
					undefined,
				),
			);
		}
		return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/ThisExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$ThisExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$ThisExpression_ts$thisExpression.assert(
			node,
		);
		const thisScope = scope.find(
			___R$project$rome$$romejs$js$analysis$scopes_ts$ThisScope,
		);
		if (thisScope === undefined) {
			// TODO complain
			return undefined;
		} else {
			const type = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
				scope,
				node,
			);
			type.shouldMatch(thisScope.context);
			return type;
		}
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/ThrowStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$ThrowStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$ThrowStatement_ts$throwStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/TryStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$TryStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$TryStatement_ts$tryStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAnyKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAnyKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSAnyKeywordTypeAnnotation_ts$tsAnyKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSArrayType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSArrayType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSArrayType_ts$tsArrayType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAsExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAsExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSAsExpression_ts$tsAsExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAssignmentAsExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentAsExpression_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentAsExpression_ts$tsAssignmentAsExpression.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAssignmentNonNullExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentNonNullExpression_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentNonNullExpression_ts$tsAssignmentNonNullExpression.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSAssignmentTypeAssertion.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentTypeAssertion_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSAssignmentTypeAssertion_ts$tsAssignmentTypeAssertion.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSBigIntKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSBigIntKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSBigIntKeywordTypeAnnotation_ts$tsBigIntKeywordTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSBooleanKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSBooleanKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSBooleanKeywordTypeAnnotation_ts$tsBooleanKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSBooleanLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSBooleanLiteralTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSBooleanLiteralTypeAnnotation_ts$tsBooleanLiteralTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSCallSignatureDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSCallSignatureDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSCallSignatureDeclaration_ts$tsCallSignatureDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSConditionalType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConditionalType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSConditionalType_ts$tsConditionalType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSConstructorType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConstructorType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSConstructorType_ts$tsConstructorType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSConstructSignatureDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConstructSignatureDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSConstructSignatureDeclaration_ts$tsConstructSignatureDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSDeclareFunction.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSDeclareFunction_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSDeclareFunction_ts$tsDeclareFunction.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSDeclareMethod.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSDeclareMethod_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSDeclareMethod_ts$tsDeclareMethod.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSEmptyKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEmptyKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSEmptyKeywordTypeAnnotation_ts$tsEmptyKeywordTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSEnumDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEnumDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSEnumDeclaration_ts$tsEnumDeclaration.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSEnumMember.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEnumMember_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSEnumMember_ts$tsEnumMember.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSExportAssignment.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExportAssignment_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSExportAssignment_ts$tsExportAssignment.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSExpressionWithTypeArguments.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExpressionWithTypeArguments_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSExpressionWithTypeArguments_ts$tsExpressionWithTypeArguments.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSExternalModuleReference.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExternalModuleReference_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSExternalModuleReference_ts$tsExternalModuleReference.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSFunctionType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSFunctionType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSFunctionType_ts$tsFunctionType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSImportEqualsDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSImportEqualsDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSImportEqualsDeclaration_ts$tsImportEqualsDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSImportType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSImportType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSImportType_ts$tsImportType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSIndexedAccessType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIndexedAccessType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSIndexedAccessType_ts$tsIndexedAccessType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSIndexSignature.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIndexSignature_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSIndexSignature_ts$tsIndexSignature.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSInferType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInferType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSInferType_ts$tsInferType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSInterfaceBody.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInterfaceBody_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceBody_ts$tsInterfaceBody.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSInterfaceDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInterfaceDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSInterfaceDeclaration_ts$tsInterfaceDeclaration.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSIntersectionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIntersectionTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSIntersectionTypeAnnotation_ts$tsIntersectionTypeAnnotation.assert(
			node,
		);

		return new ___R$project$rome$$romejs$js$analysis$types$IntersectionT_ts$default(
			scope,
			node,
			node.types.map((type) => {
				return scope.evaluate(type);
			}),
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSMappedType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMappedType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSMappedType_ts$tsMappedType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSMethodSignature.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMethodSignature_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSMethodSignature_ts$tsMethodSignature.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSMixedKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMixedKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSMixedKeywordTypeAnnotation_ts$tsMixedKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$MixedT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSModuleBlock.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSModuleBlock_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSModuleBlock_ts$tsModuleBlock.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSModuleDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSModuleDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSModuleDeclaration_ts$tsModuleDeclaration.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSNamespaceExportDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNamespaceExportDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSNamespaceExportDeclaration_ts$tsNamespaceExportDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSNeverKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNeverKeywordTypeAnnotation_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSNeverKeywordTypeAnnotation_ts$tsNeverKeywordTypeAnnotation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSNonNullExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNonNullExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSNonNullExpression_ts$tsNonNullExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSNullKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNullKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSNullKeywordTypeAnnotation_ts$tsNullKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$NullT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSNumberKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNumberKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSNumberKeywordTypeAnnotation_ts$tsNumberKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSNumericLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNumericLiteralTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSNumericLiteralTypeAnnotation_ts$tsNumericLiteralTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSObjectKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSObjectKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSObjectKeywordTypeAnnotation_ts$tsObjectKeywordTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSOptionalType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSOptionalType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSOptionalType_ts$tsOptionalType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSParenthesizedType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSParenthesizedType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSParenthesizedType_ts$tsParenthesizedType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSPropertySignature.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSPropertySignature_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSPropertySignature_ts$tsPropertySignature.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSQualifiedName.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSQualifiedName_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSQualifiedName_ts$tsQualifiedName.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSSignatureDeclarationMeta.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSSignatureDeclarationMeta_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSSignatureDeclarationMeta_ts$tsSignatureDeclarationMeta.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSStringKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSStringKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSStringKeywordTypeAnnotation_ts$tsStringKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$StringT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSStringLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSStringLiteralTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSStringLiteralTypeAnnotation_ts$tsStringLiteralTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSSymbolKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSSymbolKeywordTypeAnnotation_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSSymbolKeywordTypeAnnotation_ts$tsSymbolKeywordTypeAnnotation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTemplateLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTemplateLiteralTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTemplateLiteralTypeAnnotation_ts$tsTemplateLiteralTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSThisType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSThisType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSThisType_ts$tsThisType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTupleType.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTupleType_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTupleType_ts$tsTupleType.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeAssertion.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeAssertion_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeAssertion_ts$tsTypeAssertion.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeLiteral.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeLiteral_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeLiteral_ts$tsTypeLiteral.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeOperator.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeOperator_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeOperator_ts$tsTypeOperator.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeParameter.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameter_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameter_ts$tsTypeParameter.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeParameterDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameterDeclaration_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterDeclaration_ts$tsTypeParameterDeclaration.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeParameterInstantiation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameterInstantiation_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypePredicate.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypePredicate_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypePredicate_ts$tsTypePredicate.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeQuery.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeQuery_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeQuery_ts$tsTypeQuery.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TSTypeReference.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeReference_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/TypeAliasTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$TypeAliasTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$TypeAliasTypeAnnotation_ts$typeAliasTypeAnnotation.assert(
			node,
		);

		const typeScope = scope.fork();
		if (node.typeParameters) {
			typeScope.evaluate(node.typeParameters);
		}

		const right = typeScope.evaluate(node.right);
		scope.addBinding(node.id.name, right);
		return right;
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/UnaryExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$UnaryExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression.assert(
			node,
		);
		const argType = scope.evaluate(node.argument);

		switch (node.operator) {
			case // booleans
			"delete":
			case "!":
				return new ___R$project$rome$$romejs$js$analysis$types$BooleanT_ts$default(
					scope,
					node,
				);

			// numbers
			case "+":
			case "-":
			case "~":
				return new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(
					scope,
					node,
				);

			// strings
			case "typeof":
				return new ___R$project$rome$$romejs$js$analysis$types$TypeofT_ts$default(
					scope,
					node,
					argType,
				);

			// void
			case "void":
				return new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(
					scope,
					node,
				);

			// empty!
			case "throw":
				break;
		}

		return undefined;
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/UndefinedKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$UndefinedKeywordTypeAnnotation_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$UndefinedKeywordTypeAnnotation_ts$undefinedKeywordTypeAnnotation.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/UnionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$UnionTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$UnionTypeAnnotation_ts$unionTypeAnnotation.assert(
			node,
		);

		return new ___R$project$rome$$romejs$js$analysis$types$UnionT_ts$default(
			scope,
			node,
			node.types.map((type) => {
				return scope.evaluate(type);
			}),
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/UnknownKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$UnknownKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$UnknownKeywordTypeAnnotation_ts$unknownKeywordTypeAnnotation.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/UpdateExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$UpdateExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$UpdateExpression_ts$updateExpression.assert(
			node,
		);
		const type = new ___R$project$rome$$romejs$js$analysis$types$NumericT_ts$default(
			scope,
			node,
		);
		new ___R$project$rome$$romejs$js$analysis$types$ExhaustiveT_ts$default(
			scope,
			node.argument,
			scope.evaluate(node.argument),
			type,
		);
		return type;
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/VariableDeclaration.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$VariableDeclaration_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.assert(
			node,
		);

		for (const declarator of node.declarations) {
			const {id, init} = declarator;
			let inferredType;

			if (init === undefined) {
				inferredType = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
					scope,
					declarator,
				);
				inferredType.shouldMatch(
					new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(
						scope,
						declarator,
					),
				);
			} else {
				inferredType = scope.evaluate(init);
			}

			let actualType = inferredType;

			if (id.meta !== undefined && id.meta.typeAnnotation !== undefined) {
				const annotatedType = scope.evaluate(id.meta.typeAnnotation);
				inferredType.shouldMatch(annotatedType);
				actualType = annotatedType;
			}

			___R$project$rome$$romejs$js$analysis$utils$executeAtom_ts$default(
				id,
				actualType,
				scope,
			);
		}
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/VariableDeclarationStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$VariableDeclarationStatement_ts$default(
		node,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.assert(
			node,
		);
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/auxiliary/VariableDeclarator.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$VariableDeclarator_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/typescript/VoidKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$typescript$VoidKeywordTypeAnnotation_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$typescript$VoidKeywordTypeAnnotation_ts$voidKeywordTypeAnnotation.assert(
			node,
		);
		return new ___R$project$rome$$romejs$js$analysis$types$VoidT_ts$default(
			scope,
			node,
		);
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/WhileStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$WhileStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts$whileStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/statements/WithStatement.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$statements$WithStatement_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$statements$WithStatement_ts$withStatement.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/expressions/YieldExpression.ts
function ___R$project$rome$$romejs$js$analysis$evaluators$expressions$YieldExpression_ts$default(
		node,
		scope,
	) {
		node = ___R$project$rome$$romejs$js$ast$expressions$YieldExpression_ts$yieldExpression.assert(
			node,
		);
		scope;
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-analysis/evaluators/index.ts
const ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators = new Map();
	const ___R$project$rome$$romejs$js$analysis$evaluators$index_ts$default = ___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators;
	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"AmbiguousFlowTypeCastExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$temp$AmbiguousFlowTypeCastExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ArrayExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$ArrayExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ArrayHole",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$ArrayHole_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ArrowFunctionExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$ArrowFunctionExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"AssignmentArrayPattern",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentArrayPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"AssignmentAssignmentPattern",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentAssignmentPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"AssignmentExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$AssignmentExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"AssignmentIdentifier",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"AssignmentObjectPattern",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentObjectPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"AssignmentObjectPatternProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$AssignmentObjectPatternProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"AwaitExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$AwaitExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BigIntLiteral",
		___R$project$rome$$romejs$js$analysis$evaluators$literals$BigIntLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BinaryExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$BinaryExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BindingArrayPattern",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingArrayPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BindingAssignmentPattern",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingAssignmentPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BindingIdentifier",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BindingObjectPattern",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingObjectPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BindingObjectPatternProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$BindingObjectPatternProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BlockStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$BlockStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BooleanLiteral",
		___R$project$rome$$romejs$js$analysis$evaluators$literals$BooleanLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"BreakStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$BreakStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"CallExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$CallExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"CatchClause",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$CatchClause_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ClassDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ClassExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ClassHead",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassHead_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ClassMethod",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassMethod_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ClassPrivateMethod",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPrivateMethod_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ClassPrivateProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPrivateProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ClassProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ClassPropertyMeta",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$ClassPropertyMeta_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"CommentBlock",
		___R$project$rome$$romejs$js$analysis$evaluators$core$CommentBlock_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"CommentLine",
		___R$project$rome$$romejs$js$analysis$evaluators$core$CommentLine_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ComputedMemberProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$ComputedMemberProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ComputedPropertyKey",
		___R$project$rome$$romejs$js$analysis$evaluators$objects$ComputedPropertyKey_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ConditionalExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$ConditionalExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ContinueStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$ContinueStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"DebuggerStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$DebuggerStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"Directive",
		___R$project$rome$$romejs$js$analysis$evaluators$core$Directive_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"DoExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$DoExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"DoWhileStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$DoWhileStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"EmptyStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$EmptyStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExportAllDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportAllDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExportDefaultDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportDefaultDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExportDefaultSpecifier",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportDefaultSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExportExternalDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportExternalDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExportExternalSpecifier",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportExternalSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExportLocalDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportLocalDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExportLocalSpecifier",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportLocalSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExportNamespaceSpecifier",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ExportNamespaceSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ExpressionStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$ExpressionStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ForInStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$ForInStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ForOfStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$ForOfStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ForStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$ForStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"FunctionDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$FunctionDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"FunctionExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$FunctionExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"FunctionHead",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$FunctionHead_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"Identifier",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$Identifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"IfStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$IfStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ImportCall",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportCall_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ImportDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ImportDefaultSpecifier",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportDefaultSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ImportNamespaceSpecifier",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportNamespaceSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ImportSpecifier",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ImportSpecifierLocal",
		___R$project$rome$$romejs$js$analysis$evaluators$modules$ImportSpecifierLocal_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"InterpreterDirective",
		___R$project$rome$$romejs$js$analysis$evaluators$core$InterpreterDirective_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXAttribute",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXAttribute_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXElement",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXElement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXEmptyExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXEmptyExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXExpressionContainer",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXExpressionContainer_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXFragment",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXFragment_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXIdentifier",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXMemberExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXMemberExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXNamespacedName",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXNamespacedName_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXReferenceIdentifier",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXReferenceIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXSpreadAttribute",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXSpreadAttribute_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXSpreadChild",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXSpreadChild_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"JSXText",
		___R$project$rome$$romejs$js$analysis$evaluators$jsx$JSXText_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"LabeledStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$LabeledStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"LogicalExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$LogicalExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"MemberExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$MemberExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"MetaProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$MetaProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"MockParent",
		___R$project$rome$$romejs$js$analysis$evaluators$temp$MockParent_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"NewExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$NewExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"NullLiteral",
		___R$project$rome$$romejs$js$analysis$evaluators$literals$NullLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"NumericLiteral",
		___R$project$rome$$romejs$js$analysis$evaluators$literals$NumericLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ObjectExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ObjectMethod",
		___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectMethod_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ObjectProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$objects$ObjectProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"OptionalCallExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$OptionalCallExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"PatternMeta",
		___R$project$rome$$romejs$js$analysis$evaluators$patterns$PatternMeta_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"PrivateName",
		___R$project$rome$$romejs$js$analysis$evaluators$classes$PrivateName_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"Program",
		___R$project$rome$$romejs$js$analysis$evaluators$core$Program_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ReferenceIdentifier",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$ReferenceIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpAlternation",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpAlternation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpAnyCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpAnyCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpCharSet",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharSet_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpCharSetRange",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpCharSetRange_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpControlCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpControlCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpDigitCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpDigitCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpEndCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpEndCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpGroupCapture",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpGroupCapture_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpGroupNonCapture",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpGroupNonCapture_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpLiteral",
		___R$project$rome$$romejs$js$analysis$evaluators$literals$RegExpLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpNamedBackReference",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNamedBackReference_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpNonDigitCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonDigitCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpNonWhiteSpaceCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWhiteSpaceCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpNonWordBoundaryCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWordBoundaryCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpNonWordCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNonWordCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpNumericBackReference",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpNumericBackReference_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpQuantified",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpQuantified_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpStartCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpStartCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpSubExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpSubExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpWhiteSpaceCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWhiteSpaceCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpWordBoundaryCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWordBoundaryCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"RegExpWordCharacter",
		___R$project$rome$$romejs$js$analysis$evaluators$regex$RegExpWordCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ReturnStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$ReturnStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"SequenceExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$SequenceExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"SpreadElement",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$SpreadElement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"SpreadProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$objects$SpreadProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"StaticMemberProperty",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$StaticMemberProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"StaticPropertyKey",
		___R$project$rome$$romejs$js$analysis$evaluators$objects$StaticPropertyKey_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"StringLiteral",
		___R$project$rome$$romejs$js$analysis$evaluators$literals$StringLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"Super",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$Super_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"SwitchCase",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$SwitchCase_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"SwitchStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$SwitchStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TaggedTemplateExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$TaggedTemplateExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TemplateElement",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$TemplateElement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TemplateLiteral",
		___R$project$rome$$romejs$js$analysis$evaluators$literals$TemplateLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ThisExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$ThisExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"ThrowStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$ThrowStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TryStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$TryStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAnyKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAnyKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSArrayType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSArrayType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAsExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAsExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAssignmentAsExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentAsExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAssignmentNonNullExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentNonNullExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSAssignmentTypeAssertion",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSAssignmentTypeAssertion_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSBigIntKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSBigIntKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSBooleanKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSBooleanKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSBooleanLiteralTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSBooleanLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSCallSignatureDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSCallSignatureDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSConditionalType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConditionalType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSConstructorType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConstructorType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSConstructSignatureDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSConstructSignatureDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSDeclareFunction",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSDeclareFunction_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSDeclareMethod",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSDeclareMethod_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSEmptyKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEmptyKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSEnumDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEnumDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSEnumMember",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSEnumMember_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSExportAssignment",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExportAssignment_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSExpressionWithTypeArguments",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExpressionWithTypeArguments_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSExternalModuleReference",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSExternalModuleReference_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSFunctionType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSFunctionType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSImportEqualsDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSImportEqualsDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSImportType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSImportType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSIndexedAccessType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIndexedAccessType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSIndexSignature",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIndexSignature_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSInferType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInferType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSInterfaceBody",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInterfaceBody_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSInterfaceDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSInterfaceDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSIntersectionTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSIntersectionTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSMappedType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMappedType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSMethodSignature",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMethodSignature_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSMixedKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSMixedKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSModuleBlock",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSModuleBlock_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSModuleDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSModuleDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNamespaceExportDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNamespaceExportDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNeverKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNeverKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNonNullExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNonNullExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNullKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNullKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNumberKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNumberKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSNumericLiteralTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSNumericLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSObjectKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSObjectKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSOptionalType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSOptionalType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSParenthesizedType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSParenthesizedType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSPropertySignature",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSPropertySignature_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSQualifiedName",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSQualifiedName_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSSignatureDeclarationMeta",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSSignatureDeclarationMeta_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSStringKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSStringKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSStringLiteralTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSStringLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSSymbolKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSSymbolKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTemplateLiteralTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTemplateLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSThisType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSThisType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTupleType",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTupleType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeAssertion",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeAssertion_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeLiteral",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeOperator",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeOperator_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeParameter",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeParameterDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameterDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeParameterInstantiation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeParameterInstantiation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypePredicate",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypePredicate_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeQuery",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeQuery_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TSTypeReference",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TSTypeReference_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"TypeAliasTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$TypeAliasTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"UnaryExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$UnaryExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"UndefinedKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$UndefinedKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"UnionTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$UnionTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"UnknownKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$UnknownKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"UpdateExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$UpdateExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"VariableDeclaration",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$VariableDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"VariableDeclarationStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$VariableDeclarationStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"VariableDeclarator",
		___R$project$rome$$romejs$js$analysis$evaluators$auxiliary$VariableDeclarator_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"VoidKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$analysis$evaluators$typescript$VoidKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"WhileStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$WhileStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"WithStatement",
		___R$project$rome$$romejs$js$analysis$evaluators$statements$WithStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$analysis$evaluators$index_ts$evaluators.set(
		"YieldExpression",
		___R$project$rome$$romejs$js$analysis$evaluators$expressions$YieldExpression_ts$default,
	);


  // project-rome/@romejs/js-analysis/Evaluator.ts






	class ___R$project$rome$$romejs$js$analysis$Evaluator_ts$ModuleSignatureManager {
		constructor(graph, getModuleSignature, topScope) {
			this.topScope = topScope;
			this.getModuleSignature = getModuleSignature;
			this.graph = graph;
			this.openTypes = new Map();
			this.filename = graph.filename;

			this.exportNamesToTypeId = new Map();
		}

		addAll(manager) {
			for (const [name, id] of manager.exportNamesToTypeId) {
				if (name === "default") {
					// ignore `default`
					continue;
				}

				this.exportNamesToTypeId.set(name, id);

				const openType = manager.openTypes.get(id);
				if (openType === undefined) {
					throw new Error("Expected an open type");
				}
				this.openTypes.set(id, openType);
			}
		}

		async init() {
			const {graph, openTypes} = this;

			// Create initial open types for all the nodes in this graph
			for (const id in graph.types) {
				const open = new ___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default(
					this.topScope,
					undefined,
				);
				openTypes.set(id, open);
			}

			let currGetType;

			// Create a factory to fetch the open ids
			const getType = (id) => {
				if (id === undefined) {
					throw new Error("expected id");
				}

				if (typeof id !== "string") {
					throw new Error("expected string id");
				}

				const type = openTypes.get(id);

				if (type === undefined) {
					throw new Error(
						graph.filename +
						": Expected type of id " +
						id +
						" but it doesn't exist, serialized data: " +
						String(JSON.stringify(currGetType)),
					);
				}

				return type;
			};

			// Fetch the graphs of `export *` dependencies, future calls to `this.getModuleSignature` will fetch from 'cache
			await Promise.all(
				graph.exports.map((def) => {
					if (def.type === "all") {
						return this.getModuleSignature(def.source, graph.filename);
					} else {
						return undefined;
					}
				}),
			);

			// Resolve all exports
			for (const def of graph.exports) {
				if (def.type === "all") {
					const manager = await this.getModuleSignature(
						def.source,
						graph.filename,
					);
					if (manager !== undefined) {
						this.addAll(manager);
					}
				} else {
					this.exportNamesToTypeId.set(def.name, def.value);
				}
			}

			// Hydrate all types in the graph and link them to their open types
			for (const id in graph.types) {
				const node = graph.types[id];
				const {origin, type, data, human} = node;
				currGetType = node;

				// Retrieve the open type
				const openT = openTypes.get(id);
				if (openT === undefined) {
					throw new Error("Expected an open type");
				}

				// Get the type constructor
				const TConstructor = ___R$project$rome$$romejs$js$analysis$types$index_ts$default.get(
					type,
				);
				if (TConstructor === undefined) {
					throw new Error("Expected a valid internal type constructor name");
				}

				// Create the type

				// @ts-ignore
				const realT = TConstructor.hydrate(
					this.topScope,
					{loc: origin},
					data,
					getType,
				);

				//
				realT.setHuman(human);

				// Link it to the open type
				openT.shouldMatch(realT);
			}
		}

		link(importedName, type) {
			const graph = this.graph;

			// Get type id for this export
			const maybeExportId = this.exportNamesToTypeId.get(importedName);
			if (maybeExportId === undefined) {
				// Export not found in the module so let's link it to an error
				const error = new ___R$project$rome$$romejs$js$analysis$types$errors$UnknownImportE_ts$default(
					this.topScope,
					type.originNode,
					{
						possibleNames: Array.from(this.exportNamesToTypeId.keys()),
						importedName,
						source: graph.filename,
					},
				);
				error.shouldMatch(type);
				return;
			}

			// Retrieve the open type
			const openT = this.openTypes.get(maybeExportId);
			if (openT === undefined) {
				throw new Error("Expected an open type");
			}

			// Link it to this type
			type.setResolvedType(openT);
		}
	}



	class ___R$project$rome$$romejs$js$analysis$Evaluator_ts$default {
		constructor(hub, filename) {
			this.filename = filename;
			this.nodeToType = new Map();
			this.exports = [];
			this.imports = [];
			this.hub = hub;
			this.graph = hub.graph;
			// TODO we should use `ThisScope` and set it correctly to `window` or `undefined` depending on strict mode
			this.topScope = new ___R$project$rome$$romejs$js$analysis$scopes_ts$Scope({
				evaluator: this,
			});
			this.intrinsics = this.topScope.intrinsics = new ___R$project$rome$$romejs$js$analysis$Intrinsics_ts$default(
				this.topScope,
			);
			this.evaluatingType = undefined;
		}

		initModuleSignature(graph, getModuleSignature) {
			return new ___R$project$rome$$romejs$js$analysis$Evaluator_ts$ModuleSignatureManager(
				graph,
				getModuleSignature,
				this.topScope,
			);
		}

		seed(ast) {
			return this.evaluate(ast, this.topScope);
		}

		evaluate(node, scope) {
			if (node === undefined) {
				throw new Error("Expected node but received undefined");
			}

			const evaluator = ___R$project$rome$$romejs$js$analysis$evaluators$index_ts$default.get(
				node.type,
			);
			if (evaluator === undefined) {
				throw new Error("what is this? " + node.type);
			} else {
				const oldEvaluatingType = this.evaluatingType;
				this.evaluatingType = node.type;
				let type = evaluator(node, scope, this.hub);
				if (type === undefined) {
					type = new ___R$project$rome$$romejs$js$analysis$types$EmptyT_ts$default(
						scope,
						node,
					);
				}
				this.evaluatingType = oldEvaluatingType;
				this.nodeToType.set(node, type);
				return type;
			}
		}

		getTypeFromEvaluatedNode(node) {
			const type = this.nodeToType.get(node);
			if (type === undefined) {
				throw new Error(
					"getTypeFromEvaluatedNode() called on a node that has not been validated yet",
				);
			} else {
				return type;
			}
		}

		addExport(name, type) {
			this.exports.push({
				type: "local",
				name,
				value: type,
			});
		}

		addExportAll(source) {
			this.exports.push({
				type: "all",
				source,
			});
		}

		addImport(t, opts) {
			this.imports.push({
				relative: opts.relative,
				importedName: opts.importedName,
				source: opts.source,
				type: t,
			});
		}
	}


  // project-rome/@romejs/js-analysis/Utils.ts
class ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$ReduceRecursionError
		extends Error {}

	const ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE = {
		type: "compatible",
	};

	const ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$MAX_DEPTH = 100;

	class ___R$project$rome$$romejs$js$analysis$Utils_ts$HumanBuilder {
		constructor() {
			this.stack = new Set();
			this.usedAliases = new Set();
			this.aliases = new Map();
		}

		isRecursive(t) {
			if (t.human !== undefined) {
				return false;
			}

			if (this.aliases.has(t)) {
				return true;
			}

			if (this.stack.has(t)) {
				return true;
			}

			return false;
		}

		humanize(type) {
			// Check if we already have a human form for this type
			if (type.human !== undefined) {
				return type.human;
			}

			// Check if we have an already created alias
			if (this.aliases.has(type)) {
				const alias = this.aliases.get(type);
				if (alias === undefined) {
					throw new Error("Expected alias");
				}
				return alias;
			}

			// Generate an alias if we've determined this as recursive
			if (this.isRecursive(type)) {
				const alias = "Alias" + type.id;
				this.aliases.set(type, alias);
				return alias;
			}

			// Setup the stack and call
			this.stack.add(type);
			try {
				let humanized = type.humanize(this);

				// Check if an alias was created
				const alias = this.aliases.get(type);
				if (alias !== undefined) {
					humanized = alias + " = " + humanized;
				}
				return humanized;
			} finally {
				this.stack.delete(type);
			}
		}
	}

	class ___R$project$rome$$romejs$js$analysis$Utils_ts$default {
		constructor(hub) {
			this.reduceCatchers = new Set();
			this.reduceCache = new Map();
			this.reduceStack = new Set();
			this.compatibilityDepth = 0;
			this.hub = hub;
			this.debug = false;
		}

		inspect(t, safe = false) {
			const prevDebug = this.debug;
			this.debug = true;

			const data = new Map();
			data.set("id", String(t.id));

			const {originLoc, originEvaluator} = t;
			if (originLoc === undefined) {
				data.set("origin", "unknown");
			} else {
				data.set(
					"origin",
					String(originLoc.filename) +
					":" +
					String(originLoc.start.line) +
					":" +
					String(originLoc.start.column),
				);
			}
			if (originEvaluator !== undefined) {
				data.set("evaluator", originEvaluator);
			}

			const dataStr = Array.from(data.keys()).map((key) =>
				key + ": " + String(data.get(key))
			).join(", ");

			let info = t.getConstructor().type + "<";
			if (safe === false) {
				info += this.humanize(t) + ", ";
			}
			info += dataStr + ">";

			this.debug = prevDebug;
			return info;
		}

		assertClosed() {
			if (this.debug === false) {
				this.hub.assertClosed();
			}
		}

		explodeUnion(type) {
			return Array.from(new Set(this.reduce(type).explodeUnion()));
		}

		isCompatibleWith(a, b) {
			return this.checkCompability(a, b).type === "compatible";
		}

		checkCompability(a, b) {
			this.assertClosed();

			const lower = this.reduce(a);
			const upper = this.reduce(b);

			// Exact same type
			if (lower === upper) {
				return ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
			}

			// Any types shouldn't cause errors
			if (
				lower instanceof
				___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default ||
				upper instanceof
				___R$project$rome$$romejs$js$analysis$types$AnyT_ts$default
			) {
				return ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
			}

			// Simple check for call stack limits
			if (
				this.compatibilityDepth >
				___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$MAX_DEPTH
			) {
				throw new Error(
					"Max depth exceeded when checking compatibility of " +
					lower.inspect() +
					" to " +
					upper.inspect(),
				);
			}

			const cached = lower.compatibilityCache.get(upper);
			if (cached === undefined) {
				lower.compatibilityCache.set(
					upper,
					{
						type: "incompatible",
						lower,
						upper,
					},
				);
			} else {
				return cached;
			}

			// Check this relationship for compatibility
			this.compatibilityDepth++;
			let ret;
			try {
				ret = lower.compatibleWith(upper);
			} catch (err) {
				if (
					err instanceof
					___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$ReduceRecursionError
				) {
					ret = ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
				} else {
					throw err;
				}
			} finally {
				this.compatibilityDepth--;
			}
			let res;
			if (ret === true) {
				res = ___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$TYPE_COMPATIBLE;
			} else if (ret === false) {
				res = {type: "incompatible", lower: a, upper: b};
			} else if (
				ret instanceof
				___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default
			) {
				res = {type: "incompatible", lower: a, upper: ret};
			} else {
				res = ret;
			}

			lower.compatibilityCache.set(upper, res);

			return res;
		}

		humanize(type) {
			this.assertClosed();

			return new ___R$project$rome$$romejs$js$analysis$Utils_ts$HumanBuilder().humanize(
				type,
			);
		}

		reduce(type) {
			//
			this.assertClosed();

			//
			const cached = this.reduceCache.get(type);
			if (cached !== undefined) {
				return cached;
			}

			// Check if we're already trying to reduce this node, in that case this is a recursion error
			if (this.reduceStack.has(type)) {
				//throw new ReduceRecursionError(`Reduce recursion error for ${this.inspect(type, true)}`);
				return new ___R$project$rome$$romejs$js$analysis$types$UnknownT_ts$default(
					type.scope,
					type.originNode,
				);
			}

			//
			if (
				this.reduceStack.size >
				___R$$priv$project$rome$$romejs$js$analysis$Utils_ts$MAX_DEPTH
			) {
				throw new Error("Max depth exceeded when reducing");
			}

			this.reduceStack.add(type);

			if (this.reduceCatchers.size) {
				for (const set of this.reduceCatchers) {
					set.add(type);
				}
			}

			try {
				const reduced = type.reduce();

				if (reduced === undefined) {
					throw new Error(
						"The reduce() method for " +
						this.inspect(type, true) +
						" returned null",
					);
				}

				if (reduced.getConstructor().type === "OpenT") {
					throw new Error(
						"The reduce() method for " +
						this.inspect(type, true) +
						" returned an OpenT. This should never be possible. It likely forgot to return utils.reduce() on it.",
					);
				}

				if (this.debug === false) {
					this.reduceCache.set(type, reduced);
				}

				return reduced;
			} finally {
				this.reduceStack.delete(type);
			}
		}

		reduceCatch(type) {
			const involved = new Set();
			this.reduceCatchers.add(involved);

			const final = this.reduce(type);
			this.reduceCatchers.delete(involved);

			return {final, involved};
		}
	}


  // project-rome/@romejs/js-analysis/Hub.ts
const ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses = {
		OPEN: 0,
		CLOSING: 1,
		CLOSED: 2,
	};



	class ___R$project$rome$$romejs$js$analysis$Hub_ts$default {
		constructor(ast, project) {
			this.context = new ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default({
				// TODO
				sourceText: "",
				ast,
				project,
				origin: {
					category: "typeChecking",
				},
			});
			this.utils = new ___R$project$rome$$romejs$js$analysis$Utils_ts$default(
				this,
			);
			this.graph = new ___R$project$rome$$romejs$js$analysis$Graph_ts$default();
			this.evaluator = new ___R$project$rome$$romejs$js$analysis$Evaluator_ts$default(
				this,
				ast.filename,
			);
			this.status = ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.OPEN;
		}

		close() {
			this.status = ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.CLOSING;

			for (const [node] of this.graph.nodesByValue) {
				this.utils.reduce(node);
			}

			this.status = ___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.CLOSED;
		}

		isClosing() {
			return (
				this.status ===
				___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.CLOSING
			);
		}

		isOpen() {
			return (
				this.isClosing() ||
				this.status ===
				___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.OPEN
			);
		}

		isClosed() {
			return (
				this.isClosing() ||
				this.status ===
				___R$$priv$project$rome$$romejs$js$analysis$Hub_ts$statuses.CLOSED
			);
		}

		assertOpen() {
			if (this.isClosed() && this.isClosing() === false) {
				throw new Error(
					"This method can only be called when the graph has been open",
				);
			}
		}

		assertClosed() {
			if (this.isOpen() && this.isClosing() === false) {
				throw new Error(
					"This method can only be called when the graph has been closed",
				);
			}
		}
	}


  // project-rome/@romejs/js-analysis/api/buildGraph.ts
async function ___R$project$rome$$romejs$js$analysis$api$buildGraph_ts$default(
		opts,
	) {
		const {ast, connected, project, provider} = opts;

		const hub = new ___R$project$rome$$romejs$js$analysis$Hub_ts$default(
			ast,
			project,
		);
		const {evaluator} = hub;
		if (provider.libs !== undefined) {
			let body = [];
			for (const ast of provider.libs) {
				body = [...body, ...ast.body];
			}
			evaluator.seed(Object.assign({}, ast, {body}));
		}
		evaluator.seed(ast);

		// fetch imports
		if (connected) {
			// create graphs
			const graphs = new Map();
			async function getModuleSignature(source, relative) {
				const graphKey = relative + ":" + source;
				if (graphs.has(graphKey)) {
					// already prepared graph
					return graphs.get(graphKey);
				}

				// query the provider for the export types
				const graph = await provider.getExportTypes(relative, source);

				// check if the resolved graph even exists
				if (graph === undefined) {
					// TODO unknown module, create an error
					graphs.set(graphKey, undefined);
					return undefined;
				}

				// check if we've already initialised this graph before, in the case of different relative URLs
				if (graphs.has(graph.filename)) {
					// TODO this is pretty inefficient, we shouldn't even receive it
					const manager = graphs.get(graph.filename);
					graphs.set(graphKey, manager);
					return manager;
				}

				// create the graph
				const manager = evaluator.initModuleSignature(graph, getModuleSignature);
				graphs.set(graphKey, manager);
				graphs.set(graph.filename, manager);
				await manager.init();
				return manager;
			}

			// seed graphs
			const seedCache = new Set();
			await Promise.all(
				evaluator.imports.map(({source, relative}) => {
					const cacheKey = source + ":" + relative;
					if (seedCache.has(cacheKey)) {
						return undefined;
					}

					seedCache.add(cacheKey);
					return getModuleSignature(source, relative);
				}),
			);

			// link imports
			for (const {source, importedName, relative, type} of evaluator.imports) {
				const graphKey = relative + ":" + source;
				const graph = graphs.get(graphKey);
				if (graph === undefined) {
					// unknown module, an error would have been created in the initial graph prep
					continue;
				}

				if (importedName === undefined) {
					// nothing to link here!
					continue;
				}

				type.setAbsolute(graph.filename);
				graph.link(importedName, type);
			}
		}

		evaluator.intrinsics.link();
		hub.close();
		return hub;
	}


  // project-rome/@romejs/js-analysis/api/getModuleSignature.ts
const ___R$$priv$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$exportsCache = new WeakMap();

	async function ___R$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$default(
		opts,
	) {
		const {ast, provider} = opts;
		const {filename} = ast;

		if (filename.includes("node_modules")) {
			return {
				filename,
				exports: [],
				types: {},
			};
		}

		const cached = ___R$$priv$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$exportsCache.get(
			ast,
		);
		if (cached !== undefined) {
			return cached;
		}

		const {
			evaluator: {exports},
			utils,
		} = await ___R$project$rome$$romejs$js$analysis$api$buildGraph_ts$default({
			ast,
			project: opts.project,
			connected: false,
			provider,
		});
		const types = {};
		const exportMap = [];

		const added = new Set();

		function addType(type) {
			const reducedType = utils.reduce(type);
			if (added.has(reducedType)) {
				return reducedType.id;
			} else {
				added.add(reducedType);
			}

			// export errors as any types to suppress errors
			if (
				reducedType instanceof
				___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default
			) {
				types[reducedType.id] = {
					human: undefined,
					origin: reducedType.originLoc,
					type: "AnyT",
					data: {},
				};
				return reducedType.id;
			}

			const data = reducedType.serialize(addType);

			types[reducedType.id] = {
				human: reducedType.human,
				origin: reducedType.originLoc,
				type: reducedType.getConstructor().type,
				data,
			};
			return reducedType.id;
		}

		for (const def of exports) {
			if (def.type === "all") {
				exportMap.push({
					type: "all",
					source: def.source,
				});
			} else if (def.type === "local") {
				exportMap.push({
					type: "local",
					name: def.name,
					value: addType(def.value),
				});
			} else {
				throw new Error("unknown export def type");
			}
		}

		const result = {
			filename,
			exports: exportMap,
			types,
		};
		___R$$priv$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$exportsCache.set(
			ast,
			result,
		);
		return result;
	}


  // project-rome/@romejs/js-analysis/api/check.ts
async function ___R$project$rome$$romejs$js$analysis$api$check_ts$default(opts) {
		const hub = await ___R$project$rome$$romejs$js$analysis$api$buildGraph_ts$default({
			ast: opts.ast,
			connected: true,
			provider: opts.provider,
			project: opts.project,
		});
		___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$resolveGraph(hub);
		return hub.context.diagnostics.getDiagnostics();
	}

	function ___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(t) {
		return (
			t !== undefined &&
			t instanceof
			___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default
		);
	}

	function ___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$resolveGraph(
		hub,
	) {
		const {graph, utils, context} = hub;

		// we track caught errors here as if a normal type returns a error in it's reduce() method

		// then it will be added to the graph, however we'd have already dealt with it
		const caughtErrors = new Set();

		for (const node of graph.nodes) {
			const lower = node.value;

			// unconnected node, we'll resolve these if they've been connected to any nodes
			if (
				lower instanceof
				___R$project$rome$$romejs$js$analysis$types$OpenT_ts$default
			) {
				continue;
			}

			// see if this reduces to a type error
			const reduced = utils.reduce(lower);
			if (
				reduced instanceof
				___R$project$rome$$romejs$js$analysis$types$errors$E_ts$default
			) {
				if (caughtErrors.has(reduced)) {
					continue;
				} else {
					caughtErrors.add(reduced);
				}

				let {description, lowerTarget, upperTarget} = reduced.getError();

				// ignore errors inside
				if (
					___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(
						lowerTarget,
					) ||
					___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(
						upperTarget,
					)
				) {
					continue;
				}

				let advice = [];

				if (upperTarget !== undefined) {
					const marker =
						upperTarget && !(upperTarget instanceof reduced.constructor)
							? utils.humanize(upperTarget)
							: undefined;
					const {originLoc} = upperTarget;

					if (originLoc !== undefined && marker !== undefined) {
						advice.push({
							type: "log",
							category: "info",
							text: marker,
						});
					} else if (originLoc !== undefined) {
						advice.push({
							type: "frame",
							location: {
								filename: originLoc.filename,
								start: originLoc.start,
								end: originLoc.end,
								marker,
							},
						});
					}
				}

				description = Object.assign(
					{},
					description,
					{advice: [...advice, ...description.advice]},
				);

				context.addNodeDiagnostic(
					lowerTarget.originNode,
					description,
					{
						marker: lowerTarget && !(lowerTarget instanceof reduced.constructor)
							? utils.humanize(lowerTarget)
							: undefined,
					},
				);
				continue;
			}

			// ignore unconnected nodes
			if (node.lines.length === 0) {
				continue;
			}

			for (const line of node.lines) {
				const upper = line.value;
				const compatibility = utils.checkCompability(upper, lower);

				if (compatibility.type === "incompatible") {
					// ignore associated errors, as they've already been handled
					if (
						___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(
							compatibility.lower,
						) ||
						___R$$priv$project$rome$$romejs$js$analysis$api$check_ts$isError(
							compatibility.upper,
						)
					) {
						continue;
					}

					context.addNodeDiagnostic(
						compatibility.lower.originNode,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TYPE_CHECK.INCOMPATIBILITY(
							utils.humanize(upper),
							upper.originLoc,
						),
						{
							marker: utils.humanize(compatibility.lower),
						},
					);
				}
			}
		}

		return context.diagnostics.getDiagnostics();
	}


  // project-rome/@romejs/js-analysis/types.ts
const ___R$project$rome$$romejs$js$analysis$types_ts = {};











  // project-rome/@romejs/js-analysis/index.ts
const ___R$project$rome$$romejs$js$analysis$index_ts = {
		get getModuleSignature() {
			return ___R$project$rome$$romejs$js$analysis$api$getModuleSignature_ts$default;
		},
		get buildGraph() {
			return ___R$project$rome$$romejs$js$analysis$api$buildGraph_ts$default;
		},
		get check() {
			return ___R$project$rome$$romejs$js$analysis$api$check_ts$default;
		},
	};
	Object.keys(___R$project$rome$$romejs$js$analysis$types$index_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$analysis$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$analysis$types$index_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$analysis$types_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$analysis$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$analysis$types_ts[key];
				},
			},
		);
	});


  // project-rome/@romejs/js-formatter/node/parentheses.ts
function ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isClassExtendsClause(
		node,
		parent,
	) {
		return (
			(parent.type === "ClassDeclaration" || parent.type === "ClassExpression") &&
			parent.meta.superClass === node
		);
	}

	const ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens = new Map();
	const ___R$project$rome$$romejs$js$formatter$node$parentheses_ts$default = ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens;
	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"TSAsExpression",
		() => true,
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"TSAssignmentAsExpression",
		() => true,
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"TSTypeAssertion",
		() => true,
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"MemberExpression",
		(node, parent) => {
			if (node.property.optional) {
				return (
					(parent.type === "CallExpression" && parent.callee === node) ||
					(parent.type === "MemberExpression" && parent.object === node)
				);
			} else {
				return false;
			}
		},
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"UpdateExpression",
		(node, parent) => {
			return (
				// (foo++).test(), (foo++)[0]
				(parent.type === "MemberExpression" && parent.object === node) ||
				// (foo++)()
				(parent.type === "CallExpression" && parent.callee === node) ||
				// new (foo++)()
				(parent.type === "NewExpression" && parent.callee === node) ||
				___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isClassExtendsClause(
					node,
					parent,
				)
			);
		},
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"ObjectExpression",
		(node, parent, printStack) => {
			return ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isFirstInStatement(
				printStack,
				{considerArrow: true},
			);
		},
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"DoExpression",
		(node, parent, printStack) => {
			return ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isFirstInStatement(
				printStack,
			);
		},
	);

	function ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenLogicalExpression(
		node,
		parent,
	) {
		if (
			node.operator === "**" &&
			parent.type === "BinaryExpression" &&
			parent.operator === "**"
		) {
			return parent.left === node;
		}

		// class A extends (B ?? C) {
		if (
			___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isClassExtendsClause(
				node,
				parent,
			)
		) {
			return true;
		}

		// (f ?? g)()
		// (f ?? g)?.()
		// new (A ?? B)()
		if (
			parent.type === "CallExpression" ||
			parent.type === "OptionalCallExpression" ||
			parent.type === "NewExpression"
		) {
			return parent.callee === node;
		}

		// ...(a ?? b)
		// await (a ?? b)
		if (
			___R$project$rome$$romejs$js$ast$utils$isUnaryLike_ts$default(parent) ||
			parent.type === "AwaitExpression"
		) {
			return true;
		}

		// (a ?? b).x
		// (a ?? b)?.x
		if (parent.type === "MemberExpression" && parent.object === node) {
			return true;
		}

		// (a ?? b) ?? c
		// a ?? (b ?? c)
		if (parent.type === "LogicalExpression") {
			if (node.type === "LogicalExpression") {
				return node.operator !== parent.operator;
			}
		}

		if (___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(parent)) {
			const parentOp = parent.operator;
			const parentPos = ___R$project$rome$$romejs$js$ast$utils$getPrecedence_ts$default(
				parentOp,
			);

			const nodeOp = node.operator;
			const nodePos = ___R$project$rome$$romejs$js$ast$utils$getPrecedence_ts$default(
				nodeOp,
			);

			if (
				// Logical expressions with the same precedence don't need parens.
				(parentPos === nodePos &&
				parent.right === node &&
				parent.type !== "LogicalExpression") ||
				parentPos > nodePos
			) {
				return true;
			}
		}

		return false;
	}

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"LogicalExpression",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenLogicalExpression,
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"BinaryExpression",
		(node, parent) => {
			// let i = (1 in []);
			// for ((1 in []);;);
			if (
				node.operator === "in" &&
				(parent.type === "VariableDeclarator" ||
				___R$project$rome$$romejs$js$ast$utils$isFor_ts$default(parent))
			) {
				return true;
			}

			return ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenLogicalExpression(
				node,
				parent,
			);
		},
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"SequenceExpression",
		(node, parent) => {
			if (
				// Although parentheses wouldn't hurt around sequence
				// expressions in the head of for loops, traditional style
				// dictates that e.g. i++, j++ should not be wrapped with
				// parentheses.
				parent.type === "ForStatement" ||
				parent.type === "ThrowStatement" ||
				parent.type === "ReturnStatement" ||
				(parent.type === "IfStatement" && parent.test === node) ||
				(parent.type === "WhileStatement" && parent.test === node) ||
				(parent.type === "ForInStatement" && parent.right === node) ||
				(parent.type === "SwitchStatement" && parent.discriminant === node) ||
				(parent.type === "ExpressionStatement" && parent.expression === node)
			) {
				return false;
			}

			// Arrow function builder handles the parens printing.
			if (parent.type === "ArrowFunctionExpression") {
				return false;
			}

			// Otherwise err on the side of overparenthesization, adding
			// explicit exceptions above if this proves overzealous.
			return true;
		},
	);

	function ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenYieldExpression(
		node,
		parent,
	) {
		return (
			___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(parent) ||
			___R$project$rome$$romejs$js$ast$utils$isUnaryLike_ts$default(parent) ||
			parent.type === "MemberExpression" ||
			(parent.type === "CallExpression" && parent.callee === node) ||
			(parent.type === "NewExpression" && parent.callee === node) ||
			(parent.type === "AwaitExpression" && node.type === "YieldExpression") ||
			(parent.type === "ConditionalExpression" && node === parent.test) ||
			___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isClassExtendsClause(
				node,
				parent,
			)
		);
	}

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"YieldExpression",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenYieldExpression,
	);
	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"AwaitExpression",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenYieldExpression,
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"OptionalCallExpression",
		(node, parent) => {
			return (
				(parent.type === "CallExpression" && parent.callee === node) ||
				(parent.type === "MemberExpression" && parent.object === node)
			);
		},
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"ClassExpression",
		(node, parent, printStack) => {
			return ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isFirstInStatement(
				printStack,
				{considerDefaultExports: true},
			);
		},
	);

	function ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenUnaryExpression(
		node,
		parent,
	) {
		return (
			(parent.type === "MemberExpression" && parent.object === node) ||
			(parent.type === "CallExpression" && parent.callee === node) ||
			(parent.type === "NewExpression" && parent.callee === node) ||
			(parent.type === "BinaryExpression" &&
			parent.operator === "**" &&
			parent.left === node) ||
			___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isClassExtendsClause(
				node,
				parent,
			)
		);
	}

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"UnaryExpression",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenUnaryExpression,
	);
	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"SpreadElement",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenUnaryExpression,
	);
	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"SpreadProperty",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenUnaryExpression,
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"FunctionExpression",
		(node, parent, printStack) => {
			return ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isFirstInStatement(
				printStack,
				{considerDefaultExports: true},
			);
		},
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"ArrowFunctionExpression",
		(node, parent) => {
			return (
				parent.type === "ExportLocalDeclaration" ||
				___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenConditionalExpression(
					node,
					parent,
				)
			);
		},
	);

	function ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenConditionalExpression(
		node,
		parent,
	) {
		if (
			___R$project$rome$$romejs$js$ast$utils$isUnaryLike_ts$default(parent) ||
			___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(parent) ||
			(parent.type === "ConditionalExpression" && parent.test === node) ||
			parent.type === "AwaitExpression" ||
			(parent.type === "MemberExpression" &&
			parent.object === node &&
			parent.property.optional) ||
			(parent.type === "OptionalCallExpression" && parent.callee === node) ||
			parent.type === "TaggedTemplateExpression" ||
			parent.type === "TSTypeAssertion" ||
			parent.type === "TSAsExpression"
		) {
			return true;
		}

		return ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenUnaryExpression(
			node,
			parent,
		);
	}

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"ConditionalExpression",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenConditionalExpression,
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"AssignmentExpression",
		(node, parent) => {
			if (node.left.type === "AssignmentObjectPattern") {
				return true;
			} else {
				return ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenConditionalExpression(
					node,
					parent,
				);
			}
		},
	);

	function ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenUnionTypeAnnotation(
		node,
		parent,
	) {
		return (
			parent.type === "TSIntersectionTypeAnnotation" ||
			parent.type === "UnionTypeAnnotation" ||
			parent.type === "TSArrayType" ||
			parent.type === "TSOptionalType"
		);
	}

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"UnionTypeAnnotation",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenUnionTypeAnnotation,
	);
	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"TSIntersectionTypeAnnotation",
		___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$needsParenUnionTypeAnnotation,
	);

	___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$parens.set(
		"TSInferType",
		(node, parent) => {
			return parent.type === "TSArrayType" || parent.type === "TSOptionalType";
		},
	);

	// Walk up the print stack to deterimine if our node can come first
	// in statement.
	function ___R$$priv$project$rome$$romejs$js$formatter$node$parentheses_ts$isFirstInStatement(
		printStack,
		{considerArrow = false, considerDefaultExports = false} = {},
	) {
		let i = printStack.length - 1;
		let node = printStack[i];
		i--;
		let parent = printStack[i];
		while (i > 0) {
			if (
				(parent.type === "ExpressionStatement" && parent.expression === node) ||
				parent.type === "TaggedTemplateExpression" ||
				(considerDefaultExports &&
				parent.type === "ExportDefaultDeclaration" &&
				parent.declaration === node) ||
				(considerArrow &&
				parent.type === "ArrowFunctionExpression" &&
				parent.body === node)
			) {
				return true;
			}

			if (
				(parent.type === "CallExpression" && parent.callee === node) ||
				(parent.type === "SequenceExpression" && parent.expressions[0] === node) ||
				(parent.type === "MemberExpression" && parent.object === node) ||
				(___R$project$rome$$romejs$js$ast$utils$isConditional_ts$default(parent) &&
				parent.test === node) ||
				(___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(parent) &&
				parent.left === node) ||
				(parent.type === "AssignmentExpression" && parent.left === node)
			) {
				node = parent;
				i--;
				parent = printStack[i];
			} else {
				return false;
			}
		}

		return false;
	}


  // project-rome/@romejs/js-formatter/node/index.ts
const ___R$project$rome$$romejs$js$formatter$node$index_ts = {
		getLinesBetween: ___R$project$rome$$romejs$js$formatter$node$index_ts$getLinesBetween,
		needsParens: ___R$project$rome$$romejs$js$formatter$node$index_ts$needsParens,
		isOnSameLine: ___R$project$rome$$romejs$js$formatter$node$index_ts$isOnSameLine,
	};
	function ___R$$priv$project$rome$$romejs$js$formatter$node$index_ts$isOrHasCallExpression(
		node,
	) {
		if (node.type === "CallExpression") {
			return true;
		}

		if (node.type === "ComputedMemberProperty") {
			return ___R$$priv$project$rome$$romejs$js$formatter$node$index_ts$isOrHasCallExpression(
				node.value,
			);
		}

		if (node.type === "MemberExpression") {
			return (
				___R$$priv$project$rome$$romejs$js$formatter$node$index_ts$isOrHasCallExpression(
					node.object,
				) ||
				___R$$priv$project$rome$$romejs$js$formatter$node$index_ts$isOrHasCallExpression(
					node.property,
				)
			);
		}

		return false;
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$node$index_ts$orderLoc(
		a,
		b,
	) {
		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(a.end.index) <
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(b.start.index)
		) {
			return [a, b];
		} else {
			return [b, a];
		}
	}

	function ___R$project$rome$$romejs$js$formatter$node$index_ts$getLinesBetween(
		aNode,
		bNode,
	) {
		if (aNode.loc && bNode.loc) {
			const [a, b] = ___R$$priv$project$rome$$romejs$js$formatter$node$index_ts$orderLoc(
				aNode.loc,
				bNode.loc,
			);
			return (
				___R$project$rome$$romejs$ob1$index_ts$ob1Get1(b.start.line) -
				___R$project$rome$$romejs$ob1$index_ts$ob1Get1(a.end.line)
			);
		} else {
			return 0;
		}
	}

	function ___R$project$rome$$romejs$js$formatter$node$index_ts$needsParens(
		node,
		parent,
		printStack,
	) {
		if (!parent) {
			return false;
		}

		if (parent.type === "NewExpression" && parent.callee === node) {
			if (
				___R$$priv$project$rome$$romejs$js$formatter$node$index_ts$isOrHasCallExpression(
					node,
				)
			) {
				return true;
			}
		}

		const fn = ___R$project$rome$$romejs$js$formatter$node$parentheses_ts$default.get(
			node.type,
		);
		return fn ? fn(node, parent, printStack) : false;
	}

	function ___R$project$rome$$romejs$js$formatter$node$index_ts$isOnSameLine(
		aNode,
		bNode,
	) {
		if (aNode.loc && bNode.loc) {
			return aNode.loc.end.line === bNode.loc.start.line;
		} else {
			return false;
		}
	}


  // project-rome/@romejs/js-formatter/tokens.ts




















	const ___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace = {
		type: "Line",
		mode: "space",
	};

	const ___R$project$rome$$romejs$js$formatter$tokens_ts$softline = {
		type: "Line",
		mode: "soft",
	};

	const ___R$project$rome$$romejs$js$formatter$tokens_ts$hardline = {
		type: "Line",
		mode: "hard",
	};

	const ___R$project$rome$$romejs$js$formatter$tokens_ts$space = {
		type: "Space",
	};

	function ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
		contents,
		shouldBreak = false,
	) {
		return {
			type: "Group",
			contents,
			shouldBreak,
		};
	}

	function ___R$project$rome$$romejs$js$formatter$tokens_ts$comment(value) {
		return {
			type: "Comment",
			value,
		};
	}

	function ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(contents) {
		return {
			type: "Indent",
			contents,
		};
	}

	function ___R$project$rome$$romejs$js$formatter$tokens_ts$mark(loc, prop) {
		return {
			type: "PositionMarker",
			loc,
			prop,
		};
	}

	function ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(parts) {
		if (parts.length === 0) {
			return "";
		}

		if (parts.length === 1) {
			return parts[0];
		}

		return {
			type: "Concat",
			parts,
		};
	}

	function ___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(
		breakContents,
		flatContents,
	) {
		return {
			type: "IfBreak",
			breakContents,
			flatContents,
		};
	}

	function ___R$project$rome$$romejs$js$formatter$tokens_ts$join(
		separator,
		tokens,
	) {
		if (tokens.length === 0) {
			return "";
		}

		if (tokens.length === 1) {
			return tokens[0];
		}

		const parts = [];

		for (let i = 0; i < tokens.length; i++) {
			if (i > 0) {
				parts.push(separator);
			}
			parts.push(tokens[i]);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(parts);
	}

	function ___R$project$rome$$romejs$js$formatter$tokens_ts$lineSuffix(contents) {
		return {
			type: "LineSuffix",
			contents,
		};
	}


  // project-rome/@romejs/js-formatter/builders/comments.ts
function ___R$project$rome$$romejs$js$formatter$builders$comments_ts$hasInnerComments(
		node,
	) {
		return node.innerComments !== undefined && node.innerComments.length > 0;
	}

	function ___R$project$rome$$romejs$js$formatter$builders$comments_ts$printComment(
		node,
	) {
		switch (node.type) {
			case "CommentBlock": {
				const lines = node.value.split("\n");
				if (lines.every((line) => line.trimStart().charAt(0) === "*")) {
					return ___R$project$rome$$romejs$js$formatter$tokens_ts$comment(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							"/*",
							___R$project$rome$$romejs$js$formatter$tokens_ts$join(
								___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
								lines.map((line, index) =>
									index === 0
										? line.trimEnd()
										: " " +
											(index < lines.length - 1 ? line.trim() : line.trimStart())
								),
							),
							"*/",
						]),
					);
				} else {
					return ___R$project$rome$$romejs$js$formatter$tokens_ts$comment(
						"/*" + node.value + "*/",
					);
				}
			}

			case "CommentLine": {
				return ___R$project$rome$$romejs$js$formatter$tokens_ts$comment(
					"//" + node.value.trimEnd(),
				);
			}
		}
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$builders$comments_ts$printCommentSeparator(
		left,
		right,
	) {
		const linesBetween = ___R$project$rome$$romejs$js$formatter$node$index_ts$getLinesBetween(
			left,
			right,
		);
		return linesBetween === 0
			? ___R$project$rome$$romejs$js$formatter$tokens_ts$space
			: linesBetween === 1
				? ___R$project$rome$$romejs$js$formatter$tokens_ts$hardline
				: ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
						___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
					]);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$comments_ts$printLeadingComment(
		node,
		next,
	) {
		const comment = ___R$project$rome$$romejs$js$formatter$builders$comments_ts$printComment(
			node,
		);
		if (node.type === "CommentLine") {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				comment,
				___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
			]);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				comment,
				___R$$priv$project$rome$$romejs$js$formatter$builders$comments_ts$printCommentSeparator(
					node,
					next,
				),
			]);
		}
	}

	function ___R$project$rome$$romejs$js$formatter$builders$comments_ts$printTrailingComment(
		node,
		previous,
	) {
		const comment = ___R$project$rome$$romejs$js$formatter$builders$comments_ts$printComment(
			node,
		);
		const linesBetween = ___R$project$rome$$romejs$js$formatter$node$index_ts$getLinesBetween(
			previous,
			node,
		);

		if (linesBetween >= 1) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$lineSuffix(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					linesBetween > 1
						? ___R$project$rome$$romejs$js$formatter$tokens_ts$hardline
						: "",
					___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
					comment,
				]),
			);
		} else {
			if (node.type === "CommentBlock") {
				return ___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineSuffix(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$space,
							comment,
						]),
					),
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$space,
						comment,
					]),
				);
			} else {
				return ___R$project$rome$$romejs$js$formatter$tokens_ts$lineSuffix(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$space,
						comment,
					]),
				);
			}
		}
	}


  // project-rome/@romejs/js-formatter/builders/temp/AmbiguousFlowTypeCastExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$temp$AmbiguousFlowTypeCastExpression_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-formatter/builders/expressions/ArrayExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$ArrayExpression_ts$default(
		builder,
		node,
	) {
		const hasContents = node.elements.length > 0;
		const hasRest =
			(node.type === "BindingArrayPattern" ||
			node.type === "AssignmentArrayPattern") &&
			node.rest !== undefined;

		if (!hasContents && !hasRest) {
			if (
				___R$project$rome$$romejs$js$formatter$builders$comments_ts$hasInnerComments(
					node,
				)
			) {
				return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						"[",
						builder.tokenizeInnerComments(node, true),
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						"]",
					]),
				);
			} else {
				return "[]";
			}
		}

		const tokens = [];

		if (hasContents) {
			const elements = [];

			for (let i = 0; i < node.elements.length; i++) {
				const element = node.elements[i];
				const printed = builder.tokenize(element, node);

				if (i > 0 && builder.getLinesBetween(node.elements[i - 1], element) > 1) {
					elements.push(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
							printed,
						]),
					);
				} else {
					elements.push(printed);
				}
			}

			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$join(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						",",
						___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
					]),
					elements,
				),
			);

			if (hasRest) {
				tokens.push(
					",",
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
				);
			} else {
				// Add trailing comma
				tokens.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(","),
				);
			}
		}

		if (hasRest) {
			tokens.push("...", builder.tokenize((node).rest, node));
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"[",
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
					]),
				),
				___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
				"]",
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/ArrayHole.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$ArrayHole_ts$default(
		builder,
		node,
	) {
		return builder.tokenizeInnerComments(node, false);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/ArrowFunctionExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$ArrowFunctionExpression_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.head.async === true) {
			tokens.push("async");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		tokens.push(builder.tokenize(node.head, node));
		tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space, "=>");

		const body = builder.tokenize(node.body, node);

		// Keep these types of node on the line as the arrow
		if (
			node.body.type === "ArrayExpression" ||
			node.body.type === "ObjectExpression" ||
			node.body.type === "BlockStatement" ||
			node.body.type === "ArrowFunctionExpression"
		) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					body,
				]),
			);
		}

		if (node.body.type === "SequenceExpression") {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
				___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$space,
						"(",
						___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
							___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
								___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
								body,
							]),
						),
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						")",
					]),
				),
			]);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
				___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
							___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
								___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
								body,
							]),
						),
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
					]),
				),
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/patterns/AssignmentArrayPattern.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentArrayPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$expressions$ArrayExpression_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/patterns/BindingAssignmentPattern.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$BindingAssignmentPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.left, node),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"=",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.right, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/patterns/AssignmentAssignmentPattern.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentAssignmentPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$patterns$BindingAssignmentPattern_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/utils.ts
function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$buildLabelStatementBuilder(
		prefix,
	) {
		return (builder, node) => {
			const tokens = [prefix];

			if (node.label) {
				tokens.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					builder.tokenize(node.label, node),
				);
			}

			tokens.push(";");

			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		};
	}

	function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$buildThrowAndReturnStatementBuilder(
		prefix,
	) {
		return (builder, node) => {
			const tokens = [prefix];

			if (node.argument) {
				tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);

				if (
					node.argument.type === "BinaryExpression" ||
					node.argument.type === "LogicalExpression" ||
					node.argument.type === "SequenceExpression"
				) {
					tokens.push(
						___R$project$rome$$romejs$js$formatter$tokens_ts$group(
							___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
								___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak("("),
								___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
									___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
										___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
										builder.tokenize(node.argument, node),
									]),
								),
								___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
								___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(")"),
							]),
						),
					);
				} else {
					tokens.push(builder.tokenize(node.argument, node));
				}
			}

			tokens.push(";");

			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		};
	}

	function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printMethod(
		builder,
		node,
	) {
		const kind = node.kind;

		const tokens = [];

		if (kind === "method" && node.head.generator === true) {
			tokens.push("*");
		}

		if (kind === "get" || kind === "set") {
			tokens.push(kind);
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		if (node.head.async === true) {
			tokens.push("async");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		if (node.type === "TSDeclareMethod") {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
				builder.tokenize(node.head, node),
			]);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			builder.tokenize(node.key, node),
			builder.tokenize(node.head, node),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.body, node),
		]);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printBindingPatternParams(
		builder,
		node,
		params,
		rest,
	) {
		if (params.length === 0 && rest === undefined) {
			if (
				___R$project$rome$$romejs$js$formatter$builders$comments_ts$hasInnerComments(
					node,
				)
			) {
				return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"(",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
					")",
				]);
			} else {
				return "()";
			}
		}

		const tokens = [
			___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
			___R$project$rome$$romejs$js$formatter$tokens_ts$join(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					",",
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
				]),
				params.map((param) => builder.tokenize(param, node)),
			),
		];

		if (rest) {
			if (params.length > 0) {
				tokens.push(
					",",
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
				);
			}
			tokens.push("...", builder.tokenize(rest, node));
		}

		if (params.length > 0 && !rest) {
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(","));
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"(",
			___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			),
			___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
			")",
		]);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printTSBraced(
		builder,
		node,
		members,
	) {
		if (members.length === 0) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"{",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
					"}",
				]),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"{",
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
						___R$project$rome$$romejs$js$formatter$tokens_ts$join(
							___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
							members.map((member, index) => {
								const printed = builder.tokenize(member, node);
								if (
									index > 0 &&
									builder.getLinesBetween(members[index - 1], member) > 1
								) {
									return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
										___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
										printed,
									]);
								} else {
									return printed;
								}
							}),
						),
					]),
				),
				___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
				"}",
			]),
			true,
		);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printPatternMeta(
		builder,
		node,
		meta,
	) {
		if (builder.options.typeAnnotations && meta !== undefined) {
			const tokens = [];

			if (meta.optional) {
				tokens.push("?");
			}

			if (meta.typeAnnotation) {
				tokens.push(
					":",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					builder.tokenize(meta.typeAnnotation, node),
				);
			}

			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		} else {
			return "";
		}
	}

	function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printClause(
		builder,
		clause,
		parent,
	) {
		if (clause.type === "EmptyStatement") {
			return ";";
		}

		if (clause.type === "BlockStatement") {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(clause, parent),
			]);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
				builder.tokenize(clause, parent),
			]),
		);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printCommaList(
		builder,
		nodes,
		parent,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$join(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				",",
				___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
			]),
			nodes.map((node) => builder.tokenize(node, parent)),
		);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printAssignment(
		builder,
		node,
		left,
		operator,
		right,
	) {
		const canBreak =
			right.type === "BinaryExpression" ||
			right.type === "LogicalExpression" ||
			right.type === "SequenceExpression" ||
			(right.type === "ConditionalExpression" &&
			___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(right.test));

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				builder.tokenize(left, node),
				operator,
				canBreak
					? ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
							___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
								___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
									___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
									builder.tokenize(right, node),
								]),
							),
						)
					: ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$space,
							builder.tokenize(right, node),
						]),
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/AssignmentExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$AssignmentExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printAssignment(
			builder,
			node,
			node.left,
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				node.operator,
			]),
			node.right,
		);
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/Identifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$Identifier_ts$default(
		builder,
		node,
	) {
		return node.name;
	}


  // project-rome/@romejs/js-formatter/builders/patterns/AssignmentIdentifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentIdentifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$auxiliary$Identifier_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/objects/ObjectExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$objects$ObjectExpression_ts$default(
		builder,
		node,
	) {
		if (
			___R$project$rome$$romejs$js$formatter$builders$comments_ts$hasInnerComments(
				node,
			)
		) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"{",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
					"}",
				]),
			);
		}

		const tokens = [];
		const props = node.properties;

		tokens.push(
			___R$project$rome$$romejs$js$formatter$tokens_ts$join(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					",",
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
				]),
				props.map((prop, index) => {
					const printed = builder.tokenize(prop, node);
					if (index > 0 && builder.getLinesBetween(props[index - 1], prop) > 1) {
						return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
							printed,
						]);
					} else {
						return printed;
					}
				}),
			),
		);

		if (
			(node.type === "BindingObjectPattern" ||
			node.type === "AssignmentObjectPattern") &&
			node.rest !== undefined
		) {
			if (props.length > 0) {
				tokens.push(
					",",
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
				);
				if (builder.getLinesBetween(props[props.length - 1], node.rest) > 1) {
					tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$softline);
				}
			}

			tokens.push("...", builder.tokenize(node.rest, node));
		} else if (props.length > 0) {
			// Add trailing comma
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(","));
		}

		// If the first property is not one the same line as the opening brace,
		// the object is printed on multiple lines.
		const shouldBreak =
			node.loc !== undefined &&
			props.length > 0 &&
			props[0].loc !== undefined &&
			props[0].loc.start.line !== node.loc.start.line;

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"{",
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
					]),
				),
				___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
				"}",
			]),
			shouldBreak,
		);
	}


  // project-rome/@romejs/js-formatter/builders/patterns/AssignmentObjectPattern.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentObjectPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$objects$ObjectExpression_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/objects/ObjectProperty.ts
function ___R$$priv$project$rome$$romejs$js$formatter$builders$objects$ObjectProperty_ts$isShorthand(
		key,
		value,
	) {
		return (
			key.type === "StaticPropertyKey" &&
			key.value.type === "Identifier" &&
			(value.type === "ReferenceIdentifier" ||
			value.type === "BindingIdentifier" ||
			value.type === "AssignmentIdentifier") &&
			value.name === key.value.name
		);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$objects$ObjectProperty_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.key, node)];

		if (
			(node.value.type === "BindingAssignmentPattern" ||
			node.value.type === "AssignmentAssignmentPattern") &&
			___R$$priv$project$rome$$romejs$js$formatter$builders$objects$ObjectProperty_ts$isShorthand(
				node.key,
				node.value.left,
			)
		) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"=",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.value.right, node.value),
			]);
		} else if (
			___R$$priv$project$rome$$romejs$js$formatter$builders$objects$ObjectProperty_ts$isShorthand(
				node.key,
				node.value,
			)
		) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
				":",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.value, node),
			]);
		}
	}


  // project-rome/@romejs/js-formatter/builders/patterns/AssignmentObjectPatternProperty.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentObjectPatternProperty_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$objects$ObjectProperty_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/AwaitExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$AwaitExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"await",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.argument, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/literals/BigIntLiteral.ts
function ___R$project$rome$$romejs$js$formatter$builders$literals$BigIntLiteral_ts$default(
		builder,
		node,
	) {
		return node.value + "n";
	}


  // project-rome/@romejs/js-formatter/builders/expressions/BinaryExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$BinaryExpression_ts$default(
		builder,
		node,
		parent,
	) {
		const shouldNotGroup =
			(parent.type === "IfStatement" && parent.test === node) ||
			(parent.type === "DoWhileStatement" && parent.test === node) ||
			(parent.type === "WhileStatement" && parent.test === node) ||
			(parent.type === "SwitchStatement" && parent.discriminant === node);

		const parts = ___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$BinaryExpression_ts$printBinaryExpression(
			builder,
			node,
			parent,
			shouldNotGroup,
		);

		if (shouldNotGroup) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(parts);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(parts),
		);
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$BinaryExpression_ts$printBinaryExpression(
		builder,
		node,
		parent,
		shouldNotGroup,
	) {
		const parts = [];

		if (
			___R$project$rome$$romejs$js$ast$utils$isBinary_ts$default(node.left) &&
			___R$project$rome$$romejs$js$ast$utils$getPrecedence_ts$default(
				node.operator,
			) ===
			___R$project$rome$$romejs$js$ast$utils$getPrecedence_ts$default(
				node.left.operator,
			)
		) {
			var ___R$;
			___R$ = parts,
				___R$.push.apply(
					___R$,
					[
						...___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$BinaryExpression_ts$printBinaryExpression(
							builder,
							node.left,
							node,
							shouldNotGroup,
						),
					],
				);
		} else {
			parts.push(builder.tokenize(node.left, node));
		}

		// Inline object and array expressions:
		//   obj && {
		//   arr ?? [
		const shouldInline =
			node.type === "LogicalExpression" &&
			(node.right.type === "ArrayExpression" ||
			node.right.type === "ObjectExpression");

		const right = ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			node.operator,
			shouldInline
				? ___R$project$rome$$romejs$js$formatter$tokens_ts$space
				: ___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
			builder.tokenize(node.right, node),
		]);

		const shouldGroup =
			!shouldNotGroup &&
			node.type !== parent.type &&
			node.type !== node.left.type &&
			node.type !== node.right.type;

		parts.push(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				shouldGroup
					? ___R$project$rome$$romejs$js$formatter$tokens_ts$group(right)
					: right,
			]),
		);

		return parts;
	}


  // project-rome/@romejs/js-formatter/builders/patterns/BindingArrayPattern.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$BindingArrayPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$builders$expressions$ArrayExpression_ts$default(
				builder,
				node,
			),
			___R$project$rome$$romejs$js$formatter$builders$utils_ts$printPatternMeta(
				builder,
				node,
				node.meta,
			),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/patterns/BindingIdentifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$BindingIdentifier_ts$default(
		builder,
		node,
	) {
		if (node.name[0] === "*") {
			// Internal name
			return "";
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$builders$auxiliary$Identifier_ts$default(
				builder,
				node,
			),
			___R$project$rome$$romejs$js$formatter$builders$utils_ts$printPatternMeta(
				builder,
				node,
				node.meta,
			),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/patterns/BindingObjectPattern.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$BindingObjectPattern_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$builders$objects$ObjectExpression_ts$default(
				builder,
				node,
			),
			___R$project$rome$$romejs$js$formatter$builders$utils_ts$printPatternMeta(
				builder,
				node,
				node.meta,
			),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/patterns/BindingObjectPatternProperty.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$BindingObjectPatternProperty_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$objects$ObjectProperty_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/statements/BlockStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$BlockStatement_ts$default(
		builder,
		node,
		parent,
	) {
		const hasComments =
			node.innerComments !== undefined && node.innerComments.length > 0;
		const hasContents = node.body !== undefined && node.body.length > 0;
		const hasDirectives =
			node.directives !== undefined && node.directives.length > 0;

		if (
			!hasComments &&
			!hasContents &&
			!hasDirectives &&
			(parent.type === "ArrowFunctionExpression" ||
			parent.type === "ClassMethod" ||
			parent.type === "ClassPrivateMethod" ||
			parent.type === "DoWhileStatement" ||
			parent.type === "ForInStatement" ||
			parent.type === "ForOfStatement" ||
			parent.type === "ForStatement" ||
			parent.type === "FunctionDeclaration" ||
			parent.type === "FunctionExpression" ||
			parent.type === "ObjectMethod" ||
			parent.type === "SwitchStatement" ||
			parent.type === "WhileStatement")
		) {
			return "{}";
		}

		const tokens = ["{"];

		if (hasDirectives) {
			for (const directive of node.directives) {
				tokens.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
							builder.tokenize(directive, node),
						]),
					),
				);
			}
		}

		if (hasContents) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
						builder.tokenizeStatementList(node.body, node),
					]),
				),
			);
		}

		if (hasComments) {
			tokens.push(builder.tokenizeInnerComments(node, true));
		}

		tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$hardline, "}");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/literals/BooleanLiteral.ts
function ___R$project$rome$$romejs$js$formatter$builders$literals$BooleanLiteral_ts$default(
		builder,
		node,
	) {
		return node.value ? "true" : "false";
	}


  // project-rome/@romejs/js-formatter/builders/statements/BreakStatement.ts
const ___R$project$rome$$romejs$js$formatter$builders$statements$BreakStatement_ts$default = ___R$project$rome$$romejs$js$formatter$builders$utils_ts$buildLabelStatementBuilder(
		"break",
	);


  // project-rome/@romejs/js-formatter/builders/expressions/CallExpression.ts


	function ___R$project$rome$$romejs$js$formatter$builders$expressions$CallExpression_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.callee, node)];

		if (node.type === "OptionalCallExpression") {
			tokens.push("?.");
		}

		if (node.typeArguments) {
			tokens.push(builder.tokenize(node.typeArguments, node));
		}

		tokens.push(
			___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$CallExpression_ts$printArguments(
				builder,
				node,
			),
		);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$CallExpression_ts$printArguments(
		builder,
		node,
	) {
		if (node.arguments.length === 0) {
			if (
				___R$project$rome$$romejs$js$formatter$builders$comments_ts$hasInnerComments(
					node,
				)
			) {
				return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"(",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
					")",
				]);
			} else {
				return "()";
			}
		}

		if (node.arguments.length === 1) {
			const argument = node.arguments[0];
			if (
				argument.type === "ArrayExpression" ||
				argument.type === "ObjectExpression" ||
				___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(
					argument,
				)
			) {
				return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"(",
					builder.tokenize(argument, node),
					")",
				]);
			}
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"(",
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						___R$project$rome$$romejs$js$formatter$builders$utils_ts$printCommaList(
							builder,
							node.arguments,
							node,
						),
					]),
				),
				___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(","),
				___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
				")",
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/CatchClause.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$CatchClause_ts$default(
		builder,
		node,
	) {
		if (node.param) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"catch",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"(",
				builder.tokenize(node.param, node),
				") ",
				builder.tokenize(node.body, node),
			]);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"catch",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.body, node),
			]);
		}
	}


  // project-rome/@romejs/js-formatter/builders/classes/ClassDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$ClassDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = ["class"];

		if (node.id) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.id, node),
			);
		}

		tokens.push(
			builder.tokenize(node.meta, node),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"{",
		);

		if (
			___R$project$rome$$romejs$js$formatter$builders$comments_ts$hasInnerComments(
				node.meta,
			)
		) {
			tokens.push(
				builder.tokenizeInnerComments(node.meta, true),
				___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
			);
		}

		if (node.meta.body.length > 0) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
							builder.tokenizeStatementList(node.meta.body, node.meta),
						]),
					),
					___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
				]),
			);
		}

		tokens.push("}");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/classes/ClassExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$ClassExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$classes$ClassDeclaration_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/classes/ClassHead.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$ClassHead_ts$default(
		builder,
		node,
	) {
		const tokens = [];
		const tokenGroups = [];

		tokens.push(builder.tokenize(node.typeParameters, node));

		if (node.superClass) {
			tokenGroups.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
						"extends",
						___R$project$rome$$romejs$js$formatter$tokens_ts$space,
						builder.tokenize(node.superClass, node),
						builder.tokenize(node.superTypeParameters, node),
					]),
				),
			);
		}

		if (
			builder.options.typeAnnotations &&
			node.implements &&
			node.implements.length > 0
		) {
			tokenGroups.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
				"implements",
				___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
							___R$project$rome$$romejs$js$formatter$builders$utils_ts$printCommaList(
								builder,
								node.implements,
								node,
							),
						]),
					),
				),
			);
		}

		if (tokenGroups.length > 0) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokenGroups),
					),
				),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/classes/ClassMethod.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$ClassMethod_ts$default(
		builder,
		node,
	) {
		const printed = ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printMethod(
			builder,
			node,
		);

		if (node.meta.static === true) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"static",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				printed,
			]);
		} else {
			return printed;
		}
	}


  // project-rome/@romejs/js-formatter/builders/classes/ClassPrivateMethod.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$ClassPrivateMethod_ts$default(
		builder,
		node,
	) {
		const printed = ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printMethod(
			builder,
			node,
		);
		if (node.meta.static === true) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"static",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				printed,
			]);
		} else {
			return printed;
		}
	}


  // project-rome/@romejs/js-formatter/builders/classes/ClassPrivateProperty.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$ClassPrivateProperty_ts$default(
		builder,
		node,
	) {
		const tokens = [
			builder.tokenize(node.meta, node),
			builder.tokenize(node.key, node),
		];

		if (builder.options.typeAnnotations && node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		if (node.value) {
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
			tokens.push("=");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(node.value, node));
		}

		tokens.push(";");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@romejs/js-formatter/builders/classes/ClassProperty.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$ClassProperty_ts$default(
		builder,
		node,
	) {
		if (node.value === undefined && !builder.options.typeAnnotations) {
			// A ClassProperty with no value is a type annotation
			return "";
		}

		const tokens = [
			builder.tokenize(node.meta, node),
			builder.tokenize(node.key, node),
		];

		if (builder.options.typeAnnotations && node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		if (node.value) {
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
			tokens.push("=");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(node.value, node));
		}

		tokens.push(";");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@romejs/js-formatter/builders/classes/ClassPropertyMeta.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$ClassPropertyMeta_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (!builder.options.typeAnnotations) {
			if (node.accessibility) {
				tokens.push(node.accessibility);
			}

			if (node.readonly) {
				tokens.push(
					"readonly",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				);
			}

			if (node.abstract) {
				tokens.push(
					"abstract",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				);
			}
		}

		if (node.static) {
			tokens.push(
				"static",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/core/CommentBlock.ts
function ___R$project$rome$$romejs$js$formatter$builders$core$CommentBlock_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-formatter/builders/core/CommentLine.ts
function ___R$project$rome$$romejs$js$formatter$builders$core$CommentLine_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/ComputedMemberProperty.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$ComputedMemberProperty_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.optional) {
			tokens.push("?.");
		}

		tokens.push("[", builder.tokenize(node.value, node), "]");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/objects/ComputedPropertyKey.ts
function ___R$project$rome$$romejs$js$formatter$builders$objects$ComputedPropertyKey_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"[",
			builder.tokenize(node.value, node),
			"]",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/ConditionalExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$printConditionalExpression(
			builder.tokenize(node.test, node),
			builder.tokenize(node.consequent, node),
			builder.tokenize(node.alternate, node),
			parent,
			node.consequent,
			node.alternate,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$isConditionalExpression(
		node,
	) {
		return (
			node.type === "ConditionalExpression" || node.type === "TSConditionalType"
		);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$printConditionalExpression(
		test,
		consequent,
		alternate,
		parentNode,
		consequentNode,
		alternateNode,
	) {
		const printed = ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			test,
			___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
					"?",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$isConditionalExpression(
						consequentNode,
					)
						? consequent
						: ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
								consequent,
							),
				]),
			),
			___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
					":",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$isConditionalExpression(
						alternateNode,
					)
						? alternate
						: ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(alternate),
				]),
			),
		]);

		// Do not group nested conditional expressions. By doing so, if a conditional
		// expression breaks, the hole chain breaks.
		return ___R$$priv$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$isConditionalExpression(
			parentNode,
		)
			? printed
			: ___R$project$rome$$romejs$js$formatter$tokens_ts$group(printed);
	}


  // project-rome/@romejs/js-formatter/builders/statements/ContinueStatement.ts
const ___R$project$rome$$romejs$js$formatter$builders$statements$ContinueStatement_ts$default = ___R$project$rome$$romejs$js$formatter$builders$utils_ts$buildLabelStatementBuilder(
		"continue",
	);


  // project-rome/@romejs/js-formatter/builders/statements/DebuggerStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$DebuggerStatement_ts$default() {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"debugger",
			";",
		]);
	}


  // project-rome/@romejs/js-parser/options.ts






	const ___R$$priv$project$rome$$romejs$js$parser$options_ts$DEFAULT_USER_OPTIONS = {
		// I want to kill this option very badly
		allowReturnOutsideFunction: false,
		// Source type ("template", "script" or "module") for different semantics
		sourceType: "script",
		// Whether we should be tracking tokens when parsing this file
		// NOTE: This is memory-intensive
		tokens: false,
		syntax: [],
		manifestPath: "package.json",
	};

	// Interpret and default an options object
	function ___R$project$rome$$romejs$js$parser$options_ts$normalizeOptions(opts) {
		return Object.assign(
			{},
			___R$$priv$project$rome$$romejs$js$parser$options_ts$DEFAULT_USER_OPTIONS,
			opts,
		);
	}


  // project-rome/@romejs/js-parser/xhtmlEntities.ts
const ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts = {
		get xhtmlEntityNameToChar() {
			return ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar;
		},
		get xhtmlEntityCharToName() {
			return ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName;
		},
		escapeXHTMLEntities: ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities,
	};
	const ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar = {
		quot: '"',
		amp: "&",
		apos: "'",
		lt: "<",
		gt: ">",
		nbsp: "\xa0",
		iexcl: "\xa1",
		cent: "\xa2",
		pound: "\xa3",
		curren: "\xa4",
		yen: "\xa5",
		brvbar: "\xa6",
		sect: "\xa7",
		uml: "\xa8",
		copy: "\xa9",
		ordf: "\xaa",
		laquo: "\xab",
		not: "\xac",
		shy: "\xad",
		reg: "\xae",
		macr: "\xaf",
		deg: "\xb0",
		plusmn: "\xb1",
		sup2: "\xb2",
		sup3: "\xb3",
		acute: "\xb4",
		micro: "\xb5",
		para: "\xb6",
		middot: "\xb7",
		cedil: "\xb8",
		sup1: "\xb9",
		ordm: "\xba",
		raquo: "\xbb",
		frac14: "\xbc",
		frac12: "\xbd",
		frac34: "\xbe",
		iquest: "\xbf",
		Agrave: "\xc0",
		Aacute: "\xc1",
		Acirc: "\xc2",
		Atilde: "\xc3",
		Auml: "\xc4",
		Aring: "\xc5",
		AElig: "\xc6",
		Ccedil: "\xc7",
		Egrave: "\xc8",
		Eacute: "\xc9",
		Ecirc: "\xca",
		Euml: "\xcb",
		Igrave: "\xcc",
		Iacute: "\xcd",
		Icirc: "\xce",
		Iuml: "\xcf",
		ETH: "\xd0",
		Ntilde: "\xd1",
		Ograve: "\xd2",
		Oacute: "\xd3",
		Ocirc: "\xd4",
		Otilde: "\xd5",
		Ouml: "\xd6",
		times: "\xd7",
		Oslash: "\xd8",
		Ugrave: "\xd9",
		Uacute: "\xda",
		Ucirc: "\xdb",
		Uuml: "\xdc",
		Yacute: "\xdd",
		THORN: "\xde",
		szlig: "\xdf",
		agrave: "\xe0",
		aacute: "\xe1",
		acirc: "\xe2",
		atilde: "\xe3",
		auml: "\xe4",
		aring: "\xe5",
		aelig: "\xe6",
		ccedil: "\xe7",
		egrave: "\xe8",
		eacute: "\xe9",
		ecirc: "\xea",
		euml: "\xeb",
		igrave: "\xec",
		iacute: "\xed",
		icirc: "\xee",
		iuml: "\xef",
		eth: "\xf0",
		ntilde: "\xf1",
		ograve: "\xf2",
		oacute: "\xf3",
		ocirc: "\xf4",
		otilde: "\xf5",
		ouml: "\xf6",
		divide: "\xf7",
		oslash: "\xf8",
		ugrave: "\xf9",
		uacute: "\xfa",
		ucirc: "\xfb",
		uuml: "\xfc",
		yacute: "\xfd",
		thorn: "\xfe",
		yuml: "\xff",
		OElig: "\u0152",
		oelig: "\u0153",
		Scaron: "\u0160",
		scaron: "\u0161",
		Yuml: "\u0178",
		fnof: "\u0192",
		circ: "\u02c6",
		tilde: "\u02dc",
		Alpha: "\u0391",
		Beta: "\u0392",
		Gamma: "\u0393",
		Delta: "\u0394",
		Epsilon: "\u0395",
		Zeta: "\u0396",
		Eta: "\u0397",
		Theta: "\u0398",
		Iota: "\u0399",
		Kappa: "\u039a",
		Lambda: "\u039b",
		Mu: "\u039c",
		Nu: "\u039d",
		Xi: "\u039e",
		Omicron: "\u039f",
		Pi: "\u03a0",
		Rho: "\u03a1",
		Sigma: "\u03a3",
		Tau: "\u03a4",
		Upsilon: "\u03a5",
		Phi: "\u03a6",
		Chi: "\u03a7",
		Psi: "\u03a8",
		Omega: "\u03a9",
		alpha: "\u03b1",
		beta: "\u03b2",
		gamma: "\u03b3",
		delta: "\u03b4",
		epsilon: "\u03b5",
		zeta: "\u03b6",
		eta: "\u03b7",
		theta: "\u03b8",
		iota: "\u03b9",
		kappa: "\u03ba",
		lambda: "\u03bb",
		mu: "\u03bc",
		nu: "\u03bd",
		xi: "\u03be",
		omicron: "\u03bf",
		pi: "\u03c0",
		rho: "\u03c1",
		sigmaf: "\u03c2",
		sigma: "\u03c3",
		tau: "\u03c4",
		upsilon: "\u03c5",
		phi: "\u03c6",
		chi: "\u03c7",
		psi: "\u03c8",
		omega: "\u03c9",
		thetasym: "\u03d1",
		upsih: "\u03d2",
		piv: "\u03d6",
		ensp: "\u2002",
		emsp: "\u2003",
		thinsp: "\u2009",
		zwnj: "\u200c",
		zwj: "\u200d",
		lrm: "\u200e",
		rlm: "\u200f",
		ndash: "\u2013",
		mdash: "\u2014",
		lsquo: "\u2018",
		rsquo: "\u2019",
		sbquo: "\u201a",
		ldquo: "\u201c",
		rdquo: "\u201d",
		bdquo: "\u201e",
		dagger: "\u2020",
		Dagger: "\u2021",
		bull: "\u2022",
		hellip: "\u2026",
		permil: "\u2030",
		prime: "\u2032",
		Prime: "\u2033",
		lsaquo: "\u2039",
		rsaquo: "\u203a",
		oline: "\u203e",
		frasl: "\u2044",
		euro: "\u20ac",
		image: "\u2111",
		weierp: "\u2118",
		real: "\u211c",
		trade: "\u2122",
		alefsym: "\u2135",
		larr: "\u2190",
		uarr: "\u2191",
		rarr: "\u2192",
		darr: "\u2193",
		harr: "\u2194",
		crarr: "\u21b5",
		lArr: "\u21d0",
		uArr: "\u21d1",
		rArr: "\u21d2",
		dArr: "\u21d3",
		hArr: "\u21d4",
		forall: "\u2200",
		part: "\u2202",
		exist: "\u2203",
		empty: "\u2205",
		nabla: "\u2207",
		isin: "\u2208",
		notin: "\u2209",
		ni: "\u220b",
		prod: "\u220f",
		sum: "\u2211",
		minus: "\u2212",
		lowast: "\u2217",
		radic: "\u221a",
		prop: "\u221d",
		infin: "\u221e",
		ang: "\u2220",
		and: "\u2227",
		or: "\u2228",
		cap: "\u2229",
		cup: "\u222a",
		int: "\u222b",
		there4: "\u2234",
		sim: "\u223c",
		cong: "\u2245",
		asymp: "\u2248",
		ne: "\u2260",
		equiv: "\u2261",
		le: "\u2264",
		ge: "\u2265",
		sub: "\u2282",
		sup: "\u2283",
		nsub: "\u2284",
		sube: "\u2286",
		supe: "\u2287",
		oplus: "\u2295",
		otimes: "\u2297",
		perp: "\u22a5",
		sdot: "\u22c5",
		lceil: "\u2308",
		rceil: "\u2309",
		lfloor: "\u230a",
		rfloor: "\u230b",
		lang: "\u2329",
		rang: "\u232a",
		loz: "\u25ca",
		spades: "\u2660",
		clubs: "\u2663",
		hearts: "\u2665",
		diams: "\u2666",
	};

	const ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName = {

	};
	for (const key in ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar) {
		___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName[___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar[key]] = key;
	}

	function ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(
		value,
		only,
	) {
		let escaped = "";
		for (const char of value) {
			const entity = ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityCharToName[char];
			if (entity !== undefined && (only === undefined || only.includes(char))) {
				escaped += "&" + entity + ";";
			} else {
				escaped += char;
			}
		}
		return escaped;
	}


  // project-rome/@romejs/js-parser/tokenizer/types.ts
// ## Token types
	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.
	// All token type variables start with an underscore, to make them
	// easy to recognize.
	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr = true;
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr = true;
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isLoop = true;
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isAssign = true;
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix = true;
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$postfix = true;



	class ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType {
		constructor(label, conf = {}) {
			this.label = label;
			this.keyword = conf.keyword;
			this.beforeExpr = !!conf.beforeExpr;
			this.startsExpr = !!conf.startsExpr;
			this.rightAssociative = !!conf.rightAssociative;
			this.isLoop = !!conf.isLoop;
			this.isAssign = !!conf.isAssign;
			this.prefix = !!conf.prefix;
			this.postfix = !!conf.postfix;
			this.binop = typeof conf.binop === "number" ? conf.binop : undefined;
			this.updateContext = undefined;
		}

		getBinop() {
			const {binop} = this;
			if (binop === undefined) {
				throw new Error("Token " + this.label + " doesn't have a binop");
			}
			return binop;
		}
	}

	const ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$keywords = new Map();

	class ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType
		extends ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType {
		constructor(name, options = {}) {
			options.keyword = name;

			super(name, options);

			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$keywords.set(
				name,
				this,
			);
		}
	}

	class ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType
		extends ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType {
		constructor(name, prec) {
			super(
				name,
				{
					beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
					binop: prec,
				},
			);
		}
	}

	const ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types = {
		num: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"num",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		bigint: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"bigint",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		regexp: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"regexp",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		string: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"string",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		name: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"name",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		eof: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"eof",
		),
		invalid: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"invalid",
		),
		comment: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"comment",
		),
		// Punctuation token types.
		bracketL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"[",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		bracketR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"]",
		),
		braceL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"{",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		braceBarL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"{|",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		braceR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"}",
		),
		braceBarR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"|}",
		),
		parenL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"(",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		parenR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			")",
		),
		comma: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			",",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		semi: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			";",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		colon: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			":",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		doubleColon: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"::",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		dot: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			".",
		),
		question: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"?",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		questionDot: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"?.",
		),
		arrow: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"=>",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		template: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"template",
		),
		ellipsis: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"...",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		backQuote: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"`",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		dollarBraceL: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"${",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		at: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"@",
		),
		hash: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"#",
		),
		// Operators. These carry several kinds of properties to help the
		// parser use them properly (the presence of these properties is
		// what categorizes them as operators).
		//
		// `binop`, when present, specifies that this operator is a binary
		// operator, and will refer to its precedence.
		//
		// `prefix` and `postfix` mark the operator as a prefix or postfix
		// unary operator.
		//
		// `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
		// binary operators with a very low precedence, that should result
		// in AssignmentExpression nodes.
		eq: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"=",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				isAssign: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isAssign,
			},
		),
		assign: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"_=",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				isAssign: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isAssign,
			},
		),
		incDec: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"++/--",
			{
				prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix,
				postfix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$postfix,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		bang: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"!",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		tilde: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"~",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		nullishCoalescing: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"??",
			1,
		),
		logicalOR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"||",
			1,
		),
		logicalAND: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"&&",
			2,
		),
		bitwiseOR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"|",
			3,
		),
		bitwiseXOR: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"^",
			4,
		),
		bitwiseAND: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"&",
			5,
		),
		equality: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"==/!=",
			6,
		),
		relational: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"</>",
			7,
		),
		bitShift: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"<</>>",
			8,
		),
		plusMin: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"+/-",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				binop: 9,
				prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		modulo: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"%",
			10,
		),
		star: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"*",
			10,
		),
		slash: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$BinopTokenType(
			"/",
			10,
		),
		exponent: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"**",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				binop: 11,
				rightAssociative: true,
			},
		),
		jsxName: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"jsxName",
		),
		jsxText: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"jsxText",
			{beforeExpr: true},
		),
		jsxTagStart: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"jsxTagStart",
			{startsExpr: true},
		),
		jsxTagEnd: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$TokenType(
			"jsxTagEnd",
		),
		_break: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"break",
		),
		_case: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"case",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_catch: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"catch",
		),
		_continue: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"continue",
		),
		_debugger: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"debugger",
		),
		_default: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"default",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_do: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"do",
			{
				isLoop: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isLoop,
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_else: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"else",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_finally: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"finally",
		),
		_for: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"for",
			{
				isLoop: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isLoop,
			},
		),
		_function: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"function",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_if: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"if",
		),
		_return: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"return",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_switch: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"switch",
		),
		_throw: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"throw",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_try: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"try",
		),
		_var: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"var",
		),
		_const: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"const",
		),
		_while: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"while",
			{
				isLoop: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$isLoop,
			},
		),
		_with: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"with",
		),
		_new: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"new",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_this: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"this",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_super: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"super",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_class: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"class",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_extends: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"extends",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
			},
		),
		_export: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"export",
		),
		_import: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"import",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_null: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"null",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_true: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"true",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_false: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"false",
			{
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_in: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"in",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				binop: 7,
			},
		),
		_instanceof: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"instanceof",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				binop: 7,
			},
		),
		_typeof: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"typeof",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_void: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"void",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
		_delete: new ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$KeywordTokenType(
			"delete",
			{
				beforeExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$beforeExpr,
				prefix: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$prefix,
				startsExpr: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$types_ts$startsExpr,
			},
		),
	};




  // project-rome/@romejs/js-parser/tokenizer/context.ts


	class ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext {
		constructor(token, isExpr, preserveSpace, override) {
			this.token = token;
			this.isExpr = !!isExpr;
			this.preserveSpace = !!preserveSpace;
			this.override = override;
		}
	}

	const ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types = {
		braceStatement: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"{",
			false,
		),
		braceExpression: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"{",
			true,
		),
		templateQuasi: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"${",
			false,
		),
		parenStatement: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"(",
			false,
		),
		parenExpression: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"(",
			true,
		),
		template: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"`",
			true,
			true,
			(p) =>
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readTemplateToken(
					p,
				)
			,
		),
		functionExpression: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"function",
			true,
		),
		functionStatement: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"function",
			false,
		),
		// JSX
		jsxOpenTag: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"<tag",
			false,
		),
		jsxCloseTag: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"</tag",
			false,
		),
		jsxInner: new ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$TokContext(
			"<tag>...</tag>",
			true,
			true,
		),
	};

	// Token-specific context update code
	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR.updateContext = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR.updateContext = function(
		parser,
	) {
		if (parser.state.context.length === 1) {
			parser.state.exprAllowed = true;
			return;
		}

		let out = parser.state.context.pop();
		if (
			out ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement
		) {
			const context = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
				parser,
			);
			if (context !== undefined && context.token === "function") {
				out = parser.state.context.pop();
			}
		}

		if (out === undefined) {
			throw new Error("No context found");
		}

		parser.state.exprAllowed = !out.isExpr;
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name.updateContext = function(
		parser,
		prevType,
	) {
		let allowed = false;
		if (
			prevType !==
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot
		) {
			if (
				(parser.state.tokenValue === "of" && !parser.state.exprAllowed) ||
				(parser.state.tokenValue === "yield" && parser.inScope("GENERATOR"))
			) {
				allowed = true;
			}
		}

		parser.state.exprAllowed = allowed;

		if (parser.state.isIterator) {
			parser.state.isIterator = false;
		}
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL.updateContext = function(
		parser,
		prevType,
	) {
		parser.state.context.push(
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$isBraceBlock(
				parser,
				prevType,
			)
				? ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement
				: ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceExpression,
		);
		parser.state.exprAllowed = true;
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL.updateContext = function(
		parser,
	) {
		parser.state.context.push(
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.templateQuasi,
		);
		parser.state.exprAllowed = true;
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL.updateContext = function(
		parser,
		prevType,
	) {
		const statementParens =
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._if ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._for ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._with ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._while;
		parser.state.context.push(
			statementParens
				? ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.parenStatement
				: ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.parenExpression,
		);
		parser.state.exprAllowed = true;
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.incDec.updateContext = function() {
		// tokExprAllowed stays unchanged
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function.updateContext = function(
		parser,
		prevType,
	) {
		if (
			prevType.beforeExpr &&
			prevType !==
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi &&
			prevType !==
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._else &&
			!(prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._return &&
			___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
				parser.getRawInput(
					parser.state.lastEndPos.index,
					parser.state.startPos.index,
				),
			)) &&
			!((prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL) &&
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
				parser,
			) === ___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.bStat)
		) {
			parser.state.context.push(
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.functionExpression,
			);
		} else {
			parser.state.context.push(
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.functionStatement,
			);
		}

		parser.state.exprAllowed = false;
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class.updateContext = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function.updateContext;

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote.updateContext = function(
		parser,
	) {
		if (
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
				parser,
			) ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.template
		) {
			parser.state.context.pop();
		} else {
			parser.state.context.push(
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.template,
			);
		}
		parser.state.exprAllowed = false;
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart.updateContext = function(
		parser,
	) {
		parser.state.context.push(
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxInner,
		); // treat as beginning of JSX expression
		parser.state.context.push(
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag,
		); // start opening tag context
		parser.state.exprAllowed = false;
	};

	___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd.updateContext = function(
		parser,
		prevType,
	) {
		const out = parser.state.context.pop();
		if (
			(out ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag &&
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash) ||
			out ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag
		) {
			parser.state.context.pop();
			parser.state.exprAllowed =
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
					parser,
				) ===
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxInner;
		} else {
			parser.state.exprAllowed = true;
		}
	};


  // project-rome/@romejs/js-parser/parser/comments.ts
const ___R$project$rome$$romejs$js$parser$parser$comments_ts = {
		addComment: ___R$project$rome$$romejs$js$parser$parser$comments_ts$addComment,
		attachComments: ___R$project$rome$$romejs$js$parser$parser$comments_ts$attachComments,
	};
	function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(
		stack,
	) {
		return stack[stack.length - 1];
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getIds(
		comments,
	) {
		return comments.map((comment) => comment.id);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getLoc(
		node,
	) {
		const {loc} = node;
		if (loc === undefined) {
			throw new Error("No loc found");
		}
		return loc;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
		node,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getLoc(
			node,
		).start.index;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
		node,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getLoc(
			node,
		).end.index;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$hasComments(
		comments,
	) {
		return comments !== undefined && comments.length > 0;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$setComments(
		node,
		key,
		comments,
	) {
		let innerEndIndex = -1;

		for (let i = 0; i < comments.length; i++) {
			const comment = comments[i];
			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
					comment,
				) >=
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node) &&
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
					comment,
				) <=
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node)
			) {
				innerEndIndex++;
			} else {
				break;
			}
		}

		if (innerEndIndex === -1) {
			node[key] = ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getIds(
				comments,
			);
		} else {
			node.innerComments = ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getIds(
				comments.slice(0, innerEndIndex + 1),
			);
			node[key] = ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getIds(
				comments.slice(innerEndIndex + 1),
			);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$comments_ts$addComment(
		parser,
		comment,
	) {
		parser.state.trailingComments.push(comment);
		parser.state.leadingComments.push(comment);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
		parser,
		node,
		elements,
		// When the current node is followed by a token which hasn't a respective AST node, we
		// need to take all the trailing comments to prevent them from being attached to an
		// unrelated node. e.g. in
		//     var { x } /* cmt */ = { y }
		// we don't want /* cmt */ to be attached to { y }.
		// On the other hand, in
		//     fn(x) [new line] /* cmt */ [new line] y
		// /* cmt */ is both a trailing comment of fn(x) and a leading comment of y
		takeAllComments,
	) {
		if (parser.state.leadingComments.length === 0) {
			return;
		}

		let lastElement = undefined;
		let i = elements.length;
		while (lastElement === undefined && i > 0) {
			lastElement = elements[--i];
		}
		if (lastElement === undefined) {
			return;
		}

		const {commentPreviousNode} = parser.state;
		if (commentPreviousNode === undefined) {
			throw new Error("No commentPreviousNode found");
		}

		for (let j = 0; j < parser.state.leadingComments.length; j++) {
			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
					parser.state.leadingComments[j],
				) <
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
					commentPreviousNode,
				)
			) {
				parser.state.leadingComments.splice(j, 1);
				j--;
			}
		}

		const newTrailingComments = [];
		for (let i = 0; i < parser.state.leadingComments.length; i++) {
			const leadingComment = parser.state.leadingComments[i];
			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
					leadingComment,
				) <
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node)
			) {
				newTrailingComments.push(leadingComment);

				// Perf: we don't need to splice if we are going to reset the array anyway
				if (!takeAllComments) {
					parser.state.leadingComments.splice(i, 1);
					i--;
				}
			} else {
				if (node.trailingComments === undefined) {
					node.trailingComments = [];
				}
				node.trailingComments.push(leadingComment.id);
			}
		}
		if (takeAllComments) {
			parser.state.leadingComments = [];
		}

		if (newTrailingComments.length > 0) {
			lastElement.trailingComments = ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$getIds(
				newTrailingComments,
			);
		} else if (lastElement.trailingComments !== undefined) {
			lastElement.trailingComments = [];
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$comments_ts$attachComments(
		parser,
		node,
	) {
		if (node.type === "Program" && node.body.length > 0) {
			return;
		}

		const {commentStack, commentPreviousNode} = parser.state;

		let trailingComments;

		if (parser.state.trailingComments.length > 0) {
			// If the first comment in trailingComments comes after the
			// current node, then we're good - all comments in the array will
			// come after the node and so it's safe to add them as official
			// trailingComments.
			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
					parser.state.trailingComments[0],
				) >=
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node)
			) {
				trailingComments = parser.state.trailingComments;
				parser.state.trailingComments = [];
			} else {
				// Otherwise, if the first comment doesn't come after the
				// current node, that means we have a mix of leading and trailing
				// comments in the array and that leadingComments contains the
				// same items as trailingComments. Reset trailingComments to
				// zero items and we'll handle this by evaluating leadingComments
				// later.
				parser.state.trailingComments = [];
			}
		} else if (commentStack.length > 0) {
			const lastInStack = ___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(
				commentStack,
			);
			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$hasComments(
					lastInStack.trailingComments,
				) &&
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
					parser.comments.assertGetCommentFromId(
						lastInStack.trailingComments[0],
					),
				) >=
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(node)
			) {
				trailingComments = parser.comments.getCommentsFromIds(
					lastInStack.trailingComments,
				);
				lastInStack.trailingComments = undefined;
			}
		}

		// Eating the stack.
		let firstChild;
		if (
			commentStack.length > 0 &&
			___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(
					commentStack,
				),
			) >=
			___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node)
		) {
			firstChild = commentStack.pop();
		}

		let lastChild;
		while (
			commentStack.length > 0 &&
			___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(
					commentStack,
				),
			) >=
			___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node)
		) {
			lastChild = commentStack.pop();
		}

		if (!lastChild && firstChild) {
			lastChild = firstChild;
		}

		// Adjust comments that follow a trailing comma on the last element in a
		// comma separated list of nodes to be the trailing comments on the last
		// element
		if (firstChild) {
			switch (node.type) {
				case "ObjectExpression": {
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.properties,
					);
					break;
				}

				case "BindingObjectPattern":
				case "AssignmentObjectPattern": {
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.properties,
						true,
					);
					break;
				}

				case "CallExpression": {
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.arguments,
					);
					break;
				}

				case "ArrayExpression": {
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.elements,
					);
					break;
				}

				case "BindingArrayPattern":
				case "AssignmentArrayPattern": {
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
						parser,
						node,
						node.elements,
						true,
					);
					break;
				}
			}
		} else if (
			commentPreviousNode !== undefined &&
			((commentPreviousNode.type === "ImportSpecifier" &&
			node.type !== "ImportSpecifier") ||
			(commentPreviousNode.type === "ExportLocalSpecifier" &&
			node.type !== "ExportExternalSpecifier") ||
			(commentPreviousNode.type === "ExportExternalSpecifier" &&
			node.type !== "ExportExternalSpecifier"))
		) {
			___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$adjustCommentsAfterTrailingComma(
				parser,
				node,
				[parser.state.commentPreviousNode],
			);
		}

		if (lastChild !== undefined) {
			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$hasComments(
					lastChild.leadingComments,
				)
			) {
				if (
					lastChild !== node &&
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
						parser.comments.assertGetCommentFromId(
							___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(
								lastChild.leadingComments,
							),
						),
					) <=
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
						node,
					)
				) {
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$setComments(
						node,
						"leadingComments",
						parser.comments.getCommentsFromIds(lastChild.leadingComments),
					);
					lastChild.leadingComments = undefined;
				} else {
					// A leading comment for an anonymous class had been stolen by its first ClassMethod,
					// so this takes back the leading comment.
					// See also: https://github.com/eslint/espree/issues/158
					for (let i = lastChild.leadingComments.length - 2; i >= 0; --i) {
						if (
							___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
								parser.comments.assertGetCommentFromId(
									lastChild.leadingComments[i],
								),
							) <=
							___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
								node,
							)
						) {
							___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$setComments(
								node,
								"leadingComments",
								parser.comments.getCommentsFromIds(
									lastChild.leadingComments.splice(0, i + 1),
								),
							);
							break;
						}
					}
				}
			}
		} else if (parser.state.leadingComments.length > 0) {
			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$last(
						parser.state.leadingComments,
					),
				) <=
				___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(node)
			) {
				if (parser.state.commentPreviousNode) {
					for (let j = 0; j < parser.state.leadingComments.length; j++) {
						if (
							___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
								parser.state.leadingComments[j],
							) <
							___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
								parser.state.commentPreviousNode,
							)
						) {
							parser.state.leadingComments.splice(j, 1);
							j--;
						}
					}
				}

				if (parser.state.leadingComments.length > 0) {
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$setComments(
						node,
						"leadingComments",
						parser.state.leadingComments,
					);
					parser.state.leadingComments = [];
				}
			} else {
				// https://github.com/eslint/espree/issues/2
				//
				// In special cases, such as return (without a value) and
				// debugger, all comments will end up as leadingComments and
				// will otherwise be eliminated. This step runs when the
				// commentStack is empty and there are comments left
				// in leadingComments.
				//
				// This loop figures out the stopping point between the actual
				// leading and trailing comments by finding the location of the
				// first comment that comes after the given node.
				let i = 0;
				while (i < parser.state.leadingComments.length) {
					if (
						___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$end(
							parser.state.leadingComments[i],
						) >
						___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$start(
							node,
						)
					) {
						break;
					} else {
						i++;
					}
				}

				// Split the array based on the location of the first comment
				// that comes after the node. Keep in mind that this could
				// result in an empty array, and if so, the array must be
				// deleted.

				const leadingComments = parser.state.leadingComments.slice(0, i);

				if (leadingComments.length > 0) {
					___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$setComments(
						node,
						"leadingComments",
						leadingComments,
					);
				}

				// Similarly, trailing comments are attached later. The variable
				// must be reset to null if there are no trailing comments.
				trailingComments = parser.state.leadingComments.slice(i);
				if (trailingComments.length === 0) {
					trailingComments = undefined;
				}
			}
		}

		parser.state.commentPreviousNode = node;

		if (trailingComments) {
			___R$$priv$project$rome$$romejs$js$parser$parser$comments_ts$setComments(
				node,
				"trailingComments",
				trailingComments,
			);
		}

		commentStack.push(node);
	}


  // project-rome/@romejs/js-parser/parser/statement.ts
const ___R$project$rome$$romejs$js$parser$parser$statement_ts = {
		parseTopLevel: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTopLevel,
		parsePossibleInterpreterDirective: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective,
		expressionStatementToDirective: ___R$project$rome$$romejs$js$parser$parser$statement_ts$expressionStatementToDirective,
		isLetStart: ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart,
		parseStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement,
		isAsyncFunctionDeclarationStart: ___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart,
		assertModuleNodeAllowed: ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed,
		parseBreakContinueStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement,
		parseDebuggerStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDebuggerStatement,
		parseDoStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDoStatement,
		parseForStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForStatement,
		assertVarKind: ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind,
		parseIfStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseIfStatement,
		parseReturnStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseReturnStatement,
		parseSwitchStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseSwitchStatement,
		parseThrowStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseThrowStatement,
		parseTryStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTryStatement,
		parseVarStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarStatement,
		parseWhileStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWhileStatement,
		parseWithStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWithStatement,
		parseEmptyStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseEmptyStatement,
		parseLabeledStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseLabeledStatement,
		parseExpressionStatement: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExpressionStatement,
		parseBlock: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock,
		isValidDirective: ___R$project$rome$$romejs$js$parser$parser$statement_ts$isValidDirective,
		parseBlockBody: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockBody,
		parseBlockOrModuleBlockBody: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody,
		parseFor: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor,
		parseForIn: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForIn,
		parseVar: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVar,
		parseVarHead: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarHead,
		parseFunctionDeclaration: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration,
		parseExportDefaultFunctionDeclaration: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration,
		parseFunctionExpression: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionExpression,
		parseFunction: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction,
		splitFunctionParams: ___R$project$rome$$romejs$js$parser$parser$statement_ts$splitFunctionParams,
		parseFunctionParams: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams,
	};
	const ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$loopLabel = {
		kind: "loop",
	};
	const ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$switchLabel = {
		kind: "switch",
	};

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTopLevel(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = {
			name: "top-level",
			start,
			indent: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			open: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
			close: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
		};

		// Parse the body, and catch fatal syntax errors

		// Get the first token
		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);

		const interpreter = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective(
			parser,
		);
		const {body, directives} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockBody(
			parser,
			true,
			true,
			openContext,
		);

		return parser.finishNode(
			start,
			{
				type: "Program",
				corrupt: parser.state.corrupt,
				body,
				directives,
				mtime: parser.mtime,
				diagnostics: parser.getDiagnostics(),
				filename: parser.filename,
				comments: parser.state.comments,
				sourceType: parser.sourceType,
				interpreter,
				syntax: Array.from(parser.syntax),
				hasHoistedVars: parser.state.hasHoistedVars,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parsePossibleInterpreterDirective(
		parser,
	) {
		// Check for #!
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.hash,
			) &&
			parser.input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				parser.state.endPos.index,
			)] === "!"
		) {
			const directive = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipInterpreterDirective(
				parser,
				1,
			);

			// Advance to next token
			parser.next();

			return directive;
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$expressionStatementToDirective(
		parser,
		stmt,
	) {
		const expr = stmt.expression;

		const start = parser.getLoc(stmt).start;

		const raw = parser.getRawInput(
			parser.getLoc(expr).start.index,
			parser.getLoc(expr).end.index,
		);
		const val = raw.slice(1, -1); // remove quotes
		const end = parser.getLoc(stmt).end;

		return parser.finishNodeAt(
			start,
			end,
			{
				type: "Directive",
				value: val,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(
		parser,
		context,
	) {
		if (!parser.isContextual("let")) {
			return false;
		}

		___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.lastIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
			parser.state.index,
		);
		const skip = ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.exec(
			parser.input,
		);
		if (skip == null) {
			throw new Error("Should never be true");
		}

		const next = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
			parser.state.index,
			skip[0].length,
		);
		const nextCh = parser.input.charCodeAt(
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(next),
		);

		// For ambiguous cases, determine if a LexicalDeclaration (or only a

		// Statement) is allowed here. If context is not empty then only a Statement

		// is allowed. However, `let [` is an explicit negative lookahead for

		// ExpressionStatement, so special-case it first.
		if (
			nextCh ===
			___R$project$rome$$romejs$string$charcodes$index_ts.leftSquareBracket
		) {
			return true;
		}

		if (context !== undefined) {
			return false;
		}

		if (
			nextCh ===
			___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace
		) {
			return true;
		}

		if (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(
				nextCh,
			)
		) {
			let pos = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(next, 1);
			while (
				___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(
					parser.input.charCodeAt(
						___R$project$rome$$romejs$ob1$index_ts$ob1Get0(pos),
					),
				)
			) {
				pos = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(pos);
			}

			const ident = parser.getRawInput(next, pos);
			if (
				!___R$project$rome$$romejs$js$parser$utils$identifier_ts$keywordRelationalOperator.test(
					ident,
				)
			) {
				return true;
			}
		}
		return false;
	}


	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
		parser,
		context = undefined,
		topLevel = false,
	) {
		let startType = parser.state.tokenType;
		const start = parser.getPosition();

		if (
			startType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const &&
			parser.isSyntaxEnabled("ts")
		) {
			const ahead = parser.lookaheadState();
			if (
				ahead.tokenType ===
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name &&
				ahead.tokenValue === "enum"
			) {
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const,
				);
				parser.expectContextual("enum");
				return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
					parser,
					start,
					/* isConst */ true,
				);
			}
		}

		let kind;
		if (
			___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(
				parser,
				context,
			)
		) {
			startType = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var;
			kind = "let";
		}

		// Most types of statements are recognized by the keyword they

		// start with. Many are trivial to parse, some require a bit of

		// complexity.
		switch (startType) {
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._break:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(
					parser,
					start,
					true,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._continue:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(
					parser,
					start,
					false,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._debugger:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDebuggerStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._do:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDoStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._for:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function: {
				if (
					parser.lookaheadState().tokenType ===
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot
				) {
					// MetaProperty: eg. function.sent
					break;
				}

				if (context !== undefined) {
					if (parser.inScope("STRICT")) {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ILLEGAL_FUNCTION_IN_STRICT,
						});
					} else if (context !== "if" && context !== "label") {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ILLEGAL_FUNCTION_IN_NON_STRICT,
						});
					}
				}

				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function,
				);

				const result = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(
					parser,
					start,
					false,
				);

				if (context !== undefined && result.head.generator === true) {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ILLEGAL_GENERATOR_DEFINITION,
						loc: result.loc,
					});
				}

				return result;
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class: {
				if (context !== undefined) {
					parser.unexpectedToken();
				}
				return ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration(
					parser,
					start,
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._if:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseIfStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._return:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseReturnStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._switch:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseSwitchStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._throw:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseThrowStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._try:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTryStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var: {
				kind =
					kind === undefined
						? ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind(
								String(parser.state.tokenValue),
							)
						: kind;
				if (context !== undefined && kind !== "var") {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.LEXICAL_DECLARATION_IN_SINGLE_STATEMENT_CONTEXT,
					});
				}
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarStatement(
					parser,
					start,
					kind,
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._while:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWhileStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._with:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWithStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi:
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseEmptyStatement(
					parser,
					start,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._export:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import: {
				const nextToken = parser.lookaheadState();
				if (
					nextToken.tokenType ===
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL ||
					nextToken.tokenType ===
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot
				) {
					break;
				}

				parser.next();

				let result;
				if (
					startType ===
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import
				) {
					result = ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseImport(
						parser,
						start,
					);
				} else {
					result = ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseExport(
						parser,
						start,
					);
				}

				if (!topLevel) {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_EXPORT_MUST_TOP_LEVEL,
					});
				}

				___R$project$rome$$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed(
					parser,
					result,
				);

				return result;
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name:
				if (
					___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
						parser,
					)
				) {
					if (context !== undefined) {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ILLEGAL_ASYNC_DEFINITION,
						});
					}

					// async identifier
					parser.expect(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
					);

					// function keyword
					parser.expect(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function,
					);

					return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(
						parser,
						start,
						true,
					);
				}
		}

		// If the statement does not start with a statement keyword or a

		// brace, it's an ExpressionStatement or LabeledStatement. We

		// simply start parsing an expression, and afterwards, if the

		// next token is a colon and the expression was a simple

		// Identifier node, we switch to interpreting it as a label.
		const maybeName = String(parser.state.tokenValue);
		const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
			parser,
			"statement expression",
		);

		if (
			startType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name &&
			expr.type === "ReferenceIdentifier" &&
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseLabeledStatement(
				parser,
				start,
				maybeName,
				expr,
				context,
			);
		} else {
			return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExpressionStatement(
				parser,
				start,
				expr,
			);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
		parser,
	) {
		if (!parser.isContextual("async")) {
			return false;
		}

		const {input} = parser;
		const {index} = parser.state;

		___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.lastIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
			index,
		);
		const skip = ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$skipWhiteSpace.exec(
			input,
		);

		if (!skip || skip.length === 0) {
			return false;
		}

		const next = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
			index,
			skip[0].length,
		);

		return (
			!___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
				parser.getRawInput(index, next),
			) &&
			parser.getRawInput(
				next,
				___R$project$rome$$romejs$ob1$index_ts$ob1Add(next, 8),
			) === "function" &&
			(___R$project$rome$$romejs$ob1$index_ts$ob1Get0(next) + 8 === input.length ||
			!___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(
				input.charCodeAt(
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(next) + 8,
				),
			))
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertModuleNodeAllowed(
		parser,
		node,
	) {
		if (
			(node.type === "ImportDeclaration" &&
			(node.importKind === "type" || node.importKind === "typeof")) ||
			(node.type === "ExportLocalDeclaration" && node.exportKind === "type") ||
			(node.type === "ExportAllDeclaration" && node.exportKind === "type")
		) {
			// Allow Flow type imports and exports in all conditions because
			// Flow itself does not care about 'sourceType'.
			return;
		}

		if (!parser.inModule) {
			parser.addDiagnostic({
				loc: node.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_EXPORT_IN_SCRIPT(
					parser.options.manifestPath,
				),
			});
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBreakContinueStatement(
		parser,
		start,
		isBreak,
	) {
		parser.next();

		let label;
		if (parser.isLineTerminator()) {
			label = undefined;
		} else if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			label = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
			);
			parser.semicolon();
		} else {
			parser.unexpectedToken();
		}

		// Verify that there is an actual destination to break or

		// continue to.
		let i;
		for (i = 0; i < parser.state.labels.length; ++i) {
			const lab = parser.state.labels[i];
			if (label === undefined || lab.name === label.name) {
				if (lab.kind !== undefined && (isBreak || lab.kind === "loop")) {
					break;
				}

				if (label && isBreak) {
					break;
				}
			}
		}
		if (i === parser.state.labels.length) {
			parser.addDiagnostic({
				start,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNKNOWN_LABEL(
					label && label.name,
				),
			});
		}

		if (isBreak) {
			return parser.finishNode(
				start,
				{
					type: "BreakStatement",
					label,
				},
			);
		} else {
			return parser.finishNode(
				start,
				{
					type: "ContinueStatement",
					label,
				},
			);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDebuggerStatement(
		parser,
		start,
	) {
		parser.next();
		parser.semicolon();
		return parser.finishNode(start, {type: "DebuggerStatement"});
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseDoStatement(
		parser,
		start,
	) {
		parser.next();
		parser.state.labels.push(
			___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$loopLabel,
		);
		const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
			parser,
			"do",
		);
		parser.state.labels.pop();
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._while,
		);
		const test = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"do test",
		);
		parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
		);
		return parser.finishNode(
			start,
			{
				type: "DoWhileStatement",
				body,
				test,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForStatement(
		parser,
		start,
	) {
		parser.next();
		parser.state.labels.push(
			___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$loopLabel,
		);

		let awaitAt;
		if (parser.inScope("ASYNC") && parser.eatContextual("await")) {
			awaitAt = parser.getLastEndPosition();
		}

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			"for head",
		);

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
			)
		) {
			if (awaitAt) {
				parser.unexpectedToken();
			}
			return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor(
				parser,
				start,
				openContext,
				undefined,
			);
		}

		const _isLet = ___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(
			parser,
		);
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const,
			) ||
			_isLet
		) {
			const initStart = parser.getPosition();

			const kind = ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind(
				_isLet ? "let" : String(parser.state.tokenValue),
			);
			parser.next();

			const declarations = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVar(
				parser,
				initStart,
				kind,
				true,
			);

			const init = parser.finishNode(
				initStart,
				{
					type: "VariableDeclaration",
					kind,
					declarations,
				},
			);

			if (
				(parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in,
				) ||
				parser.isContextual("of")) &&
				init.declarations.length === 1
			) {
				return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForIn(
					parser,
					start,
					openContext,
					init,
					awaitAt,
				);
			}

			if (awaitAt !== undefined) {
				parser.addDiagnostic({
					start: awaitAt,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.REGULAR_FOR_AWAIT,
				});
			}

			return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor(
				parser,
				start,
				openContext,
				init,
			);
		}

		const refShorthandDefaultPos = {
			index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
		};
		let init = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
			parser,
			"for init",
			true,
			refShorthandDefaultPos,
		);

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in,
			) ||
			parser.isContextual("of")
		) {
			const description = parser.isContextual("of")
				? "for-of statement"
				: "for-in statement";
			const initPattern = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
				parser,
				init,
				description,
			);
			___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
				parser,
				init,
				undefined,
				undefined,
				description,
			);
			return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForIn(
				parser,
				start,
				openContext,
				initPattern,
				awaitAt,
			);
		}

		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) >
			0
		) {
			parser.unexpectedToken(
				parser.getPositionFromIndex(refShorthandDefaultPos.index),
			);
		}

		if (awaitAt !== undefined) {
			parser.addDiagnostic({
				start: awaitAt,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.REGULAR_FOR_AWAIT,
			});
		}

		return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor(
			parser,
			start,
			openContext,
			init,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind(
		kind,
	) {
		if (kind === "let" || kind === "var" || kind === "const") {
			return kind;
		} else {
			throw new Error("Expected valid variable kind but got " + kind);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseIfStatement(
		parser,
		start,
	) {
		parser.next();
		const test = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"if test",
		);
		const consequent = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
			parser,
			"if",
		);
		const alternate = parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._else,
		)
			? ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
					parser,
					"if",
				)
			: undefined;
		return parser.finishNode(
			start,
			{
				type: "IfStatement",
				test,
				consequent,
				alternate,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseReturnStatement(
		parser,
		start,
	) {
		if (
			!parser.inScope("FUNCTION") &&
			parser.sourceType !== "template" &&
			!parser.options.allowReturnOutsideFunction
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.RETURN_OUTSIDE_FUNCTION,
			});
		}

		parser.next();

		// In `return` (and `break`/`continue`), the keywords with

		// optional arguments, we eagerly look for a semicolon or the

		// possibility to insert one.
		let argument;
		if (!parser.isLineTerminator()) {
			argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
				parser,
				"return argument",
			);
			parser.semicolon();
		}

		return parser.finishNode(
			start,
			{
				type: "ReturnStatement",
				argument,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseSwitchStatement(
		parser,
		start,
	) {
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._switch,
		);
		const discriminant = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"switch discriminant",
		);
		const cases = [];
		const hasBrace = parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
		);
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"switch body",
		);
		parser.state.labels.push(
			___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$switchLabel,
		);

		if (hasBrace) {
			// Statements under must be grouped (by label) in SwitchCase
			// nodes. `cur` is used to keep the node that we are currently
			// adding statements to.
			let cur;

			function pushCase() {
				if (cur === undefined) {
					return;
				}

				cases.push(
					parser.finishNode(
						cur.start,
						{
							type: "SwitchCase",
							test: cur.test,
							consequent: cur.consequent,
						},
					),
				);

				cur = undefined;
			}

			let sawDefault;

			while (true) {
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
					)
				) {
					break;
				}

				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._case,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._default,
					)
				) {
					pushCase();

					const isCase = parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._case,
					);

					parser.next();

					let test;
					if (isCase) {
						test = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
							parser,
							"case test",
						);
					} else {
						if (sawDefault) {
							// TODO point to other default
							parser.addDiagnostic({
								start: parser.state.lastStartPos,
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.MULTIPLE_DEFAULT_CASE,
							});
						}
						sawDefault = true;
					}

					cur = {
						start: parser.getPosition(),
						consequent: [],
						test,
					};

					parser.expect(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
					);
				} else {
					const stmt = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
						parser,
						undefined,
					);
					if (cur === undefined) {
						parser.addDiagnostic({
							loc: stmt.loc,
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.SWITCH_STATEMENT_OUTSIDE_CASE,
						});
					} else {
						cur.consequent.push(stmt);
					}
				}
			}

			pushCase();
		}

		parser.expectClosing(openContext);
		parser.state.labels.pop();

		return parser.finishNode(
			start,
			{
				type: "SwitchStatement",
				discriminant,
				cases,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseThrowStatement(
		parser,
		start,
	) {
		parser.next();
		if (
			___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
				parser.getRawInput(
					parser.state.lastEndPos.index,
					parser.state.startPos.index,
				),
			)
		) {
			parser.addDiagnostic({
				start: parser.state.lastEndPos,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.NEWLINE_AFTER_THROW,
			});
		}

		const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
			parser,
			"throw argument",
		);
		parser.semicolon();
		return parser.finishNode(
			start,
			{
				type: "ThrowStatement",
				argument,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTryStatement(
		parser,
		start,
	) {
		parser.next();

		const block = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(
			parser,
		);
		let handler = undefined;

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._catch,
			)
		) {
			const clauseStart = parser.getPosition();
			parser.next();

			let param;
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
				)
			) {
				const openContext = parser.expectOpening(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
					"catch clause param",
				);
				param = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(
					parser,
				);
				const clashes = new Map();
				___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
					parser,
					param,
					true,
					clashes,
					"catch clause",
				);
				parser.expectClosing(openContext);
			}

			const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(
				parser,
			);
			handler = parser.finishNode(
				clauseStart,
				{
					type: "CatchClause",
					body,
					param,
				},
			);
		}

		const finalizer = parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._finally,
		)
			? ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(
					parser,
				)
			: undefined;

		if (!handler && !finalizer) {
			parser.addDiagnostic({
				start,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TRY_MISSING_FINALLY_OR_CATCH,
			});
		}

		return parser.finishNode(
			start,
			{
				type: "TryStatement",
				block,
				finalizer,
				handler,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarStatement(
		parser,
		start,
		kind,
	) {
		parser.next();
		const declarations = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVar(
			parser,
			start,
			kind,
			false,
		);
		parser.semicolon();
		return parser.finishNode(
			start,
			{
				type: "VariableDeclarationStatement",
				declaration: parser.finishNode(
					start,
					{
						type: "VariableDeclaration",
						kind,
						declarations,
					},
				),
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWhileStatement(
		parser,
		start,
	) {
		parser.next();
		const test = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"while test",
		);
		parser.state.labels.push(
			___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$loopLabel,
		);
		const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
			parser,
			"while",
		);
		parser.state.labels.pop();
		return parser.finishNode(start, {type: "WhileStatement", test, body});
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseWithStatement(
		parser,
		start,
	) {
		parser.next();
		const object = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(
			parser,
			"with object",
		);
		const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
			parser,
			"with",
		);

		if (parser.inScope("STRICT")) {
			parser.addDiagnostic({
				loc: parser.finishLoc(start),
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.WITH_IN_STRICT,
			});
		}

		return parser.finishNode(
			start,
			{
				type: "WithStatement",
				object,
				body,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseEmptyStatement(
		parser,
		start,
	) {
		parser.next();
		return parser.finishNode(start, {type: "EmptyStatement"});
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseLabeledStatement(
		parser,
		start,
		maybeName,
		expr,
		context,
	) {
		for (const label of parser.state.labels) {
			if (label.name === maybeName) {
				parser.addDiagnostic({
					loc: expr.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DUPLICATE_LABEL(
						maybeName,
						label.loc,
					),
				});
			}
		}

		let kind = undefined;
		if (parser.state.tokenType.isLoop) {
			kind = "loop";
		} else if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._switch,
			)
		) {
			kind = "switch";
		}

		for (let i = parser.state.labels.length - 1; i >= 0; i--) {
			const label = parser.state.labels[i];
			if (label.statementStart === start.index) {
				label.statementStart = parser.state.startPos.index;
				label.kind = kind;
			} else {
				break;
			}
		}

		parser.state.labels.push({
			name: maybeName,
			kind,
			loc: parser.getLoc(expr),
			statementStart: parser.state.startPos.index,
		});

		let statementContext = "label";
		if (context !== undefined) {
			if (context.includes("label")) {
				statementContext = context;
			} else {
				// @ts-ignore
				statementContext = context + "label";
			}
		}
		const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
			parser,
			statementContext,
		);

		if (
			body.type === "ClassDeclaration" ||
			(body.type === "VariableDeclarationStatement" &&
			body.declaration.kind !== "var") ||
			(body.type === "FunctionDeclaration" &&
			(parser.inScope("STRICT") ||
			body.head.generator === true ||
			body.head.async === true))
		) {
			parser.addDiagnostic({
				loc: body.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_LABEL_DECLARATION,
			});
		}

		parser.state.labels.pop();
		return parser.finishNode(
			start,
			{
				type: "LabeledStatement",
				label: Object.assign({}, expr, {type: "Identifier"}),
				body,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExpressionStatement(
		parser,
		start,
		expr,
	) {
		const node = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeExpressionStatement(
			parser,
			start,
			expr,
		);
		if (node !== undefined) {
			return node;
		}

		parser.semicolon();
		return parser.finishNode(
			start,
			{
				type: "ExpressionStatement",
				expression: expr,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(
		parser,
		allowDirectives,
	) {
		const start = parser.getPosition();
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"block",
		);
		const {body, directives} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockBody(
			parser,
			allowDirectives,
			false,
			openContext,
		);
		return parser.finishNode(
			start,
			{
				type: "BlockStatement",
				directives,
				body,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$isValidDirective(
		parser,
		stmt,
	) {
		return (
			stmt.type === "ExpressionStatement" &&
			stmt.expression.type === "StringLiteral" &&
			!parser.isParenthesized(stmt.expression)
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockBody(
		parser,
		allowDirectives = false,
		topLevel,
		openContext,
	) {
		return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
			parser,
			allowDirectives,
			topLevel,
			openContext,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
		parser,
		allowDirectives,
		topLevel,
		openContext,
	) {
		const body = [];
		const directives = [];

		let parsedNonDirective = false;
		let didSetStrict = undefined;
		let octalPosition;

		while (true) {
			if (
				parser.match(openContext.close) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				parser.expectClosing(openContext);
				break;
			}

			if (!parsedNonDirective && parser.state.containsOctal && !octalPosition) {
				octalPosition = parser.state.octalPosition;
			}

			const stmt = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
				parser,
				undefined,
				topLevel,
			);

			if (
				allowDirectives &&
				!parsedNonDirective &&
				stmt.type === "ExpressionStatement" &&
				___R$project$rome$$romejs$js$parser$parser$statement_ts$isValidDirective(
					parser,
					stmt,
				)
			) {
				const directive = ___R$project$rome$$romejs$js$parser$parser$statement_ts$expressionStatementToDirective(
					parser,
					stmt,
				);
				directives.push(directive);

				if (didSetStrict === undefined && directive.value === "use strict") {
					___R$project$rome$$romejs$js$parser$tokenizer$index_ts$setStrict(
						parser,
						true,
					);
					didSetStrict = true;

					if (octalPosition !== undefined) {
						parser.addDiagnostic({
							index: octalPosition,
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.OCTAL_IN_STRICT,
						});
					}
				}

				continue;
			}

			parsedNonDirective = true;
			body.push(stmt);
		}

		if (didSetStrict) {
			parser.popScope("STRICT");
		}

		return {body, directives};
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFor(
		parser,
		start,
		openContext,
		init,
	) {
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
		);

		const test = parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
		)
			? undefined
			: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
					parser,
					"for test",
				);
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
		);

		const update = parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
		)
			? undefined
			: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
					parser,
					"for update",
				);
		parser.expectClosing(openContext);

		const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
			parser,
			"for",
		);
		parser.state.labels.pop();

		return parser.finishNode(
			start,
			{
				type: "ForStatement",
				init,
				test,
				update,
				body,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseForIn(
		parser,
		start,
		openContext,
		init,
		awaitAt,
	) {
		const isForIn = parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in,
		);
		parser.next();

		const isAwait = awaitAt !== undefined;
		if (isForIn && isAwait) {
			parser.addDiagnostic({
				start: awaitAt,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.REGULAR_FOR_AWAIT,
			});
		}

		if (
			init.type === "VariableDeclaration" &&
			init.declarations[0].init !== undefined &&
			(!isForIn ||
			parser.inScope("STRICT") ||
			init.kind !== "var" ||
			init.declarations[0].id.type !== "BindingIdentifier")
		) {
			parser.addDiagnostic({
				loc: init.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.FOR_IN_OF_WITH_INITIALIZER,
			});
		}

		const left = init;
		const right = isForIn
			? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
					parser,
					"for right",
				)
			: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"for right",
				);
		parser.expectClosing(openContext);

		const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
			parser,
			"for",
		);
		parser.state.labels.pop();

		if (isForIn) {
			const node = parser.finishNode(
				start,
				{
					type: "ForInStatement",
					left,
					right,
					body,
				},
			);
			return node;
		} else {
			const node = parser.finishNode(
				start,
				{
					type: "ForOfStatement",
					await: isAwait,
					left,
					right,
					body,
				},
			);
			return node;
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVar(
		parser,
		start,
		kind,
		isFor,
	) {
		const declarations = [];

		while (true) {
			const start = parser.getPosition();
			const id = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarHead(
				parser,
				start,
			);

			if (kind === "var") {
				parser.state.hasHoistedVars = true;
			}

			let init;
			if (
				parser.eat(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
				)
			) {
				init = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"var init",
					isFor,
				);
			} else {
				if (
					kind === "const" &&
					!(parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in,
					) || parser.isContextual("of"))
				) {
					// `const` with no initializer is allowed in TypeScript.
					// It could be a declaration like `const x: number;`.
					if (!parser.isSyntaxEnabled("ts")) {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.CONST_WITHOUT_INITIALIZER,
							loc: id.loc,
						});
					}
				}

				// We exclude `const` because we already validated it above
				if (
					kind !== "const" &&
					id.type !== "BindingIdentifier" &&
					!(isFor &&
					(parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in,
					) ||
					parser.isContextual("of")))
				) {
					parser.addDiagnostic({
						start: parser.state.lastEndPos,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.COMPLEX_BINDING_WITHOUT_INITIALIZER,
					});
				}
			}

			declarations.push(
				parser.finishNode(
					start,
					{
						type: "VariableDeclarator",
						id,
						init,
					},
				),
			);

			if (
				!parser.eat(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				break;
			}
		}

		return declarations;
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarHead(
		parser,
		start,
	) {
		const id = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(
			parser,
		);

		___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
			parser,
			id,
			true,
			undefined,
			"variable declaration",
		);

		let definite;
		if (
			id.type === "BindingIdentifier" &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang,
			)
		) {
			definite = true;
			parser.expectSyntaxEnabled("ts");
			parser.next();
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			const typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);

			return parser.finishNode(
				start,
				Object.assign(
					{},
					id,
					{
						meta: parser.finishNode(
							start,
							{
								type: "PatternMeta",
								typeAnnotation,
								definite,
							},
						),
					},
				),
			);
		} else if (definite) {
			return Object.assign(
				{},
				id,
				{meta: parser.finishNode(start, {type: "PatternMeta", definite})},
			);
		} else {
			return id;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionId(
		parser,
		requiredStatementId,
	) {
		if (
			requiredStatementId ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(
		parser,
		start,
		isAsync,
	) {
		const ___R$ = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction(
			parser,
			{
				start,
				requiredStatementId: true,
				isStatement: true,
				isAsync,
			},
		);
		const shape = Object.assign({}, ___R$);
		delete shape.id;
		delete shape.body;
		const {id, body} = ___R$;
		if (id === undefined) {
			throw new Error("Required function name");
		}

		if (body === undefined) {
			return parser.finalizeNode(
				Object.assign({type: "TSDeclareFunction"}, shape, {id}),
			);
		}

		return parser.finalizeNode(
			Object.assign({type: "FunctionDeclaration"}, shape, {id, body}),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration(
		parser,
		start,
		isAsync,
	) {
		let ___R$1 = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction(
			parser,
			{
				start,
				requiredStatementId: false,
				isStatement: true,
				isAsync,
			},
		);
		let shape = Object.assign({}, ___R$1);
		delete shape.id;
		delete shape.body;
		let {id, body} = ___R$1;
		if (id === undefined) {
			id = {
				type: "BindingIdentifier",
				name: "*default*",
				// Does this `loc` make sense?
				loc: shape.loc,
			};
		}

		if (body === undefined) {
			return parser.finalizeNode(
				Object.assign({type: "TSDeclareFunction"}, shape, {id}),
			);
		}

		return parser.finalizeNode(
			Object.assign({type: "FunctionDeclaration"}, shape, {id, body}),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionExpression(
		parser,
		start,
		isAsync,
	) {
		const ___R$2 = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction(
			parser,
			{
				start,
				requiredStatementId: false,
				isStatement: false,
				isAsync,
			},
		);
		const shape = Object.assign({}, ___R$2);
		delete shape.body;
		const {body} = ___R$2;
		if (body === undefined) {
			throw new Error("Expected body");
		}

		return Object.assign({}, shape, {body, type: "FunctionExpression"});
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunction(
		parser,
		opts,
	) {
		const {start, isStatement, requiredStatementId, isAsync} = opts;

		const isGenerator = parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
		);

		let id;
		if (isStatement) {
			id = ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionId(
				parser,
				requiredStatementId,
			);
		}

		const oldYieldPos = parser.state.yieldPos;
		const oldAwaitPos = parser.state.awaitPos;
		parser.pushScope("FUNCTION_LOC", start);
		parser.pushScope("FUNCTION", true);
		parser.pushScope("METHOD", false);
		parser.pushScope("GENERATOR", isGenerator);
		parser.pushScope("ASYNC", isAsync);
		parser.pushScope("CLASS_PROPERTY", false);
		parser.pushScope("NON_ARROW_FUNCTION");
		parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
		parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;

		if (!isStatement) {
			id = ___R$$priv$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionId(
				parser,
				false,
			);
		}

		const headStart = parser.getPosition();
		const {params, rest, typeParameters} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams(
			parser,
		);
		const {head, body} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
			parser,
			{
				allowBodiless: isStatement,
				id,
				params,
				rest,
				isArrowFunction: false,
				isMethod: false,
				isAsync,
				isGenerator,
				headStart,
				start,
			},
		);

		parser.state.yieldPos = oldYieldPos;
		parser.state.awaitPos = oldAwaitPos;

		parser.popScope("NON_ARROW_FUNCTION");
		parser.popScope("FUNCTION");
		parser.popScope("FUNCTION_LOC");
		parser.popScope("CLASS_PROPERTY");
		parser.popScope("METHOD");
		parser.popScope("GENERATOR");
		parser.popScope("ASYNC");

		if (body !== undefined && body.type !== "BlockStatement") {
			throw new Error("Expected block statement for functions");
		}

		return {
			head: Object.assign({}, head, {typeParameters}),
			body,
			id,
			loc: parser.finishLoc(start),
		};
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$splitFunctionParams(
		params,
	) {
		const firstParam = params[0];
		if (
			firstParam !== undefined &&
			firstParam.type === "BindingIdentifier" &&
			firstParam.name === "this"
		) {
			return {
				thisType: firstParam,
				params: params.slice(1),
			};
		} else {
			return {
				thisType: undefined,
				params,
			};
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams(
		parser,
		kind,
		allowTSModifiers,
	) {
		let typeParameters = undefined;
		if (parser.isRelational("<")) {
			typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
				parser,
			);

			if (typeParameters !== undefined && (kind === "get" || kind === "set")) {
				parser.addDiagnostic({
					loc: typeParameters.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ACCESSOR_WITH_TYPE_PARAMS,
				});
			}
		}

		parser.pushScope("PARAMETERS", true);

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			"function params",
		);
		const {list: params, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(
			parser,
			openContext,
			allowTSModifiers,
		);

		parser.popScope("PARAMETERS");
		___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(
			parser,
		);
		return {params, rest, typeParameters};
	}


  // project-rome/@romejs/codec-js-regexp/index.ts








	function ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isHex(str) {
		return !/[^0-9a-fA-F]/.test(str);
	}

	function ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isOct(str) {
		const OCT_REGEX = /^[0-7]+$/;
		return OCT_REGEX.test(str);
	}

	function ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$getCodePoint(
		char,
	) {
		if (char.length === 1) {
			const point = char.codePointAt(0);
			if (point !== undefined) {
				return point;
			}
		}

		throw new Error("Input was not 1 character long");
	}

	function ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$readOctalCode(
		input,
		index,
		nextChar,
	) {
		let char = nextChar;
		let octal = "";
		let nextIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 1);
		while (___R$project$rome$$romejs$parser$core$index_ts$isDigit(char)) {
			octal += char;
			// stop at max octal ascii in case of octal escape
			if (parseInt(octal) > 377) {
				octal = octal.slice(0, octal.length - 1);
				break;
			}
			nextIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(nextIndex, 1);
			char = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(nextIndex)];
		}
		if (octal === "") {
			return {octalValue: undefined, end: nextIndex};
		}
		const octalValue = parseInt(octal, 10);
		return {octalValue, end: nextIndex};
	}

	const ___R$project$rome$$romejs$codec$js$regexp$index_ts$createRegExpParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser((
		ParserCore,
	) =>
		(() => {
			class RegExpParser extends ParserCore {
				constructor(opts) {
					super(opts, "parse/regex");
					this.diagnostics = [];
					this.unicode = opts.unicode;
				}

				addDiagnostic(opts) {
					this.diagnostics.push(this.createDiagnostic(opts));
				}

				unexpected() {
					throw new Error("No throwing");
				}

				tokenize(index, input) {
					const char = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					)];

					if (char === "\\") {
						let end = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 2);

						const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
							index,
						) + 1];
						switch (nextChar) {
							case "t":
								return this.finishComplexToken(
									"Character",
									{
										escaped: false,
										value: "\t",
									},
									end,
								);

							case "n":
								return this.finishComplexToken(
									"Character",
									{
										escaped: false,
										value: "\n",
									},
									end,
								);

							case "r":
								return this.finishComplexToken(
									"Character",
									{
										escaped: false,
										value: "\r",
									},
									end,
								);

							case "v":
								return this.finishComplexToken(
									"Character",
									{
										escaped: false,
										value: "\x0b",
									},
									end,
								);

							case "f":
								return this.finishComplexToken(
									"Character",
									{
										escaped: false,
										value: "\f",
									},
									end,
								);

							case "d":
							case "D":
							case "b":
							case "B":
							case "s":
							case "S":
							case "w":
							case "W":
								return this.finishValueToken("EscapedCharacter", nextChar, end);

							case "k": {
								if (this.unicode) {
									// named group back reference https://github.com/tc39/proposal-regexp-named-groups#backreferences
									let namedBackReference = "";
									let namedBackReferenceIndex =
										___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) + 2;
									let namedBackReferenceChar = input[namedBackReferenceIndex];
									if (namedBackReferenceChar === "<") {
										namedBackReferenceChar = input[namedBackReferenceIndex];
										while (
											namedBackReferenceChar !== ">" &&
											namedBackReferenceIndex < input.length
										) {
											namedBackReference += namedBackReferenceChar;
											namedBackReferenceIndex++;
											namedBackReferenceChar = input[namedBackReferenceIndex];
										}
										if (namedBackReferenceChar === ">") {
											namedBackReference += namedBackReferenceChar;
											namedBackReferenceIndex++;
										}
										return this.finishComplexToken(
											"NamedBackReferenceCharacter",
											{
												value: namedBackReference,
												escaped: true,
											},
											___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
												namedBackReferenceIndex,
											),
										);
									}
								}

								return this.finishComplexToken(
									"Character",
									{
										value: "k",
										escaped: true,
									},
									end,
								);
							}

							case "p": {
								if (this.unicode) {
									// TODO unicode property escapes https://github.com/tc39/proposal-regexp-unicode-property-escapes
								}

								return this.finishComplexToken(
									"Character",
									{
										value: "p",
										escaped: true,
									},
									end,
								);
							}

							case "P": {
								if (this.unicode) {
									// TODO unicode property escapes https://github.com/tc39/proposal-regexp-unicode-property-escapes
								}

								return this.finishComplexToken(
									"Character",
									{
										value: "P",
										escaped: true,
									},
									end,
								);
							}

							case "c":
								// TODO???
								return this.finishComplexToken(
									"Character",
									{
										value: "c",
										escaped: true,
									},
									end,
								);

							case "0": {
								const {octalValue, end: octalEnd} = ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$readOctalCode(
									input,
									index,
									nextChar,
								);
								if (
									octalValue !== undefined &&
									___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isOct(
										octalValue.toString(),
									)
								) {
									const octal = parseInt(octalValue.toString(), 8);
									return this.finishComplexToken(
										"Character",
										{
											value: String.fromCharCode(octal),
											escaped: true,
										},
										octalEnd,
									);
								}
								return this.finishComplexToken(
									"Character",
									{
										value: String.fromCharCode(0),
										escaped: true,
									},
									end,
								);
							}

							case "x": {
								const possibleHex = input.slice(
									___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) + 1,
									___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) + 3,
								);

								// \xhh
								if (
									possibleHex.length === 2 &&
									___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isHex(
										possibleHex,
									)
								) {
									end = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(end, 2);

									return this.finishComplexToken(
										"Character",
										{
											value: String.fromCharCode(parseInt(possibleHex, 16)),
											escaped: true,
										},
										end,
									);
								}

								return this.finishComplexToken(
									"Character",
									{
										value: "x",
										escaped: true,
									},
									end,
								);
							}

							case "u": {
								// Get the next 4 characters after \u
								const possibleHex = input.slice(
									___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) + 2,
									___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index) + 6,
								);

								// \uhhhh
								if (
									possibleHex.length === 4 &&
									___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isHex(
										possibleHex,
									)
								) {
									end = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(end, 4);

									return this.finishComplexToken(
										"Character",
										{
											value: String.fromCharCode(parseInt(possibleHex, 16)),
											escaped: true,
										},
										end,
									);
								}

								if (this.unicode) {
									// TODO \u{hhhh} or \u{hhhhh}
								}

								return this.finishComplexToken(
									"Character",
									{
										value: "u",
										escaped: true,
									},
									end,
								);
							}

							// Redundant escaping
							default: {
								let {
									octalValue: referenceValue,
									end: referenceEnd,
								} = ___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$readOctalCode(
									input,
									index,
									nextChar,
								);
								if (referenceValue !== undefined) {
									let backReference = referenceValue.toString();
									// \8 \9 are treated as escape char
									if (referenceValue === 8 || referenceValue === 9) {
										return this.finishComplexToken(
											"Character",
											{
												value: backReference,
												escaped: true,
											},
											referenceEnd,
										);
									}

									if (
										___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isOct(
											backReference,
										)
									) {
										const octal = parseInt(backReference, 8);
										return this.finishComplexToken(
											"Character",
											{
												value: String.fromCharCode(octal),
												escaped: true,
											},
											referenceEnd,
										);
									}

									// back reference allowed are 1 - 99
									if (referenceValue >= 1 && referenceValue <= 99) {
										return this.finishComplexToken(
											"NumericBackReferenceCharacter",
											{
												value: parseInt(backReference, 10),
												escaped: true,
											},
											referenceEnd,
										);
									} else {
										backReference = backReference.slice(
											0,
											backReference.length - 1,
										);
										referenceEnd = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
											referenceEnd,
											-1,
										);
										if (
											___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$isOct(
												backReference,
											)
										) {
											return this.finishComplexToken(
												"Character",
												{
													value: String.fromCharCode(parseInt(backReference, 8)),
													escaped: true,
												},
												referenceEnd,
											);
										} else {
											return this.finishComplexToken(
												"NumericBackReferenceCharacter",
												{
													value: parseInt(backReference, 10),
													escaped: true,
												},
												referenceEnd,
											);
										}
									}
								}

								return this.finishComplexToken(
									"Character",
									{
										value: nextChar,
										escaped: true,
									},
									end,
								);
							}
						}
					}

					switch (char) {
						case "$":
						case "^":
						case ".":
						case "?":
						case "{":
						case "}":
						case "+":
						case "|":
						case "*":
						case "[":
						case "]":
						case "(":
						case ")":
							return this.finishValueToken("Operator", char);
					}

					return this.finishComplexToken(
						"Character",
						{
							value: char,
							escaped: false,
						},
					);
				}

				getGroupModifiers() {
					const token = this.getToken();

					if (token.type === "Character") {
						switch (token.value) {
							case ":": {
								this.nextToken();
								return {
									type: "NON_CAPTURE",
									kind: undefined,
								};
							}

							case "=": {
								this.nextToken();
								return {
									type: "NON_CAPTURE",
									kind: "positive-lookahead",
								};
							}

							case "!": {
								this.nextToken();
								return {
									type: "NON_CAPTURE",
									kind: "negative-lookahead",
								};
							}

							case "<": {
								const nextToken = this.lookaheadToken();

								if (nextToken.type === "Character") {
									switch (nextToken.value) {
										case "!": {
											this.nextToken();
											this.nextToken();
											return {
												type: "NON_CAPTURE",
												kind: "negative-lookbehind",
											};
										}

										case "=": {
											this.nextToken();
											this.nextToken();
											return {
												type: "NON_CAPTURE",
												kind: "positive-lookbehind",
											};
										}
									}

									if (
										___R$project$rome$$romejs$parser$core$index_ts$isESIdentifierStart(
											nextToken.value,
										)
									) {
										let name = "";

										// 1 is for the <
										let skipCount = 1;
										let targetToken = nextToken;
										while (
											targetToken.type === "Character" &&
											___R$project$rome$$romejs$parser$core$index_ts$isESIdentifierChar(
												targetToken.value,
											)
										) {
											name += targetToken.value;
											targetToken = this.lookaheadToken(targetToken.end);
											skipCount++;
										}

										if (
											targetToken.type === "Character" &&
											targetToken.value === ">"
										) {
											// Skip through all the name tokens including >
											skipCount++;

											// This is kinda a hacky solution, and slower than it could be
											for (let i = 0; i < skipCount; i++) {
												this.nextToken();
											}

											return {
												type: "NAMED_CAPTURE",
												name,
											};
										}
									}
								}
							}
						}
					}

					this.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.INVALID_CAPTURE_GROUP_MODIFIER,
						token,
					});

					return undefined;
				}

				matchOperator(op) {
					const token = this.getToken();
					return token.type === "Operator" && token.value === op;
				}

				eatOperator(op) {
					if (this.matchOperator(op)) {
						this.nextToken();
						return true;
					} else {
						return false;
					}
				}

				parseGroupCapture() {
					const start = this.getPosition();
					this.nextToken();

					let modifiers;
					if (this.eatOperator("?")) {
						modifiers = this.getGroupModifiers();
					}

					const expression = this.parseExpression(() => !this.matchOperator(")"));

					if (!this.eatOperator(")")) {
						this.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.UNCLOSED_GROUP,
							start,
						});
					}

					if (modifiers !== undefined && modifiers.type === "NON_CAPTURE") {
						return {
							type: "RegExpGroupNonCapture",
							expression,
							kind: modifiers.kind,
							loc: this.finishLoc(start),
						};
					} else {
						let name = modifiers !== undefined ? modifiers.name : undefined;
						return {
							type: "RegExpGroupCapture",
							expression,
							name,
							loc: this.finishLoc(start),
						};
					}
				}

				parseCharSet() {
					const start = this.getPosition();
					this.nextToken();

					const body = [];
					const invert = this.eatOperator("^");

					while (!this.matchToken("EOF") && !this.matchOperator("]")) {
						const part = this.parseCharacterOrRange();
						body.push(part);
					}

					if (!this.eatOperator("]")) {
						this.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.UNCLOSED_CHAR_SET,
							start,
						});
					}

					return {
						type: "RegExpCharSet",
						invert,
						body,
						loc: this.finishLoc(start),
					};
				}

				getCharacterFromToken(token) {
					switch (token.type) {
						case "Character":
						case "Operator":
							return token.value;

						case "SOF":
						case "EOF":
						case "Invalid":
							throw new Error("Unnecessary");

						default:
							throw new Error("Never");
					}
				}

				parseCharacter() {
					const token = this.getToken();

					if (token.type === "Character") {
						this.nextToken();
						return {
							type: "RegExpCharacter",
							value: token.value,
							loc: this.finishLocFromToken(token),
						};
					}

					if (token.type === "NumericBackReferenceCharacter") {
						this.nextToken();

						return {
							type: "RegExpNumericBackReference",
							value: token.value,
							loc: this.finishLocFromToken(token),
						};
					}

					if (token.type === "NamedBackReferenceCharacter") {
						const start = this.input.slice(
							0,
							___R$project$rome$$romejs$ob1$index_ts$ob1Get0(token.start),
						);
						this.nextToken();

						if (token.value[token.value.length - 1] !== ">") {
							this.addDiagnostic({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.UNCLOSED_NAMED_CAPTURE,
								loc: this.finishLocFromToken(token),
							});
						}

						if (!start.includes(token.value)) {
							this.addDiagnostic({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.INVALID_NAMED_CAPTURE,
								loc: this.finishLocFromToken(token),
							});
						}

						const name = token.value.slice(1, token.value.length - 1);
						return {
							type: "RegExpNamedBackReference",
							name,
							loc: this.finishLocFromToken(token),
						};
					}

					if (token.type === "EscapedCharacter") {
						this.nextToken();

						const loc = this.finishLocFromToken(token);
						switch (token.value) {
							case "d":
								return {
									type: "RegExpDigitCharacter",
									loc,
								};

							case "D":
								return {
									type: "RegExpNonDigitCharacter",
									loc,
								};

							case "b":
								return {
									type: "RegExpWordBoundaryCharacter",
									loc,
								};

							case "B":
								return {
									type: "RegExpNonWordBoundaryCharacter",
									loc,
								};

							case "s":
								return {
									type: "RegExpWhiteSpaceCharacter",
									loc,
								};

							case "S":
								return {
									type: "RegExpNonWhiteSpaceCharacter",
									loc,
								};

							case "w":
								return {
									type: "RegExpWordCharacter",
									loc,
								};

							case "W":
								return {
									type: "RegExpNonWordCharacter",
									loc,
								};
						}
					}

					this.nextToken();
					return {
						type: "RegExpCharacter",
						value: this.getCharacterFromToken(token),
						loc: this.finishLocFromToken(token),
					};
				}

				parseCharacterOrRange() {
					const startPos = this.getPosition();
					let start = this.parseCharacter();

					// Range
					const nextToken = this.getToken();
					if (
						start.type === "RegExpCharacter" &&
						nextToken.type === "Character" &&
						nextToken.value === "-" &&
						!nextToken.escaped
					) {
						const lookaheadToken = this.lookaheadToken();
						if (lookaheadToken.type === "Character") {
							// Skip dash
							this.nextToken();

							let end = this.parseCharacter();

							const loc = this.finishLoc(startPos);

							if (
								start.type === "RegExpCharacter" &&
								end.type === "RegExpCharacter" &&
								___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$getCodePoint(
									end.value,
								) <
								___R$$priv$project$rome$$romejs$codec$js$regexp$index_ts$getCodePoint(
									start.value,
								)
							) {
								this.addDiagnostic({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.REVERSED_CHAR_SET_RANGE,
									loc,
								});
								const _end = end;
								end = start;
								start = _end;
							}

							return {
								type: "RegExpCharSetRange",
								loc,
								start,
								end,
							};
						}
					}

					return start;
				}

				parseDigits() {
					let digits = "";
					let token = this.getToken();
					while (
						token.type === "Character" &&
						___R$project$rome$$romejs$parser$core$index_ts$isDigit(token.value)
					) {
						digits += token.value;
						token = this.nextToken();
					}

					if (digits.length === 0) {
						return undefined;
					} else {
						return Number(digits);
					}
				}

				parseQuantifier() {
					if (this.eatOperator("?")) {
						return {
							min: 0,
							max: 1,
						};
					}

					if (this.eatOperator("*")) {
						return {
							min: 0,
							max: undefined,
						};
					}

					if (this.eatOperator("+")) {
						return {
							min: 1,
							max: undefined,
						};
					}

					if (this.matchOperator("{")) {
						const snapshot = this.save();

						this.nextToken();

						const start = this.getPosition();
						const min = this.parseDigits();

						if (min !== undefined) {
							const nextToken = this.getToken();
							if (nextToken.type === "Character" && nextToken.value === ",") {
								this.nextToken();

								const max = this.parseDigits();
								const end = this.getPosition();

								const endToken = this.getToken();
								if (endToken.type === "Operator" && endToken.value === "}") {
									this.nextToken();

									if (max !== undefined && min > max) {
										this.addDiagnostic({
											description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.REVERSED_QUANTIFIER_RANGE,
											start,
											end,
										});
										return {
											max: min,
											min: max,
										};
									}

									return {
										min,
										max,
									};
								}
							} else if (
								nextToken.type === "Operator" &&
								nextToken.value === "}"
							) {
								this.nextToken();
								return {
									min,
									max: min,
								};
							}
						}

						this.restore(snapshot);
					}

					return undefined;
				}

				parseBodyItem() {
					const start = this.getPosition();

					const prefix = this.parseBodyItemPrefix();
					if (prefix === undefined) {
						return undefined;
					}

					let target = prefix;

					while (true) {
						const quantifier = this.parseQuantifier();
						if (quantifier === undefined) {
							break;
						}

						const lazy = this.eatOperator("?");

						const quantified = Object.assign(
							{
								type: "RegExpQuantified",
								loc: this.finishLoc(start),
								target,
								lazy,
							},
							quantifier,
						);

						target = quantified;
					}

					return target;
				}

				parseOperator(token) {
					switch (token.value) {
						case "$": {
							this.nextToken();
							return {
								type: "RegExpEndCharacter",
								loc: this.finishLocFromToken(token),
							};
						}

						case "^": {
							this.nextToken();
							return {
								type: "RegExpStartCharacter",
								loc: this.finishLocFromToken(token),
							};
						}

						case ".": {
							this.nextToken();
							return {
								type: "RegExpAnyCharacter",
								loc: this.finishLocFromToken(token),
							};
						}

						case "[":
							return this.parseCharSet();

						case "(":
							return this.parseGroupCapture();

						case ")": {
							this.nextToken();
							this.addDiagnostic({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.UNOPENED_GROUP,
								token,
							});
							return;
						}

						case "{": {
							const start = this.getPosition();
							const unmatchedQuantifier = this.parseQuantifier();
							if (unmatchedQuantifier === undefined) {
								// Quantifier is undefined and eaten tokens were restored
								// Return a '{' token as a RegexpCharacter, parseBodyItem() will handle parsing of subsequent quantifiers
								return this.parseCharacter();
							} else {
								// If quantifier is defined, then syntax error: Nothing to repeat
								const end = this.getPosition();
								this.addDiagnostic({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.NO_TARGET_QUANTIFIER,
									start,
									end,
								});
								return;
							}
						}

						case "?":
						case "*":
						case "+": {
							this.nextToken();
							this.addDiagnostic({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.INVALID_QUANTIFIER_TARGET,
								token,
							});
							return;
						}

						case "]":
						case "}":
							return this.parseCharacter();

						default:
							return undefined;
					}
				}

				parseBodyItemPrefix() {
					const token = this.getToken();

					switch (token.type) {
						case "Operator":
							return this.parseOperator(token);

						case "EscapedCharacter":
						case "Character":
						case "NumericBackReferenceCharacter":
						case "NamedBackReferenceCharacter":
							return this.parseCharacter();
					}

					this.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.REGEX_PARSER.UNKNOWN_REGEX_PART,
						token,
					});

					return undefined;
				}

				parseExpression(whileCallback) {
					const alternations = [];
					let body = [];

					const start = this.getPosition();
					let alternateStart = start;

					while (
						!this.matchToken("EOF") &&
						(whileCallback === undefined || whileCallback())
					) {
						if (this.eatOperator("|")) {
							alternations.push({
								start: alternateStart,
								end: this.getPosition(),
								body,
							});
							alternateStart = this.getPosition();
							body = [];
							continue;
						}

						const part = this.parseBodyItem();
						if (part !== undefined) {
							body.push(part);
						}
					}

					alternations.push({
						body,
						start: alternateStart,
						end: this.getPosition(),
					});

					let expression;

					while (alternations.length > 0) {
						const alternation = alternations.shift();

						const sub = {
							type: "RegExpSubExpression",
							body: alternation.body,
							loc: this.finishLocAt(alternation.start, alternation.end),
						};

						if (expression === undefined) {
							expression = sub;
						} else {
							const alternationNode = {
								type: "RegExpAlternation",
								left: expression,
								right: sub,
								loc: this.finishLocAt(
									this.getLoc(expression).start,
									alternation.end,
								),
							};

							expression = alternationNode;
						}
					}

					if (expression === undefined) {
						throw new Error(
							"Impossible. We should always have at least one alternation that will set this.",
						);
					}

					return expression;
				}

				parse() {
					return {
						expression: this.parseExpression(),
						diagnostics: this.diagnostics,
					};
				}
			}
			return RegExpParser;
		})()
	);


  // project-rome/@romejs/js-parser/parser/expression.ts
const ___R$project$rome$$romejs$js$parser$parser$expression_ts = {
		checkPropClash: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkPropClash,
		parseExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression,
		parseMaybeAssign: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign,
		parseMaybeConditional: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeConditional,
		tryParseConditionalConsequent: ___R$project$rome$$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent,
		parseConditional: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseConditional,
		forwardNoArrowParamsConversionAt: ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt,
		parseExpressionOps: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOps,
		parseExpressionOp: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp,
		parseMaybeUnary: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary,
		parseExpressionWithPossibleSubscripts: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts,
		parseSubscripts: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseSubscripts,
		parseAsyncArrowWithTypeParameters: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowWithTypeParameters,
		parseExpressionSubscript: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscript,
		parseTaggedTemplateExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression,
		checkYieldAwaitInDefaultParams: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams,
		atPossibleAsync: ___R$project$rome$$romejs$js$parser$parser$expression_ts$atPossibleAsync,
		parseCallExpressionArguments: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments,
		shouldParseAsyncArrow: ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow,
		parseAsyncArrowFromCallExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression,
		parseNoCallExpr: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNoCallExpr,
		parseExpressionAtom: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom,
		parseBooleanLiteral: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBooleanLiteral,
		parseMaybePrivateName: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybePrivateName,
		parseFunctionExpressionOrMetaProperty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty,
		parseMetaProperty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty,
		parseImportMetaProperty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseImportMetaProperty,
		parseParenExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression,
		parseParenAndDistinguishExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression,
		shouldParseArrow: ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseArrow,
		parseArrowHead: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowHead,
		parseParenItem: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem,
		parseNew: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNew,
		parseTemplateElement: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplateElement,
		parseTemplate: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate,
		parseObjectExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectExpression,
		parseObjectPattern: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPattern,
		isGetterOrSetterMethod: ___R$project$rome$$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod,
		checkGetterSetterParamCount: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount,
		parseObjectMethod: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectMethod,
		parseObjectProperty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectProperty,
		parseObjectPropertyValue: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue,
		parseObjectPropertyKey: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey,
		parseMethod: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod,
		parseArrowExpression: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression,
		isStrictBody: ___R$project$rome$$romejs$js$parser$parser$expression_ts$isStrictBody,
		parseFunctionBodyAndFinish: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish,
		parseFunctionBody: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBody,
		checkFunctionNameAndParams: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams,
		parseExpressionList: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionList,
		parseExpressionListNonEmpty: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty,
		parseCallArgument: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument,
		parseIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier,
		parseBindingIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier,
		parseReferenceIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier,
		toBindingIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier,
		toAssignmentIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier,
		toReferenceIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier,
		toIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toIdentifier,
		createIdentifier: ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier,
		parseIdentifierName: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName,
		checkReservedWord: ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord,
		parseAwait: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAwait,
		parseYield: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseYield,
		parseStringLiteral: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral,
		parseNumericLiteral: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral,
		parseArrayHole: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrayHole,
	};
	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkPropClash(
		parser,
		prop,
		props,
	) {
		if (prop.key.type === "ComputedPropertyKey" || prop.type === "ObjectMethod") {
			return undefined;
		}

		const key = prop.key.value;

		// We can only check these for collisions since they're statically known
		if (
			key.type !== "Identifier" &&
			key.type !== "StringLiteral" &&
			key.type !== "NumericLiteral"
		) {
			return;
		}

		// It is either an Identifier or a String/NumericLiteral
		const name = key.type === "Identifier" ? key.name : String(key.value);

		if (name === "__proto__") {
			if (props.has("proto")) {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.PROTO_PROP_REDEFINITION,
					loc: key.loc,
				});
			} else {
				props.add("proto");
			}
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
	) {
		const startPos = parser.state.startPos;
		const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
			parser,
			context,
			noIn,
			refShorthandDefaultPos,
		);
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			let expressions = [expr];
			while (
				parser.eat(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				expressions.push(
					___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
						parser,
						context,
						noIn,
						refShorthandDefaultPos,
					),
				);
			}

			expressions = ___R$project$rome$$romejs$js$parser$parser$lval_ts$filterSpread(
				parser,
				___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList(
					parser,
					expressions,
				),
			);

			return parser.finishNode(
				startPos,
				{
					type: "SequenceExpression",
					expressions,
				},
			);
		}
		return expr;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
		afterLeftParse,
		refNeedsArrowPos,
	) {
		const branches = parser.createBranch();

		// Try parsing as JSX
		if (
			(parser.isRelational("<") ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart,
			)) &&
			parser.shouldTokenizeJSX()
		) {
			branches.add(
				() => {
					return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
						parser,
						context,
						noIn,
						refShorthandDefaultPos,
						afterLeftParse,
						refNeedsArrowPos,
					);
				},
				{diagnosticsPriority: 1},
			);

			// Remove `tc.j_expr` and `tc.j_oTag` from 'context added

			// by parsing `jsxTagStart` to stop the JSX plugin from

			// messing with the tokens
			const cLength = parser.state.context.length;
			if (
				parser.state.context[cLength - 1] ===
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag
			) {
				parser.state.context.length -= 2;
			}
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational,
				"<",
			);
		}

		// Try parsing as an arrow function with type parameters
		if (parser.isRelational("<")) {
			branches.add(() => {
				const start = parser.getPosition();
				const typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters(
					parser,
				);
				const arrowExpression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
					parser,
					start,
					() =>
						___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
							parser,
							context,
							noIn,
							refShorthandDefaultPos,
							afterLeftParse,
							refNeedsArrowPos,
						)
					,
				);
				parser.resetStartLocationFromNode(arrowExpression, typeParameters);

				if (arrowExpression.type === "ArrowFunctionExpression") {
					return Object.assign({}, arrowExpression, {typeParameters});
				} else {
					parser.addDiagnostic({
						loc: typeParameters.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_ARROW_AFTER_TYPE_PARAMS,
					});
					return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
						parser,
						parser.createUnknownIdentifier("type params without arrow function"),
					);
				}
			});
		}

		branches.add(() => {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
				parser,
				context,
				noIn,
				refShorthandDefaultPos,
				afterLeftParse,
				refNeedsArrowPos,
			);
		});

		// Pick the branch with the least amount of errors
		return branches.pick();
	}



	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseMaybeAssign(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
		afterLeftParse,
		refNeedsArrowPos,
	) {
		const startPos = parser.state.startPos;

		if (parser.isContextual("yield")) {
			if (parser.inScope("GENERATOR")) {
				let left = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseYield(
					parser,
					noIn,
				);
				if (afterLeftParse) {
					left = afterLeftParse(parser, left, startPos);
				}
				return left;
			} else {
				// The tokenizer will assume an expression is allowed after
				// `yield`, but this isn't that kind of yield
				parser.state.exprAllowed = false;
			}
		}

		const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
		parser.state.commaAfterSpreadAt = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1;

		let failOnShorthandAssign;
		if (refShorthandDefaultPos) {
			failOnShorthandAssign = false;
		} else {
			refShorthandDefaultPos = ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker();
			failOnShorthandAssign = true;
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			parser.state.potentialArrowAt = parser.state.startPos.index;
		}

		let left = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeConditional(
			parser,
			context,
			noIn,
			refShorthandDefaultPos,
			refNeedsArrowPos,
		);
		if (afterLeftParse) {
			left = afterLeftParse(parser, left, startPos);
		}

		if (parser.state.tokenType.isAssign) {
			const operator = (String(parser.state.tokenValue));
			const leftPatt = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
				parser,
				left,
				"assignment expression",
			);

			// reset because shorthand default was used correctly
			refShorthandDefaultPos.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;

			___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
				parser,
				leftPatt,
				undefined,
				undefined,
				"assignment expression",
			);

			// We should never get patterns here...?

			//if (left.type === 'BindingArrayPattern' || left.type === 'BindingObjectPattern') {
			//  checkCommaAfterRestFromSpread(parser);

			//}
			parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

			parser.next();
			const right = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"assignment right",
				noIn,
			);
			return parser.finishNode(
				startPos,
				{
					type: "AssignmentExpression",
					operator,
					left: leftPatt,
					right,
				},
			);
		} else if (
			failOnShorthandAssign &&
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			parser.unexpectedToken(
				parser.getPositionFromIndex(refShorthandDefaultPos.index),
			);
		}

		parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

		return left;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeConditional(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
		refNeedsArrowPos,
	) {
		const startPos = parser.state.startPos;
		const potentialArrowAt = parser.state.potentialArrowAt;
		const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOps(
			parser,
			context,
			noIn,
			refShorthandDefaultPos,
		);

		if (
			expr.type === "ArrowFunctionExpression" &&
			parser.getLoc(expr).start.index === potentialArrowAt
		) {
			return expr;
		}

		if (
			refShorthandDefaultPos &&
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			return expr;
		}

		return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseConditional(
			parser,
			expr,
			noIn,
			startPos,
			refNeedsArrowPos,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent(
		parser,
	) {
		const brancher = parser.createBranch();

		brancher.add(() => {
			parser.state.noArrowParamsConversionAt.push(parser.state.startPos.index);
			const consequent = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"conditional consequent",
			);
			parser.state.noArrowParamsConversionAt.pop();
			return {
				consequent,
				failed: !parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
				),
			};
		});

		return brancher.pick();
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseConditional(
		parser,
		expr,
		noIn,
		startPos,
		refNeedsArrowPos,
	) {
		if (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			return expr;
		}

		// This is to handle a case like this: const foo = (foo?: bar) => {};

		// We'll be called due to the `?`, and we should mark ourselves as an

		// expected arrow function if parsing as a regular conditional fails
		if (refNeedsArrowPos) {
			const branch = parser.createBranch();

			branch.add(
				() =>
					___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseConditional(
						parser,
						expr,
						noIn,
						startPos,
					)
				,
				{
					maxNewDiagnostics: 0,
				},
			);

			if (branch.hasBranch()) {
				return branch.pick();
			} else {
				refNeedsArrowPos.index = parser.state.startPos.index;
				return expr;
			}
		}

		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
		);
		const originalNoArrowAt = parser.state.noArrowAt;
		let {consequent} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$tryParseConditionalConsequent(
			parser,
		);
		parser.state.noArrowAt = originalNoArrowAt;

		if (
			!parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.MISSING_CONDITIONAL_SEPARATOR,
			});
		}

		const alternate = ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
			parser,
			startPos,
			() =>
				___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"conditional alternate",
					noIn,
					undefined,
					undefined,
					undefined,
				)
			,
		);

		return parser.finishNode(
			startPos,
			{
				type: "ConditionalExpression",
				test: expr,
				consequent,
				alternate,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
		parser,
		start,
		parse,
	) {
		if (parser.state.noArrowParamsConversionAt.includes(start.index)) {
			let result;
			parser.state.noArrowParamsConversionAt.push(parser.state.startPos.index);
			result = parse();
			parser.state.noArrowParamsConversionAt.pop();
			return result;
		} else {
			return parse();
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseConditional(
		parser,
		expr,
		noIn,
		startPos,
	) {
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			const test = expr;
			const consequent = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"conditional consequent",
			);
			parser.expect(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			);
			const alternate = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"conditional alternate",
				noIn,
			);
			return parser.finishNode(
				startPos,
				{
					type: "ConditionalExpression",
					test,
					consequent,
					alternate,
				},
			);
		}
		return expr;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOps(
		parser,
		context,
		noIn,
		refShorthandDefaultPos,
	) {
		const startPos = parser.state.startPos;
		const potentialArrowAt = parser.state.potentialArrowAt;
		const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(
			parser,
			context,
			refShorthandDefaultPos,
		);

		if (
			expr.type === "ArrowFunctionExpression" &&
			parser.getLoc(expr).start.index === potentialArrowAt
		) {
			return expr;
		}
		if (
			refShorthandDefaultPos &&
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			return expr;
		}

		return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(
			parser,
			context,
			expr,
			startPos,
			-1,
			noIn,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(
		parser,
		context,
		left,
		leftStartPos,
		minPrec,
		noIn = false,
	) {
		if (
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in.getBinop() >
			minPrec &&
			!parser.hasPrecedingLineBreak() &&
			parser.isContextual("as")
		) {
			const _const = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(
				parser,
			);

			let typeAnnotation;
			if (_const) {
				___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
					parser,
					left,
				);
				typeAnnotation = _const;
			} else {
				typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(
					parser,
				);
			}

			const node = parser.finishNode(
				leftStartPos,
				{
					type: "TSAsExpression",
					typeAnnotation,
					expression: left,
				},
			);

			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(
				parser,
				context,
				node,
				leftStartPos,
				minPrec,
				noIn,
			);
		}

		const prec = parser.state.tokenType.binop;
		if (
			prec !== undefined &&
			(!noIn ||
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in,
			))
		) {
			if (prec > minPrec) {
				const operator = (String(parser.state.tokenValue));

				if (
					operator === "**" &&
					left.type === "UnaryExpression" &&
					!parser.isParenthesized(left)
				) {
					parser.addDiagnostic({
						loc: left.argument.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.WRAP_EXPONENTIATION,
					});
				}

				const op = parser.state.tokenType;
				parser.next();

				const startPos = parser.state.startPos;

				const right = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(
					parser,
					context,
					___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(
						parser,
						context,
					),
					startPos,
					op.rightAssociative ? prec - 1 : prec,
					noIn,
				);

				let node;
				if (operator === "||" || operator === "&&" || operator === "??") {
					node = parser.finishNode(
						leftStartPos,
						{
							type: "LogicalExpression",
							left,
							right,
							operator,
						},
					);
				} else {
					node = parser.finishNode(
						leftStartPos,
						{
							type: "BinaryExpression",
							left,
							right,
							operator,
						},
					);
				}

				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionOp(
					parser,
					context,
					node,
					leftStartPos,
					minPrec,
					noIn,
				);
			}
		}

		return left;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(
		parser,
		context,
		refShorthandDefaultPos,
	) {
		if (
			parser.isSyntaxEnabled("ts") &&
			!parser.isSyntaxEnabled("jsx") &&
			parser.isRelational("<")
		) {
			return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion(
				parser,
			);
		}

		if (parser.isContextual("await") && parser.inScope("ASYNC")) {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAwait(
				parser,
			);
		}

		if (parser.state.tokenType.prefix) {
			const start = parser.getPosition();
			const update = parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.incDec,
			);
			const operator = (String(parser.state.tokenValue));
			const prefix = true;

			parser.next();

			const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(
				parser,
				context,
			);

			if (
				refShorthandDefaultPos &&
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
					refShorthandDefaultPos.index,
				) > 0
			) {
				parser.unexpectedToken(
					parser.getPositionFromIndex(refShorthandDefaultPos.index),
				);
			}

			if (update) {
				___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
					parser,
					argument,
					undefined,
					undefined,
					"prefix operation",
				);
			} else if (parser.inScope("STRICT") && operator === "delete") {
				if (argument.type === "ReferenceIdentifier") {
					parser.addDiagnostic({
						loc: argument.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DELETE_LOCAL_VARIABLE_IN_STRICT,
					});
				} else if (
					argument.type === "MemberExpression" &&
					argument.property.value.type === "PrivateName"
				) {
					parser.addDiagnostic({
						loc: argument.property.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DELETE_PRIVATE_FIELD,
					});
				}
			}

			let node;
			if (update) {
				if (operator !== "++" && operator !== "--") {
					throw new Error("Expected ++/-- operator only for UpdateExpression");
				}

				node = parser.finishNode(
					start,
					{
						type: "UpdateExpression",
						argument,
						operator,
						prefix,
					},
				);
			} else {
				if (operator === "++" || operator === "--") {
					throw new Error("BinaryExpression cannot have ++/-- operator");
				}

				node = parser.finishNode(
					start,
					{
						type: "UnaryExpression",
						argument,
						operator,
						prefix,
					},
				);
			}

			return node;
		}

		const startPos = parser.state.startPos;

		let expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
			parser,
			context,
			refShorthandDefaultPos,
		);
		if (
			refShorthandDefaultPos &&
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			return expr;
		}

		while (parser.state.tokenType.postfix && !parser.canInsertSemicolon()) {
			const operator = (String(parser.state.tokenValue));
			___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
				parser,
				expr,
				undefined,
				undefined,
				"postfix operation",
			);
			parser.next();

			const updateNode = parser.finishNode(
				startPos,
				{
					type: "UpdateExpression",
					operator,
					prefix: false,
					argument: expr,
				},
			);
			expr = updateNode;
		}

		return expr;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
		parser,
		context,
		refShorthandDefaultPos,
	) {
		const startPos = parser.state.startPos;
		const potentialArrowAt = parser.state.potentialArrowAt;
		const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(
			parser,
			context,
			refShorthandDefaultPos,
		);

		if (
			expr.type === "ArrowFunctionExpression" &&
			parser.getLoc(expr).start.index === potentialArrowAt
		) {
			return expr;
		}

		if (
			refShorthandDefaultPos &&
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) > 0
		) {
			return expr;
		}

		return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseSubscripts(
			parser,
			expr,
			startPos,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseSubscripts(
		parser,
		base,
		startPos,
		noCalls,
	) {
		const maybeAsyncArrow = ___R$project$rome$$romejs$js$parser$parser$expression_ts$atPossibleAsync(
			parser,
			base,
		);

		if (
			base.type === "ReferenceIdentifier" &&
			base.name === "async" &&
			parser.state.noArrowAt.includes(startPos.index)
		) {
			const argsStart = parser.getPosition();
			const openContext = parser.expectOpening(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
				"call arguments",
			);
			const callee = base;
			const {args} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
				parser,
				openContext,
				false,
			);
			base = parser.finishNodeWithCommentStarts(
				[argsStart, startPos],
				{
					type: "CallExpression",
					callee,
					arguments: args,
				},
			);
		} else if (
			base.type === "ReferenceIdentifier" &&
			base.name === "async" &&
			parser.isRelational("<")
		) {
			const branch = parser.createBranch();
			branch.add(() =>
				___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowWithTypeParameters(
					parser,
					startPos,
				)
			);
			branch.add(() =>
				___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
					parser,
					base,
					startPos,
					noCalls,
					maybeAsyncArrow,
				)
			);
			return branch.pick();
		}

		return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
			parser,
			base,
			startPos,
			noCalls,
			maybeAsyncArrow,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowWithTypeParameters(
		parser,
		startPos,
	) {
		const {params, rest, typeParameters} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams(
			parser,
		);

		const {returnType, valid} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowHead(
			parser,
		);
		if (!valid) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_ASYNC_ARROW_WITH_TYPE_PARAMS,
			});
			return undefined;
		}

		const func = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
			parser,
			startPos,
			{
				bindingList: params,
				rest,
			},
			/* isAsync */ true,
		);

		return Object.assign(
			{},
			func,
			{head: Object.assign({}, func.head, {returnType, typeParameters})},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscriptsRecursively(
		parser,
		base,
		startPos,
		noCalls,
		maybeAsyncArrow,
	) {
		const state = {
			optionalChainMember: false,
			stop: false,
		};
		do {
			base = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscript(
				parser,
				base,
				startPos,
				noCalls,
				state,
				maybeAsyncArrow,
			);
		} while (!state.stop);
		return base;
	}



	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionSubscript(
		parser,
		base,
		startPos,
		noCalls = false,
		state,
		maybeAsyncArrow,
	) {
		if (
			!parser.hasPrecedingLineBreak() &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang,
			)
		) {
			parser.state.exprAllowed = false;
			parser.next();

			return parser.finishNode(
				startPos,
				{
					type: "TSNonNullExpression",
					expression: base,
				},
			);
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot,
			)
		) {
			state.optionalChainMember = true;

			if (
				noCalls &&
				parser.lookaheadState().tokenType ===
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL
			) {
				state.stop = true;
				return base;
			}

			parser.next();

			// eg: o.m?.<T>(e);
			if (parser.isRelational("<")) {
				if (noCalls) {
					state.stop = true;
					return base;
				}

				const callee = base;
				const typeArguments = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
					parser,
				);
				const openContext = parser.expectOpening(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
					"call arguments",
				);
				const {args} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
					parser,
					openContext,
					false,
				);
				return parser.finishNode(
					startPos,
					{
						type: "OptionalCallExpression",
						arguments: args,
						callee,
						typeArguments,
					},
				);
			}

			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
				)
			) {
				const propStart = parser.getPosition();
				const openContext = parser.expectOpening(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
					"computed property",
				);
				const object = base;
				const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
					parser,
					"optional member expression property",
				);
				parser.expectClosing(openContext);
				return parser.finishNode(
					startPos,
					{
						type: "MemberExpression",
						object,
						property: parser.finishNode(
							propStart,
							{
								type: "ComputedMemberProperty",
								optional: true,
								value: property,
							},
						),
					},
				);
			}

			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
				)
			) {
				const openContext = parser.expectOpening(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
					"call arguments",
				);
				const callee = base;
				const {args} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
					parser,
					openContext,
					false,
				);

				return parser.finishNode(
					startPos,
					{
						type: "OptionalCallExpression",
						callee,
						arguments: args,
					},
				);
			}

			const object = base;
			const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);

			return parser.finishNode(
				startPos,
				{
					type: "MemberExpression",
					object,
					property: {
						type: "StaticMemberProperty",
						loc: property.loc,
						optional: true,
						value: property,
					},
				},
			);
		}

		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			const object = base;
			const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(
				parser,
			);

			return parser.finishNode(
				startPos,
				{
					type: "MemberExpression",
					object,
					property: {
						type: "StaticMemberProperty",
						loc: property.loc,
						value: property,
					},
				},
			);
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			const propStart = parser.getPosition();
			const openContext = parser.expectOpening(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
				"computed property",
			);
			const object = base;
			const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
				parser,
				"member expression computed property",
			);
			parser.expectClosing(openContext);

			return parser.finishNode(
				startPos,
				{
					type: "MemberExpression",
					object,
					property: parser.finishNode(
						propStart,
						{
							type: "ComputedMemberProperty",
							value: property,
						},
					),
				},
			);
		}

		// Supports: foo<Foo>(); and foo<Foo>``;
		if (parser.isRelational("<") && parser.isSyntaxEnabled("ts")) {
			const possibleCallExpression = parser.tryBranch(() => {
				const typeArguments = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
					parser,
				);

				if (
					!noCalls &&
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
					)
				) {
					const argsStart = parser.getPosition();
					const openContext = parser.expectOpening(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
						"call arguments",
					);
					const {args} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
						parser,
						openContext,
						false,
					);
					const node = parser.finishNodeWithCommentStarts(
						[argsStart, startPos],
						{
							type: "CallExpression",
							arguments: args,
							callee: base,
							typeArguments,
						},
					);
					return node;
				}

				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
					)
				) {
					return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
						parser,
						startPos,
						base,
						state,
						typeArguments,
					);
				}

				return undefined;
			});

			if (possibleCallExpression !== undefined) {
				return possibleCallExpression;
			}
		}

		if (
			!noCalls &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			)
		) {
			const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
			const oldYieldPos = parser.state.yieldPos;
			const oldAwaitPos = parser.state.awaitPos;
			parser.state.maybeInArrowParameters = true;
			parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
			parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;

			const argsStart = parser.getPosition();
			const openContext = parser.expectOpening(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
				"call arguments",
			);
			const callee = base;

			const oldCommaAfterSpreadAt = parser.state.commaAfterSpreadAt;
			parser.state.commaAfterSpreadAt = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1;

			let {args, params} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
				parser,
				openContext,
				maybeAsyncArrow,
			);

			if (
				maybeAsyncArrow &&
				___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(
					parser,
				)
			) {
				state.stop = true;

				___R$project$rome$$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread(
					parser,
				);

				const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression(
					parser,
					startPos,
					params === undefined ? args : params,
				);
				___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(
					parser,
				);
				parser.state.yieldPos = oldYieldPos;
				parser.state.awaitPos = oldAwaitPos;
				return node;
			} else {
				args = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeep(
					parser,
					args,
				);

				// We keep the old value if it isn't null, for cases like

				//   (x = async(yield)) => {}
				parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
				parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;
			}

			parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
			parser.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;

			return parser.finishNodeWithCommentStarts(
				[argsStart, startPos],
				{
					type: "CallExpression",
					callee,
					arguments: args,
				},
			);
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
			)
		) {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
				parser,
				startPos,
				base,
				state,
			);
		}

		state.stop = true;
		return base;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTaggedTemplateExpression(
		parser,
		startPos,
		tag,
		state,
		typeArguments,
	) {
		if (state.optionalChainMember) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TAGGED_TEMPLATE_IN_OPTIONAL_CHAIN,
			});
		}

		const quasi = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate(
			parser,
			true,
		);
		return parser.finishNode(
			startPos,
			{
				type: "TaggedTemplateExpression",
				tag,
				quasi,
				typeArguments,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(
		parser,
	) {
		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(parser.state.yieldPos) > 0 &&
			(parser.state.awaitPos ===
			___R$project$rome$$romejs$ob1$index_ts$ob1Number0 ||
			parser.state.yieldPos < parser.state.awaitPos)
		) {
			parser.addDiagnostic({
				index: parser.state.yieldPos,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.YIELD_IN_GENERATOR_PARAMS,
			});
		}

		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(parser.state.awaitPos) >
			0
		) {
			parser.addDiagnostic({
				index: parser.state.awaitPos,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.AWAIT_IN_ASYNC_PARAMS,
			});
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$atPossibleAsync(
		parser,
		base,
	) {
		const loc = parser.getLoc(base);
		return (
			base.type === "ReferenceIdentifier" &&
			base.name === "async" &&
			parser.state.lastEndPos.index === loc.end.index &&
			!parser.canInsertSemicolon() &&
			parser.getRawInput(loc.start.index, loc.end.index) === "async"
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallExpressionArguments(
		parser,
		openContext,
		possibleAsyncArrow,
		refTrailingCommaPos,
	) {
		let callArgs = [];
		let funcParams = [];

		let innerParenStart;
		let first = true;

		let forceAsyncArrow = false;

		while (true) {
			if (
				parser.match(openContext.close) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				parser.expectClosing(openContext);
				break;
			}

			if (first) {
				first = false;
			} else {
				if (
					!parser.expect(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
					)
				) {
					break;
				}

				if (parser.eat(openContext.close)) {
					break;
				}
			}

			// we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
				) &&
				!innerParenStart
			) {
				innerParenStart = parser.state.startPos;
			}

			const elt = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument(
				parser,
				"call expression argument",
				false,
				possibleAsyncArrow
					? ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker()
					: undefined,
				possibleAsyncArrow
					? ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker()
					: undefined,
				possibleAsyncArrow ? refTrailingCommaPos : undefined,
			);
			if (elt.type === "ArrayHole") {
				throw new Error("Expected element");
			}

			if (elt.type === "AmbiguousFlowTypeCastExpression") {
				if (possibleAsyncArrow) {
					// Definitely needs to be an arrow
					forceAsyncArrow = true;

					if (callArgs.length > 0) {
						funcParams = callArgs.slice();
						callArgs = [];
					}

					funcParams.push(elt);
				} else {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.CONFUSING_CALL_ARGUMENT,
						loc: elt.loc,
					});
				}
				continue;
			}

			if (funcParams.length > 0) {
				funcParams.push(elt);
			} else {
				callArgs.push(elt);
			}
		}

		if (
			forceAsyncArrow &&
			!___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(
				parser,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_ARROW_AFTER_ASYNC_TYPE_PARAMS,
			});
		}

		// we found an async arrow function so let's not allow any inner parens
		if (
			possibleAsyncArrow &&
			innerParenStart !== undefined &&
			___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(
				parser,
			)
		) {
			parser.addDiagnostic({
				start: innerParenStart,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.PARENTHESIZED_FUNCTION_PARAMS,
			});
		}

		return {
			args: callArgs,
			params: funcParams.length === 0 ? undefined : funcParams,
		};
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseAsyncArrow(
		parser,
	) {
		return (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			) ||
			(parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
			) &&
			!parser.canInsertSemicolon())
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAsyncArrowFromCallExpression(
		parser,
		start,
		args,
	) {
		let returnType;

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
			parser.state.noAnonFunctionType = true;
			returnType = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
			parser.state.noAnonFunctionType = oldNoAnonFunctionType;
		}

		const oldYield = parser.state.yieldInPossibleArrowParameters;
		parser.state.yieldInPossibleArrowParameters = undefined;
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
		);
		const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
			parser,
			start,
			{
				assignmentList: args,
			},
			true,
		);
		parser.state.yieldInPossibleArrowParameters = oldYield;
		return Object.assign(
			{},
			node,
			{head: Object.assign({}, node.head, {returnType})},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNoCallExpr(
		parser,
		context,
	) {
		const startPos = parser.state.startPos;
		return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseSubscripts(
			parser,
			___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(
				parser,
				context,
			),
			startPos,
			true,
		);
	}



	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(
		parser,
		context,
		refShorthandDefaultPos,
	) {
		// If a division operator appears in an expression position, the
		// tokenizer got confused, and we force it to read a regexp instead.
		if (
			parser.state.tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash
		) {
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readRegexp(parser);
		}

		const canBeArrow =
			parser.state.potentialArrowAt === parser.state.startPos.index;

		// We don't want to match <! as it's the start of a HTML comment
		if (
			parser.isRelational("<") &&
			parser.input.charCodeAt(
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(parser.state.index),
			) !== ___R$project$rome$$romejs$string$charcodes$index_ts.exclamationMark
		) {
			// In case we encounter an lt token here it will always be the start of
			// jsx as the lt sign is not allowed in places that expect an expression
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart,
			);
			return ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement(
				parser,
			);
		}

		switch (parser.state.tokenType) {
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart:
				return ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._super:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseSuper(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseImportOrMetaProperty(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._this: {
				const start = parser.getPosition();
				parser.next();
				return parser.finishNode(start, {type: "ThisExpression"});
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name: {
				const start = parser.getPosition();
				const containsEsc = parser.state.escapePosition !== undefined;
				const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
					parser,
				);

				if (
					!containsEsc &&
					id.name === "async" &&
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function,
					) &&
					!parser.canInsertSemicolon()
				) {
					parser.next();
					return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionExpression(
						parser,
						start,
						true,
					);
				}

				if (
					canBeArrow &&
					!containsEsc &&
					id.name === "async" &&
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
					)
				) {
					const oldYield = parser.state.yieldInPossibleArrowParameters;
					parser.state.yieldInPossibleArrowParameters = undefined;
					const params = [
						___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(
							parser,
						),
					];
					parser.expect(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
					);
					// let foo = bar => {};
					const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
						parser,
						start,
						{
							assignmentList: params,
						},
						true,
					);
					parser.state.yieldInPossibleArrowParameters = oldYield;
					return node;
				}

				if (
					canBeArrow &&
					!parser.canInsertSemicolon() &&
					parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
					)
				) {
					const oldYield = parser.state.yieldInPossibleArrowParameters;
					parser.state.yieldInPossibleArrowParameters = undefined;
					const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
						parser,
						start,
						{
							assignmentList: [
								___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
									parser,
									id,
								),
							],
						},
					);
					parser.state.yieldInPossibleArrowParameters = oldYield;
					return node;
				}

				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					id,
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._do:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseDoExpression(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.regexp:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseRegExpLiteral(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bigint:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseBigIntLiteral(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._null:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseNullLiteral(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._false:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBooleanLiteral(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression(
					parser,
					context,
					canBeArrow,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseArrayExpression(
					parser,
					refShorthandDefaultPos,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectExpression(
					parser,
					refShorthandDefaultPos,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class: {
				const start = parser.getPosition();
				return ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassExpression(
					parser,
					start,
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNew(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate(
					parser,
					false,
				);

			default: {
				const start = parser.getPosition();
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNKNOWN_EXPRESSION_ATOM_START(
						context,
					),
				});
				parser.next();
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					parser.createUnknownIdentifier(context, start),
				);
			}
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBooleanLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const value = parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true,
		);
		parser.next();
		return parser.finishNode(
			start,
			{
				type: "BooleanLiteral",
				value,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(
		parser,
	) {
		const isPrivate = parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.hash,
		);

		if (isPrivate) {
			const start = parser.getPosition();
			parser.next();
			parser.assertNoSpace(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.SPACE_BETWEEN_PRIVATE_HASH,
			);
			const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);
			return parser.finishNode(
				start,
				{
					type: "PrivateName",
					id,
				},
			);
		} else {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionExpressionOrMetaProperty(
		parser,
	) {
		const start = parser.getPosition();
		parser.next();

		// We do not do parseIdentifier here because when parseFunctionExpressionOrMetaProperty

		// is called we already know that the current token is a "name" with the value "function"

		// This will improve perf a tiny little bit as we do not do validation but more importantly

		// here is that parseIdentifier will remove an item from the expression stack

		// if "function" or "class" is parsed as identifier (in objects e.g.), which should not happen here.
		const meta = ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier(
			parser,
			start,
			"function",
		);

		if (
			parser.inScope("GENERATOR") &&
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty(
				parser,
				start,
				meta,
				"sent",
			);
		}

		const node = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionExpression(
			parser,
			start,
			false,
		);

		if (node.type !== "FunctionExpression") {
			throw new Error("Expected parseFunction to return a FunctionExpression");
		}

		return node;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty(
		parser,
		start,
		meta,
		propertyName,
	) {
		if (
			meta.name === "function" &&
			propertyName === "sent" &&
			!parser.isContextual(propertyName)
		) {
			// They didn't actually say `function.sent`, just `function.`, so a simple error would be less confusing.
			parser.unexpectedToken();
		}

		const escapePosition = parser.state.escapePosition;
		const property = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);

		if (property.name === propertyName) {
			parser.banUnicodeEscape(escapePosition, propertyName);
		} else {
			parser.addDiagnostic({
				loc: property.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_META_PROPERTY(
					meta.name,
					propertyName,
				),
			});
		}

		return parser.finishNode(
			start,
			{
				type: "MetaProperty",
				meta,
				property,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseImportMetaProperty(
		parser,
	) {
		const start = parser.getPosition();
		const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
		);
		const node = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty(
			parser,
			start,
			id,
			"meta",
		);

		if (!parser.inModule) {
			parser.addDiagnostic({
				loc: node.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_META_OUTSIDE_MODULE,
			});
		}

		return node;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenExpression(
		parser,
		context,
	) {
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			context,
		);
		const val = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
			parser,
			context,
		);
		parser.expectClosing(openContext);
		return val;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenAndDistinguishExpression(
		parser,
		context,
		canBeArrow,
	) {
		if (parser.state.noArrowAt.includes(parser.state.startPos.index)) {
			canBeArrow = false;
		}

		const startPos = parser.state.startPos;

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			"paren expression",
		);

		const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
		const oldYieldPos = parser.state.yieldPos;
		const oldAwaitPos = parser.state.awaitPos;
		const oldYield = parser.state.yieldInPossibleArrowParameters;
		parser.state.maybeInArrowParameters = true;
		parser.state.yieldInPossibleArrowParameters = undefined;
		parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
		parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;

		const innerStart = parser.getPosition();
		const exprList = [];
		const refShorthandDefaultPos = ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker();
		const refNeedsArrowPos = ___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker();
		let first = true;
		let spreadStart;
		let optionalCommaStart;

		while (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			)
		) {
			if (first) {
				first = false;
			} else {
				if (
					!parser.expect(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
						refNeedsArrowPos.index ===
						___R$project$rome$$romejs$ob1$index_ts$ob1Number0
							? undefined
							: parser.getPositionFromIndex(refNeedsArrowPos.index),
					)
				) {
					break;
				}

				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
					)
				) {
					optionalCommaStart = parser.state.startPos;
					break;
				}
			}

			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
				)
			) {
				const spreadNodeStartPos = parser.state.startPos;
				spreadStart = parser.state.startPos;
				exprList.push(
					___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem(
						parser,
						___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread(
							parser,
						),
						spreadNodeStartPos,
					),
				);

				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
					) &&
					parser.lookaheadState().tokenType ===
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR
				) {
					___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
						parser,
					);
					parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
					);
				}
			} else {
				exprList.push(
					___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
						parser,
						context,
						false,
						refShorthandDefaultPos,
						___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem,
						refNeedsArrowPos,
					),
				);
			}
		}

		const innerEnd = parser.getPosition();
		parser.expectClosing(openContext);

		parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;

		const arrowStart = startPos;
		if (
			canBeArrow &&
			___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseArrow(
				parser,
			)
		) {
			const {valid, returnType} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowHead(
				parser,
			);

			if (valid) {
				___R$project$rome$$romejs$js$parser$parser$expression_ts$checkYieldAwaitInDefaultParams(
					parser,
				);
				parser.state.yieldPos = oldYieldPos;
				parser.state.awaitPos = oldAwaitPos;

				for (const param of exprList) {
					if (parser.isParenthesized(param)) {
						parser.addDiagnostic({
							loc: param.loc,
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.PARENTHESIZED_FUNCTION_PARAMS,
						});
					}
				}

				const arrow = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
					parser,
					arrowStart,
					{
						assignmentList: exprList,
					},
				);
				parser.state.yieldInPossibleArrowParameters = oldYield;
				return Object.assign(
					{},
					arrow,
					{head: Object.assign({}, arrow.head, {returnType})},
				);
			}
		}

		parser.state.yieldInPossibleArrowParameters = oldYield;

		// We keep the old value if it isn't null, for cases like

		//   (x = (yield)) => {}
		parser.state.yieldPos = oldYieldPos || parser.state.yieldPos;
		parser.state.awaitPos = oldAwaitPos || parser.state.awaitPos;

		if (exprList.length === 0) {
			parser.addDiagnostic({
				start: innerStart,
				end: innerEnd,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EMPTY_PARENTHESIZED_EXPRESSION,
			});

			exprList.push(
				___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					parser.createUnknownIdentifier(
						"empty parenthesized expression",
						innerStart,
						innerEnd,
					),
				),
			);
		}

		if (optionalCommaStart !== undefined) {
			parser.unexpectedToken(optionalCommaStart);
		}

		if (spreadStart !== undefined) {
			parser.unexpectedToken(spreadStart);
		}

		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				refShorthandDefaultPos.index,
			) >
			0
		) {
			parser.unexpectedToken(
				parser.getPositionFromIndex(refShorthandDefaultPos.index),
			);
		}

		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(refNeedsArrowPos.index) >
			0
		) {
			parser.unexpectedToken(
				parser.getPositionFromIndex(refNeedsArrowPos.index),
			);
		}

		const filterList = ___R$project$rome$$romejs$js$parser$parser$lval_ts$filterSpread(
			parser,
			___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeep(
				parser,
				exprList,
				/* isParenthesizedExpr */ true,
			),
		);

		let val = filterList[0];
		if (filterList.length > 1) {
			val = parser.finishNodeAt(
				innerStart,
				innerEnd,
				{
					type: "SequenceExpression",
					expressions: filterList,
				},
			);
		}

		parser.addParenthesized(val);

		return val;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$shouldParseArrow(
		parser,
	) {
		return (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			) || !parser.canInsertSemicolon()
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowHead(
		parser,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			const oldNoAnonFunctionType = parser.state.noAnonFunctionType;
			parser.state.noAnonFunctionType = true;

			const branch = parser.createBranch();

			branch.add(() => {
				const res = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
				);

				if (parser.canInsertSemicolon()) {
					// No semicolon insertion expected
					return undefined;
				}

				if (
					parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
					)
				) {
					return res;
				}

				return undefined;
			});

			if (branch.hasBranch()) {
				const returnType = branch.pick();
				parser.state.noAnonFunctionType = oldNoAnonFunctionType;

				if (returnType === undefined) {
					throw new Error(
						"hasBranchResult call above should have refined this condition",
					);
				}

				return {
					valid: true,
					returnType,
				};
			} else {
				parser.state.noAnonFunctionType = oldNoAnonFunctionType;
				return {
					valid: false,
					returnType: undefined,
				};
			}
		} else {
			return {
				valid: parser.eat(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
				),
				returnType: undefined,
			};
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem(
		parser,
		node,
		startPos,
	) {
		let optional = undefined;
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			optional = true;
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			const typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
			return parser.finishNode(
				startPos,
				{
					type: "AmbiguousFlowTypeCastExpression",
					expression: node,
					typeAnnotation,
					optional,
				},
			);
		}

		if (optional) {
			return parser.finishNode(
				startPos,
				{
					type: "AmbiguousFlowTypeCastExpression",
					expression: node,
					typeAnnotation: undefined,
					optional,
				},
			);
		}

		return node;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNew(
		parser,
	) {
		const start = parser.getPosition();
		const meta = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);

		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			const metaProp = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMetaProperty(
				parser,
				start,
				meta,
				"target",
			);

			if (
				!parser.inScope("NON_ARROW_FUNCTION") &&
				!parser.inScope("CLASS_PROPERTY")
			) {
				parser.addDiagnostic({
					loc: metaProp.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.NEW_TARGET_OUTSIDE_CLASS,
				});
			}

			return metaProp;
		}

		const callee = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNoCallExpr(
			parser,
			"new callee",
		);

		if (callee.type === "ImportCall") {
			parser.addDiagnostic({
				loc: callee.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.SUPER_OUTSIDE_METHOD,
			});
		}

		const optionalMember = ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(
			callee,
		);
		if (optionalMember !== undefined) {
			const memberLoc = parser.getLoc(optionalMember);

			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.NEW_IN_OPTIONAL_CHAIN(
					memberLoc,
				),
			});
		}

		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.NEW_IN_OPTIONAL_CHAIN(),
			});
		}

		let optional = undefined;
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot,
			)
		) {
			optional = true;
		}

		let typeArguments = undefined;
		if (parser.isSyntaxEnabled("ts") && parser.isRelational("<")) {
			typeArguments = parser.tryBranch(
				___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments,
			);
		}

		let args = [];
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			)
		) {
			const openContext = parser.expectOpening(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
				"new argument",
			);
			args = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty(
				parser,
				"new expression argument",
				openContext,
			);
			args = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList(
				parser,
				args,
			);
		} else if (parser.isSyntaxEnabled("ts") && typeArguments !== undefined) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.NEW_WITH_TYPESCRIPT_TYPE_ARGUMENTS_NO_PARENS,
			});
		}

		return parser.finishNode(
			start,
			{
				type: "NewExpression",
				callee,
				typeArguments,
				arguments: args,
				optional,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(
		node,
	) {
		if (node.type === "OptionalCallExpression") {
			return node;
		}

		if (node.type === "MemberExpression") {
			if (node.property.optional) {
				return node;
			}

			if (node.property.type === "StaticMemberProperty") {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$getFirstOptionalChainMember(
					node.object,
				);
			}
		}

		return undefined;
	}

	// Parse template expression.
	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplateElement(
		parser,
		isTagged,
	) {
		const start = parser.getPosition();
		const tokenValue = parser.state.tokenValue;

		if (tokenValue === undefined) {
			if (isTagged) {
				parser.state.invalidTemplateEscapePosition = undefined;
			} else {
				parser.addDiagnostic({
					index: parser.state.invalidTemplateEscapePosition,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_TEMPLATE_ESCAPE,
				});
			}
		}

		const raw = parser.getRawInput(
			parser.state.startPos.index,
			parser.state.endPos.index,
		).replace(/\r\n?/g, "\n");
		const cooked = tokenValue === undefined ? raw : String(tokenValue);

		parser.next();
		const tail = parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
		);
		return parser.finishNode(
			start,
			{
				type: "TemplateElement",
				raw,
				cooked,
				tail,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate(
		parser,
		isTagged,
	) {
		const start = parser.getPosition();
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
			"template literal",
		);
		const expressions = [];
		let curElt = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplateElement(
			parser,
			isTagged,
		);
		const quasis = [curElt];

		while (true) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				) ||
				curElt.tail === true
			) {
				break;
			}

			const exprPpenContext = parser.expectOpening(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				"template expression value",
			);
			expressions.push(
				___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
					parser,
					"template expression value",
				),
			);
			parser.expectClosing(exprPpenContext);

			curElt = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplateElement(
				parser,
				isTagged,
			);
			quasis.push(curElt);
		}

		parser.expectClosing(openContext);

		return parser.finishNode(
			start,
			{
				type: "TemplateLiteral",
				expressions,
				quasis,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectExpression(
		parser,
		refShorthandDefaultPos,
	) {
		const propHash = new Set();
		let first = true;

		const start = parser.getPosition();
		const properties = [];

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"object",
		);

		while (true) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				parser.expectClosing(openContext);
				break;
			}

			if (first) {
				first = false;
			} else {
				if (
					!parser.expect(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
					)
				) {
					break;
				}

				if (
					parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					break;
				}
			}

			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
				)
			) {
				const prop = Object.assign(
					{},
					___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread(parser),
					{type: "SpreadProperty"},
				);
				properties.push(prop);
				continue;
			}

			const start = parser.getPosition();
			let isGenerator = parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			);
			let isAsync = false;

			let key;
			let escapePosition;

			if (parser.isContextual("async")) {
				if (isGenerator) {
					parser.unexpectedToken();
				}

				const asyncId = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
					parser,
				);
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
					)
				) {
					key = {
						type: "StaticPropertyKey",
						loc: asyncId.loc,
						value: asyncId,
					};
				} else {
					if (parser.hasPrecedingLineBreak()) {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ASYNC_OBJECT_METHOD_LINE_BREAK,
						});
					}

					isAsync = true;
					if (
						parser.match(
							___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
						)
					) {
						parser.next();
						isGenerator = true;
					}
					escapePosition = parser.state.escapePosition;
					key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(
						parser,
					);
				}
			} else {
				escapePosition = parser.state.escapePosition;
				key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(
					parser,
				);
			}

			const prop = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(
				parser,
				{
					key,
					start,
					isGenerator,
					isAsync,
					isPattern: false,
					refShorthandDefaultPos,
					escapePosition,
				},
			);
			if (prop === undefined) {
				continue;
			}
			if (prop.type === "BindingObjectPatternProperty") {
				throw new Error("Impossible");
			}

			___R$project$rome$$romejs$js$parser$parser$expression_ts$checkPropClash(
				parser,
				prop,
				propHash,
			);
			properties.push(prop);
		}

		return parser.finishNode(
			start,
			{
				type: "ObjectExpression",
				properties,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPattern(
		parser,
		refShorthandDefaultPos,
	) {
		const propHash = new Set();
		let first = true;

		const start = parser.getPosition();
		const properties = [];
		let rest;

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"object pattern",
		);

		let firstRestLocation = undefined;

		while (true) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				)
			) {
				break;
			}

			if (first) {
				first = false;
			} else {
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				);

				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					break;
				}
			}

			let isGenerator = false;
			let isAsync = false;
			let start = parser.getPosition();

			if (
				parser.eat(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
				)
			) {
				const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
					parser,
				);
				rest = argument;

				if (firstRestLocation !== undefined) {
					parser.addDiagnostic({
						loc: argument.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.MULTIPLE_DESTRUCTURING_RESTS,
					});
				}

				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
					)
				) {
					break;
				}

				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
					) &&
					parser.lookaheadState().tokenType ===
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR
				) {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TRAILING_COMMA_AFTER_REST,
					});
					parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
					);
					break;
				} else {
					firstRestLocation = argument.loc;
					continue;
				}
			}

			start = parser.getPosition();

			const key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(
				parser,
			);
			const prop = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(
				parser,
				{
					key,
					start,
					isGenerator,
					isAsync,
					isPattern: true,
					refShorthandDefaultPos,
					escapePosition: undefined,
				},
			);

			if (prop === undefined) {
				continue;
			}

			___R$project$rome$$romejs$js$parser$parser$expression_ts$checkPropClash(
				parser,
				prop,
				propHash,
			);

			if (prop.type !== "BindingObjectPatternProperty") {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_OBJECT_PATTERN_PROP,
					loc: prop.loc,
				});
				continue;
			}

			properties.push(prop);
		}

		parser.expectClosing(openContext);

		if (firstRestLocation !== undefined) {
			___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
				parser,
				firstRestLocation,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "BindingObjectPattern",
				properties,
				rest,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod(
		parser,
		key,
		// `key` is always from `name.key`, we just need it here to refine
		keyVal,
		isPattern,
	) {
		return (
			!isPattern &&
			key.type === "StaticPropertyKey" &&
			keyVal.type === "Identifier" &&
			(keyVal.name === "get" || keyVal.name === "set") &&
			(parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
			) ||
			// get "string"() {}
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num,
			) ||
			// get 1() {}
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			) ||
			// get ["string"]() {}
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			) ||
			// get foo() {}
			!!parser.state.tokenType.keyword) // get debugger() {}
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(
		parser,
		method,
		kind,
	) {
		const head = method.head;

		if (kind === "get") {
			if (head.rest !== undefined || head.params.length !== 0) {
				parser.addDiagnostic({
					loc: method.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.GETTER_WITH_PARAMS,
				});
			}
		} else if (kind === "set") {
			if (head.rest !== undefined) {
				parser.addDiagnostic({
					loc: head.rest.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.SETTER_WITH_REST,
				});
			} else if (head.params.length !== 1) {
				parser.addDiagnostic({
					loc: method.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.SETTER_NOT_ONE_PARAM,
				});
			}
		}
	}



	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectMethod(
		parser,
		{
			key,
			start,
			isGenerator,
			isAsync,
			isPattern,
			escapePosition,
		},
	) {
		if (
			isAsync ||
			isGenerator ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			)
		) {
			if (isPattern) {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.OBJECT_METHOD_IN_PATTERN,
				});
			}

			const partial = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
				parser,
				{
					kind: "method",
					isClass: false,
					isGenerator,
					isAsync,
					isConstructor: false,
				},
			);

			const {body} = partial;
			if (body === undefined || body.type !== "BlockStatement") {
				throw new Error("Expected body");
			}

			return parser.finishNode(
				start,
				Object.assign(
					{},
					partial,
					{body, key, type: "ObjectMethod", kind: "method"},
				),
			);
		}

		if (
			___R$project$rome$$romejs$js$parser$parser$expression_ts$isGetterOrSetterMethod(
				parser,
				key,
				key.value,
				isPattern,
			)
		) {
			if (isAsync) {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ASYNC_GETTER_SETTER,
				});
			}

			if (isGenerator) {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.GENERATOR_GETTER_SETTER,
				});
			}

			const kind = key.value.name;
			if (kind !== "get" && kind !== "set") {
				throw new Error(
					"Name should be get or set as we already validated it as such",
				);
			}
			parser.banUnicodeEscape(escapePosition, kind);

			const newKey = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(
				parser,
			);

			const partial = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
				parser,
				{
					kind,
					isClass: false,
					isGenerator: false,
					isAsync: false,
					isConstructor: false,
				},
			);

			const {body, head} = partial;
			if (body === undefined || body.type !== "BlockStatement") {
				throw new Error("Expected body");
			}

			const method = parser.finishNode(
				start,
				{
					head,
					body,
					key: newKey,
					type: "ObjectMethod",
					kind,
				},
			);
			___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(
				parser,
				method,
				method.kind,
			);
			return method;
		}

		return undefined;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectProperty(
		parser,
		key,
		start,
		isPattern,
		refShorthandDefaultPos,
	) {
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			if (isPattern) {
				const value = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault(
					parser,
				);
				return parser.finishNode(
					start,
					{
						key,
						type: "BindingObjectPatternProperty",
						value,
					},
				);
			} else {
				const value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"object property value",
					false,
					refShorthandDefaultPos,
				);
				return parser.finishNode(
					start,
					{
						key,
						type: "ObjectProperty",
						value,
					},
				);
			}
		}

		if (key.type === "StaticPropertyKey" && key.value.type === "Identifier") {
			___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
				parser,
				key.value.name,
				parser.getLoc(key.value),
				true,
				true,
			);

			if (isPattern) {
				let value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					parser.cloneNode(key.value),
				);

				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
					) &&
					refShorthandDefaultPos
				) {
					if (
						refShorthandDefaultPos.index ===
						___R$project$rome$$romejs$ob1$index_ts$ob1Number0
					) {
						refShorthandDefaultPos.index = parser.state.startPos.index;
					}

					value = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault(
						parser,
						start,
						value,
					);
				}

				return parser.finishNode(
					start,
					{
						type: "BindingObjectPatternProperty",
						key,
						value,
					},
				);
			}

			return parser.finishNode(
				start,
				{
					type: "ObjectProperty",
					key,
					value: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
						parser,
						parser.cloneNode(key.value),
					),
				},
			);
		}

		return undefined;
	}



	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyValue(
		parser,
		{
			key,
			start,
			isGenerator,
			isAsync,
			isPattern,
			refShorthandDefaultPos,
			escapePosition,
		},
	) {
		// parse type parameters for object method shorthand
		let typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
			parser,
		);
		if (
			typeParameters !== undefined &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			)
		) {
			parser.unexpectedToken();
		}

		let node =
			___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectMethod(
				parser,
				{
					key,
					start,
					isGenerator,
					isAsync,
					isPattern,
					escapePosition,
				},
			) ||
			___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectProperty(
				parser,
				key,
				start,
				isPattern,
				refShorthandDefaultPos,
			);

		if (node === undefined) {
			parser.unexpectedToken();
			return undefined;
		}

		if (typeParameters === undefined) {
			return node;
		} else {
			if (
				node.type === "ObjectProperty" ||
				node.type === "BindingObjectPatternProperty"
			) {
				parser.addDiagnostic({
					loc: typeParameters.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.OBJECT_PROPERTY_WITH_TYPE_PARAMETERS,
				});
				return node;
			}

			return Object.assign(
				{},
				node,
				{head: Object.assign({}, node.head, {typeParameters})},
			);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(
		parser,
	) {
		const start = parser.getPosition();

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			const openContext = parser.expectOpening(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
				"property name",
			);

			const value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"property name",
			);
			parser.expectClosing(openContext);
			return parser.finishNode(
				start,
				{
					type: "ComputedPropertyKey",
					value,
				},
			);
		} else {
			parser.pushScope("PROPERTY_NAME", true);

			// We check if it's valid for it to be a private name when we push it.
			let value;
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num,
				)
			) {
				value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral(
					parser,
				);
			} else if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
				)
			) {
				value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);
			} else {
				value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybePrivateName(
					parser,
				);
			}

			parser.popScope("PROPERTY_NAME");

			return parser.finishNode(
				start,
				{
					type: "StaticPropertyKey",
					value,
				},
			);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
		parser,
		opts,
	) {
		const {kind, isClass, isGenerator, isAsync, isConstructor} = opts;

		const oldYieldPos = parser.state.yieldPos;
		const oldAwaitPos = parser.state.awaitPos;
		parser.pushScope("FUNCTION", true);
		parser.pushScope("NON_ARROW_FUNCTION");
		parser.pushScope("METHOD", kind);
		parser.pushScope("GENERATOR", isGenerator);
		parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
		parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;

		const allowTSModifiers = isConstructor;
		const headStart = parser.getPosition();
		const {typeParameters, rest, params} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionParams(
			parser,
			kind,
			allowTSModifiers,
		);
		const start = parser.getPosition();
		const {body, head} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
			parser,
			{
				headStart,
				rest,
				params,
				id: undefined,
				allowBodiless: isClass,
				isArrowFunction: false,
				isAsync,
				isGenerator,
				isMethod: true,
				start,
			},
		);

		parser.popScope("METHOD");
		parser.popScope("GENERATOR");
		parser.popScope("FUNCTION");
		parser.popScope("NON_ARROW_FUNCTION");
		parser.state.yieldPos = oldYieldPos;
		parser.state.awaitPos = oldAwaitPos;

		return {
			head: Object.assign({}, head, {typeParameters}),
			body,
		};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$createFunctionHead(
		parser,
		params,
		rest,
		opts,
	) {
		const nonRestParams = [];

		for (const param of params) {
			switch (param.type) {
				case "BindingIdentifier":
				case "BindingAssignmentPattern":
				case "BindingObjectPattern":
				case "BindingArrayPattern": {
					nonRestParams.push(param);
					break;
				}

				default:
					throw new Error("TODO");
			}
		}

		return Object.assign(
			{type: "FunctionHead", rest},
			___R$project$rome$$romejs$js$parser$parser$statement_ts$splitFunctionParams(
				nonRestParams,
			),
			opts,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrowExpression(
		parser,
		start,
		opts,
		isAsync = false,
	) {
		// if we got there, it's no more "yield in possible arrow parameters";
		// it's just "yield in arrow parameters"
		if (parser.state.yieldInPossibleArrowParameters) {
			parser.addDiagnostic({
				start: parser.state.yieldInPossibleArrowParameters,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.YIELD_NAME_IN_GENERATOR,
			});
		}

		parser.pushScope("FUNCTION", true);

		const oldYieldPos = parser.state.yieldPos;
		const oldAwaitPos = parser.state.awaitPos;
		const oldMaybeInArrowParameters = parser.state.maybeInArrowParameters;
		parser.pushScope("GENERATOR", false);
		parser.state.maybeInArrowParameters = false;
		parser.state.yieldPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
		parser.state.awaitPos = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;

		const headEnd = parser.getLastEndPosition();

		let params = [];
		let rest = opts.rest;

		if (opts.bindingList !== undefined) {
			params = opts.bindingList;
		}

		if (opts.assignmentList !== undefined) {
			({params, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList(
				parser,
				opts.assignmentList,
				"arrow function parameters",
			));
		}

		let head = parser.finishNodeAt(
			start,
			headEnd,
			___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$createFunctionHead(
				parser,
				params,
				rest,
				{
					hasHoistedVars: false,
					async: isAsync,
				},
			),
		);

		const {body, hasHoistedVars} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBody(
			parser,
			{
				id: undefined,
				allowBodiless: false,
				isArrowFunction: true,
				isMethod: false,
				isAsync,
				isGenerator: false,
				start,
			},
		);

		head = Object.assign({}, head, {hasHoistedVars});

		___R$project$rome$$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams(
			parser,
			{
				isArrowFunction: true,
				isMethod: false,
				id: undefined,
				params,
				rest,
				start,
			},
			body,
		);

		parser.popScope("GENERATOR");
		parser.popScope("FUNCTION");
		parser.state.maybeInArrowParameters = oldMaybeInArrowParameters;
		parser.state.yieldPos = oldYieldPos;
		parser.state.awaitPos = oldAwaitPos;

		return parser.finishNode(
			start,
			{
				type: "ArrowFunctionExpression",
				body,
				head,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$isStrictBody(
		parser,
		body,
	) {
		if (body.type === "BlockStatement" && body.directives !== undefined) {
			for (const directive of body.directives) {
				if (directive.value === "use strict") {
					return true;
				}
			}
		}

		return false;
	}



	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBodyAndFinish(
		parser,
		opts,
	) {
		let returnType = undefined;

		// For arrow functions, `parseArrow` handles the return type itself.
		if (
			!opts.isArrowFunction &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			returnType = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			);
		}

		const headEnd = parser.getLastEndPosition();
		const head = parser.finishNodeAt(
			opts.headStart,
			headEnd,
			___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$createFunctionHead(
				parser,
				opts.params,
				opts.rest,
				{
					generator: opts.isGenerator,
					async: opts.isAsync,
					hasHoistedVars: false,
					returnType,
				},
			),
		);

		if (
			opts.allowBodiless &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			) &&
			parser.isLineTerminator()
		) {
			return {
				head,
				body: undefined,
			};
		}

		const {body, hasHoistedVars} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBody(
			parser,
			opts,
		);

		___R$project$rome$$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams(
			parser,
			{
				isArrowFunction: opts.isArrowFunction,
				isMethod: opts.isMethod,
				id: opts.id,
				start: opts.start,
				params: opts.params,
				rest: opts.rest,
			},
			body,
		);

		head.hasHoistedVars = hasHoistedVars;

		return {
			head,
			body,
		};
	}



	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseFunctionBody(
		parser,
		opts,
	) {
		if (opts.isArrowFunction) {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$forwardNoArrowParamsConversionAt(
				parser,
				opts.start,
				() =>
					___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseFunctionBody(
						parser,
						opts,
					)
				,
			);
		} else {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseFunctionBody(
				parser,
				opts,
			);
		}
	}

	// Parse function body and check parameters.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$_parseFunctionBody(
		parser,
		opts,
	) {
		const {isArrowFunction, isAsync, isGenerator} = opts;

		const isExpression =
			isArrowFunction &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			);

		parser.pushScope("PARAMETERS", false);
		parser.pushScope("ASYNC", isAsync);

		let hasHoistedVars = false;
		let body;
		if (isExpression) {
			body = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"function body",
			);
		} else {
			// Start a new scope with regard to labels and the `inGenerator`
			// flag (restore them to their old value afterwards).
			const oldLabels = parser.state.labels;
			parser.pushScope("GENERATOR", isGenerator);
			parser.state.labels = [];

			const oldhasHoistedVars = parser.state.hasHoistedVars;
			parser.state.hasHoistedVars = false;

			body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(
				parser,
				true,
			);
			hasHoistedVars = parser.state.hasHoistedVars;

			parser.popScope("GENERATOR");

			parser.state.hasHoistedVars = oldhasHoistedVars;
			parser.state.labels = oldLabels;
		}

		parser.popScope("ASYNC");
		parser.popScope("PARAMETERS");

		return {body, hasHoistedVars};
	}



	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkFunctionNameAndParams(
		parser,
		opts,
		body,
		force,
	) {
		const {isArrowFunction, isMethod, id, rest, params, start} = opts;

		if (
			!___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$isSimpleParamList(
				params,
				rest,
			) &&
			body.type === "BlockStatement" &&
			body.directives !== undefined
		) {
			const firstDirective = body.directives[0];
			if (firstDirective !== undefined && firstDirective.value === "use strict") {
				parser.addDiagnostic({
					loc: firstDirective.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.STRICT_DIRECTIVE_IN_NON_SIMPLE_PARAMS,
				});
			}
		}

		if (
			isArrowFunction &&
			force !== true &&
			parser.state.noArrowParamsConversionAt.includes(start.index)
		) {
			return undefined;
		}

		// If this is a strict mode function, verify that argument names

		// are not repeated, and it does not try to bind the words `eval`
		const _isStrictBody = ___R$project$rome$$romejs$js$parser$parser$expression_ts$isStrictBody(
			parser,
			body,
		);
		const isStrict = parser.inScope("STRICT") || _isStrictBody;

		const isSimpleParams = ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$isSimpleParamList(
			params,
			rest,
		);
		const shouldCheckLVal =
			isStrict || isArrowFunction || isMethod || !isSimpleParams;

		parser.pushScope("STRICT", isStrict);

		if (shouldCheckLVal) {
			const clashes = new Map();

			if (id !== undefined) {
				___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
					parser,
					id,
					true,
					undefined,
					"function name",
				);
			}

			for (const param of params) {
				if (_isStrictBody && param.type !== "BindingIdentifier") {
					parser.addDiagnostic({
						loc: param.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.NON_SIMPLE_PARAM_IN_EXPLICIT_STRICT_FUNCTION,
					});
				}
				___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
					parser,
					param,
					true,
					clashes,
					"function parameter list",
				);
			}
		}

		parser.popScope("STRICT");
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$isSimpleParamList(
		params,
		rest,
	) {
		if (rest !== undefined) {
			return false;
		}

		for (const param of params) {
			if (param.type !== "BindingIdentifier") {
				return false;
			}
		}

		return true;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionList(
		parser,
		context,
		openContext,
		allowEmpty,
		refShorthandDefaultPos,
	) {
		const elts = [];
		let first = true;

		while (true) {
			if (
				parser.match(openContext.close) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				break;
			}

			if (first) {
				first = false;
			} else {
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				);

				if (parser.match(openContext.close)) {
					break;
				}
			}

			elts.push(
				___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument(
					parser,
					context,
					allowEmpty,
					refShorthandDefaultPos,
				),
			);
		}

		parser.expectClosing(openContext);

		return elts;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionListNonEmpty(
		parser,
		context,
		openContext,
		refShorthandDefaultPos,
	) {
		const val = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionList(
			parser,
			context,
			openContext,
			false,
			refShorthandDefaultPos,
		);
		// @ts-ignore: Passed allowEmpty: false above
		return val;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument(
		parser,
		context,
		allowHoles = false,
		refShorthandDefaultPos,
		refNeedsArrowPos,
		refTrailingCommaPos,
	) {
		if (
			allowHoles &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrayHole(
				parser,
			);
		} else if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
			)
		) {
			const spreadNodeStart = parser.state.startPos;

			const elt = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem(
				parser,
				___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread(
					parser,
					refShorthandDefaultPos,
					refNeedsArrowPos,
				),
				spreadNodeStart,
			);

			if (
				refTrailingCommaPos &&
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				refTrailingCommaPos.index = parser.state.startPos.index;
			}

			return elt;
		} else {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				context,
				false,
				refShorthandDefaultPos,
				___R$project$rome$$romejs$js$parser$parser$expression_ts$parseParenItem,
				refNeedsArrowPos,
			);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
		parser,
		liberal,
	) {
		const start = parser.getPosition();
		const name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(
			parser,
			liberal,
		);
		return ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier(
			parser,
			start,
			name,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
		parser,
		liberal,
	) {
		return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
			parser,
			___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				liberal,
			),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(
		parser,
		liberal,
	) {
		return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
			parser,
			___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				liberal,
			),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
		parser,
		node,
	) {
		return parser.finalizeNode(
			Object.assign({}, node, {type: "BindingIdentifier"}),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(
		parser,
		node,
	) {
		return parser.finalizeNode(
			Object.assign({}, node, {type: "AssignmentIdentifier"}),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
		parser,
		node,
	) {
		return parser.finalizeNode(
			Object.assign({}, node, {type: "ReferenceIdentifier"}),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$toIdentifier(
		parser,
		node,
	) {
		return Object.assign({}, node, {type: "Identifier"});
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$createIdentifier(
		parser,
		start,
		name,
	) {
		const node = parser.finishNode(
			start,
			{
				type: "Identifier",
				name,
			},
		);
		parser.getLoc(node).identifierName = name;
		return node;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(
		parser,
		liberal = false,
	) {
		const loc = parser.finishLocAt(parser.state.startPos, parser.state.endPos);

		if (!liberal) {
			___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
				parser,
				String(parser.state.tokenValue),
				loc,
				!!parser.state.tokenType.keyword,
				false,
			);
		}

		let name;

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			name = String(parser.state.tokenValue);
		} else if (parser.state.tokenType.keyword !== undefined) {
			name = parser.state.tokenType.keyword;

			// `class` and `function` keywords push new context into this.context.

			// But there is no chance to pop the context if the keyword is consumed

			// as an identifier such as a property name.

			// If the previous token is a dot, this does not apply because the

			// context-managing code already ignored the keyword
			if (
				(name === "class" || name === "function") &&
				(parser.state.lastEndPos.index !==
				___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
					parser.state.lastStartPos.index,
				) ||
				parser.input.charCodeAt(
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						parser.state.lastStartPos.index,
					),
				) !== ___R$project$rome$$romejs$string$charcodes$index_ts.dot)
			) {
				parser.state.context.pop();
			}
		} else {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_IDENTIFIER,
			});
			name = "";
		}

		if (!liberal) {
			___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
				parser,
				name,
				loc,
				parser.state.tokenType.keyword !== undefined,
				false,
			);
		}

		parser.next();
		return name;
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
		parser,
		word,
		loc,
		checkKeywords,
		isBinding,
	) {
		if (parser.isSyntaxEnabled("ts")) {
			// TypeScript support in Babel disables reserved word checking...
			// This is mostly because TS allows reserved words in certain scenarios
			// TODO we should just allow those rather than relying on this hack
			return undefined;
		}

		if (parser.inScope("GENERATOR") && word === "yield") {
			parser.addDiagnostic({
				loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.YIELD_NAME_IN_GENERATOR,
			});
		}

		if (parser.inScope("ASYNC") && word === "await") {
			parser.addDiagnostic({
				loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.AWAIT_NAME_IN_ASYNC,
			});
		}

		if (parser.inScope("CLASS_PROPERTY") && word === "arguments") {
			parser.addDiagnostic({
				loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ARGUMENTS_IN_CLASS_FIELD,
			});
		}

		if (
			checkKeywords &&
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isKeyword(word)
		) {
			parser.addDiagnostic({
				loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNEXPECTED_KEYWORD(
					word,
				),
			});
		}

		let isReserved = false;
		if (parser.inScope("STRICT")) {
			if (isBinding) {
				isReserved = ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(
					word,
					parser.inModule,
				);
			} else {
				isReserved = ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictReservedWord(
					word,
					parser.inModule,
				);
			}
		} else {
			isReserved = ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isReservedWord(
				word,
				parser.inModule,
			);
		}

		if (isReserved) {
			if (!parser.inScope("ASYNC") && word === "await") {
				parser.addDiagnostic({
					loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.AWAIT_OUTSIDE_ASYNC,
				});
			} else {
				parser.addDiagnostic({
					loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.RESERVED_WORD(
						word,
					),
				});
			}
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseAwait(
		parser,
	) {
		if (!parser.state.awaitPos) {
			parser.state.awaitPos = parser.state.index;
		}

		if (!parser.inScope("ASYNC")) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.AWAIT_OUTSIDE_ASYNC,
			});
		}

		const start = parser.getPosition();
		parser.next();

		if (parser.inScope("PARAMETERS")) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.AWAIT_IN_ASYNC_PARAMS,
			});
		}

		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			)
		) {
			parser.addDiagnostic({
				start,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.AWAIT_STAR,
			});
		}

		const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(
			parser,
			"await argument",
		);
		return parser.finishNode(start, {type: "AwaitExpression", argument});
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseYield(
		parser,
		noIn,
	) {
		if (!parser.state.yieldPos) {
			parser.state.yieldPos = parser.state.index;
		}

		const start = parser.getPosition();

		if (parser.inScope("PARAMETERS")) {
			parser.addDiagnostic({
				start,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.YIELD_IN_GENERATOR_PARAMS,
			});
		}

		if (
			parser.state.maybeInArrowParameters &&
			// We only set yieldInPossibleArrowParameters if we haven't already
			// found a possible invalid YieldExpression.
			parser.state.yieldInPossibleArrowParameters === undefined
		) {
			parser.state.yieldInPossibleArrowParameters = start;
		}

		parser.next();

		let delegate;
		let argument;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
			) ||
			(!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			) &&
			!parser.state.tokenType.startsExpr) ||
			parser.canInsertSemicolon()
		) {
			delegate = false;
		} else {
			delegate = parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			);
			argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"yield argument",
				noIn,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "YieldExpression",
				delegate,
				argument,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseNullLiteral(
		parser,
	) {
		const start = parser.getPosition();
		parser.next();
		return parser.finishNode(start, {type: "NullLiteral"});
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const value = String(parser.state.tokenValue);
		parser.next();
		return parser.finishNode(
			start,
			{
				type: "StringLiteral",
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseBigIntLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const value = String(parser.state.tokenValue);
		parser.next();
		return parser.finishNode(
			start,
			{
				type: "BigIntLiteral",
				value,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseNumericLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const {tokenValue} = parser.state;
		if (
			!(tokenValue instanceof
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$NumberTokenValue)
		) {
			throw new Error("Expected NumberTokenValue");
		}

		const {value, format} = tokenValue;
		parser.next();
		return parser.finishNode(
			start,
			{
				type: "NumericLiteral",
				format,
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseRegExpLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const value = parser.state.tokenValue;
		if (
			!(value instanceof
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue)
		) {
			throw new Error("Expected regex token value");
		}
		parser.next();

		const {flags, pattern} = value;

		const regexParser = ___R$project$rome$$romejs$codec$js$regexp$index_ts$createRegExpParser({
			offsetPosition: Object.assign(
				{},
				start,
				{
					column: ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(start.column),
					index: ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(start.index),
				},
			),
			path: parser.filename,
			input: pattern,
			unicode: flags.has("u"),
		});

		const {diagnostics, expression} = regexParser.parse();

		for (const diagnostic of diagnostics) {
			parser.addDiagnostic(diagnostic);
		}

		return parser.finishNode(
			start,
			{
				type: "RegExpLiteral",
				expression,
				global: flags.has("g"),
				multiline: flags.has("m"),
				sticky: flags.has("y"),
				insensitive: flags.has("i"),
				noDotNewline: flags.has("s"),
				unicode: flags.has("u"),
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseImportOrMetaProperty(
		parser,
	) {
		if (
			parser.lookaheadState().tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot
		) {
			return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseImportMetaProperty(
				parser,
			);
		} else {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseImportCall(
				parser,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseImportCall(
		parser,
	) {
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import,
		);

		const start = parser.getPosition();
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			"array",
		);

		let argument;

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_EXACT_ARGUMENTS,
			});

			argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
				parser,
				parser.createUnknownIdentifier("import call argument"),
			);
		} else {
			const callArg = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseCallArgument(
				parser,
				"call expression argument",
				false,
			);
			if (callArg.type === "ArrayHole") {
				throw new Error(
					"Expected argument, parseExpressionListItem was passed maybeAllowEmpty: false",
				);
			} else {
				argument = callArg;
			}
		}

		// TODO warn on multiple arguments
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			parser.addDiagnostic({
				start: parser.state.lastStartPos,
				end: parser.state.lastEndPos,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_TRAILING_COMMA,
			});
		}

		if (argument.type === "SpreadElement") {
			parser.addDiagnostic({
				loc: argument.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_SPREAD,
			});
		}

		parser.expectClosing(openContext);

		const spreadOrExpression =
			argument.type === "AmbiguousFlowTypeCastExpression"
				? argument.expression
				: argument;

		const expression =
			spreadOrExpression.type === "SpreadElement"
				? spreadOrExpression.argument
				: spreadOrExpression;

		return parser.finishNode(start, {type: "ImportCall", argument: expression});
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseSuper(
		parser,
	) {
		if (
			!parser.inScope("METHOD") &&
			!parser.inScope("CLASS_PROPERTY") &&
			parser.sourceType !== "template"
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.SUPER_OUTSIDE_METHOD,
			});
		}

		const start = parser.getPosition();
		parser.next();

		if (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_SUPER_SUFFIX,
			});
		}

		const loc = parser.finishLoc(start);

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) &&
			(parser.getLastScope("METHOD") !== "constructor" ||
			parser.getLastScope("CLASS") !== "derived") &&
			parser.sourceType !== "template"
		) {
			parser.addDiagnostic({
				loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.SUPER_CALL_OUTSIDE_CONSTRUCTOR,
			});
		}

		return parser.finalizeNode({
			type: "Super",
			loc,
		});
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseDoExpression(
		parser,
	) {
		const start = parser.getPosition();
		parser.next();
		const oldLabels = parser.state.labels;
		parser.state.labels = [];
		parser.pushScope("FUNCTION", false);
		const body = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlock(
			parser,
			false,
		);
		parser.popScope("FUNCTION");
		parser.state.labels = oldLabels;
		return parser.finishNode(
			start,
			{
				type: "DoExpression",
				body,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrayHole(
		parser,
	) {
		return parser.finishNode(
			parser.getPosition(),
			{
				type: "ArrayHole",
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$expression_ts$parseArrayExpression(
		parser,
		refShorthandDefaultPos,
	) {
		const start = parser.getPosition();
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
			"array",
		);

		const elements = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListOptional(
			parser,
			___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionList(
				parser,
				"array element",
				openContext,
				true,
				refShorthandDefaultPos,
			),
		);

		return parser.finishNode(
			start,
			{
				type: "ArrayExpression",
				elements,
			},
		);
	}


  // project-rome/@romejs/js-parser/parser/lval.ts
const ___R$project$rome$$romejs$js$parser$parser$lval_ts = {
		toAssignmentPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern,
		toTargetAssignmentPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern,
		toTargetBindingPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern,
		toParamBindingPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toParamBindingPattern,
		toBindingPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern,
		toAssignmentObjectProperty: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty,
		toAssignableList: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignableList,
		toFunctionParamsBindingList: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList,
		toReferencedList: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList,
		toReferencedListOptional: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListOptional,
		normalizeReferencedItem: ___R$project$rome$$romejs$js$parser$parser$lval_ts$normalizeReferencedItem,
		filterSpread: ___R$project$rome$$romejs$js$parser$parser$lval_ts$filterSpread,
		toReferencedListDeep: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeep,
		toReferencedListDeepOptional: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional,
		parseSpread: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread,
		parseTargetBindingPattern: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern,
		parseBindingList: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingList,
		parseBindingListNonEmpty: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty,
		parseBindingListItem: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItem,
		parseBindingListItemTypes: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes,
		parseMaybeDefault: ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault,
		checkLVal: ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal,
		checkToRestConversion: ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkToRestConversion,
		hasCommaAfterRest: ___R$project$rome$$romejs$js$parser$parser$lval_ts$hasCommaAfterRest,
		raiseRestNotLast: ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast,
		checkCommaAfterRestFromSpread: ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread,
	};
	const ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$VALID_REST_ARGUMENT_TYPES = [
		"Identifier",
		"MemberExpression",
	];


	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
		parser,
		node,
		contextDescription,
	) {
		switch (node.type) {
			case "AssignmentObjectPattern":
			case "AssignmentArrayPattern":
			case "AssignmentAssignmentPattern":
			case "AssignmentObjectPatternProperty":
			case "AssignmentIdentifier":
			case "MemberExpression":
				return node;

			case "AmbiguousFlowTypeCastExpression":
				return ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
					parser,
					___R$project$rome$$romejs$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter(
						parser,
						node,
					),
					contextDescription,
				);

			case "BindingIdentifier":
			case "ReferenceIdentifier":
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(
					parser,
					node,
				);

			case "TSAsExpression":
				return Object.assign(
					{},
					node,
					{
						type: "TSAssignmentAsExpression",
						expression: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							node.expression,
							contextDescription,
						),
					},
				);

			case "TSNonNullExpression":
				return Object.assign(
					{},
					node,
					{
						type: "TSAssignmentNonNullExpression",
						expression: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							node.expression,
							contextDescription,
						),
					},
				);

			case "TSTypeAssertion":
				return Object.assign(
					{},
					node,
					{
						type: "TSAssignmentTypeAssertion",
						expression: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							node.expression,
							contextDescription,
						),
					},
				);

			case "ObjectExpression": {
				const props = [];
				let rest;
				for (let index = 0; index < node.properties.length; index++) {
					const prop = node.properties[index];
					if (prop.type === "SpreadProperty") {
						const arg = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							prop.argument,
							contextDescription,
						);
						if (arg.type === "AssignmentIdentifier") {
							rest = arg;
						} else {
							parser.addDiagnostic({
								loc: arg.loc,
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_OBJECT_REST_ARGUMENT,
							});
						}
						continue;
					}

					props.push(
						___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty(
							parser,
							prop,
						),
					);
				}
				return {
					type: "AssignmentObjectPattern",
					loc: node.loc,
					properties: props,
					rest,
				};
			}

			case "ArrayExpression": {
				const {list: elements, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignableList(
					parser,
					node.elements,
					contextDescription,
				);
				return {
					type: "AssignmentArrayPattern",
					loc: node.loc,
					elements,
					rest,
				};
			}

			case "AssignmentExpression": {
				if (node.operator !== "=") {
					parser.addDiagnostic({
						loc: parser.getLoc(node.left),
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_ASSIGNMENT_PATTERN_OPERATOR,
					});
				}

				return Object.assign(
					{},
					node,
					{
						type: "AssignmentAssignmentPattern",
						left: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
							parser,
							node.left,
							contextDescription,
						),
						right: node.right,
						loc: node.loc,
					},
				);
			}

			default: {
				parser.addDiagnostic({
					loc: node.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_LEFT_HAND_SIDE(
						contextDescription,
					),
				});
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$toAssignmentIdentifier(
					parser,
					parser.createUnknownIdentifier(contextDescription),
				);
			}
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
		parser,
		node,
		contextDescription,
	) {
		const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
			parser,
			node,
			contextDescription,
		);

		switch (binding.type) {
			case "AssignmentIdentifier":
			case "AssignmentArrayPattern":
			case "AssignmentObjectPattern":
			case "MemberExpression":
			case "TSAssignmentAsExpression":
			case "TSAssignmentNonNullExpression":
			case "TSAssignmentTypeAssertion":
				return binding;

			default: {
				parser.addDiagnostic({
					loc: node.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_ASSIGNMENT_TARGET,
				});
				return {
					type: "AssignmentIdentifier",
					loc: node.loc,
					name: "X",
				};
			}
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(
		parser,
		node,
		contextDescription,
	) {
		const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(
			parser,
			node,
			contextDescription,
		);

		switch (binding.type) {
			case "BindingIdentifier":
			case "BindingArrayPattern":
			case "BindingObjectPattern":
				return binding;

			default:
				// TODO return Unknown
				throw new Error("TODO " + binding.type);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toParamBindingPattern(
		parser,
		node,
		contextDescription,
	) {
		const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(
			parser,
			node,
			contextDescription,
		);

		switch (binding.type) {
			case "BindingIdentifier":
			case "BindingArrayPattern":
			case "BindingObjectPattern":
			case "BindingAssignmentPattern":
				return binding;

			default:
				// TODO return Unknown
				throw new Error("TODO " + binding.type);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(
		parser,
		node,
		contextDescription,
	) {
		const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
			parser,
			node,
			contextDescription,
		);

		if (binding.type === "MemberExpression") {
			parser.addDiagnostic({
				loc: node.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.BINDING_MEMBER_EXPRESSION,
			});

			return {
				type: "BindingIdentifier",
				name: "X",
				loc: node.loc,
			};
		}

		switch (binding.type) {
			case "AssignmentObjectPattern": {
				const newNode = Object.assign(
					{},
					binding,
					{
						type: "BindingObjectPattern",
						rest: binding.rest === undefined
							? undefined
							: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
									parser,
									binding.rest,
								),
						properties: binding.properties.map((prop) => {
							const bindingProp = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(
								parser,
								prop,
								contextDescription,
							);

							if (bindingProp.type !== "BindingObjectPatternProperty") {
								throw new Error("impossible condition");
							}

							return bindingProp;
						}),
					},
				);
				return newNode;
			}

			case "AssignmentAssignmentPattern": {
				const newNode = Object.assign(
					{},
					binding,
					{
						type: "BindingAssignmentPattern",
						left: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(
							parser,
							binding.left,
							contextDescription,
						),
					},
				);
				return newNode;
			}

			case "AssignmentArrayPattern": {
				const newNode = Object.assign(
					{},
					binding,
					{
						type: "BindingArrayPattern",
						elements: binding.elements.map((elem) =>
							elem.type === "ArrayHole"
								? elem
								: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toParamBindingPattern(
										parser,
										elem,
										contextDescription,
									)
						),
						rest: binding.rest === undefined
							? undefined
							: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(
									parser,
									binding.rest,
									contextDescription,
								),
					},
				);
				return newNode;
			}

			case "AssignmentIdentifier": {
				const newNode = Object.assign({}, binding, {type: "BindingIdentifier"});
				return newNode;
			}

			case "AssignmentObjectPatternProperty": {
				const newNode = Object.assign(
					{},
					binding,
					{
						type: "BindingObjectPatternProperty",
						value: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(
							parser,
							binding.value,
							contextDescription,
						),
					},
				);
				return newNode;
			}

			default:
				throw new Error("Unknown node " + node.type);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentObjectProperty(
		parser,
		prop,
	) {
		switch (prop.type) {
			case "ObjectMethod": {
				parser.addDiagnostic({
					loc: prop.key.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.OBJECT_PATTERN_CANNOT_CONTAIN_METHODS,
				});

				const fakeProp = {
					type: "AssignmentObjectPatternProperty",
					loc: prop.loc,
					key: {
						type: "StaticPropertyKey",
						value: {
							type: "Identifier",
							name: "X",
							loc: prop.loc,
						},
						loc: prop.loc,
					},
					value: {
						type: "AssignmentIdentifier",
						name: "X",
						loc: prop.loc,
					},
				};

				return fakeProp;
			}

			case "ObjectProperty":
				return Object.assign(
					{},
					prop,
					{
						type: "AssignmentObjectPatternProperty",
						value: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
							parser,
							prop.value,
							"assignment object property value",
						),
					},
				);

			default: {
				parser.addDiagnostic({
					loc: prop.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_OBJECT_PATTERN_PROPERTY,
				});
				return {
					type: "AssignmentObjectPatternProperty",
					loc: prop.loc,
					key: {
						type: "StaticPropertyKey",
						loc: prop.loc,
						value: {
							type: "Identifier",
							loc: prop.loc,
							name: "X",
						},
					},
					value: {
						type: "AssignmentIdentifier",
						loc: prop.loc,
						name: "X",
					},
				};
			}
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignableList(
		parser,
		exprList,
		contextDescription,
	) {
		const newList = [];
		let rest;

		let end = exprList.length;

		// Validate last element
		if (end > 0) {
			let last = exprList[end - 1];

			if (last !== undefined && last.type === "SpreadElement") {
				const arg = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
					parser,
					last.argument,
					contextDescription,
				);
				rest = arg;
				end--;
			}

			if (
				last !== undefined &&
				last.type === "AmbiguousFlowTypeCastExpression" &&
				last.expression.type === "SpreadElement"
			) {
				rest = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter(
					parser,
					Object.assign({}, last, {expression: last.expression.argument}),
				);
				end--;
			}
		}

		// Turn type casts that we found in function parameter head into type annotated params
		for (let i = 0; i < end; i++) {
			const expr = exprList[i];

			if (expr.type === "AmbiguousFlowTypeCastExpression") {
				exprList[i] = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter(
					parser,
					expr,
				);
			}

			if (expr.type === "TSAsExpression" || expr.type === "TSTypeAssertion") {
				parser.addDiagnostic({
					loc: expr.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_UNEXPECTED_CAST_IN_PARAMETER_POSITION,
				});
			}
		}

		for (let i = 0; i < end; i++) {
			const elt = exprList[i];

			if (elt.type === "SpreadElement") {
				___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
					parser,
					parser.getLoc(elt),
				);
			}

			if (elt.type === "ArrayHole") {
				newList.push(elt);
				continue;
			}

			const assign = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignmentPattern(
				parser,
				elt,
				contextDescription,
			);
			newList.push(assign);
		}

		return {list: newList, rest};
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toFunctionParamsBindingList(
		parser,
		exprList,
		contextDescription,
	) {
		const bindingList = [];

		const {list: assignmentList, rest: assignmentRest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toAssignableList(
			parser,
			exprList,
			contextDescription,
		);

		const bindingRest =
			assignmentRest === undefined
				? assignmentRest
				: ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(
						parser,
						assignmentRest,
						contextDescription,
					);

		for (const item of assignmentList) {
			if (item === undefined) {
				// TODO should never happen?
				continue;
			}

			if (item.type === "AssignmentAssignmentPattern") {
				const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toBindingPattern(
					parser,
					item,
					contextDescription,
				);
				if (binding.type !== "BindingAssignmentPattern") {
					throw new Error("TODO");
				}

				bindingList.push(binding);
				continue;
			}

			const binding = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetBindingPattern(
				parser,
				item,
				contextDescription,
			);
			bindingList.push(binding);
		}

		return {params: bindingList, rest: bindingRest};
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList(
		parser,
		exprList,
		isParenthesizedExpr,
	) {
		for (let i = 0; i < exprList.length; i++) {
			const expr = exprList[i];
			exprList[i] = ___R$project$rome$$romejs$js$parser$parser$lval_ts$normalizeReferencedItem(
				parser,
				expr,
				exprList.length > 1,
				isParenthesizedExpr,
			);
		}

		// @ts-ignore: We actually filtered them out
		return exprList;
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListOptional(
		parser,
		exprList,
		isParenthesizedExpr,
	) {
		for (let i = 0; i < exprList.length; i++) {
			const expr = exprList[i];
			if (expr.type !== "ArrayHole") {
				exprList[i] = ___R$project$rome$$romejs$js$parser$parser$lval_ts$normalizeReferencedItem(
					parser,
					expr,
					exprList.length > 1,
					isParenthesizedExpr,
				);
			}
		}

		// @ts-ignore: We actually filtered them out
		return exprList;
	}



	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$normalizeReferencedItem(
		parser,
		expr,
		multiple,
		isParenthesizedExpr,
	) {
		if (expr.type !== "AmbiguousFlowTypeCastExpression") {
			return expr;
		}

		parser.addDiagnostic({
			loc: expr.loc,
			description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.FLOW_TYPE_CAST_IN_TS,
		});

		if (!parser.isParenthesized(expr) && (multiple || !isParenthesizedExpr)) {
			parser.addDiagnostic({
				loc: expr.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TYPE_CAST_EXPECTED_PARENS,
			});
		}

		if (expr.optional) {
			parser.addDiagnostic({
				loc: expr.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TYPE_CAST_CANNOT_BE_OPTIONAL,
			});
		}

		const {typeAnnotation, expression} = expr;

		if (typeAnnotation === undefined) {
			parser.addDiagnostic({
				loc: expr.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TYPE_CAST_WITHOUT_ANNOTATION,
			});
			return expression;
		}

		if (expression.type === "SpreadElement") {
			throw new Error(
				"I don't think a SpreadElement is ever allowed to hit this path?",
			);
		}

		return expression;
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$filterSpread(
		parser,
		elems,
	) {
		for (let i = 0; i < elems.length; i++) {
			const elem = elems[i];
			if (elem.type === "SpreadElement") {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNEXPECTED_SPREAD,
				});

				elems[i] = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					parser.createUnknownIdentifier("spread substitute"),
				);
			}
		}
		// @ts-ignore Technically wrong but we removed all SpreadElement
		return elems;
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeep(
		parser,
		exprList,
		isParenthesizedExpr,
	) {
		const refList = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedList(
			parser,
			exprList,
			isParenthesizedExpr,
		);
		___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(
			parser,
			refList,
		);
		return refList;
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional(
		parser,
		exprList,
		isParenthesizedExpr,
	) {
		const refList = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListOptional(
			parser,
			exprList,
			isParenthesizedExpr,
		);
		___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(
			parser,
			refList,
		);
		return refList;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepItems(
		parser,
		exprList,
	) {
		for (let i = 0; i < exprList.length; i++) {
			const expr = exprList[i];
			if (expr.type === "ArrayExpression") {
				___R$project$rome$$romejs$js$parser$parser$lval_ts$toReferencedListDeepOptional(
					parser,
					expr.elements,
				);
			}
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseSpread(
		parser,
		refShorthandDefaultPos,
		refNeedsArrowPos,
	) {
		const start = parser.getPosition();
		parser.next();

		const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
			parser,
			"spread argument",
			false,
			refShorthandDefaultPos,
			undefined,
			refNeedsArrowPos,
		);

		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				parser.state.commaAfterSpreadAt,
			) === -1 &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			parser.state.commaAfterSpreadAt = parser.state.index;
		}

		return parser.finishNode(
			start,
			{
				type: "SpreadElement",
				argument,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(
		parser,
	) {
		switch (parser.state.tokenType) {
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$parseArrayPattern(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPattern(
					parser,
					___R$project$rome$$romejs$js$parser$utils$location_ts$createIndexTracker(),
				);
		}

		return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$parseArrayPattern(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
			"array pattern",
		);
		const {list: elements, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingList(
			parser,
			openContext,
			true,
		);
		return parser.finishNode(
			start,
			{
				type: "BindingArrayPattern",
				elements,
				rest,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingList(
		parser,
		openContext,
		allowHoles = false,
		allowTSModifiers = false,
	) {
		const elts = [];
		let rest;

		let first = true;
		while (true) {
			if (
				parser.match(openContext.close) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				parser.expectClosing(openContext);
				break;
			}

			if (first) {
				first = false;
			} else {
				if (
					!parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
					)
				) {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_COMMA_SEPARATOR(
							openContext.name,
						),
					});
					break;
				}
			}

			if (
				allowHoles &&
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				elts.push(
					___R$project$rome$$romejs$js$parser$parser$expression_ts$parseArrayHole(
						parser,
					),
				);
			} else if (parser.match(openContext.close)) {
				parser.expectClosing(openContext);
				break;
			} else if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
				)
			) {
				parser.next();

				rest = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(
					parser,
					parser.getPosition(),
					___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(
						parser,
					),
				);

				if (
					!___R$project$rome$$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(
						parser,
					)
				) {
					parser.expectClosing(openContext);
					break;
				}
			} else {
				elts.push(
					___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItem(
						parser,
						allowTSModifiers,
					),
				);
			}
		}
		return {list: elts, rest};
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(
		parser,
		openContext,
		allowTSModifiers,
	) {
		const list = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingList(
			parser,
			openContext,
			false,
			allowTSModifiers,
		);
		// @ts-ignore: Need to make this more explicit we set `allowEmpty: false` above
		return list;
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItem(
		parser,
		allowTSModifiers,
	) {
		const start = parser.getPosition();

		let accessibility;
		let readonly = false;
		if (allowTSModifiers) {
			accessibility = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(
				parser,
			);
			readonly = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(
				parser,
				["readonly"],
			);
		}

		const left = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(
			parser,
			start,
			___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(
				parser,
			),
		);
		const elt = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault(
			parser,
			start,
			left,
		);

		if (accessibility !== undefined || readonly) {
			if (!parser.isSyntaxEnabled("ts")) {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_DISABLED_BUT_ACCESSIBILITY_OR_READONLY,
				});
			}

			if (
				elt.type !== "BindingIdentifier" &&
				elt.type !== "BindingAssignmentPattern"
			) {
				parser.addDiagnostic({
					start,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_PARAMETER_PROPERTY_BINDING_PATTERN,
				});
			}

			return parser.finishNode(
				start,
				Object.assign(
					{},
					elt,
					{
						meta: parser.finishNode(
							start,
							{
								type: "PatternMeta",
								accessibility,
								readonly,
							},
						),
					},
				),
			);
		}

		return elt;
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListItemTypes(
		parser,
		start,
		param,
	) {
		let typeAnnotation;
		let optional;

		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			if (param.type !== "BindingIdentifier") {
				parser.addDiagnostic({
					loc: param.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TYPE_BINDING_PARAMETER_OPTIONAL,
				});
			}

			optional = true;
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
		}

		return parser.finalizeNode(
			Object.assign(
				{},
				param,
				{
					meta: parser.finishNode(
						start,
						{
							type: "PatternMeta",
							optional,
							typeAnnotation,
						},
					),
				},
			),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseMaybeDefault(
		parser,
		start = parser.getPosition(),
		left = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseTargetBindingPattern(
			parser,
		),
	) {
		let target;

		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
			)
		) {
			const right = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"assignment pattern right",
			);
			const assign = parser.finishNode(
				start,
				{
					type: "BindingAssignmentPattern",
					left,
					right,
				},
			);
			target = assign;
		} else {
			target = left;
		}

		if (
			target.type === "BindingAssignmentPattern" &&
			target.meta !== undefined &&
			target.meta.typeAnnotation !== undefined &&
			parser.getLoc(target.right).start.index <
			parser.getLoc(target.meta.typeAnnotation).start.index
		) {
			parser.addDiagnostic({
				loc: target.meta.typeAnnotation.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TYPE_ANNOTATION_AFTER_ASSIGNMENT,
			});
		}

		return target;
	}

	const ___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES = [
		"Identifier",
		"MemberExpression",
		"TSAsExpression",
		"TSTypeAssertion",
		"TSAssignmentTypeAssertion",
		"TSAssignmentAsExpression",
		"TSAssignmentNonNullExpression",
	];

	// Verify that a node is an lval — something that can be assigned
	// to.
	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
		parser,
		expr,
		maybeIsBinding,
		checkClashes,
		contextDescription,
	) {
		const isBinding = maybeIsBinding === undefined ? false : maybeIsBinding;

		// Verify that nodes aren't parenthesized
		if (
			parser.isParenthesized(expr) &&
			!___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$ALLOWED_PARENTHESIZED_LVAL_TYPES.includes(
				expr.type,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_PARENTEHSIZED_LVAL(
					expr.type === "BindingObjectPattern"
						? "object"
						: expr.type === "BindingArrayPattern"
							? "array"
							: undefined,
				),
				loc: expr.loc,
			});
		}

		switch (expr.type) {
			case "TSAsExpression":
			case "TSNonNullExpression":
			case "TSTypeAssertion": {
				___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
					parser,
					expr.expression,
					isBinding,
					checkClashes,
					contextDescription,
				);
				return undefined;
			}

			case "BindingIdentifier":
			case "ReferenceIdentifier":
			case "AssignmentIdentifier": {
				if (
					parser.inScope("STRICT") &&
					___R$project$rome$$romejs$js$parser$utils$identifier_ts$isStrictBindReservedWord(
						expr.name,
						parser.inModule,
					)
				) {
					parser.addDiagnostic({
						loc: expr.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.RESERVED_WORD(
							expr.name,
						),
					});
				}

				if (checkClashes !== undefined) {
					const clash = checkClashes.get(expr.name);

					if (clash === undefined) {
						checkClashes.set(expr.name, expr);
					} else {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ARGUMENT_CLASH_IN_STRICT(
								expr.name,
								expr.loc,
							),
							loc: expr.loc,
						});
					}
				}
				break;
			}

			case "AssignmentObjectPattern":
			case "BindingObjectPattern": {
				if (expr.rest !== undefined) {
					___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
						parser,
						expr.rest,
						isBinding,
						checkClashes,
						"rest property",
					);
				}

				for (let prop of expr.properties) {
					if (prop.type === "BindingObjectPatternProperty") {
						___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
							parser,
							prop.value,
							isBinding,
							checkClashes,
							"object destructuring pattern",
						);
					} else {
						___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
							parser,
							prop,
							isBinding,
							checkClashes,
							"object destructuring pattern",
						);
					}
				}
				break;
			}

			case "AssignmentObjectPatternProperty":
			case "BindingObjectPatternProperty":
				break;

			case "AssignmentArrayPattern":
			case "BindingArrayPattern": {
				if (expr.rest !== undefined) {
					___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
						parser,
						expr.rest,
						isBinding,
						checkClashes,
						"rest element",
					);
				}

				for (const elem of expr.elements) {
					___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
						parser,
						elem,
						isBinding,
						checkClashes,
						"array destructuring pattern",
					);
				}
				break;
			}

			case "BindingAssignmentPattern": {
				___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
					parser,
					expr.left,
					isBinding,
					checkClashes,
					"assignment pattern",
				);
				break;
			}
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkToRestConversion(
		parser,
		node,
	) {
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$lval_ts$VALID_REST_ARGUMENT_TYPES.includes(
				node.argument.type,
			) ===
			false
		) {
			parser.addDiagnostic({
				loc: node.argument.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.REST_INVALID_ARGUMENT,
			});
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(
		parser,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
				parser,
			);
			return true;
		}

		return false;
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
		parser,
		loc,
		start,
	) {
		parser.addDiagnostic({
			start,
			loc,
			description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DESTRUCTURING_REST_ELEMENT_NOT_LAST,
		});
	}

	function ___R$project$rome$$romejs$js$parser$parser$lval_ts$checkCommaAfterRestFromSpread(
		parser,
	) {
		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				parser.state.commaAfterSpreadAt,
			) >
			-1
		) {
			___R$project$rome$$romejs$js$parser$parser$lval_ts$raiseRestNotLast(
				parser,
				undefined,
				parser.getPositionFromIndex(parser.state.commaAfterSpreadAt),
			);
		}
	}


  // project-rome/@romejs/js-parser/parser/jsx.ts
const ___R$project$rome$$romejs$js$parser$parser$jsx_ts = {
		parseJSXText: ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXText,
		parseJSXElement: ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement,
	};
	// Indicates whether we should create a JSXIdentifier or a JSXReferenceIdentifier
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$isHTMLTagName(
		tagName,
	) {
		return (
			/^[a-z]|-/.test(tagName) &&
			___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(
				tagName,
			)
		);
	}

	// Transforms JSX element name to string.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
		node,
	) {
		if (node === undefined) {
			return "";
		}

		switch (node.type) {
			case "JSXIdentifier":
			case "JSXReferenceIdentifier":
				return node.name;

			case "JSXNamespacedName":
				return node.namespace.name + ":" + node.name.name;

			case "JSXMemberExpression":
				return (
					___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
						node.object,
					) +
					"." +
					___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
						node.property,
					)
				);
		}
	}

	// Parse next token as JSX identifier
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(
		parser,
	) {
		const start = parser.getPosition();
		let name;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxName,
			)
		) {
			name = String(parser.state.tokenValue);
		} else if (parser.state.tokenType.keyword !== undefined) {
			name = parser.state.tokenType.keyword;
		} else {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_UNKNOWN_IDENTIFIER_TOKEN,
			});
			name = "";
		}

		parser.next();
		return parser.finishNode(
			start,
			{
				type: "JSXIdentifier",
				name,
			},
		);
	}

	// Parse namespaced identifier.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(
		parser,
	) {
		const start = parser.getPosition();

		const namespace = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(
			parser,
		);
		if (
			!parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			return namespace;
		}

		const name = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(
			parser,
		);
		return parser.finishNode(
			start,
			{
				type: "JSXNamespacedName",
				name,
				namespace,
			},
		);
	}

	// Parses element name in any form - namespaced, member
	// or single identifier.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementName(
		parser,
	) {
		const start = parser.getPosition();

		const namespacedName = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(
			parser,
		);

		let node;
		if (
			namespacedName.type === "JSXIdentifier" &&
			!___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$isHTMLTagName(
				namespacedName.name,
			)
		) {
			node = Object.assign({}, namespacedName, {type: "JSXReferenceIdentifier"});
		} else {
			node = namespacedName;
		}

		while (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			const property = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXIdentifier(
				parser,
			);
			node = parser.finishNode(
				start,
				{
					type: "JSXMemberExpression",
					object: node,
					property,
				},
			);
		}

		return node;
	}

	// Parses any type of JSX attribute value.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXAttributeValue(
		parser,
	) {
		let node;
		switch (parser.state.tokenType) {
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL: {
				node = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(
					parser,
				);
				if (node.expression.type === "JSXEmptyExpression") {
					parser.addDiagnostic({
						loc: node.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_EMPTY_ATTRIBUTE_VALUE,
					});
				}
				return node;
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart:
				return ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string:
				return ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);

			default: {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_INVALID_ATTRIBUTE_VALUE,
				});
				return parser.finishNode(
					parser.getPosition(),
					{
						type: "StringLiteral",
						value: "?",
					},
				);
			}
		}
	}

	// JSXEmptyExpression is unique type since it doesn't actually parse anything,
	// and so it should start at the end of last read token (left brace) and finish
	// at the beginning of the next one (right brace).
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXEmptyExpression(
		parser,
	) {
		return parser.finishNode(
			parser.state.lastEndPos,
			{
				type: "JSXEmptyExpression",
			},
		);
	}

	// Parse JSX spread child
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXSpreadChild(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"jsx spread child",
		);
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
		);
		const expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
			parser,
			"jsx spread child expression",
		);
		parser.expectClosing(openContext);

		return parser.finishNode(
			start,
			{
				type: "JSXSpreadChild",
				expression,
			},
		);
	}

	// Parses JSX expression enclosed into curly brackets.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"jsx expression container",
		);
		let expression;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			)
		) {
			expression = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXEmptyExpression(
				parser,
			);
		} else {
			expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
				parser,
				"jsx inner expression container",
			);
		}
		parser.expectClosing(openContext);
		return parser.finishNode(
			start,
			{
				type: "JSXExpressionContainer",
				expression,
			},
		);
	}

	// Parses following JSX attribute name-value pair.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXAttribute(
		parser,
	) {
		const start = parser.getPosition();

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			)
		) {
			const openContext = parser.expectOpening(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				"jsx attribute spread",
			);
			parser.expect(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
			);
			const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"jsx attribute spread",
			);
			parser.expectClosing(openContext);
			return parser.finishNode(
				start,
				{
					type: "JSXSpreadAttribute",
					argument,
				},
			);
		}

		const name = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXNamespacedName(
			parser,
		);
		const value = parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
		)
			? ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXAttributeValue(
					parser,
				)
			: undefined;
		return parser.finishNode(
			start,
			{
				type: "JSXAttribute",
				name,
				value,
			},
		);
	}


	// Parses JSX opening tag starting after "<".
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXOpeningElementAt(
		parser,
		start,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			)
		) {
			parser.expect(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			);
			return {
				typeArguments: undefined,
				name: undefined,
				loc: {
					filename: parser.filename,
					start,
					end: parser.getPosition(),
				},
				attributes: [],
				selfClosing: false,
			};
		}

		const attributes = [];
		const name = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementName(
			parser,
		);

		let typeArguments;
		if (parser.isRelational("<")) {
			if (!parser.isSyntaxEnabled("ts")) {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_ELEM_TYPE_ARGUMENTS_OUTSIDE_TS,
				});
			}

			typeArguments = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		}

		// We need to check for isRelational('>') here as the above type arguments parsing can put the tokenizer

		// into an unusual state for: <foo<bar>></foo>
		while (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			) &&
			!parser.atEOF()
		) {
			attributes.push(
				___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXAttribute(
					parser,
				),
			);
		}
		const selfClosing = parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash,
		);
		if (
			!parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_UNCLOSED_SELF_CLOSING_TAG,
			});
		}
		return {
			typeArguments,
			name,
			attributes,
			selfClosing,
			loc: parser.getLoc(name),
		};
	}

	// Parses JSX closing tag starting after "</".
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXClosingElementAt(
		parser,
	) {
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			)
		) {
			return undefined;
		}

		const name = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementName(
			parser,
		);

		if (
			!parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_UNCLOSED_CLOSING_TAG,
			});
		}

		return name;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$recoverFromUnclosedJSX(
		parser,
	) {
		// jsxOpenTag
		parser.state.context.pop();
		parser.state.exprAllowed = false;
	}

	// Parses entire JSX element, including it"s opening tag
	// (starting after "<"), attributes, contents and closing tag.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(
		parser,
		start,
	) {
		const children = [];
		const openingDef = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXOpeningElementAt(
			parser,
			start,
		);

		let closingNameLoc;
		let closingName;

		// Parse children for unclosed elements
		if (openingDef.selfClosing === false) {
			contents: while (true) {
				switch (parser.state.tokenType) {
					case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart: {
						const start = parser.getPosition();
						parser.next();
						if (
							parser.eat(
								___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash,
							)
						) {
							closingName = ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXClosingElementAt(
								parser,
							);
							closingNameLoc = {
								filename: parser.filename,
								start,
								end: parser.getPosition(),
							};
							break contents;
						}
						children.push(
							___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(
								parser,
								start,
							),
						);
						break;
					}

					case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxText: {
						children.push(
							___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXText(
								parser,
							),
						);
						break;
					}

					case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL: {
						if (
							parser.lookaheadState().tokenType ===
							___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis
						) {
							children.push(
								___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXSpreadChild(
									parser,
								),
							);
						} else {
							children.push(
								___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXExpressionContainer(
									parser,
								),
							);
						}
						break;
					}

					case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof: {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_UNCLOSED_ELEMENT(
								___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
									openingDef.name,
								),
								openingDef.loc,
							),
						});
						break contents;
					}

					default: {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_UNKNOWN_CHILD_START(
								___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
									openingDef.name,
								),
								openingDef.loc,
							),
						});

						// We don't need to do it for the tt.eof case above because nothing will ever be parsed after
						___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$recoverFromUnclosedJSX(
							parser,
						);

						break contents;
					}
				}
			}

			// Unclosed element, would have produced an error above but we still want to produce a valid AST and avoid the below error conditions
			if (closingNameLoc === undefined) {
				closingName = openingDef.name;
				closingNameLoc = openingDef.loc;
			}

			// Fragment open, element close
			if (openingDef.name === undefined && closingName !== undefined) {
				parser.addDiagnostic({
					loc: openingDef.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_EXPECTED_CLOSING_FRAGMENT_TAG(
						___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
							openingDef.name,
						),
						openingDef.loc,
					),
				});
			}

			// Element open, fragment close
			if (openingDef.name !== undefined && closingName === undefined) {
				parser.addDiagnostic({
					loc: openingDef.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_EXPECTED_CLOSING_TAG(
						___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
							openingDef.name,
						),
						openingDef.loc,
					),
				});
			}

			// Validate element names: Element open, element close
			if (openingDef.name !== undefined && closingName !== undefined) {
				if (
					___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
						closingName,
					) !==
					___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
						openingDef.name,
					)
				) {
					parser.addDiagnostic({
						loc: openingDef.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_EXPECTED_CLOSING_TAG(
							___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$getQualifiedJSXName(
								openingDef.name,
							),
							openingDef.loc,
						),
					});
				}
			}
		}

		___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$checkAccidentalFragment(
			parser,
		);

		const openingName = openingDef.name;
		if (openingName === undefined) {
			return parser.finishNode(
				start,
				{
					type: "JSXFragment",
					children,
				},
			);
		} else {
			return parser.finishNode(
				start,
				{
					type: "JSXElement",
					name: openingName,
					typeArguments: openingDef.typeArguments,
					attributes: openingDef.attributes,
					selfClosing: openingDef.selfClosing,
					children,
				},
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$checkAccidentalFragment(
		parser,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational,
			) &&
			parser.state.tokenValue === "<"
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNWRAPPED_ADJACENT_JHX,
			});
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXText(
		parser,
	) {
		// No need to assert syntax here because we wont get that far as parseJSXElement would have already been called
		const start = parser.getPosition();
		const value = String(parser.state.tokenValue);
		parser.next();
		return parser.finishNode(
			start,
			{
				type: "JSXText",
				value,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElement(
		parser,
	) {
		// Only necessary here as this is the only JSX entry point
		if (!parser.isSyntaxEnabled("jsx")) {
			if (parser.isSyntaxEnabled("ts")) {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_IN_TS_EXTENSION,
				});
			} else {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.JSX_DISABLED,
				});
			}
		}

		const start = parser.getPosition();
		parser.next();
		return ___R$$priv$project$rome$$romejs$js$parser$parser$jsx_ts$parseJSXElementAt(
			parser,
			start,
		);
	}


  // project-rome/@romejs/js-parser/parser/typescript.ts
const ___R$project$rome$$romejs$js$parser$parser$typescript_ts = {
		parseTSModifier: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier,
		hasTSModifier: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier,
		ambiguousTypeCastToParameter: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter,
		maybeParseTSTypeParameters: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeParameters,
		maybeParseTSTypeArguments: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeArguments,
		parseTSTypeParameters: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters,
		tryTSNextParseConstantContext: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext,
		tsCheckLiteralForConstantContext: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext,
		tryTSParseIndexSignature: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature,
		parseTSTypeOrTypePredicateAnnotation: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation,
		parseTSTypeAnnotation: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation,
		parseTSTypeAssertion: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion,
		parseTSHeritageClause: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause,
		parseTSInterfaceDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration,
		parseTSTypeAlias: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAlias,
		tsNextThenParseType: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType,
		parseTSEnumDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration,
		parseTSModuleBlock: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock,
		parseTSModuleOrNamespaceDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration,
		parseTSAmbientExternalModuleDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration,
		parseTSImportEqualsDeclaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration,
		parseTSDeclare: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDeclare,
		parseTSTypeExpressionStatement: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeExpressionStatement,
		parseTSAbstractClass: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass,
		parseTSExportDefaultAbstractClass: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass,
		parseTSTypeArguments: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments,
		isTSDeclarationStart: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart,
		parseTSAccessModifier: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier,
		isTSAbstractClass: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSAbstractClass,
		parseTSExport: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExport,
	};

	// Doesn't handle 'void' or 'null' because those are keywords, not identifiers.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$keywordTypeFromName(
		value,
	) {
		switch (value) {
			case "any":
				return "TSAnyKeywordTypeAnnotation";

			case "boolean":
				return "TSBooleanKeywordTypeAnnotation";

			case "bigint":
				return "TSBigIntKeywordTypeAnnotation";

			case "never":
				return "TSNeverKeywordTypeAnnotation";

			case "number":
				return "TSNumberKeywordTypeAnnotation";

			case "object":
				return "TSObjectKeywordTypeAnnotation";

			case "string":
				return "TSStringKeywordTypeAnnotation";

			case "symbol":
				return "TSSymbolKeywordTypeAnnotation";

			case "undefined":
				return "UndefinedKeywordTypeAnnotation";

			case "unknown":
				return "UnknownKeywordTypeAnnotation";

			default:
				return undefined;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(
		parser,
	) {
		// TODO: actually a bit more complex in TypeScript, but shouldn't matter.
		// See https://github.com/Microsoft/TypeScript/issues/15008
		return parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextTokenCanFollowModifier(
		parser,
	) {
		// Note: TypeScript's implementation is much more complicated because
		// more things are considered modifiers there.
		// This implementation only handles modifiers not handled by @babel/parser itself. And 'static'.
		// TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
		parser.next();
		return (
			!parser.hasPrecedingLineBreak() &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang,
			)
		);
	}

	/** Parses a modifier matching one the given modifier names.*/
	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier(
		parser,
		allowedModifiers,
	) {
		if (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			return undefined;
		}

		// @ts-ignore: We are lying here but we validate it in all the correct places
		const modifier = String(parser.state.tokenValue);
		if (
			allowedModifiers.includes(modifier) &&
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParse(
				parser,
				___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextTokenCanFollowModifier,
			)
		) {
			return modifier;
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(
		parser,
		allowedModifiers,
	) {
		return (
			___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier(
				parser,
				allowedModifiers,
			) !== undefined
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(
		parser,
		kind,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
			)
		) {
			return true;
		}

		switch (kind) {
			case "EnumMembers":
			case "TypeMembers":
				return parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				);

			case "HeritageClauseElement":
				return parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
				);

			case "TupleElementTypes":
				return parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
				);

			case "TypeParametersOrArguments":
				return parser.isRelational(">");
		}

		throw new Error("Unreachable");
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$addTSDiagnostic(
		parser,
		label,
		start,
	) {
		if (parser.isSyntaxEnabled("ts")) {
			return;
		}

		parser.addDiagnostic({
			start,
			description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_REQUIRED(
				label,
			),
		});
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSList(
		parser,
		kind,
		parseElement,
	) {
		const result = [];
		while (
			!___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(
				parser,
				kind,
			)
		) {
			// Skipping 'parseListElement' from the TS source since that's just for error handling.
			result.push(parseElement(parser));
		}
		return result;
	}

	/**
 * If !expectSuccess, returns undefined instead of failing to parse.
 * If expectSuccess, parseElement should always return a defined value.
 */
	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
		parser,
		kind,
		parseElement,
	) {
		const result = [];

		while (true) {
			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(
					parser,
					kind,
				)
			) {
				break;
			}

			const element = parseElement(parser);
			if (element === undefined) {
				break;
			}

			result.push(element);

			if (
				parser.eat(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				continue;
			}

			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsListTerminator(
					parser,
					kind,
				)
			) {
				break;
			}

			// This will fail with an error about a missing comma
			if (
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				break;
			}
		}

		return result;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(
		parser,
		kind,
		parseElement,
		bracket,
		skipFirstToken,
	) {
		if (!skipFirstToken) {
			if (bracket) {
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
				);
			} else {
				parser.expectRelational("<");
			}
		}

		const result = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
			parser,
			kind,
			parseElement,
		);

		if (bracket) {
			parser.expect(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
			);
		} else {
			parser.expectRelational(">");
		}

		return result;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportType(
		parser,
	) {
		const start = parser.getPosition();
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import,
		);
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			"ts import type",
		);

		if (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_IMPORT_ARG_NOT_STRING,
			});
		}

		const argument = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(
			parser,
			"ts import argument",
		);
		parser.expectClosing(openContext);

		let qualifier;
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			qualifier = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(
				parser,
				/* allowReservedWords */ true,
			);
		}

		let typeParameters;
		if (parser.isRelational("<")) {
			typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSImportType",
				argument,
				qualifier,
				typeParameters,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(
		parser,
		allowReservedWords,
	) {
		let entity = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(
			parser,
		);
		while (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			const start = parser.getLoc(entity).start;
			const right = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				allowReservedWords,
			);
			entity = parser.finishNode(
				start,
				{
					type: "TSQualifiedName",
					left: entity,
					right,
				},
			);
		}
		return entity;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(
		parser,
	) {
		const start = parser.getPosition();
		const typeName = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(
			parser,
			/* allowReservedWords */ false,
		);
		let typeParameters;
		if (!parser.hasPrecedingLineBreak() && parser.isRelational("<")) {
			typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		}
		return parser.finishNode(
			start,
			{
				type: "TSTypeReference",
				typeName,
				typeParameters,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSThisTypePredicate(
		parser,
		lhs,
	) {
		parser.next();
		const start = parser.getLoc(lhs).start;
		const parameterName = lhs;
		const typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
			parser,
			/* eatColon */ false,
		);

		return parser.finishNode(
			start,
			{
				type: "TSTypePredicate",
				asserts: false,
				parameterName,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSThisTypeNode(
		parser,
	) {
		const start = parser.getPosition();
		parser.next();
		return parser.finishNode(
			start,
			{
				type: "TSThisType",
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeQuery(
		parser,
	) {
		const start = parser.getPosition();
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._typeof,
		);
		let exprName;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import,
			)
		) {
			exprName = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportType(
				parser,
			);
		} else {
			exprName = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(
				parser,
				/* allowReservedWords */ true,
			);
		}
		return parser.finishNode(
			start,
			{
				type: "TSTypeQuery",
				exprName,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$ambiguousTypeCastToParameter(
		parser,
		node,
	) {
		const start = parser.getPosition();
		const expr = ___R$project$rome$$romejs$js$parser$parser$lval_ts$toTargetAssignmentPattern(
			parser,
			node.expression,
			"parameter",
		);

		const meta = parser.finishNode(
			start,
			{
				type: "PatternMeta",
				optional: node.optional,
				typeAnnotation: node.typeAnnotation,
			},
		);

		return parser.finishNode(
			start,
			Object.assign(
				{},
				expr,
				{
					// @ts-ignore
					meta,
				},
			),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
		parser,
	) {
		if (parser.isRelational("<")) {
			return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeArguments(
		parser,
	) {
		if (parser.isRelational("<")) {
			return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameter(
		parser,
	) {
		const start = parser.getPosition();
		const name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(
			parser,
		);
		const constraint = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends,
		);
		const _default = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
		);
		return parser.finishNode(
			start,
			{
				type: "TSTypeParameter",
				name,
				constraint,
				default: _default,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
		parser,
	) {
		if (parser.isRelational("<")) {
			return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameters(
		parser,
	) {
		const start = parser.getPosition();

		parser.expectRelational("<");

		const params = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(
			parser,
			"TypeParametersOrArguments",
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeParameter,
			/* bracket */ false,
			/* skipFirstToken */ true,
		);

		return parser.finishNode(
			start,
			{
				type: "TSTypeParameterDeclaration",
				params,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(
		parser,
	) {
		if (
			parser.lookaheadState().tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const
		) {
			parser.next();
			return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
		parser,
		node,
	) {
		switch (node.type) {
			case "StringLiteral":
			case "TemplateLiteral":
			case "NumericLiteral":
			case "BooleanLiteral":
			case "SpreadElement":
			case "ObjectMethod":
			case "ObjectExpression":
				break;

			case "ArrayExpression": {
				for (const elem of node.elements) {
					if (elem) {
						___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
							parser,
							elem,
						);
					}
				}
				break;
			}

			case "ObjectProperty": {
				___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
					parser,
					node.value,
				);
				break;
			}

			case "UnaryExpression": {
				___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
					parser,
					node.argument,
				);
				break;
			}

			default:
				parser.addDiagnostic({
					loc: node.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_CONSTANT_NOT_LITERAL,
				});
		}
	}

	// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
	// but here it's always false, because parser.is only used for types.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
		parser,
		returnToken,
	) {
		const start = parser.getPosition();

		// Arrow fns *must* have return token (`=>`). Normal functions can omit it.
		const returnTokenRequired =
			returnToken ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow;
		const typeParameters = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
			parser,
		);
		const {list: parameters, rest} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBindingListForSignature(
			parser,
		);

		let typeAnnotation;
		if (returnTokenRequired) {
			typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
				parser,
				returnToken,
			);
		} else if (parser.match(returnToken)) {
			typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
				parser,
				returnToken,
			);
		}

		return {
			typeAnnotation,
			meta: parser.finishNode(
				start,
				{
					type: "TSSignatureDeclarationMeta",
					typeParameters,
					parameters,
					rest,
				},
			),
		};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBindingListForSignature(
		parser,
	) {
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			"ts signature parameters",
		);
		const {list: patterns, rest} = ___R$project$rome$$romejs$js$parser$parser$lval_ts$parseBindingListNonEmpty(
			parser,
			openContext,
		);
		const validPatterns = [];

		for (const pattern of patterns) {
			if (
				pattern.type === "BindingIdentifier" ||
				pattern.type === "BindingObjectPattern" ||
				pattern.type === "BindingArrayPattern"
			) {
				validPatterns.push(pattern);
			} else {
				parser.addDiagnostic({
					loc: pattern.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_INVALID_SIGNATURE_BINDING_NODE,
				});
			}
		}

		return {list: validPatterns, rest};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(
		parser,
	) {
		if (
			!parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			parser.semicolon();
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSConstructSignatureDeclaration(
		parser,
	) {
		const start = parser.getPosition();
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new,
		);
		const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
		);
		parser.semicolon();
		return parser.finishNode(
			start,
			{
				type: "TSConstructSignatureDeclaration",
				meta,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSCallSignatureDeclaration(
		parser,
	) {
		const start = parser.getPosition();
		const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
		);
		parser.semicolon();
		return parser.finishNode(
			start,
			{
				type: "TSCallSignatureDeclaration",
				meta,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyIndexSignature(
		parser,
	) {
		parser.next(); // Skip '{'
		return (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			) &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(
		parser,
		start,
	) {
		if (
			!(parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			) &&
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(
				parser,
				___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyIndexSignature,
			))
		) {
			return undefined;
		}

		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
		);

		const idStart = parser.getPosition();
		const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);

		const keyTypeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
			parser,
		);
		const key = parser.finishNode(
			idStart,
			Object.assign(
				{},
				id,
				{
					meta: parser.finishNode(
						idStart,
						Object.assign(
							{},
							id.meta,
							{type: "PatternMeta", typeAnnotation: keyTypeAnnotation},
						),
					),
				},
			),
		);

		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
		);

		const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(
			parser,
		);

		parser.semicolon();
		return parser.finishNode(
			start,
			{
				type: "TSIndexSignature",
				typeAnnotation,
				key,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSPropertyOrMethodSignature(
		parser,
		start,
		readonly,
	) {
		const key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(
			parser,
		);
		const optional = parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
		);

		if (
			!readonly &&
			(parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) ||
			parser.isRelational("<"))
		) {
			const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			);
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(
				parser,
			);
			return parser.finishNode(
				start,
				{
					type: "TSMethodSignature",
					optional,
					meta,
					key,
					returnType: typeAnnotation,
				},
			);
		} else {
			const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(
				parser,
			);
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMemberSemicolon(
				parser,
			);
			return parser.finishNode(
				start,
				{
					type: "TSPropertySignature",
					optional,
					readonly,
					typeAnnotation,
					key,
				},
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMember(
		parser,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) ||
			parser.isRelational("<")
		) {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSCallSignatureDeclaration(
				parser,
			);
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new,
			) &&
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(
				parser,
				___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfConstructSignature,
			)
		) {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSConstructSignatureDeclaration(
				parser,
			);
		}

		const start = parser.getPosition();
		const readonly = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(
			parser,
			["readonly"],
		);

		const idx = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(
			parser,
			start,
		);
		if (idx) {
			return Object.assign({}, idx, {readonly});
		}

		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSPropertyOrMethodSignature(
			parser,
			start,
			readonly,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfConstructSignature(
		parser,
	) {
		parser.next();
		return (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) || parser.isRelational("<")
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteral(
		parser,
	) {
		const start = parser.getPosition();
		const members = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(
			parser,
		);
		return parser.finishNode(
			start,
			{
				type: "TSTypeLiteral",
				members,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(
		parser,
	) {
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"ts object type members",
		);
		const members = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSList(
			parser,
			"TypeMembers",
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeMember,
		);
		parser.expectClosing(openContext);
		return members;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfMappedType(
		parser,
	) {
		parser.next();

		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin,
			)
		) {
			return parser.isContextual("readonly");
		}

		if (parser.isContextual("readonly")) {
			parser.next();
		}

		if (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			return false;
		}

		parser.next();

		if (
			!___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(
				parser,
			)
		) {
			return false;
		}

		parser.next();

		return parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSMappedTypeParameter(
		parser,
	) {
		const start = parser.getPosition();
		const name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(
			parser,
		);
		const constraint = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._in,
		);
		return parser.finishNode(
			start,
			{
				type: "TSTypeParameter",
				name,
				constraint,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$toPlusMin(
		val,
	) {
		const str = String(val);
		if (str === "+" || str === "-") {
			return str;
		} else {
			throw new Error("Expected +/-");
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSMappedType(
		parser,
	) {
		const start = parser.getPosition();

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"ts mapped type",
		);

		let readonly;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin,
			)
		) {
			readonly = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$toPlusMin(
				parser.state.tokenValue,
			);
			parser.next();
			parser.expectContextual("readonly");
		} else if (parser.eatContextual("readonly")) {
			readonly = true;
		}

		const paramOpenContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
			"ts mapped type parameter",
		);
		const typeParameter = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSMappedTypeParameter(
			parser,
		);
		parser.expectClosing(paramOpenContext);

		let optional;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin,
			)
		) {
			optional = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$toPlusMin(
				parser.state.tokenValue,
			);
			parser.next();
			parser.expect(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			);
		} else if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			optional = true;
		}

		const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseType(
			parser,
		);
		parser.semicolon();
		parser.expectClosing(openContext);

		return parser.finishNode(
			start,
			{
				type: "TSMappedType",
				typeParameter,
				typeAnnotation,
				optional,
				readonly,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTupleType(
		parser,
	) {
		const start = parser.getPosition();
		const elementDefs = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSBracketedList(
			parser,
			"TupleElementTypes",
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTupleElementType,
			/* bracket */ true,
			/* skipFirstToken */ false,
		);

		// Validate the elementTypes to ensure:
		//   No mandatory elements may follow optional elements

		//   If there's a rest element, it must be at the end of the tuple
		let seenOptionalElement = false;
		const elementTypes = [];
		let rest;
		for (const {type, isRest} of elementDefs) {
			if (rest !== undefined) {
				// No elements should come after a rest, we should have already produced an error
				continue;
			}

			if (type.type === "TSOptionalType") {
				seenOptionalElement = true;
			} else if (seenOptionalElement && !isRest) {
				parser.addDiagnostic({
					loc: type.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_REQUIRED_FOLLOWS_OPTIONAL,
				});
			}

			if (isRest) {
				rest = type;
			} else {
				elementTypes.push(type);
			}
		}

		return parser.finishNode(
			start,
			{
				type: "TSTupleType",
				elementTypes,
				rest,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTupleElementType(
		parser,
	) {
		// parses `...TsType[]`
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
			)
		) {
			parser.next(); // skips ellipsis
			const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
				parser,
			);
			___R$project$rome$$romejs$js$parser$parser$lval_ts$hasCommaAfterRest(
				parser,
			);

			return {
				isRest: true,
				type: typeAnnotation,
			};
		}

		const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);

		// Parses `TsType?`
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			const start = parser.getLoc(typeAnnotation).start;
			return {
				isRest: false,
				type: parser.finishNode(
					start,
					{
						type: "TSOptionalType",
						typeAnnotation,
					},
				),
			};
		}

		return {
			isRest: false,
			type: typeAnnotation,
		};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSParenthesizedType(
		parser,
	) {
		const start = parser.getPosition();
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			"ts parenthesized type",
		);
		const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
		parser.expectClosing(openContext);
		return parser.finishNode(
			start,
			{
				type: "TSParenthesizedType",
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSFunctionType(
		parser,
	) {
		const start = parser.getPosition();
		const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
		);

		if (typeAnnotation === undefined) {
			throw new Error(
				"Type annotation return type required as we passed tt.arrow above",
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSFunctionType",
				meta,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSConstructorType(
		parser,
	) {
		const start = parser.getPosition();
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new,
		);

		const {meta, typeAnnotation} = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSSignatureDeclarationMeta(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
		);

		if (typeAnnotation === undefined) {
			throw new Error(
				"Type annotation return type required as we passed tt.arrow above",
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSConstructorType",
				meta,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTemplateLiteralType(
		parser,
	) {
		const templateNode = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseTemplate(
			parser,
			false,
		);

		if (templateNode.expressions.length > 0) {
			parser.addDiagnostic({
				loc: parser.getLoc(templateNode.expressions[0]),
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_TEMPLATE_LITERAL_WITH_SUBSTITUION,
			});
		}

		return {
			type: "TSTemplateLiteralTypeAnnotation",
			value: templateNode.quasis[0].raw,
			loc: templateNode.loc,
		};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonArrayType(
		parser,
	) {
		switch (parser.state.tokenType) {
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._void:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._null: {
				let type;
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._void,
					)
				) {
					type = "VoidKeywordTypeAnnotation";
				} else if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._null,
					)
				) {
					type = "TSNullKeywordTypeAnnotation";
				} else {
					type = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$keywordTypeFromName(
						String(parser.state.tokenValue),
					);
				}

				if (
					type !== undefined &&
					parser.lookaheadState().tokenType !==
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot
				) {
					const start = parser.getPosition();
					parser.next();
					return parser.finishNode(
						start,
						({
							type,
						}),
					);
				}
				return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeReference(
					parser,
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._false:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteralAnnotation(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._this: {
				const thisKeyword = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSThisTypeNode(
					parser,
				);
				if (parser.isContextual("is") && !parser.hasPrecedingLineBreak()) {
					return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSThisTypePredicate(
						parser,
						thisKeyword,
					);
				} else {
					return thisKeyword;
				}
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._typeof:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeQuery(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportType(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL:
				if (
					___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(
						parser,
						___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfMappedType,
					)
				) {
					return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSMappedType(
						parser,
					);
				} else {
					return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteral(
						parser,
					);
				}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTupleType(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSParenthesizedType(
					parser,
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote:
				return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTemplateLiteralType(
					parser,
				);
		}

		parser.addDiagnostic({
			description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_UNKNOWN_NON_ARRAY_START,
		});
		parser.next();

		return parser.finishNode(
			parser.getPosition(),
			{
				type: "TSTypeReference",
				typeName: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toReferenceIdentifier(
					parser,
					parser.createUnknownIdentifier("ts non array type start"),
				),
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteralAnnotation(
		parser,
	) {
		const start = parser.getPosition();

		switch (parser.state.tokenType) {
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string: {
				const value = String(parser.state.tokenValue);
				parser.next();
				return parser.finishNode(
					start,
					{
						type: "TSStringLiteralTypeAnnotation",
						value,
					},
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num: {
				const {tokenValue} = parser.state;
				if (
					!(tokenValue instanceof
					___R$project$rome$$romejs$js$parser$tokenizer$index_ts$NumberTokenValue)
				) {
					throw new Error("Expected NumberTokenValue");
				}

				const {value, format} = tokenValue;
				parser.next();
				return parser.finishNode(
					start,
					{
						type: "TSNumericLiteralTypeAnnotation",
						value,
						format,
					},
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._false: {
				const value = parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._true,
				);
				parser.next();
				return parser.finishNode(
					start,
					{
						type: "TSBooleanLiteralTypeAnnotation",
						value,
					},
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin: {
				const {tokenValue} = parser.state;
				if (tokenValue === "-") {
					parser.next();

					if (
						!parser.match(
							___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num,
						)
					) {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TYPE_NUMERIC_LITERAL_EXPECTED,
						});
						parser.next();
						return parser.finishNode(
							start,
							{
								type: "TSNumericLiteralTypeAnnotation",
								value: 0,
							},
						);
					}

					const {tokenValue} = parser.state;
					if (
						!(tokenValue instanceof
						___R$project$rome$$romejs$js$parser$tokenizer$index_ts$NumberTokenValue)
					) {
						throw new Error("Expected NumberTokenValue");
					}

					const {value, format} = tokenValue;
					parser.next();
					return parser.finishNode(
						start,
						{
							type: "TSNumericLiteralTypeAnnotation",
							value: -value,
							format,
						},
					);
				} else {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TYPE_NUMERIC_LITERAL_PLUS,
					});
					parser.next();

					if (
						!parser.match(
							___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num,
						)
					) {
						parser.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TYPE_NUMERIC_LITERAL_EXPECTED,
						});
						parser.next();
						return parser.finishNode(
							start,
							{
								type: "TSNumericLiteralTypeAnnotation",
								value: 0,
							},
						);
					}

					return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeLiteralAnnotation(
						parser,
					);
				}
			}

			default:
				throw new Error(
					"Caller should have already validated the range of token types",
				);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSArrayTypeOrHigher(
		parser,
	) {
		let type = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonArrayType(
			parser,
		);

		while (
			!parser.hasPrecedingLineBreak() &&
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
				)
			) {
				const start = parser.getLoc(type).start;
				const elementType = type;
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
				);
				type = parser.finishNode(
					start,
					{
						type: "TSArrayType",
						elementType,
					},
				);
			} else {
				const start = parser.getLoc(type).start;
				const objectType = type;
				const indexType = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
					parser,
				);
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
				);
				type = parser.finishNode(
					start,
					{
						type: "TSIndexedAccessType",
						objectType,
						indexType,
					},
				);
			}
		}
		return type;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperator(
		parser,
		operator,
	) {
		const start = parser.getPosition();
		parser.expectContextual(operator);

		const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher(
			parser,
		);

		const node = parser.finishNode(
			start,
			{
				type: "TSTypeOperator",
				typeAnnotation,
				operator,
			},
		);

		if (operator === "readonly") {
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(
				parser,
				typeAnnotation,
			);
		}

		return node;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckTypeAnnotationForReadOnly(
		parser,
		node,
	) {
		switch (node.type) {
			case "TSTupleType":
			case "TSArrayType":
				return;

			default: {
				parser.addDiagnostic({
					loc: node.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_INVALID_READONLY_MODIFIER,
				});
				break;
			}
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInferType(
		parser,
	) {
		const inferStart = parser.getPosition();
		parser.expectContextual("infer");

		const start = parser.getPosition();
		const name = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifierName(
			parser,
		);
		const typeParameter = parser.finishNode(
			start,
			{
				type: "TSTypeParameter",
				name,
			},
		);

		return parser.finishNode(
			inferStart,
			{
				type: "TSInferType",
				typeParameter,
			},
		);
	}

	const ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$TS_TYPE_OPERATORS = [
		"keyof",
		"unique",
		"readonly",
	];

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher(
		parser,
	) {
		let operator;

		for (const op of ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$TS_TYPE_OPERATORS) {
			if (parser.isContextual(op)) {
				operator = op;
				break;
			}
		}

		if (operator !== undefined) {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperator(
				parser,
				operator,
			);
		} else if (parser.isContextual("infer")) {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInferType(
				parser,
			);
		} else {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSArrayTypeOrHigher(
				parser,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
		parser,
		kind,
		parseConstituentType,
		operator,
	) {
		parser.eat(operator);
		let type = parseConstituentType(parser);

		if (parser.match(operator)) {
			const types = [type];
			while (parser.eat(operator)) {
				types.push(parseConstituentType(parser));
			}

			const start = parser.getLoc(type).start;
			if (kind === "UnionTypeAnnotation") {
				type = parser.finishNode(
					start,
					{
						type: "UnionTypeAnnotation",
						types,
					},
				);
			} else if (kind === "TSIntersectionTypeAnnotation") {
				type = parser.finishNode(
					start,
					{
						type: "TSIntersectionTypeAnnotation",
						types,
					},
				);
			}
		}

		return type;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSIntersectionTypeAnnotationOrHigher(
		parser,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
			parser,
			"TSIntersectionTypeAnnotation",
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOperatorOrHigher,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseUnionTypeAnnotationOrHigher(
		parser,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSUnionOrIntersectionType(
			parser,
			"UnionTypeAnnotation",
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSIntersectionTypeAnnotationOrHigher,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfFunctionType(
		parser,
	) {
		if (parser.isRelational("<")) {
			return true;
		}
		return (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) &&
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(
				parser,
				___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType,
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsSkipParameterStart(
		parser,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._this,
			)
		) {
			parser.next();
			return true;
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			)
		) {
			let braceStackCounter = 1;
			parser.next();

			while (braceStackCounter > 0) {
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
					)
				) {
					braceStackCounter++;
				} else if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					braceStackCounter--;
				}

				parser.next();
			}
			return true;
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
			)
		) {
			let braceStackCounter = 1;
			parser.next();

			while (braceStackCounter > 0) {
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
					)
				) {
					braceStackCounter++;
				} else if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
					)
				) {
					braceStackCounter--;
				}

				parser.next();
			}
			return true;
		}

		return false;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsUnambiguouslyStartOfFunctionType(
		parser,
	) {
		parser.next();
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
			)
		) {
			// ()
			// (...
			return true;
		}
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsSkipParameterStart(
				parser,
			)
		) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
				) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
				) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
				)
			) {
				// (xxx :
				// (xxx ,
				// (xxx ?
				// (xxx =
				return true;
			}
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
				)
			) {
				parser.next();
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
					)
				) {
					// (xxx ) =>
					return true;
				}
			}
		}
		return false;
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeOrTypePredicateAnnotation(
		parser,
		returnToken,
	) {
		let start = parser.getPosition();
		parser.pushScope("TYPE", true);
		parser.expect(returnToken);

		let hasAsserts = parser.eatContextual("asserts");
		let parameterName;
		let typePredicateVariable;
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsIdentifier(
				parser,
			)
		) {
			typePredicateVariable = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParse(
				parser,
				___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypePredicatePrefix,
			);
		}
		if (typePredicateVariable === undefined) {
			if (hasAsserts) {
				parameterName = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
					parser,
				);
				if (parameterName === undefined) {
					throw Error("Should have an identifier after asserts");
				}
			} else {
				parser.popScope("TYPE");
				return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
					parser,
					/* eatColon */ false,
					start,
				);
			}
		} else {
			parameterName = typePredicateVariable;
		}

		let type;
		if (typePredicateVariable) {
			type = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				/* eatColon */ false,
			);
			start = parser.getLoc(typePredicateVariable).start;
		}

		parser.popScope("TYPE");

		return parser.finishNode(
			start,
			{
				type: "TSTypePredicate",
				asserts: hasAsserts,
				parameterName,
				typeAnnotation: type,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseTypeAnnotation(
		parser,
	) {
		return parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
		)
			? ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
					parser,
				)
			: undefined;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseType(
		parser,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypePredicatePrefix(
		parser,
	) {
		const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
			parser,
		);
		if (parser.isContextual("is") && !parser.hasPrecedingLineBreak()) {
			parser.next();
			return id;
		} else {
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
		parser,
		eatColon = true,
		start = parser.getPosition(),
	) {
		parser.pushScope("TYPE", true);

		if (eatColon) {
			parser.expect(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			);
		}

		const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
			parser,
			start,
		);
		parser.popScope("TYPE");
		return typeAnnotation;
	}

	/** Be sure to be in a type context before calling parser. using `tsInType`.*/
	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
		parser,
		start = parser.getPosition(),
	) {
		parser.pushScope("TYPE", true);

		const type = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(
			parser,
		);
		if (
			parser.hasPrecedingLineBreak() ||
			!parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends,
			)
		) {
			parser.popScope("TYPE");
			return type;
		}

		const checkType = type;

		const extendsType = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(
			parser,
		);
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
		);

		const trueType = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
		);

		const falseType = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
		parser.popScope("TYPE");

		return parser.finishNode(
			start,
			{
				type: "TSConditionalType",
				checkType,
				extendsType,
				trueType,
				falseType,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSNonConditionalType(
		parser,
	) {
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsStartOfFunctionType(
				parser,
			)
		) {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSFunctionType(
				parser,
			);
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._new,
			)
		) {
			// As in `new () => Date`
			return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSConstructorType(
				parser,
			);
		}

		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseUnionTypeAnnotationOrHigher(
			parser,
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAssertion(
		parser,
	) {
		const start = parser.getPosition();
		const _const = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSNextParseConstantContext(
			parser,
		);
		const typeAnnotation =
			_const ||
			___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(
				parser,
			);
		parser.expectRelational(">");

		const expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeUnary(
			parser,
			"ts type assertion",
		);
		if (_const) {
			___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsCheckLiteralForConstantContext(
				parser,
				expression,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSTypeAssertion",
				expression,
				typeAnnotation,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(
		parser,
		descriptor,
	) {
		const originalStart = parser.state.startPos;
		const delimitedList = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
			parser,
			"HeritageClauseElement",
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExpressionWithTypeArguments,
		);

		if (delimitedList.length === 0) {
			parser.addDiagnostic({
				start: originalStart,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_EMPTY_LIST(
					descriptor,
				),
			});
		}

		return delimitedList;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExpressionWithTypeArguments(
		parser,
	) {
		const start = parser.getPosition();

		// Note: TS uses parseLeftHandSideExpressionOrHigher,

		// then has grammar errors later if it's not an EntityName.
		const expression = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(
			parser,
			/* allowReservedWords */ false,
		);

		let typeParameters;
		if (parser.isRelational("<")) {
			typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
				parser,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSExpressionWithTypeArguments",
				expression,
				typeParameters,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
		parser,
		start,
	) {
		parser.pushScope("TYPE", true);
		const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);
		const typeParameters = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
			parser,
		);

		let _extends;
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends,
			)
		) {
			_extends = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(
				parser,
				"extends",
			);
		}

		const bodyStart = parser.getPosition();
		const bodyItems = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSObjectTypeMembers(
			parser,
		);
		const body = parser.finishNode(
			bodyStart,
			{
				type: "TSInterfaceBody",
				body: bodyItems,
			},
		);

		parser.popScope("TYPE");
		return parser.finishNode(
			start,
			{
				type: "TSInterfaceDeclaration",
				id,
				body,
				typeParameters,
				extends: _extends,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAlias(
		parser,
		start,
	) {
		const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);
		const typeParameters = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryParseTSTypeParameters(
			parser,
		);
		const typeAnnotation = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
		);
		parser.semicolon();
		return parser.finishNode(
			start,
			{
				type: "TypeAliasTypeAnnotation",
				id,
				typeParameters,
				right: typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsInNoContext(
		parser,
		cb,
	) {
		const oldContext = parser.state.context;
		parser.state.context = [oldContext[0]];
		const res = cb(parser);
		parser.state.context = oldContext;
		return res;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsEatThenParseType(
		parser,
		token,
	) {
		if (parser.match(token)) {
			return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(
				parser,
			);
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsExpectThenParseType(
		parser,
		token,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(
			parser,
			() => {
				parser.expect(token);
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tsNextThenParseType(
		parser,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(
			parser,
			() => parser.next(),
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsDoThenParseType(
		parser,
		cb,
	) {
		cb();
		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType(
			parser,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumMember(
		parser,
	) {
		const start = parser.getPosition();
		// Computed property names are grammar errors in an enum, so accept just string literal or identifier.
		const id = parser.match(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
		)
			? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				)
			: ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
					parser,
					/* liberal */ true,
				);

		let initializer;
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
			)
		) {
			initializer = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"ts enum member initializer",
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSEnumMember",
				initializer,
				id,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
		parser,
		start,
		isConst,
	) {
		parser.addDiagnosticFilter({
			message: "enum is a reserved word",
			start,
		});

		const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"ts enum declaration",
		);

		const members = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
			parser,
			"EnumMembers",
			___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumMember,
		);
		parser.expectClosing(openContext);

		return parser.finishNode(
			start,
			{
				type: "TSEnumDeclaration",
				members,
				id,
				const: isConst,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(
		parser,
	) {
		const start = parser.getPosition();

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"ts module block",
		);

		// Inside of a module block is considered 'top-level', meaning it can have imports and exports.
		const {body} = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseBlockOrModuleBlockBody(
			parser,
			/* allowDirectives */ false,
			/* topLevel */ true,
			openContext,
		);
		return parser.finishNode(
			start,
			{
				type: "TSModuleBlock",
				body,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
		parser,
		start,
	) {
		const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);

		let body;
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			)
		) {
			body = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
				parser,
				parser.getPosition(),
			);
		} else {
			body = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(
				parser,
			);
		}

		return parser.finishNode(
			start,
			{
				type: "TSModuleDeclaration",
				id,
				body,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(
		parser,
		start,
	) {
		let global;
		let id;
		if (parser.isContextual("global")) {
			global = true;
			id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
				parser,
			);
		} else if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
				parser,
			);
		} else {
			throw parser.unexpected();
		}

		let body;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			)
		) {
			body = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(
				parser,
			);
		} else {
			parser.semicolon();
		}

		return parser.finishNode(
			start,
			{
				type: "TSModuleDeclaration",
				id,
				global,
				body,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(
		parser,
		start,
		isExport = false,
	) {
		const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);
		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
		);

		const moduleReference = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleReference(
			parser,
		);
		parser.semicolon();

		return parser.finishNode(
			start,
			{
				type: "TSImportEqualsDeclaration",
				id,
				moduleReference,
				isExport,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsExternalModuleReference(
		parser,
	) {
		return (
			parser.isContextual("require") &&
			parser.lookaheadState().tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleReference(
		parser,
	) {
		return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsIsExternalModuleReference(
			parser,
		)
			? ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExternalModuleReference(
					parser,
				)
			: ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEntityName(
					parser,
					/* allowReservedWords */ false,
				);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExternalModuleReference(
		parser,
	) {
		const start = parser.getPosition();
		parser.expectContextual("require");
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
			"ts external module reference",
		);

		let expression;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
				parser,
			);
		} else {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_EXTERNAL_MODULE_REFERENCE_ARG_NOT_STRING,
			});

			// Skip as much of the next expression as we can
			___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(
				parser,
				"ts external module reference expression",
			);

			// Create a fake string literal
			expression = parser.finishNode(
				start,
				{
					type: "StringLiteral",
					value: "",
				},
			);
		}

		parser.expectClosing(openContext);

		return parser.finishNode(
			start,
			{
				type: "TSExternalModuleReference",
				expression,
			},
		);
	}

	// Utilities


	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$lookaheadTS(
		parser,
		f,
	) {
		const state = parser.cloneState();
		const res = f(parser);
		parser.state = state;
		return res;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParse(
		parser,
		f,
	) {
		const state = parser.cloneState();
		const result = f(parser);
		if (result === undefined || result === false) {
			parser.state = state;
			return undefined;
		} else {
			return result;
		}
	}



	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDeclare(
		parser,
		start,
	) {
		let starttype = parser.state.tokenType;
		let kind;
		if (parser.isContextual("let")) {
			starttype = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var;
			kind = "let";
		}

		if (
			starttype ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const,
			) &&
			parser.isLookaheadContextual("enum")
		) {
			// `const enum = 0;` not allowed because 'enum' is a strict mode reserved word.
			parser.expect(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const,
			);
			parser.expectContextual("enum");
			return Object.assign(
				{declare: true},
				___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
					parser,
					start,
					/* isConst */ true,
				),
			);
		}

		switch (starttype) {
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function:
				return Object.assign(
					{},
					___R$project$rome$$romejs$js$parser$parser$statement_ts$parseFunctionDeclaration(
						parser,
						start,
						false,
					),
					{declare: true},
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class:
				return Object.assign(
					{},
					___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration(
						parser,
						start,
					),
					{declare: true},
				);

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const:
			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var: {
				kind =
					kind === undefined
						? ___R$project$rome$$romejs$js$parser$parser$statement_ts$assertVarKind(
								String(parser.state.tokenValue),
							)
						: kind;
				return Object.assign(
					{declare: true},
					___R$project$rome$$romejs$js$parser$parser$statement_ts$parseVarStatement(
						parser,
						start,
						kind,
					),
				);
			}

			case ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name: {
				const value = String(parser.state.tokenValue);

				if (value === "global") {
					return Object.assign(
						{declare: true},
						___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(
							parser,
							start,
						),
					);
				} else if (
					___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(
						parser,
					)
				) {
					const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(
						parser,
					);
					const decl = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeExpressionStatement(
						parser,
						start,
						id,
					);

					if (decl === undefined) {
						throw new Error("Should have returned a node");
					}

					if (
						decl.type !== "TSInterfaceDeclaration" &&
						decl.type !== "TypeAliasTypeAnnotation" &&
						decl.type !== "TSEnumDeclaration" &&
						decl.type !== "FunctionDeclaration" &&
						decl.type !== "ClassDeclaration" &&
						decl.type !== "VariableDeclarationStatement" &&
						decl.type !== "TSDeclareFunction" &&
						decl.type !== "TSModuleDeclaration"
					) {
						throw new Error(
							"Encountered a non-TS declare node when calling parseTSTypeExpressionStatement",
						);
					}

					return Object.assign({}, decl, {declare: true});
				}
			}
		}

		parser.addDiagnostic({
			description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.TS_UNKNOWN_DECLARE_START,
		});

		// Fake node
		const loc = parser.finishLoc(start);
		return {
			type: "VariableDeclarationStatement",
			loc,
			declaration: {
				type: "VariableDeclaration",
				loc,
				kind: "var",
				declarations: [
					{
						type: "VariableDeclarator",
						loc,
						id: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
							parser,
							parser.createUnknownIdentifier("typescript declare start", start),
						),
						init: undefined,
					},
				],
			},
		};
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeExpressionStatement(
		parser,
		start,
		expr,
	) {
		// TODO TypeScript does not like parser.isLineTerminator()
		if (expr.type !== "ReferenceIdentifier") {
			return undefined;
		}

		if (parser.hasPrecedingLineBreak()) {
			return undefined;
		}

		switch (expr.name) {
			case "declare":
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var,
					) ||
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._export,
					)
				) {
					return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDeclare(
						parser,
						start,
					);
				} else {
					break;
				}

			case "interface": {
				parser.addDiagnosticFilter({
					message: "interface is a reserved word",
					start,
				});

				return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
					parser,
					start,
				);
			}

			case "type":
				// TODO perform some lookahead to make sure we want to do this
				return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAlias(
					parser,
					start,
				);

			case "abstract":
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class,
					)
				) {
					___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$addTSDiagnostic(
						parser,
						"abstract class",
						start,
					);
					return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass(
						parser,
						start,
					);
				} else {
					break;
				}

			case "enum": {
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
					)
				) {
					___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$addTSDiagnostic(
						parser,
						"enum declaration",
						start,
					);
					return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSEnumDeclaration(
						parser,
						start,
						/* isConst */ false,
					);
				} else {
					break;
				}
			}

			case "module":
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
					)
				) {
					___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$addTSDiagnostic(
						parser,
						"ambient external module declaration",
						start,
					);
					return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAmbientExternalModuleDeclaration(
						parser,
						start,
					);
				} else if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
					) &&
					!parser.isLineTerminator()
				) {
					___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$addTSDiagnostic(
						parser,
						"module or namespace declaration",
						start,
					);
					return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
						parser,
						start,
					);
				} else {
					break;
				}

			case "namespace": {
				if (
					!parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
					)
				) {
					return undefined;
				}

				___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$addTSDiagnostic(
					parser,
					"module or namespace declaration",
					start,
				);
				return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleOrNamespaceDeclaration(
					parser,
					start,
				);
			}

			// TODO abstract this into typescript.js
			case "global":
				// `global { }` (with no `declare`) may appear inside an ambient module declaration.
				// Would like to use parseTSAmbientExternalModuleDeclaration here, but already ran past 'global'.
				if (
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
					)
				) {
					___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$addTSDiagnostic(
						parser,
						"module declaration",
						start,
					);
					const global = true;
					const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
						parser,
						expr,
					);
					const body = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModuleBlock(
						parser,
					);
					return parser.finishNode(
						start,
						{
							type: "TSModuleDeclaration",
							global,
							id,
							body,
						},
					);
				}
		}

		return undefined;
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAbstractClass(
		parser,
		start,
	) {
		return Object.assign(
			{},
			___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration(
				parser,
				start,
			),
			{abstract: true},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass(
		parser,
		start,
	) {
		return Object.assign(
			{},
			___R$project$rome$$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(
				parser,
				start,
			),
			{abstract: true},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeArguments(
		parser,
	) {
		const start = parser.getPosition();
		parser.pushScope("TYPE", true);

		const params = ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$tsInNoContext(
			parser,
			() => {
				parser.expectRelational("<");
				return ___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSDelimitedList(
					parser,
					"TypeParametersOrArguments",
					___R$$priv$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSType,
				);
			},
		);

		// This reads the next token after the `>` too, so do parser.in the enclosing context.

		// But be sure not to parse a regex in the jsx expression `<C<number> />`, so set exprAllowed = false
		parser.state.exprAllowed = false;
		parser.popScope("TYPE");
		parser.expectRelational(">");

		return parser.finishNode(
			start,
			{
				type: "TSTypeParameterInstantiation",
				params,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(
		parser,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			switch (parser.state.tokenValue) {
				case "abstract":
				case "declare":
				case "enum":
				case "interface":
				case "module":
				case "namespace":
				case "type":
					return true;
			}
		}

		return false;
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(
		parser,
	) {
		return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier(
			parser,
			["public", "protected", "private"],
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSAbstractClass(
		parser,
	) {
		return (
			parser.isContextual("abstract") &&
			parser.lookaheadState().tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExport(
		parser,
		start,
	) {
		if (!parser.isSyntaxEnabled("ts")) {
			return undefined;
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import,
			)
		) {
			// `export const A =B;`
			parser.expect(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._import,
			);
			return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(
				parser,
				start,
				/* isExport */ true,
			);
		}

		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
			)
		) {
			// `export = x;`
			const expression = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpression(
				parser,
				"ts export assignment",
			);
			parser.semicolon();
			return parser.finishNode(
				start,
				{
					type: "TSExportAssignment",
					expression,
				},
			);
		}

		if (parser.eatContextual("as")) {
			// `export as namespace A;`
			// See `parseNamespaceExportDeclaration` in TypeScript's own parser
			parser.expectContextual("namespace");
			const id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
			);
			parser.semicolon();
			return parser.finishNode(
				start,
				{
					type: "TSNamespaceExportDeclaration",
					id,
				},
			);
		}

		return undefined;
	}


  // project-rome/@romejs/js-parser/parser/classes.ts
const ___R$project$rome$$romejs$js$parser$parser$classes_ts = {
		parseClassExpression: ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassExpression,
		parseExportDefaultClassDeclaration: ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration,
		parseClassDeclaration: ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration,
		parseClass: ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass,
	};
	function ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassExpression(
		parser,
		start,
	) {
		return parser.finalizeNode(
			Object.assign(
				{},
				___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass(
					parser,
					start,
					true,
				),
				{type: "ClassExpression"},
			),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(
		parser,
		start,
	) {
		let ___R$ = ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass(
			parser,
			start,
			true,
		);
		let shape = Object.assign({}, ___R$);
		delete shape.id;
		let {id} = ___R$;
		if (id === undefined) {
			id = {
				type: "BindingIdentifier",
				name: "*default*",
				// Does this `loc` make sense?
				loc: shape.loc,
			};
		}

		return parser.finalizeNode(
			Object.assign({}, shape, {type: "ClassDeclaration", id}),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClassDeclaration(
		parser,
		start,
	) {
		const ___R$1 = ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass(
			parser,
			start,
			false,
		);
		const shape = Object.assign({}, ___R$1);
		delete shape.id;
		const {id} = ___R$1;
		if (id === undefined) {
			throw new Error("Expected id");
		}

		return parser.finalizeNode(
			Object.assign({}, shape, {type: "ClassDeclaration", id}),
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseClass(
		parser,
		start,
		optionalId,
	) {
		parser.pushScope("METHOD", false);
		parser.pushScope("STRICT", true);

		parser.next();
		const {id, typeParameters} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassId(
			parser,
			optionalId,
		);
		const {superClass, superTypeParameters, implemented} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassSuper(
			parser,
		);

		parser.pushScope("CLASS", superClass === undefined ? "normal" : "derived");

		const bodyStart = parser.getPosition();
		const body = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassBody(
			parser,
		);

		parser.popScope("CLASS");
		parser.popScope("STRICT");
		parser.popScope("METHOD");

		// We have two finishNodes here to consume the innerComments inside of the body
		// This is since in the Rome AST, we don't have a ClassBody node, so the comment
		// algorithm thinks that the ClassHead location is too broad, and thinks a different
		// node should consume them.
		const meta = parser.finishNode(
			start,
			parser.finishNode(
				bodyStart,
				{
					type: "ClassHead",
					body,
					typeParameters,
					superClass,
					superTypeParameters,
					implements: implemented,
				},
			),
		);

		return {
			loc: parser.finishLoc(start),
			id,
			meta,
		};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassProperty(
		parser,
	) {
		return (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassMethod(
		parser,
	) {
		return (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
			) || parser.isRelational("<")
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(
		parser,
		key,
		meta,
	) {
		// Class property
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			return false;
		}

		// Static
		if (meta.static) {
			return false;
		}

		if (
			key.type === "StaticPropertyKey" &&
			key.value.type === "Identifier" &&
			key.value.name === "constructor"
		) {
			return true;
		}

		if (key.value.type === "StringLiteral" && key.value.value === "constructor") {
			return true;
		}

		return false;
	}



	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassBody(
		parser,
	) {
		// class bodies are implicitly strict
		parser.pushScope("STRICT", true);
		parser.state.classLevel = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
			parser.state.classLevel,
		);

		const state = {hadConstructor: false};

		const body = [];

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"class body",
		);

		while (true) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				break;
			}

			if (
				parser.eat(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
				)
			) {
				continue;
			}

			const member = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMember(
				parser,
				state,
			);
			if (member !== undefined) {
				body.push(member);
			}
		}

		parser.expectClosing(openContext);

		parser.state.classLevel = ___R$project$rome$$romejs$ob1$index_ts$ob1Dec(
			parser.state.classLevel,
		);
		parser.popScope("STRICT");

		return body;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMember(
		parser,
		state,
	) {
		const start = parser.getPosition();
		const escapePosition = parser.state.escapePosition;

		let accessibility;
		if (parser.isSyntaxEnabled("ts")) {
			accessibility = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSAccessModifier(
				parser,
			);
		}

		let isStatic = false;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			) &&
			parser.state.tokenValue === "static"
		) {
			const keyId = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			); // eats 'static'
			const key = {
				type: "StaticPropertyKey",
				value: keyId,
				loc: keyId.loc,
			};

			const meta = parser.finishNode(
				start,
				{
					type: "ClassPropertyMeta",
					static: false,
					typeAnnotation: undefined,
					accessibility,
					optional: false,
					abstract: false,
					readonly: false,
				},
			);

			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassMethod(
					parser,
				)
			) {
				// A method named 'static'
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
					parser,
					{
						start,
						meta,
						key,
						kind: "method",
						isStatic: false,
						isAsync: false,
						isGenerator: false,
						isConstructor: false,
					},
				);
			}

			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassProperty(
					parser,
				)
			) {
				// A property named 'static'
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassProperty(
					parser,
					start,
					key,
					meta,
				);
			}

			if (escapePosition !== undefined) {
				parser.addDiagnostic({
					index: escapePosition,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ESCAPE_SEQUENCE_IN_WORD(
						"static",
					),
				});
			}

			// Otherwise something static
			isStatic = true;
		}

		return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMemberWithIsStatic(
			parser,
			start,
			state,
			isStatic,
			accessibility,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMemberWithIsStatic(
		parser,
		start,
		state,
		isStatic,
		accessibility,
	) {
		let abstract = false;
		let readonly = false;

		const mod = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSModifier(
			parser,
			["abstract", "readonly"],
		);
		switch (mod) {
			case "readonly": {
				readonly = true;
				abstract = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(
					parser,
					["abstract"],
				);
				break;
			}

			case "abstract": {
				abstract = true;
				readonly = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$hasTSModifier(
					parser,
					["readonly"],
				);
				break;
			}
		}

		const nameOpts = {
			start,
			static: isStatic,
			accessibility,
			readonly,
			abstract,
		};

		if (!abstract && !isStatic && accessibility === undefined) {
			const indexSignature = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$tryTSParseIndexSignature(
				parser,
				start,
			);
			if (indexSignature) {
				return Object.assign({}, indexSignature, {readonly});
			}
		}

		// Must be a property (if not an index signature).
		if (readonly) {
			const {key, meta} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(
				parser,
				nameOpts,
			);
			if (key.value.type === "PrivateName") {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(
					parser,
					start,
					key.value,
					meta,
				);
			} else {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$pushClassProperty(
					parser,
					start,
					key,
					meta,
				);
			}
		}

		// Generator methods
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			)
		) {
			const {meta, key} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(
				parser,
				nameOpts,
			);

			if (key.value.type === "PrivateName") {
				// Private generator method
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
					parser,
					{
						start,
						key: key.value,
						meta,
						isGenerator: true,
						isAsync: false,
						kind: "method",
					},
				);
			}

			if (
				___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(
					parser,
					key,
					meta,
				)
			) {
				parser.addDiagnostic({
					loc: key.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.GENERATOR_CLASS_CONSTRUCTOR,
				});
			}

			return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
				parser,
				{
					start,
					key,
					meta,
					kind: "method",
					isStatic: false,
					isGenerator: true,
					isAsync: false,
					isConstructor: false,
				},
			);
		}

		const escapePosition = parser.state.escapePosition;
		const {meta, key} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(
			parser,
			nameOpts,
		);

		// Regular method
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassMethod(
				parser,
			)
		) {
			// Private method
			if (key.value.type === "PrivateName") {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
					parser,
					{
						start,
						key: key.value,
						meta,
						isGenerator: false,
						isAsync: false,
						kind: "method",
					},
				);
			}

			const isConstructor = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(
				parser,
				key,
				meta,
			);

			let kind = "method";
			if (isConstructor) {
				kind = "constructor";

				// TypeScript allows multiple overloaded constructor declarations
				if (state.hadConstructor && !parser.isSyntaxEnabled("ts")) {
					parser.addDiagnostic({
						loc: key.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DUPLICATE_CLASS_CONSTRUCTOR,
					});
				}
				state.hadConstructor = true;
			}

			return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
				parser,
				{
					start,
					key,
					meta,
					kind,
					isStatic,
					isGenerator: false,
					isAsync: false,
					isConstructor,
				},
			);
		}

		// Class property
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isClassProperty(
				parser,
			)
		) {
			if (key.value.type === "PrivateName") {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(
					parser,
					start,
					key.value,
					meta,
				);
			} else {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$pushClassProperty(
					parser,
					start,
					key,
					meta,
				);
			}
		}

		// Async method
		if (
			key.value.type === "Identifier" &&
			key.value.name === "async" &&
			!parser.isLineTerminator()
		) {
			parser.banUnicodeEscape(escapePosition, "async");

			// an async method
			const isGenerator = parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			);

			// The so-called parsed name would have been "async": get the real name.
			const {meta, key} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(
				parser,
				nameOpts,
			);

			if (key.value.type === "PrivateName") {
				// private async method
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
					parser,
					{
						start,
						key: key.value,
						meta,
						isGenerator,
						isAsync: true,
						kind: "method",
					},
				);
			} else {
				const method = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
					parser,
					{
						start,
						key,
						meta,
						kind: "method",
						isStatic,
						isGenerator,
						isAsync: true,
						isConstructor: false,
					},
				);

				if (
					___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(
						parser,
						key,
						meta,
					)
				) {
					parser.addDiagnostic({
						loc: key.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ASYNC_CLASS_CONSTRUCTOR,
					});
				}

				return method;
			}
		}

		// Getter/setter method
		if (
			key.value.type === "Identifier" &&
			(key.value.name === "get" || key.value.name === "set") &&
			!(parser.isLineTerminator() &&
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			))
		) {
			// `get\n*` is an uninitialized property named 'get' followed by a generator.
			// a getter or setter
			const kind = key.value.name;
			parser.banUnicodeEscape(escapePosition, kind);

			// The so-called parsed name would have been "get/set": get the real name.
			const {meta, key: methodKey} = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(
				parser,
				nameOpts,
			);

			if (methodKey.value.type === "PrivateName") {
				// private getter/setter
				const method = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
					parser,
					{
						start,
						key: methodKey.value,
						meta,
						isGenerator: false,
						isAsync: false,
						kind,
					},
				);
				___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(
					parser,
					method,
					method.kind,
				);
				return method;
			} else {
				const method = ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
					parser,
					{
						start,
						key: methodKey,
						meta,
						kind,
						isStatic: false,
						isGenerator: false,
						isAsync: false,
						isConstructor: false,
					},
				);

				if (
					___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(
						parser,
						key,
						meta,
					)
				) {
					parser.addDiagnostic({
						loc: methodKey.loc,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.GET_SET_CLASS_CONSTRUCTOR,
					});
				}

				___R$project$rome$$romejs$js$parser$parser$expression_ts$checkGetterSetterParamCount(
					parser,
					method,
					method.kind,
				);
				return method;
			}
		}

		if (parser.isLineTerminator()) {
			// an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
			if (key.value.type === "PrivateName") {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(
					parser,
					start,
					key.value,
					meta,
				);
			} else {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$pushClassProperty(
					parser,
					start,
					key,
					meta,
				);
			}
		}

		parser.addDiagnostic({
			description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNKNOWN_CLASS_PROPERTY_START,
		});
		return undefined;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPropertyMeta(
		parser,
		opts,
	) {
		let typeAnnotation;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
		}

		const key = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseObjectPropertyKey(
			parser,
		);

		if (
			key.type === "StaticPropertyKey" &&
			opts.static === true &&
			key.value.type === "Identifier" &&
			key.value.name === "prototype"
		) {
			parser.addDiagnostic({
				loc: key.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.CLASS_STATIC_PROTOTYPE_PROPERTY,
			});
		}

		if (key.value.type === "PrivateName" && key.value.id.name === "constructor") {
			parser.addDiagnostic({
				loc: key.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.CLASS_PRIVATE_FIELD_NAMED_CONSTRUCTOR,
			});
		}

		let optional = false;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			)
		) {
			optional = true;
			parser.expectSyntaxEnabled("ts");
			parser.next();
		}

		return {
			key,
			meta: parser.finishNode(
				opts.start,
				Object.assign(
					{type: "ClassPropertyMeta", typeAnnotation, optional},
					opts,
				),
			),
		};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$pushClassProperty(
		parser,
		start,
		key,
		meta,
	) {
		// This only affects properties, not methods.
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$isNonstaticConstructor(
				parser,
				key,
				meta,
			)
		) {
			parser.addDiagnostic({
				loc: key.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.CLASS_PROPERTY_NAME_CONSTRUCTOR,
			});
		}

		return ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassProperty(
			parser,
			start,
			key,
			meta,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassMethod(
		parser,
		opts,
	) {
		const {start, key, meta, kind, isGenerator, isAsync, isConstructor} = opts;

		const typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
			parser,
		);

		const {head, body} = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
			parser,
			{
				kind,
				isClass: true,
				isGenerator,
				isAsync,
				isConstructor,
			},
		);

		const method = {
			head: Object.assign({}, head, {typeParameters}),
			loc: parser.finishLoc(start),
			kind,
			key,
			meta,
		};

		if (body === undefined) {
			return parser.finalizeNode(
				Object.assign({}, method, {type: "TSDeclareMethod", body: undefined}),
			);
		} else {
			if (body.type !== "BlockStatement") {
				throw new Error("Expected BlockStatement body");
			}

			if (key.value.type === "PrivateName") {
				throw new Error("Expected to hit other private methods instead");
			}

			return parser.finalizeNode(
				Object.assign({}, method, {body, type: "ClassMethod"}),
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateMethod(
		parser,
		opts,
	) {
		const {start, key, meta, isGenerator, isAsync, kind} = opts;

		const typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
			parser,
		);
		const method = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMethod(
			parser,
			{
				kind,
				isClass: true,
				isGenerator,
				isAsync,
				isConstructor: false,
			},
		);

		const {body} = method;
		if (body === undefined || body.type !== "BlockStatement") {
			throw new Error("Expected body");
		}

		return parser.finishNode(
			start,
			Object.assign(
				{},
				method,
				{
					body,
					meta,
					key,
					kind,
					type: "ClassPrivateMethod",
					head: Object.assign({}, method.head, {typeParameters}),
				},
			),
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassPrivateProperty(
		parser,
		start,
		key,
		meta,
	) {
		parser.pushScope("CLASS_PROPERTY", true);

		let typeAnnotation;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
		}

		const value = parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
		)
			? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
					parser,
					"class private property value",
				)
			: undefined;
		parser.semicolon();
		parser.popScope("CLASS_PROPERTY");

		return parser.finishNode(
			start,
			{
				meta,
				key,
				type: "ClassPrivateProperty",
				value,
				typeAnnotation,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassProperty(
		parser,
		start,
		key,
		meta,
	) {
		// TODO maybe parsing should be abstracted for private class properties too?
		let definite;
		if (
			!meta.optional &&
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang,
			)
		) {
			definite = true;
			parser.expectSyntaxEnabled("ts");
		}

		let typeAnnotation;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
			)
		) {
			typeAnnotation = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAnnotation(
				parser,
				true,
			);
		}

		parser.pushScope("CLASS_PROPERTY", true);

		let value;
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq,
			)
		) {
			parser.next();
			value = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
				parser,
				"class property value",
			);
		}
		parser.semicolon();

		parser.popScope("CLASS_PROPERTY");

		if (key.value.type === "PrivateName") {
			throw new Error(
				"PrivateName encountered in regular parseClassProperty, expects method is parsePrivateClassProperty",
			);
		}

		return parser.finishNode(
			start,
			{
				meta,
				key,
				type: "ClassProperty",
				definite,
				typeAnnotation,
				value,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassId(
		parser,
		optionalId,
	) {
		let idAllowed = true;

		// Allow `class implements Foo {}` in class expressions
		if (optionalId === true && parser.isContextual("implements")) {
			idAllowed = false;
		}

		let id;
		if (idAllowed) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
				)
			) {
				id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
					parser,
				);
			} else if (!optionalId) {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.REQUIRED_CLASS_NAME,
				});
				id = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					parser.createUnknownIdentifier("required class name"),
				);
			}
		}

		const typeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeParameters(
			parser,
		);
		return {id, typeParameters};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$classes_ts$parseClassSuper(
		parser,
	) {
		let superClass = parser.eat(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._extends,
		)
			? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionWithPossibleSubscripts(
					parser,
					"class heritage",
				)
			: undefined;
		let superTypeParameters;

		if (superClass !== undefined) {
			superTypeParameters = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$maybeParseTSTypeArguments(
				parser,
			);
		}

		let implemented;
		if (parser.isContextual("implements")) {
			parser.next();
			implemented = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSHeritageClause(
				parser,
				"implements",
			);
		}

		return {superClass, superTypeParameters, implemented};
	}


  // project-rome/@romejs/js-parser/parser/modules.ts
const ___R$project$rome$$romejs$js$parser$parser$modules_ts = {
		parseExport: ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseExport,
		parseImport: ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseImport,
		isMaybeDefaultImport: ___R$project$rome$$romejs$js$parser$parser$modules_ts$isMaybeDefaultImport,
		hasTypeImportKind: ___R$project$rome$$romejs$js$parser$parser$modules_ts$hasTypeImportKind,
	};


	function ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseExport(
		parser,
		start,
	) {
		const tsNode = ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExport(
			parser,
			start,
		);
		if (tsNode !== undefined) {
			return tsNode;
		}

		let exportKind = "value";
		let declaration;
		let localSpecifiers;

		// export * from '...'';
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseExportStar(
				parser,
			)
		) {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportStar(
				parser,
				start,
			);
		} else if (
			___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$isExportDefaultSpecifier(
				parser,
			)
		) {
			const defStart = parser.getPosition();
			const defExported = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);

			let namedSpecifiers = [];
			let defaultSpecifier = parser.finishNode(
				defStart,
				{
					type: "ExportDefaultSpecifier",
					exported: defExported,
				},
			);
			let namespaceSpecifier;

			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				) &&
				parser.lookaheadState().tokenType ===
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star
			) {
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				);
				const specifierStart = parser.getPosition();
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
				);
				parser.expectContextual("as");
				const exported = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
					parser,
				);
				namespaceSpecifier = parser.finishNode(
					specifierStart,
					{
						type: "ExportNamespaceSpecifier",
						exported,
					},
				);
			} else {
				namedSpecifiers = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(
					parser,
				);
			}

			const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFromExpect(
				parser,
			);
			return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$createExportExternalDeclaration(
				parser,
				start,
				defaultSpecifier,
				namespaceSpecifier,
				namedSpecifiers,
				source,
			);
		} else if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._default,
			)
		) {
			// export default ...
			const declaration = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportDefaultExpression(
				parser,
			);
			___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkExport(
				parser,
				{
					specifiers: localSpecifiers,
					declaration,
					isDefault: true,
				},
			);

			const node = parser.finishNode(
				start,
				{
					type: "ExportDefaultDeclaration",
					declaration,
				},
			);
			return node;
		} else if (
			___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseExportDeclaration(
				parser,
			)
		) {
			let source;
			({
				declaration,
				source,
				localSpecifiers,
				exportKind,
			} = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportDeclaration(
				parser,
			));

			if (source !== undefined) {
				if (declaration !== undefined) {
					throw new Error(
						"When there's a source we don't also expect a declaration",
					);
				}

				return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$createExportExternalDeclaration(
					parser,
					start,
					undefined,
					undefined,
					localSpecifiers === undefined ? [] : localSpecifiers,
					source,
					exportKind,
				);
			}
		} else if (
			parser.isContextual("async") &&
			!___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
				parser,
			)
		) {
			const next = parser.lookaheadState();

			parser.addDiagnostic({
				start: next.startPos,
				end: next.endPos,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPORT_ASYNC_NO_FUNCTION_KEYWORD,
			});
			declaration = undefined;
			localSpecifiers = [];
		} else {
			// export { x, y as z } [from '...']';
			localSpecifiers = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(
				parser,
			);

			const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(
				parser,
				false,
			);
			if (source !== undefined) {
				return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$createExportExternalDeclaration(
					parser,
					start,
					undefined,
					undefined,
					localSpecifiers,
					source,
				);
			}
		}

		___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkExport(
			parser,
			{
				specifiers: localSpecifiers,
				declaration,
				isDefault: false,
			},
		);

		if (declaration !== undefined) {
			if (
				declaration.type !== "VariableDeclarationStatement" &&
				declaration.type !== "ClassDeclaration" &&
				declaration.type !== "FunctionDeclaration" &&
				declaration.type !== "TSModuleDeclaration" &&
				declaration.type !== "TSEnumDeclaration" &&
				declaration.type !== "TypeAliasTypeAnnotation" &&
				declaration.type !== "TSInterfaceDeclaration" &&
				declaration.type !== "TSDeclareFunction"
			) {
				parser.addDiagnostic({
					loc: declaration.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_EXPORT_DECLARATION,
				});
				return declaration;
			}
		}

		const node = parser.finishNode(
			start,
			{
				type: "ExportLocalDeclaration",
				exportKind,
				specifiers: localSpecifiers,
				declaration,
			},
		);
		return node;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$createExportExternalDeclaration(
		parser,
		start,
		defaultSpecifier,
		namespaceSpecifier,
		namedSpecifiers,
		source,
		exportKind,
	) {
		___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkExport(
			parser,
			{
				specifiers: [defaultSpecifier, namespaceSpecifier, ...namedSpecifiers],
				declaration: undefined,
				isDefault: false,
				localIsExternal: true,
			},
		);

		const node = parser.finishNode(
			start,
			{
				type: "ExportExternalDeclaration",
				exportKind,
				source,
				namedSpecifiers: [],
				defaultSpecifier,
				namespaceSpecifier,
			},
		);

		// We convert the specifiers after we've finished the ExportExternalDeclaration node
		// as the comment attachment logic may mess with the specifiers and so we need to
		// clone them after
		return Object.assign(
			{},
			node,
			{
				namedSpecifiers: ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
					parser,
					namedSpecifiers,
				),
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
		parser,
		specifiers = [],
	) {
		return specifiers.map((specifier) => {
			return Object.assign(
				{},
				specifier,
				{
					type: "ExportExternalSpecifier",
					local: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toIdentifier(
						parser,
						specifier.local,
					),
				},
			);
		});
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportDefaultExpression(
		parser,
	) {
		if (parser.isSyntaxEnabled("ts")) {
			if (
				___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSAbstractClass(
					parser,
				)
			) {
				const start = parser.getPosition();
				parser.next(); // Skip 'abstract'
				return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSExportDefaultAbstractClass(
					parser,
					start,
				);
			}

			if (parser.state.tokenValue === "interface" && !parser.isLineTerminator()) {
				const start = parser.getPosition();
				parser.next();
				return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
					parser,
					start,
				);
			}
		}

		const start = parser.getPosition();
		const isAsync = ___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
			parser,
		);
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function,
			) ||
			isAsync
		) {
			if (isAsync) {
				parser.eatContextual("async");
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._function,
				);
			}

			return ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseExportDefaultFunctionDeclaration(
				parser,
				start,
				isAsync,
			);
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._class,
			)
		) {
			return ___R$project$rome$$romejs$js$parser$parser$classes_ts$parseExportDefaultClassDeclaration(
				parser,
				start,
			);
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var,
			) ||
			___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(parser)
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_EXPORT_DEFAULT,
			});
		}

		const res = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseMaybeAssign(
			parser,
			"export default declaration",
		);
		parser.semicolon();
		return res;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportDeclaration(
		parser,
	) {
		if (parser.isContextual("type")) {
			const start = parser.getPosition();
			parser.next();

			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
				)
			) {
				// export { foo, bar };
				const specifiers = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(
					parser,
				);
				const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(
					parser,
					false,
				);
				return {
					exportKind: "type",
					localSpecifiers: specifiers,
					source,
				};
			} else {
				// export type Foo = Bar;
				return {
					exportKind: "type",
					declaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSTypeAlias(
						parser,
						start,
					),
				};
			}
		}

		if (parser.isContextual("interface")) {
			const declarationNode = parser.getPosition();
			parser.next();
			return {
				exportKind: "type",
				declaration: ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSInterfaceDeclaration(
					parser,
					declarationNode,
				),
			};
		}

		return {
			exportKind: "value",
			declaration: ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseStatement(
				parser,
			),
		};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$isExportDefaultSpecifier(
		parser,
	) {
		// export Foo from "mod"
		// export Foo, {Bar} from "mod"
		const lookahead = parser.lookaheadState();
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			) &&
			(lookahead.tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma ||
			(lookahead.tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name &&
			lookahead.tokenValue === "from"))
		) {
			return true;
		}

		if (
			parser.isSyntaxEnabled("ts") &&
			___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(
				parser,
			)
		) {
			return false;
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			) &&
			(parser.state.tokenValue === "type" ||
			parser.state.tokenValue === "interface" ||
			parser.state.tokenValue === "opaque")
		) {
			return false;
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			)
		) {
			return (
				parser.state.tokenValue !== "async" && parser.state.tokenValue !== "let"
			);
		}

		if (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._default,
			)
		) {
			return false;
		}

		return false;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(
		parser,
	) {
		if (
			parser.eat(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
			)
		) {
			return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(
				parser,
			);
		} else {
			return [];
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFromExpect(
		parser,
	) {
		// @ts-ignore: `expect` parameter will always return a StringLiteral
		return ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(
			parser,
			true,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(
		parser,
		expect,
	) {
		let source;

		if (parser.eatContextual("from")) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
				)
			) {
				source = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);
			} else {
				const expr = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseExpressionAtom(
					parser,
					"export from",
				);

				parser.addDiagnostic({
					loc: expr.loc,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPORT_FROM_NOT_STRING,
				});

				source = {
					type: "StringLiteral",
					value: "",
					loc: expr.loc,
				};
			}
		} else if (expect) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPORT_MISSING_FROM,
			});

			source = {
				type: "StringLiteral",
				value: "",
				loc: parser.finishLoc(parser.getPosition()),
			};
		}

		parser.semicolon();

		return source;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseExportStar(
		parser,
	) {
		return (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			) ||
			(parser.isContextual("type") &&
			parser.lookaheadState().tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportStar(
		parser,
		start,
	) {
		let exportKind;
		if (parser.eatContextual("type")) {
			exportKind = "type";
		}

		parser.expect(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
		);

		if (parser.isContextual("as")) {
			const {source, namespaceSpecifier, namedSpecifiers} = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportNamespace(
				parser,
				exportKind,
			);
			return parser.finishNode(
				start,
				{
					type: "ExportExternalDeclaration",
					namespaceSpecifier,
					exportKind,
					namedSpecifiers,
					source,
				},
			);
		} else {
			const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFrom(
				parser,
				true,
			);
			if (source === undefined) {
				throw new Error(
					"Passed `true` above which expects there to be a string",
				);
			}
			return parser.finishNode(
				start,
				{
					type: "ExportAllDeclaration",
					exportKind,
					source,
				},
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportNamespace(
		parser,
		exportKind,
	) {
		if (exportKind === "type") {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPORT_TYPE_NAMESPACE,
			});
		}

		const specifierStart = parser.state.lastStartPos;
		parser.next();
		const exported = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);

		const namespaceSpecifier = parser.finishNode(
			specifierStart,
			{
				type: "ExportNamespaceSpecifier",
				exported,
			},
		);

		const namedSpecifiers = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$convertLocalToExternalSpecifiers(
			parser,
			___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportLocalSpecifiersMaybe(
				parser,
			),
		);

		const source = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportFromExpect(
			parser,
		);
		return {source, namespaceSpecifier, namedSpecifiers};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseExportDeclaration(
		parser,
	) {
		return (
			___R$project$rome$$romejs$js$parser$parser$typescript_ts$isTSDeclarationStart(
				parser,
			) ||
			parser.isContextual("type") ||
			parser.isContextual("interface") ||
			parser.isContextual("opaque") ||
			parser.state.tokenType.keyword === "var" ||
			parser.state.tokenType.keyword === "const" ||
			parser.state.tokenType.keyword === "function" ||
			parser.state.tokenType.keyword === "class" ||
			___R$project$rome$$romejs$js$parser$parser$statement_ts$isLetStart(parser) ||
			___R$project$rome$$romejs$js$parser$parser$statement_ts$isAsyncFunctionDeclarationStart(
				parser,
			) ||
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.at,
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkExport(
		parser,
		{
			specifiers,
			declaration,
			localIsExternal = false,
			isDefault = false,
		},
	) {
		// Check for duplicate exports
		if (isDefault) {
			// Default exports
			if (declaration !== undefined) {
				___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(
					parser,
					declaration,
					"default",
				);
			}
			return undefined;
		}

		if (declaration !== undefined) {
			// Exported declarations
			if (declaration.type === "FunctionDeclaration") {
				if (declaration.id === undefined) {
					throw new Error("Expected declaration.id");
				}

				___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(
					parser,
					declaration,
					declaration.id.name,
				);
			}

			if (declaration.type === "ClassDeclaration") {
				if (declaration.id === undefined) {
					throw new Error("Expected declaration.id");
				}

				___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(
					parser,
					declaration,
					declaration.id.name,
				);
			}

			if (declaration.type === "VariableDeclaration") {
				for (const node of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
					declaration,
				)) {
					___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(
						parser,
						node,
						node.name,
					);
				}
			}
		}

		if (specifiers !== undefined) {
			// Named exports
			for (const specifier of specifiers) {
				if (specifier === undefined) {
					continue;
				}

				___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(
					parser,
					specifier,
					specifier.exported.name,
				);

				if (specifier.type === "ExportLocalSpecifier" && !localIsExternal) {
					const {local} = specifier;
					if (local !== undefined) {
						// check for keywords used as local names
						___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
							parser,
							local.name,
							parser.getLoc(local),
							true,
							false,
						);
					}
				}
			}
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$checkDuplicateExports(
		parser,
		node,
		name,
	) {
		if (parser.isSyntaxEnabled("ts")) {
			// Refer to checkReservedWord for an explanation
			return undefined;
		}

		const existing = parser.state.exportedIdentifiers.get(name);
		if (existing !== undefined) {
			parser.addDiagnostic({
				loc: node.loc,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DUPLICATE_EXPORT(
					name,
					existing,
				),
			});
		}

		parser.state.exportedIdentifiers.set(name, parser.getLoc(node));
	}

	// Parses a comma-separated list of module exports.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseExportSpecifiers(
		parser,
	) {
		const specifiers = [];
		let first = true;

		// export { x, y as z } [from '...']';
		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"export specifiers",
		);

		while (true) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				parser.expectClosing(openContext);
				break;
			}

			if (first) {
				first = false;
			} else {
				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				);
				if (
					parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					break;
				}
			}

			const start = parser.getPosition();
			const local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseReferenceIdentifier(
				parser,
				true,
			);
			const exported = parser.eatContextual("as")
				? ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
						parser,
						true,
					)
				: ___R$project$rome$$romejs$js$parser$parser$expression_ts$toIdentifier(
						parser,
						parser.cloneNode(local),
					);
			specifiers.push(
				parser.finishNode(
					start,
					{
						type: "ExportLocalSpecifier",
						local,
						exported,
						// TODO exportKind?
					},
				),
			);
		}

		return specifiers;
	}



	function ___R$project$rome$$romejs$js$parser$parser$modules_ts$parseImport(
		parser,
		start,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			) &&
			parser.lookaheadState().tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq
		) {
			return ___R$project$rome$$romejs$js$parser$parser$typescript_ts$parseTSImportEqualsDeclaration(
				parser,
				start,
			);
		}

		let namedSpecifiers = [];
		let namespaceSpecifier;
		let defaultSpecifier;
		let source;
		let importKind;

		// import '...'
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			source = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
				parser,
			);
		} else {
			({
				namedSpecifiers,
				namespaceSpecifier,
				defaultSpecifier,
				importKind,
			} = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifiers(
				parser,
				start,
			));

			if (
				parser.expectContextual("from") &&
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
				)
			) {
				source = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseStringLiteral(
					parser,
				);
			} else {
				parser.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_MISSING_SOURCE,
				});

				source = parser.finishNode(
					start,
					{
						type: "StringLiteral",
						value: "",
					},
				);
			}
		}

		parser.semicolon();
		return parser.finishNode(
			start,
			{
				type: "ImportDeclaration",
				namedSpecifiers,
				namespaceSpecifier,
				defaultSpecifier,
				source,
				importKind,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseDefaultImport(
		parser,
		kind,
	) {
		if (
			___R$project$rome$$romejs$js$parser$parser$modules_ts$hasTypeImportKind(
				kind,
			)
		) {
			return ___R$project$rome$$romejs$js$parser$parser$modules_ts$isMaybeDefaultImport(
				parser.state,
			);
		} else {
			return parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			);
		}
	}

	function ___R$project$rome$$romejs$js$parser$parser$modules_ts$isMaybeDefaultImport(
		state,
	) {
		return (
			(state.tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name ||
			!!state.tokenType.keyword) &&
			state.tokenValue !== "from"
		);
	}

	function ___R$project$rome$$romejs$js$parser$parser$modules_ts$hasTypeImportKind(
		kind,
	) {
		return kind === "type" || kind === "typeof";
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(
		parser,
		importKind,
		contextDescription,
	) {
		const start = parser.getPosition();

		const local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
			parser,
		);

		___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
			parser,
			local,
			true,
			undefined,
			contextDescription,
		);

		return parser.finishNode(
			start,
			{
				type: "ImportSpecifierLocal",
				name: local,
				importKind,
			},
		);
	}

	// Parses a comma-separated list of module imports.
	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifiers(
		parser,
		start,
	) {
		let importKind = undefined;

		// Ensure that when parsing `import from './type.js` we don't mistakenly think it's an import type';

		// TODO probably need to check for a comma and `as`
		const lh = parser.lookaheadState();
		if (
			lh.tokenType !==
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name ||
			(lh.tokenType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name &&
			lh.tokenValue !== "from")
		) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._typeof,
				)
			) {
				importKind = "typeof";
			} else if (parser.isContextual("type")) {
				importKind = "type";
			}
		}

		if (importKind) {
			if (
				importKind === "type" &&
				lh.tokenType ===
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star
			) {
				parser.addDiagnostic({
					start: lh.startPos,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_TYPE_STAR,
				});
			}

			if (
				___R$project$rome$$romejs$js$parser$parser$modules_ts$isMaybeDefaultImport(
					lh,
				) ||
				lh.tokenType ===
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL ||
				lh.tokenType ===
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star
			) {
				parser.next();
			}
		}

		let namedSpecifiers = [];
		let namespaceSpecifier;
		let defaultSpecifier;

		let first = true;

		// import defaultObj, { x, y as z } from '...'';
		if (
			___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$shouldParseDefaultImport(
				parser,
				importKind,
			)
		) {
			const meta = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(
				parser,
				importKind,
				"default import specifier",
			);

			defaultSpecifier = parser.finishNode(
				start,
				{
					type: "ImportDefaultSpecifier",
					local: meta,
				},
			);

			if (
				!parser.eat(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				)
			) {
				return {
					namedSpecifiers,
					namespaceSpecifier,
					defaultSpecifier,
					importKind,
				};
			}
		}

		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star,
			)
		) {
			parser.next();
			parser.expectContextual("as");

			const meta = ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifierLocal(
				parser,
				importKind,
				"import namespace specifier",
			);

			namespaceSpecifier = parser.finishNode(
				start,
				{
					type: "ImportNamespaceSpecifier",
					local: meta,
				},
			);

			return {namedSpecifiers, namespaceSpecifier, defaultSpecifier, importKind};
		}

		const openContext = parser.expectOpening(
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
			"import specifiers",
		);

		while (true) {
			if (
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				) ||
				parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				)
			) {
				parser.expectClosing(openContext);
				break;
			}

			if (first) {
				first = false;
			} else {
				// Detect an attempt to deep destructure
				if (
					parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
					)
				) {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DESTRUCTURING_IN_IMPORT,
					});
				}

				parser.expect(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				);

				if (
					parser.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					)
				) {
					break;
				}
			}

			namedSpecifiers.push(
				___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifier(
					parser,
					importKind,
				),
			);
		}

		return {namedSpecifiers, namespaceSpecifier, defaultSpecifier, importKind};
	}

	function ___R$$priv$project$rome$$romejs$js$parser$parser$modules_ts$parseImportSpecifier(
		parser,
		nodeKind,
	) {
		const start = parser.getPosition();
		const firstIdentPos = parser.state.startPos;
		const firstIdent = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
			parser,
			true,
		);

		let imported;
		let local;
		let importKind = undefined;
		if (firstIdent.name === "type") {
			importKind = "type";
		} else if (firstIdent.name === "typeof") {
			importKind = "typeof";
		}

		let isBinding = false;
		if (parser.isContextual("as") && !parser.isLookaheadContextual("as")) {
			const asIdent = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);
			if (
				importKind !== undefined &&
				!parser.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
				) &&
				parser.state.tokenType.keyword === undefined
			) {
				// `import {type as ,` or `import {type as }`
				imported = asIdent;
				local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					parser.cloneNode(asIdent),
				);
			} else {
				// `import {type as foo`
				imported = firstIdent;
				importKind = undefined;
				local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
					parser,
				);
			}
		} else if (
			importKind !== undefined &&
			(parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
			) ||
			parser.state.tokenType.keyword)
		) {
			// `import {type foo`
			imported = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseIdentifier(
				parser,
				true,
			);
			if (parser.eatContextual("as")) {
				local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$parseBindingIdentifier(
					parser,
				);
			} else {
				isBinding = true;
				local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
					parser,
					parser.cloneNode(imported),
				);
			}
		} else {
			isBinding = true;
			imported = firstIdent;
			importKind = undefined;
			local = ___R$project$rome$$romejs$js$parser$parser$expression_ts$toBindingIdentifier(
				parser,
				parser.cloneNode(imported),
			);
		}

		const nodeIsTypeImport = ___R$project$rome$$romejs$js$parser$parser$modules_ts$hasTypeImportKind(
			nodeKind,
		);
		const specifierIsTypeImport = ___R$project$rome$$romejs$js$parser$parser$modules_ts$hasTypeImportKind(
			importKind,
		);

		if (nodeIsTypeImport && specifierIsTypeImport) {
			parser.addDiagnostic({
				start: firstIdentPos,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IMPORT_KIND_SPECIFIER_ON_IMPORT_DECLARATION_WITH_KIND,
			});
		}

		const loc = parser.finishLoc(start);

		if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
			___R$project$rome$$romejs$js$parser$parser$expression_ts$checkReservedWord(
				parser,
				local.name,
				loc,
				true,
				true,
			);
		}

		___R$project$rome$$romejs$js$parser$parser$lval_ts$checkLVal(
			parser,
			local,
			true,
			undefined,
			"import specifier",
		);

		return parser.finishNode(
			start,
			{
				type: "ImportSpecifier",
				imported,
				local: parser.finishNode(
					start,
					{
						type: "ImportSpecifierLocal",
						name: local,
						importKind,
					},
				),
			},
		);
	}


  // project-rome/@romejs/js-parser/parser/index.ts



  // project-rome/@romejs/js-parser/tokenizer/unicodeMistakes.ts
const ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES = new Map();

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u07fa",
		["Nko Lajanyalan", "_"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe4d",
		["Dashed Low Line", "_"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe4e",
		["Centreline Low Line", "_"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe4f",
		["Wavy Low Line", "_"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff3f",
		["Fullwidth Low Line", "_"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2010",
		["Hyphen", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2011",
		["Non-Breaking Hyphen", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2012",
		["Figure Dash", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2013",
		["En Dash", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2014",
		["Em Dash", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe58",
		["Small Em Dash", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u06d4",
		["Arabic Full Stop", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2043",
		["Hyphen Bullet", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02d7",
		["Modifier Letter Minus Sign", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2212",
		["Minus Sign", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2796",
		["Heavy Minus Sign", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2cba",
		["Coptic Letter Dialect-P Ni", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30fc",
		["Katakana-Hiragana Prolonged Sound Mark", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0d",
		["Fullwidth Hyphen-Minus", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2015",
		["Horizontal Bar", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2500",
		["Box Drawings Light Horizontal", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2501",
		["Box Drawings Heavy Horizontal", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u31d0",
		["CJK Stroke H", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua7f7",
		["Latin Epigraphic Letter Dideways", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1173",
		["Hangul Jungseong Eu", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3161",
		["Hangul Letter Eu", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u4e00",
		["CJK Unified Ideograph-4E00", "-"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2f00",
		["Kangxi Radical One", "-"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u060d",
		["Arabic Date Separator", ","],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u066b",
		["Arabic Decimal Separator", ","],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201a",
		["Single Low-9 Quotation Mark", ","],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\xb8",
		["Cedilla", ","],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua4f9",
		["Lisu Letter Tone Na Po", ","],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0c",
		["Fullwidth Comma", ","],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u037e",
		["Greek Question Mark", ";"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1b",
		["Fullwidth Semicolon", ";"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe14",
		["Presentation Form For Vertical Semicolon", ";"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0903",
		["Devanagari Sign Visarga", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0a83",
		["Gujarati Sign Visarga", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1a",
		["Fullwidth Colon", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0589",
		["Armenian Full Stop", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0703",
		["Syriac Supralinear Colon", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0704",
		["Syriac Sublinear Colon", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16ec",
		["Runic Multiple Punctuation", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe30",
		["Presentation Form For Vertical Two Dot Leader", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1803",
		["Mongolian Full Stop", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1809",
		["Mongolian Manchu Full Stop", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u205a",
		["Two Dot Punctuation", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05c3",
		["Hebrew Punctuation Sof Pasuq", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02f8",
		["Modifier Letter Raised Colon", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua789",
		["Modifier Letter Colon", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2236",
		["Ratio", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02d0",
		["Modifier Letter Triangular Colon", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua4fd",
		["Lisu Letter Tone Mya Jeu", ":"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe13",
		["Presentation Form For Vertical Colon", ":"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff01",
		["Fullwidth Exclamation Mark", "!"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u01c3",
		["Latin Letter Retroflex Click", "!"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2d51",
		["Tifinagh Letter Tuareg Yang", "!"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe15",
		["Presentation Form For Vertical Exclamation Mark", "!"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0294",
		["Latin Letter Glottal Stop", "?"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0241",
		["Latin Capital Letter Glottal Stop", "?"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u097d",
		["Devanagari Letter Glottal Stop", "?"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u13ae",
		["Cherokee Letter He", "?"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua6eb",
		["Bamum Letter Ntuu", "?"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1f",
		["Fullwidth Question Mark", "?"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe16",
		["Presentation Form For Vertical Question Mark", "?"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d16d}",
		["Musical Symbol Combining Augmentation Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2024",
		["One Dot Leader", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0701",
		["Syriac Supralinear Full Stop", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0702",
		["Syriac Sublinear Full Stop", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua60e",
		["Vai Full Stop", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{10a50}",
		["Kharoshthi Punctuation Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0660",
		["Arabic-Indic Digit Zero", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u06f0",
		["Extended Arabic-Indic Digit Zero", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua4f8",
		["Lisu Letter Tone Mya Ti", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\xb7",
		["Middle Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30fb",
		["Katakana Middle Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff65",
		["Halfwidth Katakana Middle Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16eb",
		["Runic Single Punctuation", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0387",
		["Greek Ano Teleia", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2e31",
		["Word Separator Middle Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{10101}",
		["Aegean Word Separator Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2022",
		["Bullet", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2027",
		["Hyphenation Point", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2219",
		["Bullet Operator", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u22c5",
		["Dot Operator", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua78f",
		["Latin Letter Sinological Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1427",
		["Canadian Syllabics Final Middle Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1427",
		["Canadian Syllabics Final Middle Dot", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0e",
		["Fullwidth Full Stop", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3002",
		["Ideographic Full Stop", "."],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe12",
		["Presentation Form For Vertical Ideographic Full Stop", "."],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u055d",
		["Armenian Comma", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff07",
		["Fullwidth Apostrophe", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2018",
		["Left Single Quotation Mark", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2019",
		["Right Single Quotation Mark", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201b",
		["Single High-Reversed-9 Quotation Mark", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2032",
		["Prime", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2035",
		["Reversed Prime", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u055a",
		["Armenian Apostrophe", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05f3",
		["Hebrew Punctuation Geresh", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"`",
		["Grave Accent", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1fef",
		["Greek Varia", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff40",
		["Fullwidth Grave Accent", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\xb4",
		["Acute Accent", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0384",
		["Greek Tonos", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1ffd",
		["Greek Oxia", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1fbd",
		["Greek Koronis", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1fbf",
		["Greek Psili", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1ffe",
		["Greek Dasia", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02b9",
		["Modifier Letter Prime", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u0374",
		["Greek Numeral Sign", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02c8",
		["Modifier Letter Vertical Line", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02ca",
		["Modifier Letter Acute Accent", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02cb",
		["Modifier Letter Grave Accent", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02f4",
		["Modifier Letter Middle Grave Accent", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02bb",
		["Modifier Letter Turned Comma", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02bd",
		["Modifier Letter Reversed Comma", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02bc",
		["Modifier Letter Apostrophe", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02be",
		["Modifier Letter Right Half Ring", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua78c",
		["Latin Small Letter Saltillo", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05d9",
		["Hebrew Letter Yod", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u07f4",
		["Nko High Tone Apostrophe", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u07f5",
		["Nko Low Tone Apostrophe", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u144a",
		["Canadian Syllabics West-Cree P", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16cc",
		["Runic Letter Short-Twig-Sol S", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{16f51}",
		["Miao Sign Aspiration", "'"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{16f52}",
		["Miao Sign Reformed Voicing", "'"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1cd3",
		["Vedic Sign Nihshvasa", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff02",
		["Fullwidth Quotation Mark", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201c",
		["Left Double Quotation Mark", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201d",
		["Right Double Quotation Mark", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u201f",
		["Double High-Reversed-9 Quotation Mark", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2033",
		["Double Prime", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2036",
		["Reversed Double Prime", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3003",
		["Ditto Mark", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05f4",
		["Hebrew Punctuation Gershayim", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02dd",
		["Double Acute Accent", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02ba",
		["Modifier Letter Double Prime", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02f6",
		["Modifier Letter Middle Double Acute Accent", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02f5",
		["Modifier Letter Middle Double Grave Accent", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02ee",
		["Modifier Letter Double Apostrophe", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u05f2",
		["Hebrew Ligature Yiddish Double Yod", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u275e",
		["Heavy Double Comma Quotation Mark Ornament", '"'],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u275d",
		["Heavy Double Turned Comma Quotation Mark Ornament", '"'],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff08",
		["Fullwidth Left Parenthesis", "("],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2768",
		["Medium Left Parenthesis Ornament", "("],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufd3e",
		["Ornate Left Parenthesis", "("],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff09",
		["Fullwidth Right Parenthesis", ")"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2769",
		["Medium Right Parenthesis Ornament", ")"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufd3f",
		["Ornate Right Parenthesis", ")"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff3b",
		["Fullwidth Left Square Bracket", "["],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2772",
		["Light Left Tortoise Shell Bracket Ornament", "["],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300c",
		["Left Corner Bracket", "["],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300e",
		["Left White Corner Bracket", "["],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3010",
		["Left Black Lenticular Bracket", "["],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3014",
		["Left Tortoise Shell Bracket", "["],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3016",
		["Left White Lenticular Bracket", "["],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3018",
		["Left White Tortoise Shell Bracket", "["],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u301a",
		["Left White Square Bracket", "["],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff3d",
		["Fullwidth Right Square Bracket", "]"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2773",
		["Light Right Tortoise Shell Bracket Ornament", "]"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300d",
		["Right Corner Bracket", "]"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300f",
		["Right White Corner Bracket", "]"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3011",
		["Right Black Lenticular Bracket", "]"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3015",
		["Right Tortoise Shell Bracket", "]"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3017",
		["Right White Lenticular Bracket", "]"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3019",
		["Right White Tortoise Shell Bracket", "]"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u301b",
		["Right White Square Bracket", "]"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2774",
		["Medium Left Curly Bracket Ornament", "{"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d114}",
		["Musical Symbol Brace", "{"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff5b",
		["Fullwidth Left Curly Bracket", "{"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2775",
		["Medium Right Curly Bracket Ornament", "}"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff5d",
		["Fullwidth Right Curly Bracket", "}"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u204e",
		["Low Asterisk", "*"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u066d",
		["Arabic Five Pointed Star", "*"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2217",
		["Asterisk Operator", "*"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1031f}",
		["Old Italic Letter Ess", "*"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0a",
		["Fullwidth Asterisk", "*"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1735",
		["Philippine Single Punctuation", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2041",
		["Caret Insertion Point", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2215",
		["Division Slash", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2044",
		["Fraction Slash", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2571",
		["Box Drawings Light Diagonal Upper Right To Lower Left", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u27cb",
		["Mathematical Rising Diagonal", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f8",
		["Big Solidus", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d23a}",
		["Greek Instrumental Notation Symbol-47", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u31d3",
		["CJK Stroke Sp", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3033",
		["Vertical Kana Repeat Mark Upper Half", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2cc6",
		["Coptic Capital Letter Old Coptic Esh", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30ce",
		["Katakana Letter No", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u4e3f",
		["CJK Unified Ideograph-4E3F", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2f03",
		["Kangxi Radical Slash", "/"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0f",
		["Fullwidth Solidus", "/"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff3c",
		["Fullwidth Reverse Solidus", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufe68",
		["Small Reverse Solidus", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2216",
		["Set Minus", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u27cd",
		["Mathematical Falling Diagonal", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f5",
		["Reverse Solidus Operator", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f9",
		["Big Reverse Solidus", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f9",
		["Greek Vocal Notation Symbol-16", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u29f9",
		["Greek Instrumental Symbol-48", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u31d4",
		["CJK Stroke D", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u4e36",
		["CJK Unified Ideograph-4E36", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2f02",
		["Kangxi Radical Dot", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3001",
		["Ideographic Comma", "\\"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30fd",
		["Katakana Iteration Mark", "\\"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua778",
		["Latin Small Letter Um", "&"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff06",
		["Fullwidth Ampersand", "&"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16ed",
		["Runic Cross Punctuation", "+"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2795",
		["Heavy Plus Sign", "+"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1029b}",
		["Lycian Letter H", "+"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ufb29",
		["Hebrew Letter Alternative Plus Sign", "+"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff0b",
		["Fullwidth Plus Sign", "+"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2039",
		["Single Left-Pointing Angle Quotation Mark", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u276e",
		["Heavy Left-Pointing Angle Quotation Mark Ornament", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02c2",
		["Modifier Letter Left Arrowhead", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d236}",
		["Greek Instrumental Symbol-40", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1438",
		["Canadian Syllabics Pa", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u16b2",
		["Runic Letter Kauna", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u276c",
		["Medium Left-Pointing Angle Bracket Ornament", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u27e8",
		["Mathematical Left Angle Bracket", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2329",
		["Left-Pointing Angle Bracket", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3008",
		["Left Angle Bracket", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u31db",
		["CJK Stroke Pd", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u304f",
		["Hiragana Letter Ku", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{21fe8}",
		["CJK Unified Ideograph-21FE8", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300a",
		["Left Double Angle Bracket", "<"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1c",
		["Fullwidth Less-Than Sign", "<"],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1400",
		["Canadian Syllabics Hyphen", "="],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u2e40",
		["Double Hyphen", "="],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u30a0",
		["Katakana-Hiragana Double Hyphen", "="],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\ua4ff",
		["Lisu Punctuation Full Stop", "="],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1d",
		["Fullwidth Equals Sign", "="],
	);

	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u203a",
		["Single Right-Pointing Angle Quotation Mark", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u276f",
		["Heavy Right-Pointing Angle Quotation Mark Ornament", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u02c3",
		["Modifier Letter Right Arrowhead", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{1d237}",
		["Greek Instrumental Symbol-42", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u1433",
		["Canadian Syllabics Po", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u{16f3f}",
		["Miao Letter Archaic Zza", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u276d",
		["Medium Right-Pointing Angle Bracket Ornament", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u27e9",
		["Mathematical Right Angle Bracket", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u232a",
		["Right-Pointing Angle Bracket", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u3009",
		["Right Angle Bracket", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\u300b",
		["Right Double Angle Bracket", ">"],
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.set(
		"\uff1e",
		["Fullwidth Greater-Than Sign", ">"],
	);

	const ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES = new Map();
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		" ",
		"Space",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"_",
		"Underscore",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"-",
		"Minus/Hyphen",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		",",
		"Comma",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		";",
		"Semicolon",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		":",
		"Colon",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"!",
		"Exclamation Mark",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"?",
		"Question Mark",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		".",
		"Period",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"'",
		"Single Quote",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		'"',
		"Quotation Mark",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"(",
		"Left Parenthesis",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		")",
		"Right Parenthesis",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"[",
		"Left Square Bracket",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"]",
		"Right Square Bracket",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"{",
		"Left Curly Brace",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"}",
		"Right Curly Brace",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"*",
		"Asterisk",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"/",
		"Slash",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"\\",
		"Backslash",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"&",
		"Ampersand",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"+",
		"Plus Sign",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"<",
		"Less-Than Sign",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		"=",
		"Equals Sign",
	);
	___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.set(
		">",
		"Greater-Than Sign",
	);


  // project-rome/@romejs/js-parser/tokenizer/index.ts
const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$HEX_NUMBER = /^[\da-fA-F]+$/;
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$DECIMAL_NUMBER = /^\d+$/;

	// The following character codes are forbidden from 'being
	// an immediate sibling of NumericLiteralSeparator _
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings = {
		decBinOct: [
			___R$project$rome$$romejs$string$charcodes$index_ts.dot,
			___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseB,
			___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseE,
			___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseO,
			___R$project$rome$$romejs$string$charcodes$index_ts.underscore,
			// multiple separators are not allowed
			___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseB,
			___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseE,
			___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseO,
		],
		hex: [
			___R$project$rome$$romejs$string$charcodes$index_ts.dot,
			___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseX,
			___R$project$rome$$romejs$string$charcodes$index_ts.underscore,
			// multiple separators are not allowed
			___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseX,
		],
	};

	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin = [
		// 0 - 1
		___R$project$rome$$romejs$string$charcodes$index_ts.digit0,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit1,
	];
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct = [
		// 0 - 7
		...___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit2,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit3,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit4,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit5,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit6,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit7,
	];
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec = [
		// 0 - 9
		...___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit8,
		___R$project$rome$$romejs$string$charcodes$index_ts.digit9,
	];

	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex = [
		// 0 - 9, A - F, a - f,
		...___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec,
		___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseA,
		___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseB,
		___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseC,
		___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseD,
		___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseE,
		___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseF,
		___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseA,
		___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseB,
		___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseC,
		___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseD,
		___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseE,
		___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseF,
	];
	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings = {
		bin: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsBin,
		oct: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsOct,
		dec: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsDec,
		hex: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblingsHex,
	};

	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.


	class ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue {
		constructor(pattern, flags) {
			this.pattern = pattern;
			this.flags = flags;
		}
	}

	class ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$NumberTokenValue {
		constructor(value, format) {
			this.value = value;
			this.format = format;
		}
	}

	// ## Tokenizer
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
		parser,
	) {
		const index = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
			parser.state.index,
		);
		parser.state.index = index;
		return index;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
		parser,
	) {
		return ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(parser.state.index);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$codePointToString(
		code,
	) {
		// UTF-16 Decoding
		if (code <= 65_535) {
			return String.fromCharCode(code);
		} else {
			return String.fromCharCode(
				(code - 65_536 >> 10) + 55_296,
				(code - 65_536 & 1_023) + 56_320,
			);
		}
	}

	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).
	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$setStrict(
		parser,
		isStrict,
	) {
		parser.pushScope("STRICT", isStrict);

		if (
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num,
			) &&
			!parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
			)
		) {
			return undefined;
		}

		parser.state.index = parser.state.startPos.index;
		while (parser.state.index < parser.state.lineStartIndex) {
			parser.state.lineStartIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
				parser.input.lastIndexOf(
					"\n",
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						parser.state.lineStartIndex,
					) - 2,
				) + 1,
			);
			parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
				parser.state.curLine,
			);
		}
		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
	}

	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
		parser,
	) {
		return parser.state.context[parser.state.context.length - 1];
	}

	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(
		parser,
	) {
		const curContext = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
			parser,
		);

		if (!curContext || !curContext.preserveSpace) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipSpace(
				parser,
			);
		}

		parser.state.containsOctal = false;
		parser.state.octalPosition = undefined;
		parser.state.startPos = parser.getPositionFromState();

		if (parser.state.index >= parser.length) {
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
			);
			return undefined;
		}

		if (curContext !== undefined && curContext.override) {
			curContext.override(parser);
		} else {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken(
				parser,
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(
					parser,
				),
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readToken(
		parser,
		code,
	) {
		const matchedJSX = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readJSXToken(
			parser,
			code,
		);
		if (matchedJSX) {
			return undefined;
		} else {
			return ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNormalToken(
				parser,
				code,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readJSXToken(
		parser,
		code,
	) {
		if (parser.inScope("PROPERTY_NAME")) {
			return false;
		}

		if (parser.inScope("TYPE")) {
			return false;
		}

		if (!parser.shouldTokenizeJSX()) {
			return false;
		}

		const context = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
			parser,
		);

		if (
			context ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxInner
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsx(
				parser,
			);
			return true;
		}

		if (
			context ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag ||
			context ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag
		) {
			if (
				___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(
					code,
				)
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxWord(
					parser,
				);
				return true;
			}

			if (
				code ===
				___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagEnd,
				);
				return true;
			}

			if (
				(code ===
				___R$project$rome$$romejs$string$charcodes$index_ts.quotationMark ||
				code === ___R$project$rome$$romejs$string$charcodes$index_ts.apostrophe) &&
				context ===
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxString(
					parser,
					code,
				);
				return true;
			}
		}

		if (
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan &&
			parser.state.exprAllowed &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 1,
			) !== ___R$project$rome$$romejs$string$charcodes$index_ts.exclamationMark
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart,
			);
			return true;
		}

		return false;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNormalToken(
		parser,
		code,
	) {
		// Identifier or keyword. '\uXXXX' sequences are allowed in
		// identifiers, so '\' also dispatches to that.
		if (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(
				code,
			) ||
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.backslash
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord(
				parser,
			);
		} else {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(
				parser,
				code,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(
		parser,
	) {
		return ___R$project$rome$$romejs$js$parser$utils$identifier_ts$getFullCharCodeAt(
			parser.input,
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$pushComment(
		parser,
		opts,
	) {
		const loc = parser.finishLocAt(opts.startPos, opts.endPos);
		let comment;
		if (opts.block) {
			comment = parser.comments.addComment({
				type: "CommentBlock",
				value: ___R$project$rome$$romejs$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
					opts.text,
				),
				loc,
			});
		} else {
			comment = parser.comments.addComment({
				type: "CommentLine",
				value: opts.text,
				loc,
			});
		}

		// We should enable jsx syntax when there's a comment with @\jsx
		if (opts.text.includes("@jsx")) {
			parser.syntax.add("jsx");
		}

		if (parser.isLookahead === false) {
			parser.state.comments.push(comment);
			___R$project$rome$$romejs$js$parser$parser$comments_ts$addComment(
				parser,
				comment,
			);
		}

		if (parser.shouldCreateToken()) {
			/*parser.pushToken({
      type: tt.comment,
      loc,
    });*/
		}

		return comment;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipBlockComment(
		parser,
	) {
		const startPos = parser.getPositionFromState();
		const startIndex = parser.state.index;
		parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
			parser.state.index,
			2,
		);

		const endIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
			parser.input.indexOf(
				"*/",
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			),
		);

		if (endIndex === ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1) {
			parser.addDiagnostic({
				end: parser.getPositionFromIndex(
					___R$project$rome$$romejs$ob1$index_ts$ob1Sub(parser.state.index, 2),
				),
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNTERMINATED_BLOCK_COMMENT,
			});
			return undefined;
		}

		// Skip */
		parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
			endIndex,
			2,
		);

		___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreakG.lastIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
			startIndex,
		);

		let match;
		while (
			(match = ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreakG.exec(
				parser.input,
			)) &&
			match.index <
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(parser.state.index)
		) {
			parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
				parser.state.curLine,
			);
			parser.resetTokenizerLine();
			parser.state.lineStartIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
				match.index + match[0].length,
			);
		}

		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$pushComment(
			parser,
			{
				block: true,
				text: parser.getRawInput(
					___R$project$rome$$romejs$ob1$index_ts$ob1Add(startIndex, 2),
					endIndex,
				),
				startPos,
				endPos: parser.getPositionFromState(),
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$parseLineComment(
		parser,
		startSkip,
	) {
		const startIndex = parser.state.index;
		const startPos = parser.getPositionFromState();
		parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
			parser.state.index,
			startSkip,
		);
		let ch = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
		if (parser.state.index < parser.length) {
			while (
				ch !== ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed &&
				ch !==
				___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
				ch !== ___R$project$rome$$romejs$string$charcodes$index_ts.lineSeparator &&
				ch !==
				___R$project$rome$$romejs$string$charcodes$index_ts.paragraphSeparator &&
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				) < parser.length
			) {
				ch = parser.input.charCodeAt(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					),
				);
			}
		}
		const endPos = parser.getPositionFromState();
		const text = parser.getRawInput(
			___R$project$rome$$romejs$ob1$index_ts$ob1Add(startIndex, startSkip),
			parser.state.index,
		);

		return {
			startPos,
			endPos,
			text,
		};
	}

	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(
		parser,
		startSkip,
	) {
		const lineComment = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$parseLineComment(
			parser,
			startSkip,
		);
		return ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$pushComment(
			parser,
			{
				block: false,
				text: lineComment.text,
				startPos: lineComment.startPos,
				endPos: lineComment.endPos,
			},
		);
	}

	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipInterpreterDirective(
		parser,
		startSkip,
	) {
		const lineComment = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$parseLineComment(
			parser,
			startSkip,
		);
		const loc = parser.finishLocAt(lineComment.startPos, lineComment.endPos);
		return {
			type: "InterpreterDirective",
			value: lineComment.text,
			loc,
		};
	}

	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipSpace(
		parser,
	) {
		loop: while (parser.state.index < parser.length) {
			const ch = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);

			if (parser.state.lineStart) {
				if (
					ch === ___R$project$rome$$romejs$string$charcodes$index_ts.space ||
					ch === ___R$project$rome$$romejs$string$charcodes$index_ts.tab
				) {
					parser.state.indentLevel = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
						parser.state.indentLevel,
					);
				} else {
					parser.state.lineStart = false;
				}
			}

			if (
				ch ===
				___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
				parser.input.charCodeAt(
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(parser.state.index) + 1,
				) === ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}

			switch (ch) {
				case ___R$project$rome$$romejs$string$charcodes$index_ts.space:
				case ___R$project$rome$$romejs$string$charcodes$index_ts.nonBreakingSpace: {
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					break;
				}

				case ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn:
				case ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed:
				case ___R$project$rome$$romejs$string$charcodes$index_ts.lineSeparator:
				case ___R$project$rome$$romejs$string$charcodes$index_ts.paragraphSeparator: {
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
						parser.state.curLine,
					);
					parser.resetTokenizerLine();
					break;
				}

				case ___R$project$rome$$romejs$string$charcodes$index_ts.slash: {
					switch (
						parser.input.charCodeAt(
							___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
								parser,
							) + 1,
						)
					) {
						case ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk: {
							// Break the loop and don't consume Flow comment code
							if (
								parser.input.charCodeAt(
									___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
										parser,
									) + 2,
								) === ___R$project$rome$$romejs$string$charcodes$index_ts.colon &&
								parser.input.charCodeAt(
									___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
										parser,
									) + 3,
								) === ___R$project$rome$$romejs$string$charcodes$index_ts.colon
							) {
								break loop;
							}

							___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipBlockComment(
								parser,
							);
							break;
						}

						case ___R$project$rome$$romejs$string$charcodes$index_ts.slash: {
							___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(
								parser,
								2,
							);
							break;
						}

						default:
							break loop;
					}
					break;
				}

				default:
					if (
						(ch > ___R$project$rome$$romejs$string$charcodes$index_ts.backSpace &&
						ch < ___R$project$rome$$romejs$string$charcodes$index_ts.shiftOut) ||
						(ch >=
						___R$project$rome$$romejs$string$charcodes$index_ts.oghamSpaceMark &&
						___R$project$rome$$romejs$js$parser$utils$whitespace_ts$nonASCIIwhitespace.test(
							String.fromCharCode(ch),
						))
					) {
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
							parser,
						);
					} else {
						break loop;
					}
			}
		}
	}

	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.
	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
		parser,
		type,
		val,
	) {
		parser.state.endPos = parser.getPositionFromState();

		const prevType = parser.state.tokenType;
		parser.state.tokenType = type;
		parser.state.tokenValue = val;

		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$updateContext(
			parser,
			prevType,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenDot(
		parser,
	) {
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		if (
			next >= ___R$project$rome$$romejs$string$charcodes$index_ts.digit0 &&
			next <= ___R$project$rome$$romejs$string$charcodes$index_ts.digit9
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNumber(
				parser,
				true,
			);
			return undefined;
		}

		const next2 = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 2,
		);
		if (
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.dot &&
			next2 === ___R$project$rome$$romejs$string$charcodes$index_ts.dot
		) {
			parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
				parser.state.index,
				3,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.ellipsis,
			);
		} else {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenSlash(
		parser,
	) {
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);

		// If this starts with /*:: then it's a Flow comment

		// TODO Flow also allows "flow-include" in place of "::"
		if (
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 2,
			) === ___R$project$rome$$romejs$string$charcodes$index_ts.colon &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 3,
			) === ___R$project$rome$$romejs$string$charcodes$index_ts.colon
		) {
			parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
				parser.state.index,
				4,
			);
			parser.pushScope("FLOW_COMMENT");
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
			return;
		}

		// '/'
		if (parser.state.exprAllowed) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readRegexp(parser);
			return;
		}

		if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign,
				2,
			);
		} else {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash,
				1,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenMultModulo(
		parser,
		code,
	) {
		let next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);

		// */ Is the end of a Flow comment
		if (
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk &&
			parser.inScope("FLOW_COMMENT") &&
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.slash
		) {
			parser.popScope("FLOW_COMMENT");
			parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
				parser.state.index,
				2,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
			return;
		}

		// '%*'
		let type =
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk
				? ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.star
				: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.modulo;
		let width = 1;
		const exprAllowed = parser.state.exprAllowed;

		// Exponentiation operator **
		if (
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk &&
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk
		) {
			width++;
			next = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 2,
			);
			type = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.exponent;
		}

		if (
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo &&
			!exprAllowed
		) {
			width++;
			type = ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign;
		}

		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
			parser,
			type,
			width,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenPipeAmp(
		parser,
		code,
	) {
		// '|&'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);

		if (next === code) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				code === ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar
					? ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.logicalOR
					: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.logicalAND,
				2,
			);
			return undefined;
		}

		// '|}'
		if (
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar &&
			next ===
			___R$project$rome$$romejs$string$charcodes$index_ts.rightCurlyBrace
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarR,
				2,
			);
			return undefined;
		}

		if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign,
				2,
			);
			return undefined;
		}

		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
			parser,
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar
				? ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseOR
				: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseAND,
			1,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenCaret(
		parser,
	) {
		// '^'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign,
				2,
			);
		} else {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitwiseXOR,
				1,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenPlusMin(
		parser,
		code,
	) {
		// '+-'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);

		if (next === code) {
			if (
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.dash &&
				!parser.inModule &&
				parser.input.charCodeAt(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 2,
				) === ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan &&
				(parser.state.lastEndPos.index ===
				___R$project$rome$$romejs$ob1$index_ts$ob1Number0 ||
				___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
					parser.getRawInput(parser.state.lastEndPos.index, parser.state.index),
				))
			) {
				// A `-->` line comment
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(
					parser,
					3,
				);
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipSpace(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
				return undefined;
			}
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.incDec,
				2,
			);
			return undefined;
		}

		if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign,
				2,
			);
		} else {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.plusMin,
				1,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenLtGt(
		parser,
		code,
	) {
		// '<>'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		let size = 1;

		// we need to check if we're in a type to avoid interpreting the >> in Array<Array<string>> as a bitshift
		if (next === code && !parser.inScope("TYPE")) {
			size =
				code === ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan &&
				parser.input.charCodeAt(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 2,
				) === ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan
					? 3
					: 2;
			if (
				parser.input.charCodeAt(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + size,
				) ===
				___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign,
					size + 1,
				);
				return undefined;
			}
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bitShift,
				size,
			);
			return undefined;
		}

		if (
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan &&
			next ===
			___R$project$rome$$romejs$string$charcodes$index_ts.exclamationMark &&
			!parser.inModule &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 2,
			) === ___R$project$rome$$romejs$string$charcodes$index_ts.dash &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 3,
			) === ___R$project$rome$$romejs$string$charcodes$index_ts.dash
		) {
			// `<!--`, an XML-style comment that should be interpreted as a line comment
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$skipLineComment(
				parser,
				4,
			);
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$skipSpace(
				parser,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
			return undefined;
		}

		if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
			// <= | >=
			size = 2;
		}

		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational,
			size,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenEqExcl(
		parser,
		code,
	) {
		// '=!'
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.equality,
				parser.input.charCodeAt(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 2,
				) === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo
					? 3
					: 2,
			);
			return undefined;
		}
		if (
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo &&
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan
		) {
			// '=>'
			parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
				parser.state.index,
				2,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow,
			);
			return undefined;
		}
		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
			parser,
			code === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo
				? ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eq
				: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bang,
			1,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenQuestion(
		parser,
	) {
		const next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 1,
		);
		const next2 = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) + 2,
		);
		if (
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.questionMark &&
			!parser.inScope("TYPE")
		) {
			if (next2 === ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo) {
				// '??='
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.assign,
					3,
				);
			} else {
				// '??'
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.nullishCoalescing,
					2,
				);
			}
		} else if (
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.dot &&
			!(next2 >= ___R$project$rome$$romejs$string$charcodes$index_ts.digit0 &&
			next2 <= ___R$project$rome$$romejs$string$charcodes$index_ts.digit9)
		) {
			// '.' not followed by a number
			parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
				parser.state.index,
				2,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot,
			);
		} else {
			// '?'
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.question,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenNumberSign(
		parser,
	) {
		// Only tokenize a hash if we're inside of a class, or if we're the first character in the file (hashbang indicator)
		if (
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(parser.state.classLevel) >
			0 ||
			parser.state.index === ___R$project$rome$$romejs$ob1$index_ts$ob1Number0
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.hash,
			);
			return undefined;
		}

		// TODO make this a diagnostic, and advance to the next line if suspected hashbang
		parser.addDiagnostic({
			description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNEXPECTED_HASH(
				parser.input[___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 1] === "!",
			),
		});
		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(
		parser,
		code,
	) {
		if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.digit0) {
			const next = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 1,
			);

			// '0x', '0X' - hex number
			if (
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseX ||
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseX
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readRadixNumber(
					parser,
					16,
					"hex",
				);
				return undefined;
			}

			// '0o', '0O' - octal number
			if (
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseO ||
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseO
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readRadixNumber(
					parser,
					8,
					"octal",
				);
				return undefined;
			}

			// '0b', '0B' - binary number
			if (
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseB ||
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseB
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readRadixNumber(
					parser,
					2,
					"binary",
				);
				return undefined;
			}
		}

		switch (code) {
			case ___R$project$rome$$romejs$string$charcodes$index_ts.numberSign:
				return ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenNumberSign(
					parser,
				);

			// The interpretation of a dot depends on whether it is followed

			// by a digit or another two dots.
			case ___R$project$rome$$romejs$string$charcodes$index_ts.dot: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenDot(
					parser,
				);
				return undefined;
			}

			// Punctuation tokens.
			case ___R$project$rome$$romejs$string$charcodes$index_ts.leftParenthesis: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenL,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.rightParenthesis: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.semicolon: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.comma: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.comma,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.leftSquareBracket: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketL,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.rightSquareBracket: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bracketR,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace: {
				if (
					parser.input.charCodeAt(
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) + 1,
					) ===
					___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar
				) {
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
						parser,
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceBarL,
						2,
					);
				} else {
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
						parser,
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
					);
				}
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.rightCurlyBrace: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.colon: {
				if (
					parser.input.charCodeAt(
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) + 1,
					) ===
					___R$project$rome$$romejs$string$charcodes$index_ts.colon
				) {
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
						parser,
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.doubleColon,
						2,
					);
				} else {
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
						parser,
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon,
					);
				}
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.questionMark: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenQuestion(
					parser,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.atSign: {
				// The token @@ is the start of a Flow iterator name
				const next = parser.input.charCodeAt(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 1,
				);
				if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.atSign) {
					parser.state.isIterator = true;
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord(
						parser,
					);
				} else {
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
					___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
						parser,
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.at,
					);
				}
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.graveAccent: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
				);
				return undefined;
			}

			// Anything else beginning with a digit is an integer, octal

			// number, or float.
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit0:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit1:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit2:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit3:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit4:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit5:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit6:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit7:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit8:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.digit9: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNumber(
					parser,
					false,
				);
				return undefined;
			}

			// Quotes produce strings.
			case ___R$project$rome$$romejs$string$charcodes$index_ts.quotationMark:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.apostrophe: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readString(
					parser,
					code,
				);
				return undefined;
			}

			// Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is

			// often referred to. `finishOp` simply skips the amount of

			// characters it is given as second argument, and returns a token

			// of the type given by its first argument.
			case ___R$project$rome$$romejs$string$charcodes$index_ts.slash: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenSlash(
					parser,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.percentSign:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.asterisk: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenMultModulo(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.verticalBar:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.ampersand: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenPipeAmp(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.caret: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenCaret(
					parser,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.plusSign:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.dash: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenPlusMin(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.greaterThan: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenLtGt(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.equalsTo:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.exclamationMark: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenEqExcl(
					parser,
					code,
				);
				return undefined;
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.tilde: {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.tilde,
					1,
				);
				return undefined;
			}
		}

		const char = parser.input[___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
			parser,
		)];
		const unicodeMistake = ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$UNICODE_MISTAKES.get(
			char,
		);
		if (unicodeMistake !== undefined) {
			const [unicodeName, equivalentChar] = unicodeMistake;
			const equivalentName = ___R$project$rome$$romejs$js$parser$tokenizer$unicodeMistakes_ts$ASCII_NAMES.get(
				equivalentChar,
			);
			if (equivalentName === undefined) {
				throw new Error("Expected ASCII name for " + equivalentChar);
			}

			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNEXPECTED_UNICODE_CHARACTER(
					char,
					unicodeName,
					equivalentChar,
					equivalentName,
				),
			});

			// Read the token as the equivalent character
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(
				parser,
				equivalentChar.charCodeAt(0),
			);
			return;
		}

		parser.addDiagnostic({
			description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PARSER_CORE.UNEXPECTED_CHARACTER(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$codePointToString(
					code,
				),
			),
		});

		// Skip unknown characters
		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(parser);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$finishOp(
		parser,
		type,
		size,
	) {
		const str = parser.getRawInput(
			parser.state.index,
			___R$project$rome$$romejs$ob1$index_ts$ob1Add(parser.state.index, size),
		);
		parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
			parser.state.index,
			size,
		);
		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
			parser,
			type,
			str,
		);
	}

	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readRegexp(
		parser,
	) {
		const start = parser.state.index;
		let escaped;
		let inClass;
		while (true) {
			if (parser.state.index >= parser.length) {
				parser.addDiagnostic({
					end: parser.getPositionFromIndex(parser.state.index),
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNTERMINATED_REGEX,
				});
				break;
			}

			const ch = parser.input.charAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			if (
				___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
					ch,
				)
			) {
				if (
					parser.input.charAt(
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) - 2,
					) ===
					String.fromCharCode(
						___R$project$rome$$romejs$string$charcodes$index_ts.backslash,
					) ||
					parser.input.charAt(
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) - 3,
					) ===
					String.fromCharCode(
						___R$project$rome$$romejs$string$charcodes$index_ts.backslash,
					)
				) {
					const line = parser.input.slice(
						0,
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
							parser,
						),
					);
					const backslashIndex = line.lastIndexOf(
						String.fromCharCode(
							___R$project$rome$$romejs$string$charcodes$index_ts.backslash,
						),
					);
					parser.addDiagnostic({
						end: parser.getPositionFromIndex(
							___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(backslashIndex),
						),
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DANGLING_BACKSLASH_IN_REGEX,
					});
					break;
				}
				parser.addDiagnostic({
					end: parser.getPositionFromIndex(parser.state.index),
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNTERMINATED_REGEX,
				});
				break;
			}

			if (escaped) {
				escaped = false;
			} else {
				if (ch === "[") {
					inClass = true;
				} else if (ch === "]" && inClass) {
					inClass = false;
				} else if (ch === "/" && !inClass) {
					break;
				}

				escaped = ch === "\\";
			}

			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
		}

		const content = parser.getRawInput(start, parser.state.index);
		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		const rawMods = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord1(
			parser,
		);
		if (parser.state.escapePosition !== undefined) {
			parser.addDiagnostic({
				index: parser.state.escapePosition,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNICODE_ESCAPE_IN_REGEX_FLAGS,
			});
		}
		const mods = ___R$project$rome$$romejs$js$parser$utils$regex_ts$validateRegexFlags(
			rawMods,
			(metadata, flagPosition) => {
				parser.addDiagnostic({
					index: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
							___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
								parser,
							) - rawMods.length,
						),
						flagPosition,
					),
					description: metadata,
				});
			},
		);

		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.regexp,
			new ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$RegExpTokenValue(
				content,
				mods,
			),
		);
	}

	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(
		parser,
		radix,
		len,
	) {
		const start = parser.state.index;
		const forbiddenSiblings =
			radix === 16
				? ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.hex
				: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$forbiddenNumericSeparatorSiblings.decBinOct;

		let allowedSiblings;
		if (radix === 16) {
			allowedSiblings = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.hex;
		} else if (radix === 10) {
			allowedSiblings = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.dec;
		} else if (radix === 8) {
			allowedSiblings = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.oct;
		} else {
			allowedSiblings = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$allowedNumericSeparatorSiblings.bin;
		}

		let total = 0;

		for (let i = 0, e = len === undefined ? Infinity : len; i < e; ++i) {
			const code = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			let val;

			const prev = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) - 1,
			);
			const next = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				) + 1,
			);
			if (
				code ===
				___R$project$rome$$romejs$string$charcodes$index_ts.underscore
			) {
				if (allowedSiblings.indexOf(next) === -1) {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_INT_TOKEN,
					});
				}

				if (
					forbiddenSiblings.indexOf(prev) > -1 ||
					forbiddenSiblings.indexOf(next) > -1 ||
					Number.isNaN(next)
				) {
					parser.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_INT_TOKEN,
					});
				}

				// Ignore this _ character
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				continue;
			}

			if (code >= ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseA) {
				val =
					code -
					___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseA +
					___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed;
			} else if (
				code >=
				___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseA
			) {
				val =
					code -
					___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseA +
					___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed;
			} else if (
				___R$project$rome$$romejs$string$charcodes$index_ts.isDigit(code)
			) {
				val = code - ___R$project$rome$$romejs$string$charcodes$index_ts.digit0; // 0-9
			} else {
				val = Infinity;
			}

			if (val >= radix) {
				break;
			}

			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			total = total * radix + val;
		}

		if (
			parser.state.index === start ||
			(len !== undefined &&
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			) -
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(start) !==
			len)
		) {
			return undefined;
		}

		return total;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readRadixNumber(
		parser,
		radix,
		format,
	) {
		const start = parser.state.index;
		let isBigInt = false;

		parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
			parser.state.index,
			2,
		); // 0x
		let val = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(
			parser,
			radix,
		);
		if (val === undefined) {
			parser.addDiagnostic({
				index: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(start, 2),
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_NUMBER_IN_RADIX(
					radix,
				),
			});
			val = 0;
		}

		if (
			parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			) ===
			___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseN
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			isBigInt = true;
		}

		if (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(
					parser,
				),
			)
		) {
			parser.addDiagnostic({
				index: parser.state.index,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IDENTIFIER_AFTER_NUMBER,
			});
		}

		if (isBigInt) {
			const str = parser.getRawInput(start, parser.state.index).replace(
				/[_n]/g,
				"",
			);
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bigint,
				str,
			);
			return undefined;
		}

		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num,
			new ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$NumberTokenValue(
				val,
				format,
			),
		);
	}

	// Read an integer, octal integer, or floating-point number.
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readNumber(
		parser,
		startsWithDot,
	) {
		const start = parser.state.startPos;
		let isFloat = false;
		let isBigInt = false;

		if (
			!startsWithDot &&
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(
				parser,
				10,
			) === undefined
		) {
			parser.addDiagnostic({
				index: parser.state.index,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_NUMBER,
			});
		}

		let isOctal =
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(parser.state.index) -
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(start.index) >=
			2 &&
			parser.input.charCodeAt(
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(start.index),
			) === ___R$project$rome$$romejs$string$charcodes$index_ts.digit0;
		if (isOctal) {
			if (parser.inScope("STRICT")) {
				parser.addDiagnostic({
					index: parser.state.index,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.LEGACY_OCTAL_IN_STRICT_MODE,
				});
			}

			if (/[89]/.test(parser.getRawInput(start.index, parser.state.index))) {
				isOctal = false;
			}
		}

		let next = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
		if (
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.dot &&
			!isOctal
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(
				parser,
				10,
			);
			isFloat = true;
			next = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
		}

		if (
			(next === ___R$project$rome$$romejs$string$charcodes$index_ts.uppercaseE ||
			next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseE) &&
			!isOctal
		) {
			next = parser.input.charCodeAt(
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					),
				),
			);

			if (
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.plusSign ||
				next === ___R$project$rome$$romejs$string$charcodes$index_ts.dash
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}

			if (
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(
					parser,
					10,
				) ===
				undefined
			) {
				parser.addDiagnostic({
					index: parser.state.index,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_NUMBER,
				});
			}

			isFloat = true;
			next = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
		}

		if (next === ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseN) {
			// Disallow floats and legacy octal syntax, new style octal ("0o") is handled in readRadixNumber
			if (isFloat) {
				parser.addDiagnostic({
					index: parser.state.index,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.DECIMAL_BIGINT,
				});
			}

			if (isOctal) {
				parser.addDiagnostic({
					index: parser.state.index,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.OCTAL_BIGINT,
				});
			}

			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			isBigInt = true;
		}

		if (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart(
				parser.input.codePointAt(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					),
				),
			)
		) {
			parser.addDiagnostic({
				index: parser.state.index,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.IDENTIFIER_AFTER_NUMBER,
			});
		}

		// Remove "_" for numeric literal separator, and "n" for BigInts
		const str = parser.getRawInput(start.index, parser.state.index).replace(
			/[_n]/g,
			"",
		);

		if (isBigInt) {
			___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
				parser,
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.bigint,
				str,
			);
			return undefined;
		}

		const num = isOctal ? parseInt(str, 8) : parseFloat(str);
		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.num,
			new ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$NumberTokenValue(
				num,
				isOctal ? "octal" : undefined,
			),
		);
	}

	// Read a string value, interpreting backslash-escapes.
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readCodePoint(
		parser,
		throwOnInvalid,
	) {
		const ch = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
		let code;

		if (
			ch ===
			___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace
		) {
			const codePos = parser.state.index;
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			code = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readHexChar(
				parser,
				parser.input.indexOf(
					"}",
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					),
				) -
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
				throwOnInvalid,
			);
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			if (code === undefined) {
				// @ts-ignore
				parser.state.invalidTemplateEscapePosition--; // to point to the '\'' instead of the 'u'
			} else if (code > 1_114_111) {
				if (throwOnInvalid) {
					parser.addDiagnostic({
						index: codePos,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.OUT_OF_BOUND_CODE_POINT,
					});
				} else {
					parser.state.invalidTemplateEscapePosition = ___R$project$rome$$romejs$ob1$index_ts$ob1Sub(
						codePos,
						2,
					);
					return undefined;
				}
			}
		} else {
			code = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readHexChar(
				parser,
				4,
				throwOnInvalid,
			);
		}
		return code;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readString(
		parser,
		quote,
	) {
		let out = "";
		let chunkStart = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		while (true) {
			if (parser.state.index >= parser.length) {
				parser.addDiagnostic({
					end: parser.getPositionFromIndex(parser.state.index),
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNTERMINATED_STRING,
				});
				break;
			}

			const ch = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			if (ch === quote) {
				break;
			}

			if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.backslash) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readEscapedChar(
					parser,
					false,
				);
				chunkStart = parser.state.index;
			} else if (
				ch === ___R$project$rome$$romejs$string$charcodes$index_ts.lineSeparator ||
				ch ===
				___R$project$rome$$romejs$string$charcodes$index_ts.paragraphSeparator
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
				parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
					parser.state.curLine,
				);
			} else {
				if (
					___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)
				) {
					parser.addDiagnostic({
						end: parser.getPositionFromIndex(parser.state.index),
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNTERMINATED_STRING,
					});
				}
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}
		}

		out += parser.getRawInput(chunkStart, parser.state.index);
		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
			out,
		);
	}

	// Reads template string tokens.
	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$readTemplateToken(
		parser,
	) {
		let out = "";
		let chunkStart = parser.state.index;
		let containsInvalid = false;

		while (true) {
			if (parser.state.index >= parser.length) {
				parser.addDiagnostic({
					end: parser.getPositionFromIndex(parser.state.index),
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNTERMINATED_TEMPLATE,
				});
				break;
			}

			const ch = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			if (
				ch === ___R$project$rome$$romejs$string$charcodes$index_ts.graveAccent ||
				(ch === ___R$project$rome$$romejs$string$charcodes$index_ts.dollarSign &&
				parser.input.charCodeAt(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
						parser,
					) + 1,
				) === ___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace)
			) {
				if (
					parser.state.index === parser.state.startPos.index &&
					parser.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.template,
					)
				) {
					if (
						ch ===
						___R$project$rome$$romejs$string$charcodes$index_ts.dollarSign
					) {
						parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
							parser.state.index,
							2,
						);
						___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
							parser,
							___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dollarBraceL,
						);
						return undefined;
					} else {
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
							parser,
						);
						___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
							parser,
							___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.backQuote,
						);
						return undefined;
					}
				}
				out += parser.getRawInput(chunkStart, parser.state.index);
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.template,
					containsInvalid ? undefined : out,
				);
				return undefined;
			}

			if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.backslash) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				const escaped = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readEscapedChar(
					parser,
					true,
				);
				if (escaped === undefined) {
					containsInvalid = true;
				} else {
					out += escaped;
				}
				chunkStart = parser.state.index;
			} else if (
				___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)
			) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);

				if (
					ch ===
					___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
					parser.input.charCodeAt(
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
							parser,
						),
					) === ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed
				) {
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					);
				}

				switch (ch) {
					case ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn:
					case ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed: {
						out += "\n";
						break;
					}

					default: {
						out += String.fromCharCode(ch);
						break;
					}
				}

				parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
					parser.state.curLine,
				);
				parser.resetTokenizerLine();
				chunkStart = parser.state.index;
			} else {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}
		}
	}

	// Used to read escaped characters
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readEscapedChar(
		parser,
		inTemplate,
	) {
		const throwOnInvalid = !inTemplate;
		const ch = parser.input.charCodeAt(
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				),
			),
		);
		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		if (
			ch === ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			) === ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
		}

		switch (ch) {
			case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseN:
				return "\n";

			case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseR:
				return "\r";

			case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseX: {
				const code = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readHexChar(
					parser,
					2,
					throwOnInvalid,
				);
				return code === undefined ? undefined : String.fromCharCode(code);
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseU: {
				const code = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readCodePoint(
					parser,
					throwOnInvalid,
				);
				return code === undefined
					? undefined
					: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$codePointToString(
							code,
						);
			}

			case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseT:
				return "\t";

			case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseB:
				return "\b";

			case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseV:
				return "\x0b";

			case ___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseF:
				return "\f";

			case ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn:
			case ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed: {
				parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
					parser.state.curLine,
				);
				parser.resetTokenizerLine();
				return "";
			}

			default: {
				if (
					ch >= ___R$project$rome$$romejs$string$charcodes$index_ts.digit0 &&
					ch <= ___R$project$rome$$romejs$string$charcodes$index_ts.digit7
				) {
					const codePos = ___R$project$rome$$romejs$ob1$index_ts$ob1Dec(
						parser.state.index,
					);
					const octalMatches = parser.input.substr(
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
							parser,
						) - 1,
						3,
					).match(/^[0-7]+/);

					let octalStr = octalMatches[0];
					let octal = parseInt(octalStr, 8);
					if (octal > 255) {
						octalStr = octalStr.slice(0, -1);
						octal = parseInt(octalStr, 8);
					}

					if (octal > 0) {
						if (inTemplate) {
							parser.state.invalidTemplateEscapePosition = codePos;
							return undefined;
						} else if (parser.inScope("STRICT")) {
							parser.addDiagnostic({
								index: codePos,
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.OCTAL_IN_STRICT_MODE,
							});
						} else if (!parser.state.containsOctal) {
							// These properties are only used to throw an error for an octal which occurs
							// in a directive which occurs prior to a "use strict" directive.
							parser.state.containsOctal = true;
							parser.state.octalPosition = codePos;
						}
					}

					parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
						parser.state.index,
						octalStr.length - 1,
					);
					return String.fromCharCode(octal);
				}

				return String.fromCharCode(ch);
			}
		}
	}

	// Used to read character escape sequences ('\x', '\u').
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readHexChar(
		parser,
		len,
		throwOnInvalid,
	) {
		const start = parser.state.index;
		const n = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readInt(
			parser,
			16,
			len,
		);

		if (n === undefined) {
			if (throwOnInvalid) {
				parser.addDiagnostic({
					index: start,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.BAD_HEX_ESCAPE,
				});
				return 0;
			}

			const codePos = parser.state.index;
			parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Dec(
				codePos,
			);
			parser.state.invalidTemplateEscapePosition = ___R$project$rome$$romejs$ob1$index_ts$ob1Dec(
				codePos,
			);
		}

		return n;
	}

	// Read an identifier, and return it as a string. Sets `parser.state.escapePosition`
	// to an index if the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord1(
		parser,
	) {
		parser.state.escapePosition = undefined;
		let word = "";
		let first = true;
		let chunkStart = parser.state.index;

		while (parser.state.index < parser.length) {
			const ch = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$fullCharCodeAtPos(
				parser,
			);

			if (
				___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(
					ch,
				)
			) {
				parser.state.index = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
					parser.state.index,
					ch <= 65_535 ? 1 : 2,
				);
			} else if (
				parser.state.isIterator &&
				ch === ___R$project$rome$$romejs$string$charcodes$index_ts.atSign
			) {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			} else if (
				ch ===
				___R$project$rome$$romejs$string$charcodes$index_ts.backslash
			) {
				parser.state.escapePosition = parser.state.index;

				word += parser.getRawInput(chunkStart, parser.state.index);

				if (
					parser.input.charCodeAt(
						___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
							___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
								parser,
							),
						),
					) !==
					___R$project$rome$$romejs$string$charcodes$index_ts.lowercaseU
				) {
					parser.addDiagnostic({
						index: parser.state.index,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_UNICODE_ESCAPE,
					});
				}

				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);

				const esc = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readCodePoint(
					parser,
					true,
				);
				if (esc === undefined) {
					throw new Error("readCodePoint() should have thrown an error");
				}

				const isValid = first
					? ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierStart
					: ___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar;
				if (isValid(esc) === false) {
					parser.addDiagnostic({
						index: parser.state.index,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_UNICODE_ESCAPE,
					});
				}

				word += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$codePointToString(
					esc,
				);
				chunkStart = parser.state.index;
			} else {
				break;
			}

			first = false;
		}

		return word + parser.getRawInput(chunkStart, parser.state.index);
	}

	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord(
		parser,
	) {
		const word = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readWord1(
			parser,
		);

		// @ts-ignore: The value of keywordTypes has a generic parameter of `string` instead of the labels that we would actually find in keywordTypes
		let type =
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$keywords.get(word) ||
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name;

		if (type.keyword !== undefined && parser.state.escapePosition !== undefined) {
			parser.addDiagnostic({
				index: parser.state.escapePosition,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ESCAPE_SEQUENCE_IN_KEYWORD(
					word,
				),
			});
		}

		if (
			parser.state.isIterator &&
			(!___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$isIterator(
				word,
			) ||
			!parser.inScope("TYPE"))
		) {
			parser.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.INVALID_IDENTIFIER_NAME(
					word,
				),
			});
		}

		___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
			parser,
			type,
			word,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$isIterator(
		word,
	) {
		return word === "@@iterator" || word === "@@asyncIterator";
	}

	function ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$isBraceBlock(
		parser,
		prevType,
	) {
		const parent = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
			parser,
		);
		if (
			parent ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.functionExpression ||
			parent ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.functionStatement
		) {
			return true;
		}
		if (
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.colon &&
			(parent ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement ||
			parent ===
			___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceExpression)
		) {
			return !parent.isExpr;
		}

		// The check for `tt.name && exprAllowed` detects whether we are

		// after a `yield` or `of` construct. See the `updateContext` for

		// `tt.name`.
		if (
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._return ||
			(prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name &&
			parser.state.exprAllowed)
		) {
			return ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
				parser.getRawInput(
					parser.state.lastEndPos.index,
					parser.state.startPos.index,
				),
			);
		}

		if (
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._else ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.parenR ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.arrow
		) {
			return true;
		}

		if (
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL
		) {
			return (
				parent ===
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement
			);
		}

		if (
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._var ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types._const
		) {
			return false;
		}

		if (
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational
		) {
			// `class C<T> { ... }`
			return true;
		}

		return !parser.state.exprAllowed;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$updateContext(
		parser,
		prevType,
	) {
		if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceL,
			)
		) {
			const curContext = ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$getCurContext(
				parser,
			);
			if (
				curContext ===
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxOpenTag
			) {
				parser.state.context.push(
					___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceExpression,
				);
			} else if (
				curContext ===
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxInner
			) {
				parser.state.context.push(
					___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.templateQuasi,
				);
			} else {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$_updateContext(
					parser,
					prevType,
				);
			}

			parser.state.exprAllowed = true;
		} else if (
			parser.match(
				___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.slash,
			) &&
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart
		) {
			parser.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
			parser.state.context.push(
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.jsxCloseTag,
			); // reconsider as closing tag context
			parser.state.exprAllowed = false;
		} else {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$_updateContext(
				parser,
				prevType,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$_updateContext(
		parser,
		prevType,
	) {
		const type = parser.state.tokenType;

		if (
			type.keyword !== undefined &&
			(prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.dot ||
			prevType ===
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.questionDot)
		) {
			parser.state.exprAllowed = false;
		} else if (type.updateContext !== undefined) {
			type.updateContext(parser, prevType);
		} else {
			parser.state.exprAllowed = type.beforeExpr;
		}
	}

	// Reads inline JSX contents token.
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsx(
		parser,
	) {
		let out = "";
		let chunkStart = parser.state.index;
		while (true) {
			if (parser.state.index >= parser.length) {
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				);
				break;
			}

			const code = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);

			if (
				code === ___R$project$rome$$romejs$string$charcodes$index_ts.lessThan ||
				code ===
				___R$project$rome$$romejs$string$charcodes$index_ts.leftCurlyBrace
			) {
				if (parser.state.index === parser.state.startPos.index) {
					if (
						code ===
						___R$project$rome$$romejs$string$charcodes$index_ts.lessThan &&
						parser.state.exprAllowed
					) {
						___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
							parser,
						);
						return ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
							parser,
							___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxTagStart,
						);
					}

					return ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getTokenFromCode(
						parser,
						code,
					);
				}

				out += parser.getRawInput(chunkStart, parser.state.index);
				return ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
					parser,
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxText,
					out,
				);
			}

			if (code === ___R$project$rome$$romejs$string$charcodes$index_ts.ampersand) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxEntity(
					parser,
				);
				chunkStart = parser.state.index;
				continue;
			}

			if (
				___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(code)
			) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxNewLine(
					parser,
					true,
				);
				chunkStart = parser.state.index;
			} else {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}
		}
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxNewLine(
		parser,
		normalizeCRLF,
	) {
		const ch = parser.input.charCodeAt(
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			),
		);
		let out;
		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		if (
			ch === ___R$project$rome$$romejs$string$charcodes$index_ts.carriageReturn &&
			parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			) === ___R$project$rome$$romejs$string$charcodes$index_ts.lineFeed
		) {
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			out = normalizeCRLF ? "\n" : "\r\n";
		} else {
			out = String.fromCharCode(ch);
		}

		parser.state.curLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
			parser.state.curLine,
		);
		parser.resetTokenizerLine();
		return out;
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxString(
		parser,
		quote,
	) {
		let out = "";
		let chunkStart = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		while (true) {
			if (parser.state.index >= parser.length) {
				parser.addDiagnostic({
					end: parser.getPositionFromIndex(parser.state.index),
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNTERMINATED_JSX_STRING,
				});
				break;
			}

			const ch = parser.input.charCodeAt(
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
					parser,
				),
			);
			if (ch === quote) {
				break;
			}

			if (ch === ___R$project$rome$$romejs$string$charcodes$index_ts.ampersand) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxEntity(
					parser,
				);
				chunkStart = parser.state.index;
			} else if (
				___R$project$rome$$romejs$js$parser$utils$whitespace_ts$isNewLine(ch)
			) {
				out += parser.getRawInput(chunkStart, parser.state.index);
				out += ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxNewLine(
					parser,
					false,
				);
				chunkStart = parser.state.index;
			} else {
				___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
					parser,
				);
			}
		}

		out += parser.getRawInput(chunkStart, parser.state.index);
		___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);
		return ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.string,
			out,
		);
	}

	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxEntity(
		parser,
	) {
		let str = "";
		let count = 0;
		let entity;
		let ch = parser.input[___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
			parser,
		)];

		const startIndex = ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
			parser,
		);

		while (parser.state.index < parser.length && count++ < 10) {
			ch = parser.input[___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$getIndex(
				parser,
			)];
			___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
				parser,
			);
			if (ch === ";") {
				if (str[0] === "#") {
					if (str[1] === "x") {
						str = str.substr(2);
						if (
							___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$HEX_NUMBER.test(
								str,
							)
						) {
							entity = String.fromCodePoint(parseInt(str, 16));
						}
					} else {
						str = str.substr(1);
						if (
							___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$DECIMAL_NUMBER.test(
								str,
							)
						) {
							entity = String.fromCodePoint(parseInt(str, 10));
						}
					}
				} else {
					entity = ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$xhtmlEntityNameToChar[str];
				}
				break;
			}
			str += ch;
		}

		if (entity === undefined) {
			parser.state.index = startIndex;
			return "&";
		} else {
			return entity;
		}
	}

	// Read a JSX identifier (valid tag or attribute name).
	//
	// Optimized version since JSX identifiers can't contain
	// escape characters and so can be read as single slice.
	// Also assumes that first character was already checked
	// by isIdentifierStart in readToken.
	function ___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$readTokenJsxWord(
		parser,
	) {
		let ch;
		const start = parser.state.index;
		do {
			ch = parser.input.charCodeAt(
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
					___R$$priv$project$rome$$romejs$js$parser$tokenizer$index_ts$bumpIndex(
						parser,
					),
				),
			);
		} while (
			___R$project$rome$$romejs$js$parser$utils$identifier_ts$isIdentifierChar(
				ch,
			) ||
			ch === ___R$project$rome$$romejs$string$charcodes$index_ts.dash
		);
		return ___R$project$rome$$romejs$js$parser$tokenizer$index_ts$finishToken(
			parser,
			___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.jsxName,
			parser.getRawInput(start, parser.state.index),
		);
	}


  // project-rome/@romejs/js-parser/ParserBranchFinder.ts




	class ___R$project$rome$$romejs$js$parser$ParserBranchFinder_ts$default {
		constructor(parser) {
			this.parser = parser;
			this.branch = undefined;
			this.picked = false;
		}

		hasOptimalBranch() {
			return this.branch !== undefined && this.branch.optimal;
		}

		hasBranch() {
			return this.branch !== undefined;
		}

		add(callback, opts = {}) {
			const topBranch = this.branch;

			// If we already have a branch that produced no errors then no point continuing
			if (topBranch !== undefined && topBranch.optimal) {
				return this;
			}

			const {maxNewDiagnostics, diagnosticsPriority} = opts;
			const {parser} = this;
			const prevState = parser.cloneState();

			parser.pushScope("MAX_NEW_DIAGNOSTICS", maxNewDiagnostics);

			let result;
			try {
				result = callback(parser);
			} catch (err) {
				if (
					err instanceof
					___R$project$rome$$romejs$js$parser$parser_ts$DiagnosticsFatalError
				) {
					parser.setState(prevState);
					return this;
				} else {
					throw err;
				}
			}

			if (result === undefined) {
				parser.setState(prevState);
				return this;
			}

			// We capture the state at this point because it could have been previously changed
			const newState = parser.state;
			parser.popScope("MAX_NEW_DIAGNOSTICS");
			parser.setState(prevState);

			// Verify that we didn't exceed the maxDiagnostics, this should have already been done in Parser#addDiagnostic

			// but do it again as a sanity check. Previously some code caused the state to be manipulated in odd ways
			const newDiagnosticCount = newState.diagnostics.length;
			const prevDiagnosticCount = prevState.diagnostics.length;
			if (
				maxNewDiagnostics !== undefined &&
				newDiagnosticCount - prevDiagnosticCount > maxNewDiagnostics
			) {
				throw new Error(
					"Max diagnostics unexpectedly exceeded " +
					maxNewDiagnostics +
					". Prev: " +
					prevDiagnosticCount +
					" New: " +
					newDiagnosticCount,
				);
			}

			const branch = {
				diagnosticsPriority,
				result,
				state: newState,
				newDiagnosticCount: newDiagnosticCount - prevDiagnosticCount,
				diagnosticCount: newDiagnosticCount,
				optimal: newDiagnosticCount === prevDiagnosticCount,
			};

			// Promote this branch to the leader if it's the first, or if it has less diagnostics than the current
			let shouldPromote = false;

			if (topBranch === undefined || branch.optimal) {
				shouldPromote = true;
			} else {
				// Promote if the branch has less diagnostics than the top branch
				if (branch.diagnosticCount < topBranch.diagnosticCount) {
					shouldPromote = true;
				}

				// Promote if we have a priority but the top branch doesn't
				if (
					branch.diagnosticsPriority !== undefined &&
					topBranch.diagnosticsPriority === undefined
				) {
					shouldPromote = true;
				}

				// Promote if we have a priority, and the top branch does, and we're higher
				if (
					branch.diagnosticsPriority !== undefined &&
					topBranch.diagnosticsPriority !== undefined &&
					branch.diagnosticsPriority > topBranch.diagnosticsPriority
				) {
					shouldPromote = true;
				}

				// Don't promote if the top branch has a priority but we don't
				if (
					topBranch.diagnosticsPriority !== undefined &&
					branch.diagnosticsPriority === undefined
				) {
					shouldPromote = false;
				}
			}

			if (shouldPromote) {
				this.branch = branch;
			}

			return this;
		}

		getBranch() {
			if (this.branch === undefined) {
				throw new Error("No branch");
			} else {
				return this.branch;
			}
		}

		pickOptional() {
			if (this.hasBranch()) {
				return this.pick();
			} else {
				return undefined;
			}
		}

		pick() {
			if (this.picked) {
				throw new Error("Already been picked");
			}
			this.picked = true;

			const {parser} = this;
			const branch = this.getBranch();

			const {result, state} = branch;
			parser.setState(state);
			return result;
		}
	}


  // project-rome/@romejs/js-parser/tokenizer/state.ts








	const ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS = {
		line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
		column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
		index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
	};

	function ___R$project$rome$$romejs$js$parser$tokenizer$state_ts$createInitialState() {
		return {
			scopes: {},
			diagnostics: [],
			diagnosticFilters: [],
			hasHoistedVars: false,
			corrupt: false,
			tokens: [],
			potentialArrowAt: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1,
			commaAfterSpreadAt: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1,
			yieldPos: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			awaitPos: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			noArrowAt: [],
			noArrowParamsConversionAt: [],
			maybeInArrowParameters: false,
			isIterator: false,
			noAnonFunctionType: false,
			classLevel: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			labels: [],
			yieldInPossibleArrowParameters: undefined,
			comments: [],
			trailingComments: [],
			leadingComments: [],
			commentStack: [],
			commentPreviousNode: undefined,
			index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			lineStartIndex: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			curLine: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
			tokenType: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
			tokenValue: undefined,
			startPos: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
			endPos: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
			lastStartPos: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
			lastEndPos: ___R$$priv$project$rome$$romejs$js$parser$tokenizer$state_ts$EMPTY_POS,
			context: [
				___R$project$rome$$romejs$js$parser$tokenizer$context_ts$types.braceStatement,
			],
			exprAllowed: true,
			containsOctal: false,
			escapePosition: undefined,
			octalPosition: undefined,
			invalidTemplateEscapePosition: undefined,
			exportedIdentifiers: new Map(),
			lineStart: true,
			indentLevel: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
		};
	}


  // project-rome/@romejs/js-parser/parser.ts
const ___R$$priv$project$rome$$romejs$js$parser$parser_ts$TOKEN_MISTAKES = {
		";": ":",
		",": ".",
	};

	class ___R$project$rome$$romejs$js$parser$parser_ts$DiagnosticsFatalError
		extends Error {
		constructor() {
			super(
				"Diagnostics exceeded maxDiagnostics state cap, this error is expected to be handled by a try-catch in the call stack",
			);
		}
	}





	const ___R$$priv$project$rome$$romejs$js$parser$parser_ts$SCOPE_TYPES = [
		"FUNCTION_LOC",
		"NON_ARROW_FUNCTION",
		"FUNCTION",
		"GENERATOR",
		"ASYNC",
		"PROPERTY_NAME",
		"CLASS_PROPERTY",
		"PARAMETERS",
		"METHOD",
		"CLASS",
		"TYPE",
		"MAX_NEW_DIAGNOSTICS",
		"STRICT",
		"FLOW_COMMENT",
	];

	const ___R$project$rome$$romejs$js$parser$parser_ts$createJSParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser((
		ParserCore,
		ParserWithRequiredPath,
	) => {
		// rome-ignore lint/js/noExplicitAny
		class JSParser extends ParserWithRequiredPath {
			constructor(options) {
				const state = ___R$project$rome$$romejs$js$parser$tokenizer$state_ts$createInitialState();

				const parserOpts = {
					path: options.path,
					mtime: options.mtime,
					input: options.input,
				};
				super(parserOpts, "parse/js", state);

				this.isTrackingTokens = options.tokens;

				this.isLookahead = false;

				this.sourceType = options.sourceType;
				this.options = options;
				this.inModule =
					this.options.sourceType === "template" ||
					this.options.sourceType === "module";
				this.parenthesized = new Set();
				this.comments = new ___R$project$rome$$romejs$js$parser$CommentsConsumer_ts$default();

				// Turn options.syntax into a Set, probably faster than doing `includes` on the array
				// We may also push stuff to it as we read comments such as `@\flow`
				this.syntax = new Set(options.syntax);
			}

			resetTokenizerLine() {
				this.state.lineStartIndex = this.state.index;
				this.state.lineStart = true;
				this.state.indentLevel = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
			}

			getScope(type) {
				let scope = this.state.scopes[type];
				if (scope === undefined) {
					scope = [];
					this.state.scopes[type] = scope;
				}
				return scope;
			}

			getLastScope(type) {
				const scope = this.getScope(type);
				return scope[scope.length - 1];
			}

			pushScope(type, value) {
				//console.log('+' + type);
				//console.group();
				this.getScope(type).push(value);
			}

			popScope(type) {
				//console.groupEnd();
				//console.log('-' + type);
				this.getScope(type).pop();
			}

			inScope(type) {
				return this.hasScope(type) && this.getLastScope(type) !== false;
			}

			hasScope(type) {
				const scope = this.state.scopes[type];
				return scope !== undefined && scope.length > 0;
			}

			addParenthesized(node) {
				this.parenthesized.add(this.getLoc(node).start.index);
			}

			isParenthesized(node) {
				return this.parenthesized.has(this.getLoc(node).start.index);
			}

			setState(newState) {
				// Verify that this new state doesn't exceed any previous maxDiagnostic cap
				// maxDiagnostics will be at -1 when it's own limit has been exceeded, in
				// this case, we are likely replacing the State with another that's valid
				// and doesn't exceed
				const maxDiagnostics = this.getLastScope("MAX_NEW_DIAGNOSTICS");
				if (typeof maxDiagnostics === "number" && maxDiagnostics !== -1) {
					const diff =
						newState.diagnostics.length - this.state.diagnostics.length;
					if (diff > maxDiagnostics) {
						throw new ___R$project$rome$$romejs$js$parser$parser_ts$DiagnosticsFatalError();
					}
				}

				this.state = newState;
			}

			atEOF() {
				return this.match(
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
				);
			}

			createBranch() {
				return new ___R$project$rome$$romejs$js$parser$ParserBranchFinder_ts$default(
					this,
				);
			}

			tryBranch(fn) {
				const branch = new ___R$project$rome$$romejs$js$parser$ParserBranchFinder_ts$default(
					this,
				);
				branch.add(fn, {maxNewDiagnostics: 0});
				if (branch.hasBranch()) {
					return branch.pickOptional();
				} else {
					return undefined;
				}
			}

			finalizeNode(node) {
				___R$project$rome$$romejs$js$parser$parser$comments_ts$attachComments(
					this,
					node,
				);
				return node;
			}

			// Sometimes we want to pretend we're in different locations to consume the comments of other nodes
			finishNodeWithCommentStarts(starts, node) {
				for (const start of starts) {
					node = this.finishNode(start, node);
				}
				return node;
			}

			finishNode(start, node) {
				return this.finishNodeAt(start, this.getLastEndPosition(), node);
			}

			finishNodeAt(start, end, node) {
				// Maybe mutating `node` is better...?
				const newNode = Object.assign(
					{},
					node,
					{loc: this.finishLocAt(start, end)},
				);
				return this.finalizeNode(newNode);
			}

			createUnknownIdentifier(
				reason,
				start = this.getPosition(),
				end = this.getLastEndPosition(),
			) {
				this.state.corrupt = true;
				return {
					type: "Identifier",
					name: "INVALID_PLACEHOLDER",
					loc: this.finishLocAt(start, end),
				};
			}

			createUnknownStringLiteral(
				reason,
				start = this.getPosition(),
				end = this.getLastEndPosition(),
			) {
				this.state.corrupt = true;
				return {
					type: "StringLiteral",
					value: "INVALID_PLACEHOLDER",
					loc: this.finishLocAt(start, end),
				};
			}

			assertNoSpace(
				_metadata = ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNEXPECTED_SPACE,
			) {
				const {state} = this;

				if (state.startPos.index > state.lastEndPos.index) {
					this.addDiagnostic({
						start: state.lastEndPos,
						end: state.lastEndPos,
						description: _metadata,
					});
				}
			}

			getDiagnostics() {
				const collector = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default({
					origins: [
						{
							category: "js-parser",
						},
					],
					//unique: ['start.line'],
				});

				for (const filter of this.state.diagnosticFilters) {
					collector.addFilter(filter);
				}

				// TODO remove any trailing "eof" diagnostic
				return collector.addDiagnostics(this.state.diagnostics).slice(0, 1);
			}

			addDiagnosticFilter(diag) {
				this.state.diagnosticFilters.push(diag);
			}

			addCompleteDiagnostic(diags) {
				this.state.diagnostics = [...this.state.diagnostics, ...diags];
			}

			shouldCreateToken() {
				return this.isTrackingTokens && this.isLookahead === false;
			}

			createToken(state) {
				const token = {
					type: state.tokenType,
					start: state.startPos.index,
					end: state.endPos.index,
					loc: {
						filename: this.filename,
						start: state.startPos,
						end: state.endPos,
					},
				};
				this.pushToken(token);
				return token;
			}

			pushToken(token) {
				const lastToken = this.state.tokens[this.state.tokens.length - 1];
				if (lastToken !== undefined) {
					if (token.loc.start.index < lastToken.loc.end.index) {
						throw new Error(
							"Trying to push a token that appears before the last pushed token",
						);
					}
				}

				this.state.tokens.push(token);
			}

			addDiagnostic(opts) {
				if (this.isLookahead) {
					return;
				}

				let maxDiagnostics = this.getLastScope("MAX_NEW_DIAGNOSTICS");
				if (typeof maxDiagnostics === "number") {
					maxDiagnostics--;
					this.popScope("MAX_NEW_DIAGNOSTICS");
					this.pushScope("MAX_NEW_DIAGNOSTICS", maxDiagnostics);
					if (maxDiagnostics < 0) {
						throw new ___R$project$rome$$romejs$js$parser$parser_ts$DiagnosticsFatalError();
					}
				}

				if (this.state.diagnostics.length > 0) {
					//return;
				}

				let {start, end} = opts;

				if (opts.index !== undefined) {
					start = this.getPositionFromIndex(opts.index);
					end = start;
				}

				if (opts.location !== undefined) {
					start = opts.location.start;
					end = opts.location.end;
				}

				if (start === undefined && end === undefined && opts.loc !== undefined) {
					start = opts.loc.start;
					end = opts.loc.end;
				}

				// If we weren't given a start then default to the provided end, or the current token start
				if (start === undefined && end === undefined) {
					start = this.getPosition();
					end = this.getLastEndPosition();
				}

				if (start === undefined && end !== undefined) {
					start = end;
				}

				if (start !== undefined && end === undefined) {
					end = start;
				}

				this.state.diagnostics.push({
					description: Object.assign({category: "parse/js"}, opts.description),
					location: {
						filename: this.filename,
						sourceType: this.sourceType,
						mtime: this.mtime,
						start,
						end,
					},
				});
			}

			shouldTokenizeJSX() {
				return !this.isSyntaxEnabled("ts") || this.isSyntaxEnabled("jsx");
			}

			isSyntaxEnabled(syntax) {
				return this.syntax.has(syntax);
			}

			expectSyntaxEnabled(syntax) {
				if (!this.isSyntaxEnabled(syntax)) {
					this.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_ENABLE_SYNTAX(
							syntax,
						),
					});
				}
			}

			isRelational(op) {
				return (
					this.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational,
					) && this.state.tokenValue === op
				);
			}

			expectRelational(op) {
				if (this.eatRelational(op)) {
					return true;
				} else {
					this.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_RELATIONAL_OPERATOR,
					});
					return false;
				}
			}

			isLookaheadRelational(op) {
				const l = this.lookaheadState();
				return (
					l.tokenType ===
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.relational &&
					l.tokenValue === op
				);
			}

			banUnicodeEscape(index, name) {
				if (index !== undefined) {
					this.addDiagnostic({
						index,
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.ESCAPE_SEQUENCE_IN_WORD(
							name,
						),
					});
				}
			}

			// eat() for relational operators.
			eatRelational(op) {
				if (this.isRelational(op)) {
					this.next();
					return true;
				} else {
					return false;
				}
			}

			// Tests whether parsed token is a contextual keyword.
			isContextual(name) {
				return (
					this.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name,
					) &&
					this.state.tokenValue === name &&
					this.state.escapePosition === undefined
				);
			}

			isLookaheadContextual(name) {
				const l = this.lookaheadState();
				return (
					l.tokenType ===
					___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.name &&
					l.tokenValue === name &&
					l.escapePosition === undefined
				);
			}

			// Consumes contextual keyword if possible.
			eatContextual(name) {
				if (this.isContextual(name)) {
					this.next();
					return true;
				} else {
					return false;
				}
			}

			// Asserts that following token is given contextual keyword.
			expectContextual(
				name,
				_metadata = ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_KEYWORD(
					name,
				),
			) {
				if (this.eatContextual(name)) {
					return true;
				} else {
					this.addDiagnostic({
						description: _metadata,
					});
					return false;
				}
			}

			// Test whether a semicolon can be inserted at the current position.
			canInsertSemicolon() {
				return (
					this.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
					) ||
					this.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.braceR,
					) ||
					this.hasPrecedingLineBreak()
				);
			}

			hasPrecedingLineBreak() {
				return ___R$project$rome$$romejs$js$parser$utils$whitespace_ts$lineBreak.test(
					this.getRawInput(
						this.state.lastEndPos.index,
						this.state.startPos.index,
					),
				);
			}

			isLineTerminator() {
				return (
					this.eat(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.semi,
					) || this.canInsertSemicolon()
				);
			}

			// Consume a semicolon, or, failing that, see if we are allowed to

			// pretend that there is a semicolon at this position.
			semicolon() {
				if (!this.isLineTerminator()) {
					this.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_SEMI_OR_LINE_TERMINATOR,
					});
				}
			}

			// Expect a token of a given type. If found, consume it, otherwise,

			// raise an unexpected token error at given pos.
			expect(type, pos) {
				if (this.eat(type)) {
					return true;
				} else {
					this.unexpectedToken(pos, type);
					return false;
				}
			}

			expectOpening(open, close, name) {
				const pos = this.getPosition();
				const indent = this.state.indentLevel;
				this.expect(open);
				return {
					indent,
					start: pos,
					name,
					open,
					close,
				};
			}

			expectClosing(context) {
				if (this.match(context.close)) {
					this.next();
					return true;
				} else {
					const currPos = this.getPosition();

					this.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.EXPECTED_CLOSING(
							context.name,
							context.close.label,
							{
								filename: this.filename,
								start: currPos,
								end: currPos,
							},
						),
						start: context.start,
						end: context.start,
					});

					return false;
				}
			}

			// Raise an unexpected token error. Can take the expected token type

			// instead of a message string.
			unexpectedToken(pos, tokenType) {
				let expectedToken;
				let possibleShiftMistake = false;

				if (tokenType !== undefined) {
					expectedToken = tokenType.label;

					const possibleMistake = ___R$$priv$project$rome$$romejs$js$parser$parser_ts$TOKEN_MISTAKES[tokenType.label];
					possibleShiftMistake =
						possibleMistake !== undefined &&
						possibleMistake === this.state.tokenType.label;
				}

				this.addDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.JS_PARSER.UNEXPECTED_TOKEN(
						expectedToken,
						possibleShiftMistake,
					),
					start: pos === undefined ? this.state.startPos : pos,
					end: pos === undefined ? this.state.endPos : pos,
				});
			}

			unexpected() {
				throw new Error(
					"js-parser should never throw an exception, use addDiagnostic or unexpectedToken instead",
				);
			}

			tokenize() {
				throw new Error("js-parser does not use the parser-core tokenizer");
			}

			cloneNode(node) {
				if (
					node.leadingComments === undefined &&
					node.trailingComments === undefined &&
					node.innerComments === undefined
				) {
					return Object.assign({}, node);
				} else {
					return Object.assign(
						{},
						node,
						{
							leadingComments: undefined,
							trailingComments: undefined,
							innerComments: undefined,
						},
					);
				}
			}

			// Reset the start location of node to the start location of locationNode
			resetStartLocationFromNode(node, locationNode) {
				node.loc = Object.assign(
					{},
					this.getLoc(node),
					{start: this.getLoc(locationNode).start},
				);
			}

			next() {
				if (this.shouldCreateToken()) {
					this.createToken(this.state);
				}

				this.state.lastEndPos = this.state.endPos;
				this.state.lastStartPos = this.state.startPos;
				___R$project$rome$$romejs$js$parser$tokenizer$index_ts$nextToken(this);
			}

			eat(type) {
				if (this.match(type)) {
					this.next();
					return true;
				}

				return false;
			}

			match(type) {
				return this.state.tokenType === type;
			}

			lookaheadState() {
				const old = this.state;
				this.state = this.cloneState(true);

				this.isLookahead = true;
				this.next();
				this.isLookahead = false;

				const curr = this.state;
				this.state = old;
				return curr;
			}

			cloneState(skipArrays = false) {
				const state = Object.assign({}, this.state);

				for (const key in state) {
					// @ts-ignore
					let val = state[key];

					const shouldSlice = skipArrays === false || key === "context";
					if (shouldSlice && Array.isArray(val)) {
						// @ts-ignore
						state[key] = val.slice();
					}
				}

				const scopes = Object.assign({}, state.scopes);
				state.scopes = scopes;
				for (const type of ___R$$priv$project$rome$$romejs$js$parser$parser_ts$SCOPE_TYPES) {
					const scope = scopes[type];
					if (scope !== undefined) {
						scopes[type] = scope.slice();
					}
				}

				return state;
			}

			// Overrides ParserCore#getPosition
			getPosition() {
				return this.state.startPos;
			}

			// Overrides ParserCore#getLastEndPosition
			getLastEndPosition() {
				return this.state.lastEndPos;
			}

			// Private method to actually generate a Position
			getPositionFromState() {
				const {state} = this;
				return {
					index: state.index,
					line: state.curLine,
					column: ___R$project$rome$$romejs$ob1$index_ts$ob1Sub(
						state.index,
						state.lineStartIndex,
					),
				};
			}

			parse() {
				if (this.inModule) {
					this.pushScope("ASYNC", true);
					this.pushScope("STRICT", true);
				}

				const program = ___R$project$rome$$romejs$js$parser$parser$statement_ts$parseTopLevel(
					this,
				);

				if (this.inModule) {
					this.popScope("ASYNC");
					this.popScope("STRICT");
				}

				// Smoke test for unpopped scopes
				for (const type of ___R$$priv$project$rome$$romejs$js$parser$parser_ts$SCOPE_TYPES) {
					if (this.hasScope(type)) {
						throw new Error(
							"Finished parsing but there was still a " + type + " scope stack",
						);
					}
				}

				// Smoke test for token exhaustion
				if (
					!this.match(
						___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.eof,
					)
				) {
					throw new Error("Finish parsing but we arent at the end of the file");
				}

				return program;
			}
		}

		return JSParser;
	});




  // project-rome/@romejs/js-parser/index.ts
function ___R$project$rome$$romejs$js$parser$index_ts$parseJS(userOptions) {
		const options = ___R$project$rome$$romejs$js$parser$options_ts$normalizeOptions(
			userOptions,
		);
		return ___R$project$rome$$romejs$js$parser$parser_ts$createJSParser(options).parse();
	}

	function ___R$project$rome$$romejs$js$parser$index_ts$tokenizeJS(
		input,
		userOptions,
	) {
		const options = ___R$project$rome$$romejs$js$parser$options_ts$normalizeOptions(
			userOptions,
		);
		const parser = ___R$project$rome$$romejs$js$parser$parser_ts$createJSParser(
			Object.assign({}, options, {tokens: true, input}),
		);
		parser.parse();

		const diagnostics = parser.getDiagnostics();
		let tokens = parser.state.tokens;

		// If we have any diagnostics, then mark anything from the first as invalid
		if (diagnostics.length > 0) {
			const firstDiag = diagnostics[0];
			const invalidStart = firstDiag.location.start;
			const invalidEnd = firstDiag.location.end;
			if (invalidStart === undefined || invalidEnd === undefined) {
				throw new Error(
					"All parser diagnostics are expected to have a start/end",
				);
			}

			const invalidStartIndex = invalidStart.index;

			const invalidToken = {
				type: ___R$project$rome$$romejs$js$parser$tokenizer$types_ts$types.invalid,
				start: invalidStart.index,
				end: invalidEnd.index,
				loc: {
					filename: parser.filename,
					start: invalidStart,
					end: invalidEnd,
				},
			};

			// Remove all tokens after our invalid one
			tokens = tokens.filter((token) => {
				return token.loc.start.index >= invalidStartIndex;
			});

			tokens.push(invalidToken);
		}

		return tokens;
	}


  // project-rome/@romejs/js-formatter/builders/literals/StringLiteral.ts
function ___R$project$rome$$romejs$js$formatter$builders$literals$StringLiteral_ts$default(
		builder,
		node,
		parent,
	) {
		// JSX Attribute strings have ridiculous alternate semantics, should probably be a distinct AST node
		const quotes =
			parent.type === "JSXAttribute" || node.value.includes('"') ? "'" : '"';

		const value =
			parent.type === "JSXAttribute"
				? ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(
						node.value,
					)
				: node.value;

		return ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
			value,
			{quote: quotes},
		);
	}


  // project-rome/@romejs/js-formatter/builders/core/Directive.ts
function ___R$project$rome$$romejs$js$formatter$builders$core$Directive_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$builders$literals$StringLiteral_ts$default(
				builder,
				node,
				parent,
			),
			";",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/DoExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$DoExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"do",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.body, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/statements/DoWhileStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$DoWhileStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"do",
					___R$project$rome$$romejs$js$formatter$builders$utils_ts$printClause(
						builder,
						node.body,
						node,
					),
				]),
			),
			node.body.type === "BlockStatement"
				? ___R$project$rome$$romejs$js$formatter$tokens_ts$space
				: ___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
			"while",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"(",
			___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
							builder.tokenize(node.test, node),
						]),
					),
					___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
				]),
			),
			")",
			";",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/statements/EmptyStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$EmptyStatement_ts$default() {
		return ";";
	}


  // project-rome/@romejs/js-formatter/builders/modules/ExportAllDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportAllDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"export",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
		];

		if (node.exportKind === "type") {
			if (!builder.options.typeAnnotations) {
				return "";
			}

			tokens.push(
				"type",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		tokens.push(
			"*",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"from",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.source, node),
			";",
		);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ExportLocalDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportLocalDeclaration_ts$default(
		builder,
		node,
	) {
		if (node.exportKind === "type" && !builder.options.typeAnnotations) {
			return "";
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"export",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			___R$project$rome$$romejs$js$formatter$builders$modules$ExportLocalDeclaration_ts$printExportDeclaration(
				builder,
				node,
			),
		]);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportLocalDeclaration_ts$printExportDeclaration(
		builder,
		node,
	) {
		if (node.declaration) {
			const tokens = [builder.tokenize(node.declaration, node)];
			if (
				!___R$project$rome$$romejs$js$ast$utils$isDeclaration_ts$default(
					node.declaration,
				)
			) {
				tokens.push(";");
			}
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		} else {
			if (node.type !== "ExportLocalDeclaration") {
				throw new Error("Expected ExportLocalDeclaration");
			}

			const {specifiers} = node;
			if (specifiers === undefined) {
				throw new Error("Expected specifiers since there was no declaration");
			}

			const tokens = [];

			if (node.exportKind === "type") {
				tokens.push(
					"type",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				);
			}

			if (specifiers.length === 0) {
				if (
					___R$project$rome$$romejs$js$formatter$builders$comments_ts$hasInnerComments(
						node,
					)
				) {
					tokens.push(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							"{",
							builder.tokenizeInnerComments(node, true),
							___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
							"}",
						]),
					);
				} else {
					tokens.push("{}");
				}
			} else {
				tokens.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$group(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							"{",
							___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
								___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
									___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
									___R$project$rome$$romejs$js$formatter$builders$utils_ts$printCommaList(
										builder,
										specifiers,
										node,
									),
								]),
							),
							___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(","),
							___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
							"}",
						]),
					),
				);
			}

			tokens.push(";");

			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		}
	}


  // project-rome/@romejs/js-formatter/builders/modules/ExportDefaultDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportDefaultDeclaration_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"export",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"default",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			___R$project$rome$$romejs$js$formatter$builders$modules$ExportLocalDeclaration_ts$printExportDeclaration(
				builder,
				node,
			),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ExportDefaultSpecifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportDefaultSpecifier_ts$default(
		builder,
		node,
	) {
		return builder.tokenize(node.exported, node);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ImportDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ImportDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"import",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
		];

		if (node.importKind === "type" || node.importKind === "typeof") {
			tokens.push(node.importKind);
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		const {namedSpecifiers, defaultSpecifier, namespaceSpecifier} = node;

		if (
			namedSpecifiers.length > 0 ||
			namespaceSpecifier !== undefined ||
			defaultSpecifier !== undefined
		) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$builders$modules$ImportDeclaration_ts$printModuleSpecifiers(
					builder,
					node,
				),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"from",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		tokens.push(builder.tokenize(node.source, node), ";");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
		);
	}

	function ___R$project$rome$$romejs$js$formatter$builders$modules$ImportDeclaration_ts$printModuleSpecifiers(
		builder,
		node,
	) {
		const {namedSpecifiers, defaultSpecifier, namespaceSpecifier} = node;

		const groups = [];

		if (defaultSpecifier !== undefined) {
			groups.push(builder.tokenize(node.defaultSpecifier, node));
		}

		if (namespaceSpecifier !== undefined) {
			groups.push(builder.tokenize(node.namespaceSpecifier, node));
		}

		if (namedSpecifiers.length > 0) {
			const specifiers = [];

			for (const specifier of namedSpecifiers) {
				specifiers.push(builder.tokenize(specifier, node));
			}

			if (specifiers.length === 1) {
				// Do not create insert softline tokens when there is a single specifier
				// in order to keep the braces on the same line.
				groups.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						"{",
						specifiers[0],
						"}",
					]),
				);
			} else {
				groups.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						"{",
						___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
							___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
								___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
								___R$project$rome$$romejs$js$formatter$tokens_ts$join(
									___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
										",",
										___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
									]),
									specifiers,
								),
							]),
						),
						___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(","),
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						"}",
					]),
				);
			}
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$join(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				",",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			]),
			groups,
		);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ExportExternalDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportExternalDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"export",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
		];

		if (node.exportKind === "type") {
			if (!builder.options.typeAnnotations) {
				return "";
			}

			tokens.push(
				"type",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		tokens.push(
			___R$project$rome$$romejs$js$formatter$builders$modules$ImportDeclaration_ts$printModuleSpecifiers(
				builder,
				node,
			),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"from",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.source, node),
			";",
		);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ExportLocalSpecifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportLocalSpecifier_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.local, node)];

		if (node.local.name === node.exported.name) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"as",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.exported, node),
			]);
		}
	}


  // project-rome/@romejs/js-formatter/builders/modules/ExportExternalSpecifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportExternalSpecifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$modules$ExportLocalSpecifier_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ExportNamespaceSpecifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ExportNamespaceSpecifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"*",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"as",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.exported, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/statements/ExpressionStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$ExpressionStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.expression, node),
			";",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/statements/ForInStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$ForInStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"for",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"(",
				builder.tokenize(node.left, node),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"in",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.right, node),
				")",
				___R$project$rome$$romejs$js$formatter$builders$utils_ts$printClause(
					builder,
					node.body,
					node,
				),
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/statements/ForOfStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$ForOfStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"for",
				node.await
					? ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$space,
							"await",
						])
					: "",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"(",
				builder.tokenize(node.left, node),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"of",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.right, node),
				")",
				___R$project$rome$$romejs$js$formatter$builders$utils_ts$printClause(
					builder,
					node.body,
					node,
				),
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/statements/ForStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$ForStatement_ts$default(
		builder,
		node,
	) {
		const body = ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printClause(
			builder,
			node.body,
			node,
		);

		if (!node.init && !node.test && !node.update) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"for",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					"(;;)",
					body,
				]),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"for",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"(",
				___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
							___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
								___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
								builder.tokenize(node.init, node),
								";",
								___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
								builder.tokenize(node.test, node),
								";",
								___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
								builder.tokenize(node.update, node),
							]),
						),
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
					]),
				),
				")",
				body,
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/FunctionExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$FunctionExpression_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.head.async === true) {
			tokens.push("async");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		tokens.push("function");

		if (node.head.generator === true) {
			tokens.push("*");
		}

		if (node.id) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.id, node),
			);
		}

		tokens.push(
			builder.tokenize(node.head, node),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.body, node),
		);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/statements/FunctionDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$FunctionDeclaration_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$expressions$FunctionExpression_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/FunctionHead.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$FunctionHead_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (builder.options.typeAnnotations && node.typeParameters) {
			tokens.push(builder.tokenize(node.typeParameters, node));
		}

		const printedParameters = ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printBindingPatternParams(
			builder,
			node,
			node.params,
			node.rest,
		);

		let printedReturnType = "";
		if (builder.options.typeAnnotations) {
			if (node.returnType) {
				const tokens = [":"];
				tokens.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					builder.tokenize(node.returnType, node),
				);
				printedReturnType = ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(
					tokens,
				);
			}
		}

		tokens.push(
			___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					printedParameters,
					printedReturnType,
				]),
			),
		);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/statements/IfStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$IfStatement_ts$default(
		builder,
		node,
	) {
		const tokens = [
			___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"if",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					"(",
					___R$project$rome$$romejs$js$formatter$tokens_ts$group(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
								___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
									___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
									builder.tokenize(node.test, node),
								]),
							),
							___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						]),
					),
					")",
				]),
			),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
		];

		let needsBlock = false;
		if (node.alternate) {
			needsBlock =
				___R$$priv$project$rome$$romejs$js$formatter$builders$statements$IfStatement_ts$getLastStatement(
					node.consequent,
				).type === "IfStatement";
		}

		if (needsBlock) {
			tokens.push(
				"{",
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
						builder.tokenize(node.consequent, node),
					]),
				),
				___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
				"}",
			);
		} else {
			tokens.push(builder.tokenize(node.consequent, node));
		}

		if (node.alternate) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"else",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.alternate, node),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}

	// Recursively get the last statement.
	function ___R$$priv$project$rome$$romejs$js$formatter$builders$statements$IfStatement_ts$getLastStatement(
		statement,
	) {
		if (
			(statement.type === "WithStatement" ||
			statement.type === "WhileStatement" ||
			statement.type === "DoWhileStatement" ||
			statement.type === "ForOfStatement" ||
			statement.type === "ForInStatement" ||
			statement.type === "ForStatement") &&
			___R$project$rome$$romejs$js$ast$utils$isStatement_ts$default(
				statement.body,
			)
		) {
			return ___R$$priv$project$rome$$romejs$js$formatter$builders$statements$IfStatement_ts$getLastStatement(
				statement.body,
			);
		} else {
			return statement;
		}
	}


  // project-rome/@romejs/js-formatter/builders/modules/ImportCall.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ImportCall_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"import(",
			builder.tokenize(node.argument, node),
			")",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ImportDefaultSpecifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ImportDefaultSpecifier_ts$default(
		builder,
		node,
	) {
		return builder.tokenize(node.local.name, node);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ImportNamespaceSpecifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ImportNamespaceSpecifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"*",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"as",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.local.name, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ImportSpecifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ImportSpecifier_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		tokens.push(builder.tokenize(node.imported, node));

		if (node.local.name.name !== node.imported.name) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"as",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.local.name, node),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/modules/ImportSpecifierLocal.ts
function ___R$project$rome$$romejs$js$formatter$builders$modules$ImportSpecifierLocal_ts$default(
		builder,
		node,
	) {
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-formatter/builders/core/InterpreterDirective.ts
function ___R$project$rome$$romejs$js$formatter$builders$core$InterpreterDirective_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"#!" + node.value,
			___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
			___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
		]);
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXAttribute.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXAttribute_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.name, node)];

		if (node.value) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
				"=",
				builder.tokenize(node.value, node),
			]);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		}
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXElement.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXElement_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"<",
			builder.tokenize(node.name, node),
			builder.tokenize(node.typeArguments, node),
		];

		if (node.attributes.length > 0) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				___R$project$rome$$romejs$js$formatter$tokens_ts$join(
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
					node.attributes.map((attr) => builder.tokenize(attr, node)),
				),
			);
		}

		if (node.selfClosing === true && node.children.length === 0) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					"/>",
				]),
			);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
						">",
					]),
				),
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat(
						node.children.map((child) => builder.tokenize(child, node)),
					),
				),
				"</",
				builder.tokenize(node.name, node),
				">",
			]);
		}
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXEmptyExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXEmptyExpression_ts$default(
		builder,
		node,
	) {
		return builder.tokenizeInnerComments(node, false);
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXExpressionContainer.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXExpressionContainer_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"{",
			builder.tokenize(node.expression, node),
			"}",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXFragment.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXFragment_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"<>",
			___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(
					node.children.map((child) => builder.tokenize(child, node)),
				),
			),
			"</>",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXIdentifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXIdentifier_ts$default(
		builder,
		node,
	) {
		return node.name;
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXMemberExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXMemberExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.object, node),
			".",
			builder.tokenize(node.property, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXNamespacedName.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXNamespacedName_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.namespace, node),
			":",
			builder.tokenize(node.name, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXReferenceIdentifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXReferenceIdentifier_ts$default(
		builder,
		node,
	) {
		return node.name;
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXSpreadAttribute.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXSpreadAttribute_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"{",
			"...",
			builder.tokenize(node.argument, node),
			"}",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXSpreadChild.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXSpreadChild_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"{",
			"...",
			builder.tokenize(node.expression, node),
			"}",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/jsx/JSXText.ts
function ___R$project$rome$$romejs$js$formatter$builders$jsx$JSXText_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$parser$xhtmlEntities_ts$escapeXHTMLEntities(
			node.value,
		);
	}


  // project-rome/@romejs/js-formatter/builders/statements/LabeledStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$LabeledStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.label, node),
			":",
			node.body.type === "EmptyStatement"
				? ";"
				: ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$space,
						builder.tokenize(node.body, node),
					]),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/LogicalExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$LogicalExpression_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$expressions$BinaryExpression_ts$default(
			builder,
			node,
			parent,
		);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/MemberExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$MemberExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.object, node),
			builder.tokenize(node.property, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/MetaProperty.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$MetaProperty_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.meta, node),
			".",
			builder.tokenize(node.property, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/temp/MockParent.ts
function ___R$project$rome$$romejs$js$formatter$builders$temp$MockParent_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-formatter/builders/expressions/NewExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$NewExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"new",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			___R$project$rome$$romejs$js$formatter$builders$expressions$CallExpression_ts$default(
				builder,
				node,
			),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/literals/NullLiteral.ts
function ___R$project$rome$$romejs$js$formatter$builders$literals$NullLiteral_ts$default() {
		return "null";
	}


  // project-rome/@romejs/js-formatter/builders/literals/NumericLiteral.ts
function ___R$project$rome$$romejs$js$formatter$builders$literals$NumericLiteral_ts$default(
		builder,
		node,
	) {
		if (builder.options.format === "pretty") {
			if (node.format === undefined) {
				return ___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
					node.value,
				);
			} else {
				switch (node.format) {
					case "binary":
						return "0b" + node.value.toString(2);
					case "octal":
						return "0o" + node.value.toString(8);
					case "hex":
						return "0x" + node.value.toString(16);
				}
			}
		} else {
			return String(node.value);
		}
	}


  // project-rome/@romejs/js-formatter/builders/objects/ObjectMethod.ts
function ___R$project$rome$$romejs$js$formatter$builders$objects$ObjectMethod_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printMethod(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/OptionalCallExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$OptionalCallExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$expressions$CallExpression_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/patterns/PatternMeta.ts
function ___R$project$rome$$romejs$js$formatter$builders$patterns$PatternMeta_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-formatter/builders/classes/PrivateName.ts
function ___R$project$rome$$romejs$js$formatter$builders$classes$PrivateName_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"#",
			builder.tokenize(node.id, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/core/Program.ts
function ___R$project$rome$$romejs$js$formatter$builders$core$Program_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenizeStatementList(node.directives, node)];

		if (node.directives && node.directives.length) {
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$hardline);
		}

		if (node.interpreter && builder.options.allowInterpreterDirective) {
			tokens.push(builder.tokenize(node.interpreter, node));
		}

		tokens.push(
			builder.tokenizeInnerComments(node, false),
			builder.tokenizeStatementList(node.body, node),
		);

		tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$hardline);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/ReferenceIdentifier.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$ReferenceIdentifier_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$auxiliary$Identifier_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpAlternation.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpAlternation_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.left, node),
			"|",
			builder.tokenize(node.right, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpAnyCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpAnyCharacter_ts$default() {
		return ".";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpCharacter_ts$default(
		builder,
		node,
		parent,
	) {
		const isInCharSet = parent.type === "RegExpCharSet";
		if (isInCharSet) {
			switch (node.value) {
				case "$":
				case "^":
				case ".":
				case "?":
				case "{":
				case "}":
				case "+":
				case "*":
				case "[":
				case "]":
				case "(":
				case ")":
				case "|":
					return node.value;

				case "-":
					return "\\-";
			}
		}

		switch (node.value) {
			case "\t":
				return "\\t";

			case "\n":
				return "\\n";

			case "\r":
				return "\\r";

			case "\x0b":
				return "\\v";

			case "\f":
				return "\\f";

			case "\b":
				return "\\b";

			case "/":
			case "\\":
			case "$":
			case "^":
			case ".":
			case "?":
			case "{":
			case "}":
			case "+":
			case "*":
			case "[":
			case "]":
			case "(":
			case ")":
			case "|":
				return "\\" + node.value;

			default:
				return ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
					node.value,
					{json: true, unicodeOnly: true},
				);
		}
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpCharSet.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpCharSet_ts$default(
		builder,
		node,
	) {
		const tokens = ["["];

		if (node.invert) {
			tokens.push("^");
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(
				node.body.map((item) => builder.tokenize(item, node)),
			),
			"]",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpCharSetRange.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpCharSetRange_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.start, node),
			"-",
			builder.tokenize(node.end, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpControlCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpControlCharacter_ts$default() {
		throw new Error("unimplemented");
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpDigitCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpDigitCharacter_ts$default() {
		return "\\d";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpEndCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpEndCharacter_ts$default() {
		return "$";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpGroupCapture.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpGroupCapture_ts$default(
		builder,
		node,
	) {
		const tokens = ["("];

		if (node.name !== undefined) {
			tokens.push("?<");
			tokens.push(node.name);
			tokens.push(">");
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			builder.tokenize(node.expression, node),
			")",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpGroupNonCapture.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpGroupNonCapture_ts$default(
		builder,
		node,
	) {
		const tokens = ["(?"];

		switch (node.kind) {
			case "positive-lookahead": {
				tokens.push("=");
				break;
			}

			case "negative-lookahead": {
				tokens.push("!");
				break;
			}

			case "positive-lookbehind": {
				tokens.push("<!");
				break;
			}

			case "negative-lookbehind": {
				tokens.push("<=");
				break;
			}

			default: {
				tokens.push(":");
				break;
			}
		}

		tokens.push(builder.tokenize(node.expression, node));
		tokens.push(")");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/literals/RegExpLiteral.ts
function ___R$project$rome$$romejs$js$formatter$builders$literals$RegExpLiteral_ts$default(
		builder,
		node,
	) {
		const flags = [];

		if (node.global === true) {
			flags.push("g");
		}

		if (node.multiline === true) {
			flags.push("m");
		}

		if (node.sticky === true) {
			flags.push("y");
		}

		if (node.insensitive === true) {
			flags.push("i");
		}

		if (node.noDotNewline === true) {
			flags.push("s");
		}

		if (node.unicode === true) {
			flags.push("u");
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"/",
			builder.tokenize(node.expression, node),
			"/",
			flags.join(""),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpNamedBackReference.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNamedBackReference_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"\\k",
			"<",
			node.name,
			">",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpNonDigitCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNonDigitCharacter_ts$default() {
		return "\\D";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpNonWhiteSpaceCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNonWhiteSpaceCharacter_ts$default() {
		return "\\S";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpNonWordBoundaryCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNonWordBoundaryCharacter_ts$default() {
		return "\\B";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpNonWordCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNonWordCharacter_ts$default() {
		return "\\W";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpNumericBackReference.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNumericBackReference_ts$default(
		builder,
		node,
	) {
		return "\\" + node.value;
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpQuantified.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpQuantified_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.target, node)];

		if (node.min === 0 && node.max === 1) {
			tokens.push("?");
		} else if (node.min === 0 && node.max === undefined) {
			tokens.push("*");
		} else if (node.min === 1 && node.max === undefined) {
			tokens.push("+");
		} else {
			tokens.push("{");

			tokens.push(String(node.min));

			if (node.min !== node.max) {
				tokens.push(",");
				if (node.max !== undefined) {
					tokens.push(String(node.max));
				}
			}

			tokens.push("}");
		}

		if (node.lazy) {
			tokens.push("?");
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpStartCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpStartCharacter_ts$default() {
		return "^";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpSubExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpSubExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(
			node.body.map((item) => builder.tokenize(item, node)),
		);
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpWhiteSpaceCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpWhiteSpaceCharacter_ts$default() {
		return "\\s";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpWordBoundaryCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpWordBoundaryCharacter_ts$default() {
		return "\\b";
	}


  // project-rome/@romejs/js-formatter/builders/regex/RegExpWordCharacter.ts
function ___R$project$rome$$romejs$js$formatter$builders$regex$RegExpWordCharacter_ts$default() {
		return "\\w";
	}


  // project-rome/@romejs/js-formatter/builders/statements/ReturnStatement.ts
const ___R$project$rome$$romejs$js$formatter$builders$statements$ReturnStatement_ts$default = ___R$project$rome$$romejs$js$formatter$builders$utils_ts$buildThrowAndReturnStatementBuilder(
		"return",
	);


  // project-rome/@romejs/js-formatter/builders/expressions/SequenceExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$SequenceExpression_ts$default(
		builder,
		node,
		parent,
	) {
		if (
			parent.type === "ExpressionStatement" ||
			parent.type === "ForStatement" ||
			parent.type === "SequenceExpression"
		) {
			// Indent expressions after the first to improve the readability
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat(
					node.expressions.map((expr, i) =>
						i === 0
							? builder.tokenize(expr, node)
							: ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
									",",
									___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
										___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
											___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
											builder.tokenize(expr, node),
										]),
									),
								])
					),
				),
			);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$join(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						",",
						___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
					]),
					node.expressions.map((expr) => builder.tokenize(expr, node)),
				),
			);
		}
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/SpreadElement.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$SpreadElement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"...",
			builder.tokenize(node.argument, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/objects/SpreadProperty.ts
function ___R$project$rome$$romejs$js$formatter$builders$objects$SpreadProperty_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"...",
			builder.tokenize(node.argument, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/StaticMemberProperty.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$StaticMemberProperty_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.optional) {
			tokens.push("?");
		}

		tokens.push(".", builder.tokenize(node.value, node));

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/objects/StaticPropertyKey.ts
function ___R$project$rome$$romejs$js$formatter$builders$objects$StaticPropertyKey_ts$default(
		builder,
		node,
	) {
		return builder.tokenize(node.value, node);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/Super.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$Super_ts$default() {
		return "super";
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/SwitchCase.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$SwitchCase_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.test) {
			tokens.push(
				"case",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.test, node),
				":",
			);
		} else {
			tokens.push("default", ":");
		}

		const {consequent} = node;
		if (consequent.length === 1 && consequent[0].type === "BlockStatement") {
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(consequent[0], node));
		} else if (consequent.length > 0) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
						builder.tokenizeStatementList(consequent, node),
					]),
				),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/statements/SwitchStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$SwitchStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"switch",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					"(",
					___R$project$rome$$romejs$js$formatter$tokens_ts$group(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
								___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
									___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
									builder.tokenize(node.discriminant, node),
								]),
							),
							___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						]),
					),
					")",
				]),
			),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"{",
			node.cases.length > 0
				? ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
							builder.tokenizeStatementList(node.cases, node),
						]),
					)
				: "",
			___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
			"}",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/TaggedTemplateExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$TaggedTemplateExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.tag, node),
			builder.tokenize(node.quasi, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/TemplateElement.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$TemplateElement_ts$default(
		builder,
		node,
		parent,
	) {
		parent = ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.assert(
			parent,
		);

		const isFirst = parent.quasis[0] === node;
		const isLast = parent.quasis[parent.quasis.length - 1] === node;

		const value = (isFirst ? "`" : "}") + node.raw + (isLast ? "`" : "${");
		return value;
	}


  // project-rome/@romejs/js-formatter/builders/literals/TemplateLiteral.ts
function ___R$project$rome$$romejs$js$formatter$builders$literals$TemplateLiteral_ts$default(
		builder,
		node,
	) {
		const tokens = [];
		const quasis = node.quasis;

		for (let i = 0; i < quasis.length; i++) {
			tokens.push(builder.tokenize(quasis[i], node));

			if (i + 1 < quasis.length) {
				tokens.push(builder.tokenize(node.expressions[i], node));
			}
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/ThisExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$ThisExpression_ts$default() {
		return "this";
	}


  // project-rome/@romejs/js-formatter/builders/statements/ThrowStatement.ts
const ___R$project$rome$$romejs$js$formatter$builders$statements$ThrowStatement_ts$default = ___R$project$rome$$romejs$js$formatter$builders$utils_ts$buildThrowAndReturnStatementBuilder(
		"throw",
	);


  // project-rome/@romejs/js-formatter/builders/statements/TryStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$TryStatement_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"try",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.block, node),
		];

		if (node.handler) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.handler, node),
			);
		}

		if (node.finalizer) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"finally",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.finalizer, node),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSAnyKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSAnyKeywordTypeAnnotation_ts$default() {
		return "any";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSArrayType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSArrayType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.elementType, node),
			"[]",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSAsExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSAsExpression_ts$default(
		builder,
		node,
	) {
		if (builder.options.typeAnnotations) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				builder.tokenize(node.expression, node),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"as",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			]);
		} else {
			return builder.tokenize(node.expression, node);
		}
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSAssignmentAsExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSAssignmentAsExpression_ts$default(
		builder,
		node,
	) {
		if (builder.options.typeAnnotations) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				builder.tokenize(node.expression, node),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"as",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			]);
		} else {
			return builder.tokenize(node.expression, node);
		}
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSAssignmentNonNullExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSAssignmentNonNullExpression_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.expression, node),
			"!",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSAssignmentTypeAssertion.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSAssignmentTypeAssertion_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"<",
			builder.tokenize(node.typeAnnotation, node),
			">",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.expression, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSBigIntKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSBigIntKeywordTypeAnnotation_ts$default() {
		return "bigint";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSBooleanKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSBooleanKeywordTypeAnnotation_ts$default() {
		return "boolean";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSBooleanLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSBooleanLiteralTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return node.value ? "true" : "false";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSCallSignatureDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSCallSignatureDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.meta, node)];

		if (node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		tokens.push(";");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSConditionalType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSConditionalType_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$printConditionalExpression(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				builder.tokenize(node.checkType, node),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"extends",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.extendsType, node),
			]),
			builder.tokenize(node.trueType, node),
			builder.tokenize(node.falseType, node),
			parent,
			node.trueType,
			node.falseType,
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSConstructorType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSConstructorType_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"new",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.meta, node),
		];

		if (node.typeAnnotation) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"=>",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSConstructSignatureDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSConstructSignatureDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [
			"new",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.meta, node),
		];

		if (node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		tokens.push(";");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSDeclareFunction.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSDeclareFunction_ts$default(
		builder,
		node,
	) {
		let tokens = [];

		if (node.declare) {
			tokens.push(
				"declare",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			"function",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			builder.tokenize(node.head, node),
			";",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSDeclareMethod.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSDeclareMethod_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.meta, node),
			builder.tokenize(node.key, node),
			___R$project$rome$$romejs$js$formatter$builders$utils_ts$printMethod(
				builder,
				node,
			),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSEmptyKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSEmptyKeywordTypeAnnotation_ts$default() {
		return "empty";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSEnumDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSEnumDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.declare) {
			tokens.push(
				"declare",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		if (node.const) {
			tokens.push(
				"const",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		tokens.push(
			"enum",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			___R$project$rome$$romejs$js$formatter$builders$utils_ts$printTSBraced(
				builder,
				node,
				node.members,
			),
		);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSEnumMember.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSEnumMember_ts$default(
		builder,
		node,
	) {
		const tokens = [builder.tokenize(node.id, node)];

		if (node.initializer) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"=",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.initializer, node),
			);
		}

		tokens.push(",");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSExportAssignment.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSExportAssignment_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"export",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"=",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.expression, node),
			";",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSExpressionWithTypeArguments.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSExpressionWithTypeArguments_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.expression, node),
			builder.tokenize(node.typeParameters, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSExternalModuleReference.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSExternalModuleReference_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"require(",
			builder.tokenize(node.expression, node),
			")",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSFunctionType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSFunctionType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				builder.tokenize(node.meta, node),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"=>",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSImportEqualsDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSImportEqualsDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];
		if (node.isExport) {
			tokens.push("export");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		tokens.push(
			"import",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"=",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.moduleReference, node),
			";",
		);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSImportType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSImportType_ts$default(
		builder,
		node,
	) {
		const tokens = ["import(", builder.tokenize(node.argument, node), ")"];

		if (node.qualifier) {
			tokens.push(".", builder.tokenize(node.qualifier, node));
		}

		if (node.typeParameters) {
			tokens.push(builder.tokenize(node.typeParameters, node));
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSIndexedAccessType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSIndexedAccessType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.objectType, node),
			"[",
			builder.tokenize(node.indexType, node),
			"]",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSIndexSignature.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSIndexSignature_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.readonly) {
			tokens.push("readonly");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			"[",
			builder.tokenize(node.key, node),
			"]",
			":",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.typeAnnotation, node),
			";",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSInferType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSInferType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"infer",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.typeParameter, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSInterfaceBody.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSInterfaceBody_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printTSBraced(
			builder,
			node,
			node.body,
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSInterfaceDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSInterfaceDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.declare) {
			tokens.push(
				"declare",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		tokens.push(
			"interface",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			builder.tokenize(node.typeParameters, node),
		);

		if (node.extends) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"extends",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				___R$project$rome$$romejs$js$formatter$builders$utils_ts$printCommaList(
					builder,
					node.extends,
					node,
				),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.body, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSIntersectionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSIntersectionTypeAnnotation_ts$default(
		builder,
		node,
	) {
		const parts = [];
		let shouldIndent = false;
		let previous;

		for (let i = 0; i < node.types.length; i++) {
			const type = node.types[i];
			const printed = builder.tokenize(type, node);

			if (previous === undefined) {
				parts.push(printed);
			} else if (
				___R$$priv$project$rome$$romejs$js$formatter$builders$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
					previous,
				) &&
				___R$$priv$project$rome$$romejs$js$formatter$builders$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
					type,
				)
			) {
				//   let foo: {
				//     a: string;
				//     b: string;
				//   } & {
				//     c: string;
				//     d: string;
				//   };
				parts.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					"&",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					shouldIndent
						? ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(printed)
						: printed,
				);
			} else if (
				!___R$$priv$project$rome$$romejs$js$formatter$builders$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
					previous,
				) &&
				!___R$$priv$project$rome$$romejs$js$formatter$builders$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
					type,
				)
			) {
				//   let foo: XXXX &
				//     YYYY &&
				//     ZZZZ;
				parts.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$space,
							"&",
							___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
							printed,
						]),
					),
				);
			} else {
				//   let z: AAA & {
				//     a: string;
				//     b: string;
				//   } & BBB &
				//     CCC & {
				//       c: string;
				//       d: string;
				//     };
				if (i > 1) {
					shouldIndent = true;
				}

				parts.push(
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					"&",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					shouldIndent
						? ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(printed)
						: printed,
				);
			}

			previous = type;
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(parts),
		);
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$builders$typescript$TSIntersectionTypeAnnotation_ts$isObjectType(
		node,
	) {
		return node.type === "TSMappedType" || node.type === "TSTypeLiteral";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSMappedType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSMappedType_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.readonly) {
			tokens.push(
				___R$$priv$project$rome$$romejs$js$formatter$builders$typescript$TSMappedType_ts$tokenIfPlusMinus(
					builder,
					node.readonly,
				),
				"readonly",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		const {typeParameter} = node;
		tokens.push(
			"[",
			typeParameter.name,
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"in",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(typeParameter.constraint, typeParameter),
			"]",
		);

		if (node.optional) {
			tokens.push(
				___R$$priv$project$rome$$romejs$js$formatter$builders$typescript$TSMappedType_ts$tokenIfPlusMinus(
					builder,
					node.optional,
				),
				"?",
			);
		}

		if (node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"{",
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
					]),
				),
				___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
				"}",
			]),
		);
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$builders$typescript$TSMappedType_ts$tokenIfPlusMinus(
		builder,
		token,
	) {
		switch (token) {
			case "+":
			case "-":
				return token;

			default:
				return "";
		}
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSMethodSignature.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSMethodSignature_ts$default(
		builder,
		node,
	) {
		const tokens = [
			builder.tokenize(node.key, node),
			builder.tokenize(node.meta, node),
		];

		if (node.returnType) {
			tokens.push(":");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
			tokens.push(builder.tokenize(node.returnType, node));
		}

		tokens.push(";");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSMixedKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSMixedKeywordTypeAnnotation_ts$default() {
		return "mixed";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSModuleBlock.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSModuleBlock_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"{",
			___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
					builder.tokenizeStatementList(node.body, node),
				]),
			),
			___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
			"}",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSModuleDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSModuleDeclaration_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.declare) {
			tokens.push("declare");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		if (!node.global) {
			tokens.push(node.id.type === "BindingIdentifier" ? "namespace" : "module");
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$space);
		}

		tokens.push(builder.tokenize(node.id, node));

		if (!node.body) {
			tokens.push(";");
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		}

		let body = node.body;
		while (body !== undefined && body.type === "TSModuleDeclaration") {
			tokens.push(".", builder.tokenize(body.id, body));
			body = body.body;
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(body, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSNamespaceExportDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSNamespaceExportDeclaration_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"export",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"as",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"namespace",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.id, node),
			";",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSNeverKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSNeverKeywordTypeAnnotation_ts$default() {
		return "never";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSNonNullExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSNonNullExpression_ts$default(
		builder,
		node,
	) {
		const expr = builder.tokenize(node.expression, node);

		if (builder.options.typeAnnotations) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([expr, "!"]);
		} else {
			return expr;
		}
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSNullKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSNullKeywordTypeAnnotation_ts$default() {
		return "null";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSNumberKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSNumberKeywordTypeAnnotation_ts$default() {
		return "number";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSNumericLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSNumericLiteralTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return String(node.value);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSObjectKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSObjectKeywordTypeAnnotation_ts$default() {
		return "object";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSOptionalType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSOptionalType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.typeAnnotation, node),
			"?",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSParenthesizedType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSParenthesizedType_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"(",
			builder.tokenize(node.typeAnnotation, node),
			")",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSPropertySignature.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSPropertySignature_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.readonly) {
			tokens.push(
				"readonly",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		tokens.push(builder.tokenize(node.key, node));

		if (node.optional) {
			tokens.push("?");
		}

		if (node.typeAnnotation) {
			tokens.push(
				":",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		tokens.push(";");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSQualifiedName.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSQualifiedName_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.left, node),
			".",
			builder.tokenize(node.right, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSSignatureDeclarationMeta.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSSignatureDeclarationMeta_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.typeParameters, node),
			___R$project$rome$$romejs$js$formatter$builders$utils_ts$printBindingPatternParams(
				builder,
				node,
				node.parameters,
				node.rest,
			),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSStringKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSStringKeywordTypeAnnotation_ts$default() {
		return "string";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSStringLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSStringLiteralTypeAnnotation_ts$default(
		builder,
		node,
		parent,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$literals$StringLiteral_ts$default(
			builder,
			node,
			parent,
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSSymbolKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSSymbolKeywordTypeAnnotation_ts$default() {
		return "symbol";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTemplateLiteralTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTemplateLiteralTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
			node.value,
			{quote: "`"},
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSThisType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSThisType_ts$default() {
		return "this";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTupleType.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTupleType_ts$default(
		builder,
		node,
	) {
		if (node.elementTypes.length === 0 && node.rest === undefined) {
			if (
				___R$project$rome$$romejs$js$formatter$builders$comments_ts$hasInnerComments(
					node,
				)
			) {
				return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"[",
					builder.tokenizeInnerComments(node, true),
					___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
					"]",
				]);
			} else {
				return "[]";
			}
		}

		const parts = [];

		for (const elementType of node.elementTypes) {
			parts.push(builder.tokenize(elementType, node));
		}

		if (node.rest !== undefined) {
			parts.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"...",
					builder.tokenize(node.rest, node),
				]),
			);
		}

		const tokens = [
			"[",
			___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
					___R$project$rome$$romejs$js$formatter$tokens_ts$join(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							",",
							___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
						]),
						parts,
					),
				]),
			),
		];

		if (node.rest === undefined) {
			tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(","));
		}

		tokens.push(___R$project$rome$$romejs$js$formatter$tokens_ts$softline, "]");

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypeAssertion.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeAssertion_ts$default(
		builder,
		node,
	) {
		if (builder.options.typeAnnotations) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$group(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							"<",
							___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
								___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
									___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
									builder.tokenize(node.typeAnnotation, node),
								]),
							),
							___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
							">",
						]),
					),
					builder.tokenize(node.expression, node),
				]),
			);
		} else {
			return builder.tokenize(node.expression, node);
		}
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypeLiteral.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeLiteral_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printTSBraced(
			builder,
			node,
			node.members,
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypeOperator.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeOperator_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			node.operator,
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.typeAnnotation, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypeParameter.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeParameter_ts$default(
		builder,
		node,
	) {
		const tokens = [node.name];

		if (node.constraint) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"extends",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.constraint, node),
			);
		}

		if (node.default) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"=",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.default, node),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypeParameterDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeParameterDeclaration_ts$default(
		builder,
		node,
	) {
		const params = node.params;
		const shouldInline =
			params.length === 1 &&
			params[0].type !== "TSIntersectionTypeAnnotation" &&
			params[0].type !== "UnionTypeAnnotation" &&
			params[0].type !== "TSIndexedAccessType" &&
			params[0].type !== "TSMappedType";

		if (shouldInline) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"<",
				builder.tokenize(params[0], node),
				">",
			]);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					"<",
					___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
							___R$project$rome$$romejs$js$formatter$builders$utils_ts$printCommaList(
								builder,
								params,
								node,
							),
						]),
					),
					___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
					">",
				]),
			);
		}
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypeParameterInstantiation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeParameterInstantiation_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeParameterDeclaration_ts$default(
			builder,
			node,
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypePredicate.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypePredicate_ts$default(
		builder,
		node,
	) {
		const tokens = [];

		if (node.asserts) {
			tokens.push(
				"asserts",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		tokens.push(builder.tokenize(node.parameterName, node));

		if (node.typeAnnotation) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"is",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.typeAnnotation, node),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypeQuery.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeQuery_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"typeof",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			builder.tokenize(node.exprName, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TSTypeReference.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeReference_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			builder.tokenize(node.typeName, node),
			builder.tokenize(node.typeParameters, node),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/TypeAliasTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$TypeAliasTypeAnnotation_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"type",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.id, node),
				builder.tokenize(node.typeParameters, node),
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"=",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.right, node),
				";",
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/UnaryExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$UnaryExpression_ts$default(
		builder,
		node,
	) {
		if (
			node.operator === "void" ||
			node.operator === "delete" ||
			node.operator === "typeof"
		) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				node.operator,
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.argument, node),
			]);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				node.operator,
				builder.tokenize(node.argument, node),
			]);
		}
	}


  // project-rome/@romejs/js-formatter/builders/typescript/UndefinedKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$UndefinedKeywordTypeAnnotation_ts$default() {
		return "undefined";
	}


  // project-rome/@romejs/js-formatter/builders/typescript/UnionTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$UnionTypeAnnotation_ts$default(
		builder,
		node,
		parent,
	) {
		// Indentation may be handled by the parent node
		const shouldIndent =
			parent.type !== "TSTypeAssertion" &&
			parent.type !== "TSTypeParameterDeclaration" &&
			parent.type !== "TSTypeParameterInstantiation";

		const printed = ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$ifBreak(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					shouldIndent
						? ___R$project$rome$$romejs$js$formatter$tokens_ts$hardline
						: "",
					"|",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				]),
			),
			___R$project$rome$$romejs$js$formatter$tokens_ts$join(
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
					"|",
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				]),
				node.types.map((type) =>
					___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						builder.tokenize(type, node),
					)
				),
			),
		]);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			shouldIndent
				? ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(printed)
				: printed,
		);
	}


  // project-rome/@romejs/js-formatter/builders/typescript/UnknownKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$UnknownKeywordTypeAnnotation_ts$default() {
		return "unknown";
	}


  // project-rome/@romejs/js-formatter/builders/expressions/UpdateExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$UpdateExpression_ts$default(
		builder,
		node,
	) {
		if (node.prefix === true) {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				node.operator,
				builder.tokenize(node.argument, node),
			]);
		} else {
			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				builder.tokenize(node.argument, node),
				node.operator,
			]);
		}
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/VariableDeclaration.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$VariableDeclaration_ts$default(
		builder,
		node,
	) {
		const declarations = node.declarations.map((declaration) =>
			builder.tokenize(declaration, node)
		);

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				node.kind,
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				declarations.shift(),
				___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat(
						declarations.map((declaration) =>
							___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
								",",
								___R$project$rome$$romejs$js$formatter$tokens_ts$lineOrSpace,
								declaration,
							])
						),
					),
				),
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/statements/VariableDeclarationStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$VariableDeclarationStatement_ts$default(
		builder,
		node,
	) {
		if (node.declare === true && !builder.options.typeAnnotations) {
			return "";
		}

		const tokens = [];

		if (node.declare) {
			tokens.push(
				"declare",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens),
			builder.tokenize(node.declaration, node),
			";",
		]);
	}


  // project-rome/@romejs/js-formatter/builders/auxiliary/VariableDeclarator.ts
function ___R$project$rome$$romejs$js$formatter$builders$auxiliary$VariableDeclarator_ts$default(
		builder,
		node,
	) {
		if (node.init) {
			return ___R$project$rome$$romejs$js$formatter$builders$utils_ts$printAssignment(
				builder,
				node,
				node.id,
				___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
					___R$project$rome$$romejs$js$formatter$tokens_ts$space,
					"=",
				]),
				node.init,
			);
		} else {
			return builder.tokenize(node.id, node);
		}
	}


  // project-rome/@romejs/js-formatter/builders/typescript/VoidKeywordTypeAnnotation.ts
function ___R$project$rome$$romejs$js$formatter$builders$typescript$VoidKeywordTypeAnnotation_ts$default() {
		return "void";
	}


  // project-rome/@romejs/js-formatter/builders/statements/WhileStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$WhileStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$group(
			___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
				"while",
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				"(",
				___R$project$rome$$romejs$js$formatter$tokens_ts$group(
					___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
							___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
								___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
								builder.tokenize(node.test, node),
							]),
						),
						___R$project$rome$$romejs$js$formatter$tokens_ts$softline,
					]),
				),
				")",
				___R$project$rome$$romejs$js$formatter$builders$utils_ts$printClause(
					builder,
					node.body,
					node,
				),
			]),
		);
	}


  // project-rome/@romejs/js-formatter/builders/statements/WithStatement.ts
function ___R$project$rome$$romejs$js$formatter$builders$statements$WithStatement_ts$default(
		builder,
		node,
	) {
		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
			"with",
			___R$project$rome$$romejs$js$formatter$tokens_ts$space,
			"(",
			builder.tokenize(node.object, node),
			")",
			___R$project$rome$$romejs$js$formatter$builders$utils_ts$printClause(
				builder,
				node.body,
				node,
			),
		]);
	}


  // project-rome/@romejs/js-formatter/builders/expressions/YieldExpression.ts
function ___R$project$rome$$romejs$js$formatter$builders$expressions$YieldExpression_ts$default(
		builder,
		node,
	) {
		const tokens = ["yield"];

		if (node.delegate === true) {
			tokens.push("*");
		}

		if (node.argument) {
			tokens.push(
				___R$project$rome$$romejs$js$formatter$tokens_ts$space,
				builder.tokenize(node.argument, node),
			);
		}

		return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
	}


  // project-rome/@romejs/js-formatter/builders/index.ts
// rome-ignore lint/js/noExplicitAny
	const ___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders = new Map();
	const ___R$project$rome$$romejs$js$formatter$builders$index_ts$default = ___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders;
	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"AmbiguousFlowTypeCastExpression",
		___R$project$rome$$romejs$js$formatter$builders$temp$AmbiguousFlowTypeCastExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ArrayExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$ArrayExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ArrayHole",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$ArrayHole_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ArrowFunctionExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$ArrowFunctionExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"AssignmentArrayPattern",
		___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentArrayPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"AssignmentAssignmentPattern",
		___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentAssignmentPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"AssignmentExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$AssignmentExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"AssignmentIdentifier",
		___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"AssignmentObjectPattern",
		___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentObjectPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"AssignmentObjectPatternProperty",
		___R$project$rome$$romejs$js$formatter$builders$patterns$AssignmentObjectPatternProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"AwaitExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$AwaitExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BigIntLiteral",
		___R$project$rome$$romejs$js$formatter$builders$literals$BigIntLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BinaryExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$BinaryExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BindingArrayPattern",
		___R$project$rome$$romejs$js$formatter$builders$patterns$BindingArrayPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BindingAssignmentPattern",
		___R$project$rome$$romejs$js$formatter$builders$patterns$BindingAssignmentPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BindingIdentifier",
		___R$project$rome$$romejs$js$formatter$builders$patterns$BindingIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BindingObjectPattern",
		___R$project$rome$$romejs$js$formatter$builders$patterns$BindingObjectPattern_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BindingObjectPatternProperty",
		___R$project$rome$$romejs$js$formatter$builders$patterns$BindingObjectPatternProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BlockStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$BlockStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BooleanLiteral",
		___R$project$rome$$romejs$js$formatter$builders$literals$BooleanLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"BreakStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$BreakStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"CallExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$CallExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"CatchClause",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$CatchClause_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ClassDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$classes$ClassDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ClassExpression",
		___R$project$rome$$romejs$js$formatter$builders$classes$ClassExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ClassHead",
		___R$project$rome$$romejs$js$formatter$builders$classes$ClassHead_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ClassMethod",
		___R$project$rome$$romejs$js$formatter$builders$classes$ClassMethod_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ClassPrivateMethod",
		___R$project$rome$$romejs$js$formatter$builders$classes$ClassPrivateMethod_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ClassPrivateProperty",
		___R$project$rome$$romejs$js$formatter$builders$classes$ClassPrivateProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ClassProperty",
		___R$project$rome$$romejs$js$formatter$builders$classes$ClassProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ClassPropertyMeta",
		___R$project$rome$$romejs$js$formatter$builders$classes$ClassPropertyMeta_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"CommentBlock",
		___R$project$rome$$romejs$js$formatter$builders$core$CommentBlock_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"CommentLine",
		___R$project$rome$$romejs$js$formatter$builders$core$CommentLine_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ComputedMemberProperty",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$ComputedMemberProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ComputedPropertyKey",
		___R$project$rome$$romejs$js$formatter$builders$objects$ComputedPropertyKey_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ConditionalExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$ConditionalExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ContinueStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$ContinueStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"DebuggerStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$DebuggerStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"Directive",
		___R$project$rome$$romejs$js$formatter$builders$core$Directive_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"DoExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$DoExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"DoWhileStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$DoWhileStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"EmptyStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$EmptyStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExportAllDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$modules$ExportAllDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExportDefaultDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$modules$ExportDefaultDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExportDefaultSpecifier",
		___R$project$rome$$romejs$js$formatter$builders$modules$ExportDefaultSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExportExternalDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$modules$ExportExternalDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExportExternalSpecifier",
		___R$project$rome$$romejs$js$formatter$builders$modules$ExportExternalSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExportLocalDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$modules$ExportLocalDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExportLocalSpecifier",
		___R$project$rome$$romejs$js$formatter$builders$modules$ExportLocalSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExportNamespaceSpecifier",
		___R$project$rome$$romejs$js$formatter$builders$modules$ExportNamespaceSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ExpressionStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$ExpressionStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ForInStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$ForInStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ForOfStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$ForOfStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ForStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$ForStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"FunctionDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$statements$FunctionDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"FunctionExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$FunctionExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"FunctionHead",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$FunctionHead_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"Identifier",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$Identifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"IfStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$IfStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ImportCall",
		___R$project$rome$$romejs$js$formatter$builders$modules$ImportCall_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ImportDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$modules$ImportDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ImportDefaultSpecifier",
		___R$project$rome$$romejs$js$formatter$builders$modules$ImportDefaultSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ImportNamespaceSpecifier",
		___R$project$rome$$romejs$js$formatter$builders$modules$ImportNamespaceSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ImportSpecifier",
		___R$project$rome$$romejs$js$formatter$builders$modules$ImportSpecifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ImportSpecifierLocal",
		___R$project$rome$$romejs$js$formatter$builders$modules$ImportSpecifierLocal_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"InterpreterDirective",
		___R$project$rome$$romejs$js$formatter$builders$core$InterpreterDirective_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXAttribute",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXAttribute_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXElement",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXElement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXEmptyExpression",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXEmptyExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXExpressionContainer",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXExpressionContainer_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXFragment",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXFragment_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXIdentifier",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXMemberExpression",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXMemberExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXNamespacedName",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXNamespacedName_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXReferenceIdentifier",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXReferenceIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXSpreadAttribute",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXSpreadAttribute_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXSpreadChild",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXSpreadChild_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"JSXText",
		___R$project$rome$$romejs$js$formatter$builders$jsx$JSXText_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"LabeledStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$LabeledStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"LogicalExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$LogicalExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"MemberExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$MemberExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"MetaProperty",
		___R$project$rome$$romejs$js$formatter$builders$expressions$MetaProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"MockParent",
		___R$project$rome$$romejs$js$formatter$builders$temp$MockParent_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"NewExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$NewExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"NullLiteral",
		___R$project$rome$$romejs$js$formatter$builders$literals$NullLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"NumericLiteral",
		___R$project$rome$$romejs$js$formatter$builders$literals$NumericLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ObjectExpression",
		___R$project$rome$$romejs$js$formatter$builders$objects$ObjectExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ObjectMethod",
		___R$project$rome$$romejs$js$formatter$builders$objects$ObjectMethod_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ObjectProperty",
		___R$project$rome$$romejs$js$formatter$builders$objects$ObjectProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"OptionalCallExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$OptionalCallExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"PatternMeta",
		___R$project$rome$$romejs$js$formatter$builders$patterns$PatternMeta_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"PrivateName",
		___R$project$rome$$romejs$js$formatter$builders$classes$PrivateName_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"Program",
		___R$project$rome$$romejs$js$formatter$builders$core$Program_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ReferenceIdentifier",
		___R$project$rome$$romejs$js$formatter$builders$expressions$ReferenceIdentifier_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpAlternation",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpAlternation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpAnyCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpAnyCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpCharSet",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpCharSet_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpCharSetRange",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpCharSetRange_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpControlCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpControlCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpDigitCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpDigitCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpEndCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpEndCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpGroupCapture",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpGroupCapture_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpGroupNonCapture",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpGroupNonCapture_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpLiteral",
		___R$project$rome$$romejs$js$formatter$builders$literals$RegExpLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpNamedBackReference",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNamedBackReference_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpNonDigitCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNonDigitCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpNonWhiteSpaceCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNonWhiteSpaceCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpNonWordBoundaryCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNonWordBoundaryCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpNonWordCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNonWordCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpNumericBackReference",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpNumericBackReference_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpQuantified",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpQuantified_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpStartCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpStartCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpSubExpression",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpSubExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpWhiteSpaceCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpWhiteSpaceCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpWordBoundaryCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpWordBoundaryCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"RegExpWordCharacter",
		___R$project$rome$$romejs$js$formatter$builders$regex$RegExpWordCharacter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ReturnStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$ReturnStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"SequenceExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$SequenceExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"SpreadElement",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$SpreadElement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"SpreadProperty",
		___R$project$rome$$romejs$js$formatter$builders$objects$SpreadProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"StaticMemberProperty",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$StaticMemberProperty_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"StaticPropertyKey",
		___R$project$rome$$romejs$js$formatter$builders$objects$StaticPropertyKey_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"StringLiteral",
		___R$project$rome$$romejs$js$formatter$builders$literals$StringLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"Super",
		___R$project$rome$$romejs$js$formatter$builders$expressions$Super_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"SwitchCase",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$SwitchCase_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"SwitchStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$SwitchStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TaggedTemplateExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$TaggedTemplateExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TemplateElement",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$TemplateElement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TemplateLiteral",
		___R$project$rome$$romejs$js$formatter$builders$literals$TemplateLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ThisExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$ThisExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"ThrowStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$ThrowStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TryStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$TryStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSAnyKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSAnyKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSArrayType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSArrayType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSAsExpression",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSAsExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSAssignmentAsExpression",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSAssignmentAsExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSAssignmentNonNullExpression",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSAssignmentNonNullExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSAssignmentTypeAssertion",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSAssignmentTypeAssertion_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSBigIntKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSBigIntKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSBooleanKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSBooleanKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSBooleanLiteralTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSBooleanLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSCallSignatureDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSCallSignatureDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSConditionalType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSConditionalType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSConstructorType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSConstructorType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSConstructSignatureDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSConstructSignatureDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSDeclareFunction",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSDeclareFunction_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSDeclareMethod",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSDeclareMethod_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSEmptyKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSEmptyKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSEnumDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSEnumDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSEnumMember",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSEnumMember_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSExportAssignment",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSExportAssignment_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSExpressionWithTypeArguments",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSExpressionWithTypeArguments_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSExternalModuleReference",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSExternalModuleReference_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSFunctionType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSFunctionType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSImportEqualsDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSImportEqualsDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSImportType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSImportType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSIndexedAccessType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSIndexedAccessType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSIndexSignature",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSIndexSignature_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSInferType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSInferType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSInterfaceBody",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSInterfaceBody_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSInterfaceDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSInterfaceDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSIntersectionTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSIntersectionTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSMappedType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSMappedType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSMethodSignature",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSMethodSignature_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSMixedKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSMixedKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSModuleBlock",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSModuleBlock_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSModuleDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSModuleDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSNamespaceExportDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSNamespaceExportDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSNeverKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSNeverKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSNonNullExpression",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSNonNullExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSNullKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSNullKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSNumberKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSNumberKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSNumericLiteralTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSNumericLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSObjectKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSObjectKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSOptionalType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSOptionalType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSParenthesizedType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSParenthesizedType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSPropertySignature",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSPropertySignature_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSQualifiedName",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSQualifiedName_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSSignatureDeclarationMeta",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSSignatureDeclarationMeta_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSStringKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSStringKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSStringLiteralTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSStringLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSSymbolKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSSymbolKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTemplateLiteralTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTemplateLiteralTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSThisType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSThisType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTupleType",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTupleType_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypeAssertion",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeAssertion_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypeLiteral",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeLiteral_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypeOperator",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeOperator_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypeParameter",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeParameter_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypeParameterDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeParameterDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypeParameterInstantiation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeParameterInstantiation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypePredicate",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypePredicate_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypeQuery",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeQuery_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TSTypeReference",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TSTypeReference_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"TypeAliasTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$TypeAliasTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"UnaryExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$UnaryExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"UndefinedKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$UndefinedKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"UnionTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$UnionTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"UnknownKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$UnknownKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"UpdateExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$UpdateExpression_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"VariableDeclaration",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$VariableDeclaration_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"VariableDeclarationStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$VariableDeclarationStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"VariableDeclarator",
		___R$project$rome$$romejs$js$formatter$builders$auxiliary$VariableDeclarator_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"VoidKeywordTypeAnnotation",
		___R$project$rome$$romejs$js$formatter$builders$typescript$VoidKeywordTypeAnnotation_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"WhileStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$WhileStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"WithStatement",
		___R$project$rome$$romejs$js$formatter$builders$statements$WithStatement_ts$default,
	);

	___R$$priv$project$rome$$romejs$js$formatter$builders$index_ts$builders.set(
		"YieldExpression",
		___R$project$rome$$romejs$js$formatter$builders$expressions$YieldExpression_ts$default,
	);


  // project-rome/@romejs/js-formatter/Builder.ts




	class ___R$project$rome$$romejs$js$formatter$Builder_ts$default {
		constructor(opts, comments = []) {
			this.options = opts;
			this.comments = new ___R$project$rome$$romejs$js$parser$CommentsConsumer_ts$default(
				comments,
			);
			this.printedComments = new Set();
			this.printStack = [];
		}

		tokenize(node, parent) {
			if (node === undefined) {
				return "";
			}

			if (
				!this.options.typeAnnotations &&
				___R$project$rome$$romejs$js$ast$utils$isTypeNode_ts$default(node) &&
				!___R$project$rome$$romejs$js$ast$utils$isTypeExpressionWrapperNode_ts$default(
					node,
				)
			) {
				return "";
			}

			const tokenizeNode = ___R$project$rome$$romejs$js$formatter$builders$index_ts$default.get(
				node.type,
			);
			if (tokenizeNode === undefined) {
				throw new Error(
					"No known builder for node " +
					node.type +
					" with parent " +
					parent.type,
				);
			}

			this.printStack.push(node);
			let printedNode = tokenizeNode(this, node, parent);
			const needsParens = ___R$project$rome$$romejs$js$formatter$node$index_ts.needsParens(
				node,
				parent,
				this.printStack,
			);
			this.printStack.pop();

			if (printedNode !== "") {
				if (this.options.sourceMaps && node.loc !== undefined) {
					printedNode = ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						___R$project$rome$$romejs$js$formatter$tokens_ts$mark(
							node.loc,
							"start",
						),
						printedNode,
						___R$project$rome$$romejs$js$formatter$tokens_ts$mark(
							node.loc,
							"end",
						),
					]);
				}

				if (needsParens) {
					printedNode = ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
						"(",
						printedNode,
						")",
					]);
				}
			}

			return this.tokenizeComments(node, printedNode);
		}

		tokenizeComments(node, printed) {
			const tokens = [];

			const leadingComments = this.getComments("leadingComments", node);
			if (leadingComments !== undefined) {
				let next = node;

				// Leading comments are traversed backward in order to get `next` right
				for (let i = leadingComments.length - 1; i >= 0; i--) {
					const comment = leadingComments[i];
					this.printedComments.add(comment.id);
					tokens.unshift(
						___R$project$rome$$romejs$js$formatter$builders$comments_ts$printLeadingComment(
							comment,
							next,
						),
					);
					next = comment;
				}
			}

			tokens.push(printed);

			const trailingComments = this.getComments("trailingComments", node);
			if (trailingComments !== undefined) {
				let previous = node;

				for (const comment of trailingComments) {
					this.printedComments.add(comment.id);
					tokens.push(
						___R$project$rome$$romejs$js$formatter$builders$comments_ts$printTrailingComment(
							comment,
							previous,
						),
					);
					previous = comment;
				}
			}

			return ___R$project$rome$$romejs$js$formatter$tokens_ts$concat(tokens);
		}

		tokenizeStatementList(nodes, parent) {
			if (nodes.length === 0) {
				return "";
			}

			const tokens = [];

			for (let i = 0; i < nodes.length; i++) {
				const isLast = i === nodes.length - 1;
				const node = nodes[i];

				if (node.type === "EmptyStatement") {
					continue;
				}

				let printed = this.tokenize(node, parent);

				if (!isLast) {
					const nextNode = nodes[i + 1];

					if (this.getLinesBetween(node, nextNode) > 1) {
						printed = ___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							printed,
							___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
						]);
					}
				}

				tokens.push(printed);
			}

			return ___R$project$rome$$romejs$js$formatter$tokens_ts$join(
				___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
				tokens,
			);
		}

		tokenizeInnerComments(node, shouldIndent) {
			const innerComments = this.getComments("innerComments", node);
			if (innerComments === undefined) {
				return "";
			}

			const tokens = [];

			for (const comment of innerComments) {
				this.printedComments.add(comment.id);
				tokens.push(
					___R$project$rome$$romejs$js$formatter$builders$comments_ts$printComment(
						comment,
					),
				);
			}

			return shouldIndent
				? ___R$project$rome$$romejs$js$formatter$tokens_ts$indent(
						___R$project$rome$$romejs$js$formatter$tokens_ts$concat([
							___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
							___R$project$rome$$romejs$js$formatter$tokens_ts$join(
								___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
								tokens,
							),
						]),
					)
				: ___R$project$rome$$romejs$js$formatter$tokens_ts$join(
						___R$project$rome$$romejs$js$formatter$tokens_ts$hardline,
						tokens,
					);
		}

		getComments(kind, node, all = false) {
			if (!node) {
				return undefined;
			}

			const ids = node[kind];
			if (ids === undefined) {
				return undefined;
			}

			const comments = this.comments.getCommentsFromIds(ids);

			if (all) {
				return comments;
			} else {
				return comments.filter((comment) =>
					!this.printedComments.has(comment.id)
				);
			}
		}

		getLinesBetween(a, b) {
			if (a.loc === undefined || b.loc === undefined) {
				return 0;
			}

			let aEndLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(
				a.loc.end.line,
			);
			let bStartLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(
				b.loc.start.line,
			);

			// Simple cases:
			//  1. `a` and `b` are on the same line
			//  2. `a` and `b` are on their own line without empty lines between them
			if (bStartLine - aEndLine <= 1) {
				return bStartLine - aEndLine;
			}

			// If the are more than one line between `a` and `b`, the comment nodes must
			// be inspected to detect empty lines.
			//
			// In the following example, `getLinesBetween` should return `1`.
			//
			//     a;
			//     /* COMMENT */
			//     b;

			const aTrailingComments = this.getComments("trailingComments", a, true);
			const bLeadingComments = this.getComments("leadingComments", b, true);

			// Comments must be deduplicated because they are shared between nodes.
			// Walk them in order to calculate the nodes' boundaries.
			if (aTrailingComments !== undefined || bLeadingComments !== undefined) {
				const seenComments = new Set();

				// Expand `a` boundaries
				if (aTrailingComments !== undefined) {
					for (const comment of aTrailingComments) {
						seenComments.add(comment);

						if (comment.loc !== undefined) {
							aEndLine = Math.max(
								aEndLine,
								___R$project$rome$$romejs$ob1$index_ts$ob1Get1(
									comment.loc.end.line,
								),
							);
						}
					}
				}

				// Expand `b` boundaries
				if (bLeadingComments !== undefined) {
					for (const comment of bLeadingComments) {
						if (seenComments.has(comment)) {
							continue;
						}

						if (comment.loc !== undefined) {
							bStartLine = Math.min(
								bStartLine,
								___R$project$rome$$romejs$ob1$index_ts$ob1Get1(
									comment.loc.start.line,
								),
							);
						}
					}
				}
			}

			return bStartLine - aEndLine;
		}
	}


  // project-rome/@romejs/js-formatter/Printer.ts






	class ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$BreakError
		extends Error {
		constructor() {
			super(
				"This error represents a point in the formatter where we should line break. If you're seeing this something went wrong.",
			);
		}
	}

	class ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box {
		constructor(value) {
			this.value = value;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$forkState(
		parent,
		callback,
	) {
		const bufferLength = parent.buffer.length;
		const mappingsLength = parent.mappings.length;

		const state = Object.assign(
			{},
			parent,
			{
				generatedIndex: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
					parent.generatedIndex.value,
				),
				generatedLine: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
					parent.generatedLine.value,
				),
				generatedColumn: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
					parent.generatedColumn.value,
				),
				pendingSpaces: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
					parent.pendingSpaces.value,
				),
				pendingTabs: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
					parent.pendingTabs.value,
				),
				lineWidth: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
					parent.lineWidth.value,
				),
			},
		);

		try {
			callback(state);
		} catch (err) {
			// Discard dirty outputs
			if (parent.buffer.length !== bufferLength) {
				parent.buffer.length = bufferLength;
			}

			// Discard dirty mappings
			if (parent.mappings.length !== mappingsLength) {
				parent.mappings.length = mappingsLength;
			}

			throw err;
		}

		// Merge the states together
		parent.generatedIndex.value = state.generatedIndex.value;
		parent.generatedLine.value = state.generatedLine.value;
		parent.generatedColumn.value = state.generatedColumn.value;
		parent.pendingSpaces.value = state.pendingSpaces.value;
		parent.pendingTabs.value = state.pendingTabs.value;
		parent.lineWidth.value = state.lineWidth.value;
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$write(
		str,
		state,
		options,
	) {
		for (const ch of str) {
			state.generatedIndex.value = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
				state.generatedIndex.value,
			);
			if (ch === "\n") {
				state.generatedLine.value = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
					state.generatedLine.value,
				);
				state.generatedColumn.value = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
				state.lineWidth.value = 0;
			} else {
				state.generatedColumn.value = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(
					state.generatedColumn.value,
				);
				if (ch === "\t") {
					state.lineWidth.value += options.tabWidth;
				} else {
					state.lineWidth.value++;
				}
			}
		}
		state.buffer.push(str);
	}

	function ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$print(
		token,
		state,
		options,
	) {
		const stack = [[token, state]];

		while (stack.length > 0) {
			const [token, state] = stack.pop();

			if (typeof token === "string") {
				if (token !== "") {
					// Print pending tabs
					if (state.pendingTabs.value > 0) {
						___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$write(
							"\t".repeat(state.pendingTabs.value),
							state,
							options,
						);
						state.pendingTabs.value = 0;
					}

					// Print pending spaces
					if (state.pendingSpaces.value > 0) {
						___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$write(
							" ".repeat(state.pendingSpaces.value),
							state,
							options,
						);
						state.pendingSpaces.value = 0;
					}

					let currentLine = state.generatedLine.value;

					___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$write(
						token,
						state,
						options,
					);

					if (state.flat) {
						// If the line is too long, break the group
						if (state.lineWidth.value > options.printWidth) {
							throw new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$BreakError();
						}

						// If a new line was printed, break the group
						if (currentLine !== state.generatedLine.value) {
							throw new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$BreakError();
						}
					}
				}
			} else {
				switch (token.type) {
					case "Comment": {
						stack.push([token.value, state]);
						break;
					}

					case "Concat": {
						for (let i = token.parts.length - 1; i >= 0; i--) {
							stack.push([token.parts[i], state]);
						}
						break;
					}

					case "Group": {
						if (token.shouldBreak) {
							if (state.flat) {
								throw new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$BreakError();
							} else {
								stack.push([token.contents, state]);
								break;
							}
						}

						if (state.flat) {
							stack.push([token.contents, state]);
						} else {
							try {
								___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$forkState(
									state,
									(next) => {
										// Try to print the group contents on a single line.
										// If it fails, break the group.
										next.flat = true;
										___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$print(
											token.contents,
											next,
											options,
										);
									},
								);
							} catch (err) {
								if (
									err instanceof
									___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$BreakError
								) {
									stack.push([token.contents, state]);
								} else {
									// This should not happen!
									// Let the error propagate.
									throw err;
								}
							}
						}
						break;
					}

					case "IfBreak": {
						if (state.flat) {
							if (token.flatContents) {
								stack.push([token.flatContents, state]);
							}
						} else {
							stack.push([token.breakContents, state]);
						}
						break;
					}

					case "Indent": {
						stack.push([
							token.contents,
							Object.assign(
								{},
								state,
								{
									indent: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
										state.indent.value + 1,
									),
								},
							),
						]);
						break;
					}

					case "Line": {
						if (state.flat) {
							switch (token.mode) {
								case "space": {
									state.pendingSpaces.value++;
									break;
								}

								case "soft":
									// Soft lines are not printed in flat mode.
									break;

								case "hard":
									// Hard lines are always printed.
									// In flat mode, the current group be broken.
									throw new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$BreakError();
							}
						} else {
							if (state.lineSuffixes.length > 0) {
								stack.push([token, state]);
								while (state.lineSuffixes.length > 0) {
									stack.push(state.lineSuffixes.pop());
								}
							} else {
								___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$write(
									"\n",
									state,
									options,
								);

								// Enqueue the indentation
								state.pendingSpaces.value = 0;
								state.pendingTabs.value = state.indent.value;
							}
						}
						break;
					}

					case "LineSuffix": {
						if (state.flat) {
							throw new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$BreakError();
						} else {
							state.lineSuffixes.push([token.contents, state]);
						}
						break;
					}

					case "PositionMarker": {
						if (
							state.mappings.length > 0 &&
							state.mappings[state.mappings.length - 1].generated.index ===
							state.generatedIndex.value
						) {
							break;
						}

						state.mappings.push({
							generated: {
								line: state.generatedLine.value,
								column: state.generatedColumn.value,
								index: state.generatedIndex.value,
							},
							original: {
								line: token.loc[token.prop].line,
								column: token.loc[token.prop].column,
							},
							name: token.loc.identifierName,
							source: token.loc.filename,
						});
						break;
					}

					case "Space": {
						state.pendingSpaces.value++;
						break;
					}
				}
			}
		}
	}

	function ___R$project$rome$$romejs$js$formatter$Printer_ts$printTokenToString(
		token,
		options,
	) {
		const state = {
			flat: false,
			indent: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
				options.rootIndent,
			),
			pendingSpaces: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
				0,
			),
			pendingTabs: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
				0,
			),
			generatedIndex: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
				___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			),
			generatedLine: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
				___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
			),
			generatedColumn: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
				___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			),
			buffer: [],
			mappings: [],
			lineSuffixes: [],
			lineWidth: new ___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$Box(
				0,
			),
		};

		___R$$priv$project$rome$$romejs$js$formatter$Printer_ts$print(
			token,
			state,
			options,
		);

		return {
			code: state.buffer.join(""),
			mappings: state.mappings,
		};
	}


  // project-rome/@romejs/js-formatter/index.ts


	function ___R$project$rome$$romejs$js$formatter$index_ts$formatJS(
		ast,
		{
			format = "pretty",
			typeAnnotations = true,
			sourceMaps = false,
			comments,
			indent = 0,
			allowInterpreterDirective = true,
		} = {},
	) {
		const builder = new ___R$project$rome$$romejs$js$formatter$Builder_ts$default(
			{
				format,
				sourceMaps,
				typeAnnotations,
				allowInterpreterDirective,
			},
			ast.type === "Program" ? ast.comments : comments,
		);
		const token = builder.tokenize(
			ast,
			___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT,
		);
		const formatted = ___R$project$rome$$romejs$js$formatter$Printer_ts$printTokenToString(
			token,
			{
				printWidth: format === "pretty" ? 80 : Infinity,
				rootIndent: indent,
				tabWidth: 2,
			},
		);

		return formatted;
	}


  // project-rome/@romejs/core/common/file-handlers/javascript.ts
const ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$IMPLICIT_JS_EXTENSIONS = [
		"js",
		"ts",
		"tsx",
		"json",
	];

	const ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$JS_EXTENSIONS = [];

	function ___R$$priv$project$rome$$romejs$core$common$file$handlers$javascript_ts$buildJSHandler(
		ext,
		syntax,
		sourceType,
	) {
		___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$JS_EXTENSIONS.push(
			ext,
		);

		return {
			ext,
			syntax,
			sourceType,

			async analyzeDependencies({file, worker, parseOptions}) {
				const {ast, sourceText, project, generated} = await worker.parseJS(
					file,
					parseOptions,
				);
				worker.logger.info("Analyzing:", file.real);

				return worker.api.interceptAndAddGeneratedToDiagnostics(
					await ___R$project$rome$$romejs$js$compiler$index_ts.analyzeDependencies({
						ref: file,
						ast,
						sourceText,
						project,
						options: {},
					}),
					generated,
				);
			},

			async toJavaScript({file, worker}) {
				return {
					sourceText: await worker.readFile(file.real),
					generated: false,
				};
			},

			async format(info) {
				const {file: ref, parseOptions, worker} = info;

				const {ast, sourceText, generated} = await worker.parseJS(
					ref,
					parseOptions,
				);

				const out = ___R$project$rome$$romejs$js$formatter$index_ts$formatJS(
					ast,
					{
						sourceText,
					},
				);

				return worker.api.interceptAndAddGeneratedToDiagnostics(
					{
						formatted: out.code,
						sourceText,
						suppressions: [],
						diagnostics: ast.diagnostics,
					},
					generated,
				);
			},

			async lint(info) {
				const {file: ref, project, parseOptions, options, worker} = info;

				const {ast, sourceText, generated} = await worker.parseJS(
					ref,
					parseOptions,
				);

				worker.logger.info("Linting: ", ref.real);

				// Run the compiler in lint-mode which is where all the rules are actually ran
				const res = await ___R$project$rome$$romejs$js$compiler$index_ts.lint({
					applyFixes: options.applyFixes,
					ref,
					options: {
						lint: options.compilerOptions,
					},
					ast,
					project,
					sourceText,
				});

				// Extract lint diagnostics
				let {diagnostics} = res;

				// Only enable typechecking if enabled in .romeconfig
				let typeCheckingEnabled = project.config.typeCheck.enabled === true;
				if (project.config.typeCheck.libs.has(ref.real)) {
					// don't typecheck lib files
					typeCheckingEnabled = false;
				}

				// Run type checking if necessary
				if (typeCheckingEnabled) {
					const typeCheckProvider = await worker.getTypeCheckProvider(
						ref.project,
						options.prefetchedModuleSignatures,
						parseOptions,
					);
					const typeDiagnostics = await ___R$project$rome$$romejs$js$analysis$api$check_ts$default({
						ast,
						provider: typeCheckProvider,
						project,
					});
					diagnostics = [...diagnostics, ...typeDiagnostics];
				}

				return worker.api.interceptAndAddGeneratedToDiagnostics(
					{
						suppressions: res.suppressions,
						diagnostics,
						sourceText,
						formatted: res.src,
					},
					generated,
				);
			},
		};
	}

	const ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$jsHandler = ___R$$priv$project$rome$$romejs$core$common$file$handlers$javascript_ts$buildJSHandler(
		"js",
		[],
	);
	const ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$jsxHandler = ___R$$priv$project$rome$$romejs$core$common$file$handlers$javascript_ts$buildJSHandler(
		"jsx",
		["jsx"],
	);
	const ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$cjsHandler = ___R$$priv$project$rome$$romejs$core$common$file$handlers$javascript_ts$buildJSHandler(
		"cjs",
		[],
		"script",
	);
	const ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$mjsHandler = ___R$$priv$project$rome$$romejs$core$common$file$handlers$javascript_ts$buildJSHandler(
		"mjs",
		[],
		"module",
	);
	const ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$tsHandler = ___R$$priv$project$rome$$romejs$core$common$file$handlers$javascript_ts$buildJSHandler(
		"ts",
		["ts"],
		"module",
	);
	const ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$tsxHandler = ___R$$priv$project$rome$$romejs$core$common$file$handlers$javascript_ts$buildJSHandler(
		"tsx",
		["ts", "jsx"],
		"module",
	);


  // project-rome/@romejs/core/common/types/analyzeDependencies.ts
const ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts = {
		get UNKNOWN_ANALYZE_DEPENDENCIES_RESULT() {
			return ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT;
		},
	};




















	const ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT = {
		topLevelLocalBindings: {},
		moduleType: "unknown",
		syntax: [],
		diagnostics: [],
		firstTopAwaitLocation: undefined,
		importFirstUsage: [],
		exports: [],
		dependencies: [],
	};


  // project-rome/@romejs/core/common/file-handlers/text.ts
const ___R$project$rome$$romejs$core$common$file$handlers$text_ts$textHandler = {
		sourceType: "module",

		// Mock a single default export
		// We could always just pass this through to analyzeDependencies and get the same result due to the toJavaScript call below,
		// but the return value is predictable so we inline it
		async analyzeDependencies() {
			return Object.assign(
				{},
				___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT,
				{
					moduleType: "es",
					exports: [
						{
							type: "local",
							// TODO we could fake this?
							loc: undefined,
							kind: "value",
							valueType: "other",
							name: "default",
						},
					],
				},
			);
		},

		async toJavaScript({file, worker}) {
			const src = await worker.readFile(file.real);
			const serial = JSON.stringify(src);
			return {
				sourceText: "export default " + serial + ";",
				generated: true,
			};
		},
	};


  // project-rome/@romejs/core/common/file-handlers/json.ts
const ___R$project$rome$$romejs$core$common$file$handlers$json_ts$jsonHandler = Object.assign(
		{ext: "json"},
		___R$project$rome$$romejs$core$common$file$handlers$text_ts$textHandler,
		{
			async format(info) {
				const {file, worker} = info;
				const {uid} = file;

				const real = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
					file.real,
				);
				const sourceText = await worker.readFile(real);
				const path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
					uid,
				);

				let formatted = sourceText;

				if (sourceText.length > 50_000) {
					// Fast path for big JSON files
					___R$project$rome$$romejs$codec$json$index_ts$parseJSON({
						path,
						input: sourceText,
					});
				} else {
					const {consumer, comments, hasExtensions} = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra({
						input: sourceText,
						path,
					});

					if (hasExtensions) {
						formatted = ___R$project$rome$$romejs$codec$json$index_ts$stringifyRJSONFromConsumer({
							consumer,
							comments,
						});
					} else {
						formatted = String(
							___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
								consumer.asUnknown(),
							),
						);
					}
				}

				return {
					sourceText,
					diagnostics: [],
					suppressions: [],
					formatted,
				};
			},

			async toJavaScript({file, worker}) {
				const src = await worker.readFile(file.real);

				// Parse the JSON to make sure it's valid
				const obj = ___R$project$rome$$romejs$codec$json$index_ts$parseJSON({
					path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
						file.uid,
					),
					input: src,
				});

				const rawJson = JSON.stringify(obj);
				const json = rawJson === undefined ? "undefined" : rawJson;

				// TODO handle unicode newlines here
				return {
					sourceText: "export default " + json + ";",
					generated: true,
				};
			},
		},
	);

	const ___R$project$rome$$romejs$core$common$file$handlers$json_ts$rjsonHandler = Object.assign(
		{},
		___R$project$rome$$romejs$core$common$file$handlers$json_ts$jsonHandler,
		{ext: "rjson"},
	);


  // project-rome/@romejs/core/common/file-handlers/index.ts




	function ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandlerExtensions(
		projectConfig,
	) {
		return [
			...___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$DEFAULT_HANDLERS.keys(),
			...projectConfig.files.assetExtensions,
		];
	}

	function ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandler(
		path,
		projectConfig,
	) {
		const basename = path.getBasename();

		const match = basename.match(/\.([a-zA-Z]+)$/);
		if (match == null) {
			return {ext: "", handler: undefined};
		}

		const ext = match[1];
		let handler = ___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$DEFAULT_HANDLERS.get(
			ext,
		);

		// Allow setting custom assert extensions in the project config
		if (
			handler === undefined &&
			projectConfig.files.assetExtensions.includes(ext)
		) {
			handler = ___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$assetHandler;
		}

		return {ext, handler};
	}

	function ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandlerAssert(
		path,
		projectConfig,
	) {
		const {handler, ext} = ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandler(
			path,
			projectConfig,
		);

		if (handler === undefined) {
			throw new Error("No file handler found for '" + path.join() + "'");
		} else {
			return {handler, ext};
		}
	}

	const ___R$project$rome$$romejs$core$common$file$handlers$index_ts$ASSET_EXPORT_TEMPORARY_VALUE = "VALUE_INJECTED_BY_BUNDLER";

	const ___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$assetHandler = Object.assign(
		{},
		___R$project$rome$$romejs$core$common$file$handlers$text_ts$textHandler,
		{
			ext: "unknown",
			canHaveScale: true,
			isAsset: true,
			async toJavaScript() {
				// This exists just so analyzeDependencies has something to look at
				// When bundling we'll have custom logic in the compiler to handle assets and inject the correct string
				return {
					generated: true,
					sourceText: "export default '" +
					___R$project$rome$$romejs$core$common$file$handlers$index_ts$ASSET_EXPORT_TEMPORARY_VALUE +
					"';",
				};
			},
		},
	);

	// Extensions that have a `lint` handler
	const ___R$project$rome$$romejs$core$common$file$handlers$index_ts$LINTABLE_EXTENSIONS = [];

	const ___R$project$rome$$romejs$core$common$file$handlers$index_ts$FORMATTABLE_EXTENSIONS = [];

	function ___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		handler,
	) {
		const {ext} = handler;

		if (handler.lint !== undefined) {
			___R$project$rome$$romejs$core$common$file$handlers$index_ts$LINTABLE_EXTENSIONS.push(
				ext,
			);
		}

		if (handler.format !== undefined) {
			___R$project$rome$$romejs$core$common$file$handlers$index_ts$FORMATTABLE_EXTENSIONS.push(
				ext,
			);
		}

		___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$DEFAULT_HANDLERS.set(
			ext,
			handler,
		);
	}

	const ___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$DEFAULT_HANDLERS = new Map();

	const ___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$DEFAULT_ASSET_EXTENSIONS = [
		// Images
		"png",
		"jpg",
		"jpeg",
		"gif",
		// Video
		"webm",
		"mp4",
		"m4v",
		"avi",
		"mkv",
		// Audio
		"mp3",
		// Fonts
		"woff",
		"woff2",
		"eot",
		"ttf",
		"otf",
	];

	for (const ext of ___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$DEFAULT_ASSET_EXTENSIONS) {
		___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
			Object.assign(
				{ext},
				___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$assetHandler,
			),
		);
	}

	___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$jsHandler,
	);
	___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$jsxHandler,
	);
	___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$cjsHandler,
	);
	___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$mjsHandler,
	);
	___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$tsHandler,
	);
	___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$tsxHandler,
	);
	___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$romejs$core$common$file$handlers$json_ts$jsonHandler,
	);
	___R$$priv$project$rome$$romejs$core$common$file$handlers$index_ts$setHandler(
		___R$project$rome$$romejs$core$common$file$handlers$json_ts$rjsonHandler,
	);


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/assetTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$assetTransform_ts$default = {
		name: "asset",
		enter(path) {
			const {node} = path;
			const options = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				path.context,
			);

			if (
				node.type === "ExportDefaultDeclaration" &&
				node.declaration.type === "StringLiteral" &&
				node.declaration.value ===
				___R$project$rome$$romejs$core$common$file$handlers$index_ts$ASSET_EXPORT_TEMPORARY_VALUE &&
				options.assetPath !== undefined
			) {
				return Object.assign(
					{},
					node,
					{
						declaration: Object.assign(
							{},
							node.declaration,
							{value: options.moduleId},
						),
					},
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/modern/cjsRootTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$cjsRootTransform_ts$default = {
		name: "cjsRootTransform",
		enter(path) {
			const {node, scope, context} = path;

			const {moduleId} = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				context,
			);

			if (node.type === "Program") {
				const mappings = new Map();

				// make all variables private
				for (const [name] of path.scope.bindings) {
					mappings.set(
						name,
						___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(
							name,
							moduleId,
						),
					);
				}

				if (scope.hasBinding("exports") === false) {
					mappings.set(
						"exports",
						___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
							moduleId,
						),
					);
				}

				const newProgram = ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(
					path,
					mappings,
				);
				return newProgram;
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/modern/esToRefTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$esToRefTransform_ts$default = {
		name: "esToRefTransform",
		enter(path) {
			const {node, scope, context} = path;

			const opts = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				context,
			);

			if (___R$project$rome$$romejs$js$ast$core$Program_ts$program.is(node)) {
				const mappings = new Map();

				// make all variables private
				for (const [name] of path.scope.bindings) {
					mappings.set(
						name,
						___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrivateName(
							name,
							opts.moduleId,
						),
					);
				}

				// map exports and imports and correctly
				for (const child of node.body) {
					if (
						child.type === "ImportDeclaration" &&
						child.importKind !== "type" &&
						child.importKind !== "typeof"
					) {
						const moduleId = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
							child.source.value,
							opts,
						);
						if (moduleId === undefined) {
							continue;
						}

						for (const specifier of ___R$project$rome$$romejs$js$ast$utils$getImportSpecifiers_ts$default(
							child,
						)) {
							if (specifier.type === "ImportSpecifier") {
								mappings.set(
									specifier.local.name.name,
									___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
										specifier.imported.name,
										moduleId,
										opts,
									),
								);
							} else if (specifier.type === "ImportNamespaceSpecifier") {
								mappings.set(
									specifier.local.name.name,
									___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
										moduleId,
									),
								);
							} else if (specifier.type === "ImportDefaultSpecifier") {
								mappings.set(
									specifier.local.name.name,
									___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
										"default",
										moduleId,
										opts,
									),
								);
							} else {
								throw new Error("unexpected");
							}
						}
					}

					if (child.type === "ExportLocalDeclaration") {
						// export const foo = '';
						// export function foo() {}
						for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
							child,
						)) {
							mappings.set(
								name,
								___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
									name,
									opts.moduleId,
									opts,
								),
							);
						}

						// export {foo};
						if (child.specifiers !== undefined) {
							for (const specifier of child.specifiers) {
								const local = specifier.local.name;
								if (
									scope.getBindingAssert(local) instanceof
									___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding
								) {
									continue;
								}

								mappings.set(
									local,
									___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
										specifier.exported.name,
										opts.moduleId,
										opts,
									),
								);
							}
						}
					}

					if (child.type === "ExportDefaultDeclaration") {
						const {declaration: decl} = child;
						if (
							(decl.type === "FunctionDeclaration" ||
							decl.type === "ClassDeclaration") &&
							decl.id !== undefined
						) {
							mappings.set(
								decl.id.name,
								___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
									"default",
									opts.moduleId,
									opts,
								),
							);
						}
					}
				}

				const newProgram = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(
					___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(
						path,
						mappings,
					),
				);

				// Get new scope with updated bindings. TODO Maybe `renameBindings` should return the path?
				const newScope = scope.getRootScope().evaluate(
					newProgram,
					undefined,
					true,
				);

				if (opts.moduleAll === true) {
					// Get all the export names
					const exportNames = new Map();
					for (const child of newProgram.body) {
						if (child.type === "ExportDefaultDeclaration") {
							exportNames.set(
								"default",
								___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
									"default",
									opts.moduleId,
									opts,
								),
							);
						}

						if (child.type === "ExportExternalDeclaration") {
							// TODO defaultSpecifier and namespaceSpecifier
							const {source} = child;

							for (const specifier of child.namedSpecifiers) {
								// If this is an external export then use the correct name
								const moduleId = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
									source.value,
									opts,
								);
								if (moduleId === undefined) {
									continue;
								}

								const local = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
									specifier.local.name,
									moduleId,
									opts,
								);

								exportNames.set(specifier.exported.name, local);
							}
						}

						if (child.type === "ExportLocalDeclaration") {
							if (child.declaration !== undefined) {
								throw new Error(
									"No export declarations should be here as they have been removed by renameBindings",
								);
							}

							const {specifiers} = child;
							if (specifiers !== undefined) {
								for (const specifier of specifiers) {
									// The local binding has already been rewritten by renameBindings if it existed
									exportNames.set(specifier.exported.name, specifier.local.name);
								}
							}
						}
					}

					const exportObjProps = [];

					for (const [exported, local] of exportNames) {
						const binding = newScope.getBinding(local);
						if (binding !== undefined) {
							if (
								binding instanceof
								___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding
							) {
								continue;
							}

							if (
								binding instanceof
								___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding
							) {
								exportObjProps.push(
									___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create({
										key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(
											___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
												exported,
											),
										),
										value: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
											local,
										),
									}),
								);
								continue;
							}
						}

						exportObjProps.push(
							___R$project$rome$$romejs$js$ast$objects$ObjectMethod_ts$objectMethod.create({
								kind: "get",
								key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.quick(
									___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
										exported,
									),
								),
								head: ___R$project$rome$$romejs$js$ast$auxiliary$FunctionHead_ts$functionHead.quick([]),
								body: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
									body: [
										___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.create({
											argument: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create({
												name: local,
											}),
										}),
									],
								}),
							}),
						);
					}

					const exportObj = ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.create({
						properties: exportObjProps,
					});

					return Object.assign(
						{},
						newProgram,
						{
							type: "Program",
							body: [
								___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
									___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
										kind: "const",
										declarations: [
											___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
												id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
													name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
														opts.moduleId,
													),
												}),
												init: exportObj,
											}),
										],
									}),
								),
								...newProgram.body,
							],
						},
					);
				} else {
					return newProgram;
				}
			}

			if (node.type === "ImportDeclaration") {
				// should have already been handled with the Program branch
				return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
			}

			if (node.type === "ExportDefaultDeclaration") {
				const {declaration} = node;
				if (
					declaration.type === "FunctionDeclaration" ||
					declaration.type === "ClassDeclaration"
				) {
					if (declaration.id === undefined) {
						return Object.assign(
							{},
							node,
							{
								declaration: Object.assign(
									{},
									declaration,
									{
										id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
											name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
												"default",
												opts.moduleId,
												opts,
											),
										}),
									},
								),
							},
						);
					} else {
						// if the export was named then we'll have already given it the correct name
						return declaration;
					}
				} else {
					return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
						"default",
						opts.moduleId,
						opts,
					)} = ${declaration};`;
				}
			}

			if (node.type === "ExportExternalDeclaration") {
				// Remove external exports with a source as they will be resolved correctly and never point here
				return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
			}

			if (node.type === "ExportLocalDeclaration") {
				const {declaration, specifiers} = node;

				if (specifiers === undefined) {
					if (declaration === undefined) {
						throw new Error(
							"No specifiers or declaration existed, if there's no specifiers then there should be a declaration",
						);
					}
					return declaration;
				} else {
					// check if any of the specifiers reference a global or import
					// if so, we need to insert declarations for them
					const nodes = [];

					for (const specifier of specifiers) {
						if (specifier.type === "ExportLocalSpecifier") {
							const binding = path.scope.getBinding(specifier.local.name);

							// TODO we only really need this declaration for global bindings, `analyze()` could detect the exported import and resolvedImports would just work
							if (
								binding === undefined ||
								binding instanceof
								___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding
							) {
								nodes.push(
									___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
										kind: "const",
										declarations: [
											___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.create({
												id: ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.create({
													name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedName(
														specifier.exported.name,
														opts.moduleId,
														opts,
													),
												}),
												init: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
													specifier.local.name,
												),
											}),
										],
									}),
								);
							}
						} else {
							// TODO ???
						}
					}

					if (nodes.length === 0) {
						return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
					} else {
						return nodes;
					}
				}
			}

			if (node.type === "ExportAllDeclaration" && opts.moduleAll === true) {
				const moduleId = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
					node.source.value,
					opts,
				);
				if (moduleId === undefined) {
					return node;
				}

				const theirNamespace = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
					moduleId,
				);
				const ourNamespace = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
					opts.moduleId,
				);
				return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`
        Object.keys(${theirNamespace}).forEach(function (key) {
          if (key === 'default') return undefined;
          Object.defineProperty(${ourNamespace}, key, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return ${theirNamespace}[key];
            }
          });
        });
      `;
			}

			if (node.type === "ExportAllDeclaration" && opts.moduleAll !== true) {
				// We can remove these, this signature has already been flagged by analyze() and we'll automatically forward it
				return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/modern/requireRewriteTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$requireRewriteTransform_ts$default = {
		name: "requireRewriteTransform",
		enter(path) {
			const {node, context} = path;

			const {relativeSourcesToModuleId, moduleId} = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				context,
			);

			// Replace all references to module.exports to the correct version
			if (
				node.type === "MemberExpression" &&
				___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
					node,
					"module.exports",
				)
			) {
				return ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.create({
					name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
						moduleId,
					),
					loc: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(
						node,
						"module.exports",
					),
				});
			}

			// Replace all assignments of module.exports to the correct version
			if (
				node.type === "AssignmentExpression" &&
				___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
					node.left,
					"module.exports",
				)
			) {
				return ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.create({
					operator: node.operator,
					left: ___R$project$rome$$romejs$js$ast$patterns$AssignmentIdentifier_ts$assignmentIdentifier.create({
						name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
							moduleId,
						),
						loc: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(
							node,
							"module.exports",
						),
					}),
					right: node.right,
				});
			}

			// Replace import foo = require('module');
			if (
				node.type === "TSImportEqualsDeclaration" &&
				node.moduleReference.type === "TSExternalModuleReference"
			) {
				return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${node.id} = require(${node.moduleReference.expression});`;
			}

			// Now handle normal `require('module')`
			if (node.type !== "CallExpression") {
				return node;
			}

			const {callee} = node;
			if (callee.type !== "ReferenceIdentifier" || callee.name !== "require") {
				return node;
			}

			const sourceArg = node.arguments[0];
			if (sourceArg.type !== "StringLiteral") {
				return node;
			}

			if (path.scope.hasBinding("require")) {
				return node;
			}

			const replacement = relativeSourcesToModuleId[sourceArg.value];
			if (typeof replacement === "string") {
				return ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.create({
					name: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
						replacement,
					),
				});
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/legacy/magicCJSTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$magicCJSTransform_ts$default = {
		name: "magicCJSTransform",
		enter(path) {
			const {node, scope, context} = path;
			const options = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				context,
			);

			// Update relative requires with their module id
			if (
				node.type === "CallExpression" &&
				node.callee.type === "ReferenceIdentifier" &&
				node.callee.name === "require" &&
				scope.getBinding("require") === undefined
			) {
				const args = node.arguments;
				const arg = args[0];

				// Maybe error?
				if (args.length !== 1 || arg.type !== "StringLiteral") {
					return node;
				}

				const source = arg.value;

				if (
					Object.prototype.hasOwnProperty.call(
						options.relativeSourcesToModuleId,
						source,
					)
				) {
					const resolved = options.relativeSourcesToModuleId[source];
					const sourceNode = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
						value: resolved,
					});
					return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Rome.requireNamespace(${sourceNode})`;
				}
			}

			if (
				node.type === "ReferenceIdentifier" &&
				node.name === "require" &&
				scope.getBinding("require") === undefined
			) {
				return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Rome.requireNamespace`;
			}

			return node;
		},
		exit(path) {
			const {node, context} = path;
			const options = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				context,
			);

			// Add module wrapper
			if (node.type === "Program") {
				const source = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
					value: options.moduleId,
				});

				// Build factory
				const factoryBody = ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
					directives: node.directives,
					body: node.body,
				});

				const factory = Object.assign(
					{},
					___R$project$rome$$romejs$js$ast$expressions$FunctionExpression_ts$functionExpression.assert(
						___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`(function(module, exports) {})`,
					),
					{body: factoryBody},
				);

				// Build call
				const declare =
					options.analyze.moduleType === "es"
						? ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Rome.declareES`
						: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Rome.declareCJS`;
				const wrapper = ___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`${declare}(${source}, ${factory})`;

				return Object.assign({}, node, {directives: [], body: [wrapper]});
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/legacy/inlineRequiresTransform.ts
const ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES = [];
	const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$default = {
		name: "inlineRequiresTransform",
		enter(path) {
			const {node} = path;

			if (node.type === "ReferenceIdentifier") {
				const binding = path.scope.getBinding(node.name);

				// Inline references to a require variable
				if (
					binding !== undefined &&
					binding instanceof
					___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ConstBinding
				) {
					const source = ___R$project$rome$$romejs$js$ast$utils$getRequireSource_ts$default(
						binding.value,
						path.scope,
						true,
					);
					if (
						source !== undefined &&
						!___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES.includes(
							source,
						) &&
						!___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(
							path,
						) &&
						binding.value !== undefined
					) {
						return binding.value;
					}
				}
			}

			return node;
		},
		exit(path) {
			const {node} = path;

			if (node.type === "Program" || node.type === "BlockStatement") {
				const body = [];
				let hadRequires = false;

				// Remove all require declarations that could have been inlined
				for (const bodyNode of node.body) {
					if (
						bodyNode.type === "VariableDeclarationStatement" &&
						bodyNode.declaration.kind === "const"
					) {
						let hadRequireDeclarators = false;
						const declarators = [];

						for (const decl of bodyNode.declaration.declarations) {
							if (decl.id.type !== "BindingIdentifier") {
								// Patterns aren't supported yet
								declarators.push(decl);
								continue;
							}

							const source = ___R$project$rome$$romejs$js$ast$utils$getRequireSource_ts$default(
								decl.init,
								path.scope,
								true,
							);
							if (source === undefined) {
								// Didn't contain a `require`
								declarators.push(decl);
								continue;
							}

							if (
								___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$NON_INLINED_REQUIRES.includes(
									source,
								)
							) {
								// Blacklisted
								declarators.push(decl);
								continue;
							}

							hadRequireDeclarators = true;
							hadRequires = true;
						}

						if (hadRequireDeclarators) {
							if (declarators.length > 0) {
								body.push(
									Object.assign(
										{},
										bodyNode,
										{
											declaration: Object.assign(
												{},
												bodyNode.declaration,
												{declarations: declarators},
											),
										},
									),
								);
							}
							continue;
						}
					}

					body.push(bodyNode);
				}

				if (!hadRequires) {
					return node;
				}

				return Object.assign({}, node, {body});
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/legacy/esToCJSTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$esToCJSTransform_ts$default = {
		name: "esToCJSTransform",
		enter(path) {
			const {node} = path;
			if (!___R$project$rome$$romejs$js$ast$core$Program_ts$program.is(node)) {
				return node;
			}

			const options = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getOptions(
				path.context,
			);

			const topBody = [];
			const bottomBody = [];

			for (const bodyNode of node.body) {
				if (bodyNode.type === "ImportDeclaration") {
					if (bodyNode.importKind === "type" || bodyNode.importKind === "typeof") {
						continue;
					}

					const moduleId = ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getModuleId(
						bodyNode.source.value,
						options,
					);
					if (moduleId === undefined) {
						continue;
					}

					const source = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
						value: moduleId,
					});

					const specifiers = ___R$project$rome$$romejs$js$ast$utils$getImportSpecifiers_ts$default(
						bodyNode,
					);
					if (specifiers.length === 0) {
						topBody.push(
							___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`Rome.requireNamespace(${source});`,
						);
					} else {
						for (const specifier of specifiers) {
							if (specifier.type === "ImportSpecifier") {
								topBody.push(
									___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireNamespace(${source}).${specifier.imported};`,
								);
							} else if (specifier.type === "ImportNamespaceSpecifier") {
								topBody.push(
									___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireNamespace(${source});`,
								);
							} else if (specifier.type === "ImportDefaultSpecifier") {
								topBody.push(
									___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`const ${specifier.local.name} = Rome.requireDefault(${source});`,
								);
							}
						}
					}
					continue;
				}

				if (bodyNode.type === "ExportAllDeclaration") {
					// TODO
					continue;
				}

				if (bodyNode.type === "ExportExternalDeclaration") {
					if (bodyNode.exportKind === "type") {
						continue;
					}

					const {source} = bodyNode;

					// TODO defaultSpecifier and namespaceSpecifier
					for (const specifier of bodyNode.namedSpecifiers) {
						topBody.push(
							___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`Object.defineProperty(exports, ${___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
								value: specifier.exported.name,
							})}, {
                get: function() {
                  return Rome.requireNamespace(${source}).${specifier.local};
                },
              })`,
						);
					}
				}

				if (bodyNode.type === "ExportLocalDeclaration") {
					if (bodyNode.exportKind === "type") {
						continue;
					}

					const {declaration, specifiers} = bodyNode;

					if (declaration !== undefined) {
						// Hoist function declarations
						if (declaration.type === "FunctionDeclaration") {
							topBody.push(
								___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${declaration.id} = ${declaration.id}`,
							);
							bottomBody.push(declaration);
							continue;
						}

						// Handle type declarations (these have no runtime ordering implications)
						if (
							declaration.type === "TSModuleDeclaration" ||
							declaration.type === "TSEnumDeclaration" ||
							declaration.type === "TypeAliasTypeAnnotation" ||
							declaration.type === "TSInterfaceDeclaration" ||
							declaration.type === "TSDeclareFunction"
						) {
							bottomBody.push(declaration);
							continue;
						}

						// Handle variables and classes
						if (
							declaration.type === "VariableDeclarationStatement" ||
							declaration.type === "ClassDeclaration"
						) {
							bottomBody.push(declaration);

							for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
								declaration,
							)) {
								topBody.push(
									___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${id} = undefined;`,
								);
								bottomBody.push(
									___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${id} = ${id};`,
								);
							}
						}
					}

					if (specifiers !== undefined) {
						for (const specifier of specifiers) {
							const binding = path.scope.getBinding(specifier.local.name);

							if (
								binding instanceof
								___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding
							) {
								topBody.push(
									___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = ${specifier.local};`,
								);
							} else {
								topBody.push(
									___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = undefined;`,
								);
								bottomBody.push(
									___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.${specifier.exported} = ${specifier.local};`,
								);
							}
						}
					}

					continue;
				}

				if (bodyNode.type === "ExportDefaultDeclaration") {
					const {declaration} = bodyNode;

					// Hoist function declarations
					if (declaration.type === "FunctionDeclaration") {
						// If it has an id then there's no way that anything in the program can refer to it, so inline it as a function expression
						if (declaration.id === undefined) {
							const expr = Object.assign(
								{},
								declaration,
								{type: "FunctionExpression"},
							);
							topBody.push(
								___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${expr};`,
							);
						} else {
							topBody.push(declaration);
							topBody.push(
								___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration.id};`,
							);
						}
						continue;
					}

					// Handle classes
					if (declaration.type === "ClassDeclaration") {
						// Technically we could hoist these if they have no super class, but we don't as it's not spec compliant
						topBody.push(
							___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = undefined;`,
						);
						if (declaration.id === undefined) {
							const expr = Object.assign(
								{},
								declaration,
								{type: "ClassExpression"},
							);
							bottomBody.push(
								___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${expr};`,
							);
						} else {
							bottomBody.push(declaration);
							bottomBody.push(
								___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration.id};`,
							);
						}
						continue;
					}

					// Handle type declarations (these have no runtime ordering implications)
					if (
						declaration.type === "TSInterfaceDeclaration" ||
						declaration.type === "TSDeclareFunction"
					) {
						// Maybe we should keep them? Not sure what they would desugar to
						continue;
					}

					// Otherwise it's an expression
					bottomBody.push(
						___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = ${declaration};`,
					);

					// There are cases where we could omit this declaration at all if we the file has no imports, some other conditions etc
					topBody.push(
						___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement`exports.default = undefined;`,
					);

					continue;
				}

				bottomBody.push(bodyNode);
			}

			return Object.assign({}, node, {body: [...topBody, ...bottomBody]});
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/metaPropertyTransform.ts
function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(
		node,
	) {
		return (
			node.type === "MetaProperty" &&
			node.meta.name === "import" &&
			node.property.name === "meta"
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(
		context,
	) {
		const str = ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
			value: "file://" +
			___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$getFilename(
				context,
			),
		});
		return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`typeof __filename === 'string' ? 'file://' + __filename : ${str}`;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$getFilename(
		context,
	) {
		const {path} = context;
		if (path === undefined) {
			return "";
		} else {
			return path.join();
		}
	}
	const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$default = {
		name: "metaPropertyTransform",
		enter(path) {
			const {node, context} = path;

			// Inline __filenamd and __dirname

			/*if (
      node.type === 'ReferenceIdentifier' &&
      (node.type === '__dirname' || node.name === '__filename')
    ) {
      if (node.type === '__dirname') {
        return stringLiteral.create({
          value: pathUtils.dirname(getFilename(context)),
        });
      }

      if (node.type === '__filename') {
        return stringLiteral.create({
          value: getFilename(context),
        });
      }
    }*/

			// Direct reference to import.meta.url
			if (
				node.type === "MemberExpression" &&
				node.property.type === "StaticMemberProperty" &&
				___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(
					node.object,
				) &&
				node.property.value.type === "Identifier" &&
				node.property.value.name === "url"
			) {
				return ___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(
					context,
				);
			}

			// This is an escaped import.meta or else our other transform would have changed it
			if (
				___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$isImportMeta(
					node,
				)
			) {
				return ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`({url: ${___R$$priv$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$createURLString(
					context,
				)}})`;
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/scopedRomeTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$scopedRomeTransform_ts$default = {
		name: "scopedRome",
		enter(path) {
			const {node, scope} = path;

			if (scope.node === node && scope.hasBinding("Rome")) {
				return ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(
					path,
					new Map([["Rome", scope.generateUid("Rome")]]),
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/asyncImportTransform.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$asyncImportTransform_ts$default = {
		name: "asyncImport",
		enter(path) {
			const {node} = path;

			if (node.type === "CallExpression" && node.callee.type === "ImportCall") {
				return Object.assign(
					{},
					node,
					{
						callee: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create({
							name: "require",
						}),
					},
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/compileForBundle/inlineEnv.ts
const ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$inlineEnv_ts$default = {
		name: "inlineEnv",
		enter(path) {
			const {node} = path;

			if (
				node.type === "MemberExpression" &&
				node.property.value.type === "Identifier" &&
				node.property.value.name === "NODE_ENV" &&
				!path.scope.hasBinding("process") &&
				___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
					node,
					"process.env.NODE_ENV",
				)
			) {
				return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.create({
					value: "development",
				});
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/transforms/index.ts
const ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageOrder = [
		"pre",
		"compile",
		"compileForBundle",
	];

	const ___R$project$rome$$romejs$js$compiler$transforms$index_ts$hookVisitors = [
		___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$variableInjectorVisitor,
		___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$commentInjectorVisitor,
	];

	const ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageTransforms = {
		// These may effect dependency analysis
		pre: () => [
			___R$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeImports_ts$default,
			___R$project$rome$$romejs$js$compiler$transforms$compile$validation$optimizeExports_ts$default,
			___R$project$rome$$romejs$js$compiler$transforms$compile$jsx_ts$default,
		],
		compile: () => [
			___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$paramlessCatch_ts$default,
			___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$optionalChaining_ts$default,
			___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$nullishCoalescing_ts$default,
			___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$objectSpread_ts$default,
			___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$classProperties_ts$default,
			___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$templateLiterals_ts$default,
			___R$project$rome$$romejs$js$compiler$transforms$compile$transpile$callSpread_ts$default,
		],
		compileForBundle: (projectConfig, options) => {
			const opts = options.bundle;
			if (opts === undefined) {
				throw new Error("Expected bundle options for compileForBundle stage");
			}

			const transforms = [];

			if (opts.assetPath !== undefined) {
				transforms.push(
					___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$assetTransform_ts$default,
				);
			}
			transforms.push(
				___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$metaPropertyTransform_ts$default,
			);
			transforms.push(
				___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$asyncImportTransform_ts$default,
			);
			transforms.push(
				___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$scopedRomeTransform_ts$default,
			);
			transforms.push(
				___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$inlineEnv_ts$default,
			);

			if (opts.mode === "modern") {
				transforms.push(
					___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$requireRewriteTransform_ts$default,
				);
				transforms.push(
					opts.analyze.moduleType === "cjs"
						? ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$cjsRootTransform_ts$default
						: ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$modern$esToRefTransform_ts$default,
				);
			} else {
				transforms.push(
					___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$inlineRequiresTransform_ts$default,
				);
				transforms.push(
					___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$esToCJSTransform_ts$default,
				);
				transforms.push(
					___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$legacy$magicCJSTransform_ts$default,
				);
			}

			return transforms;
		},
	};


  // project-rome/@romejs/string-diff/index.ts





	/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
	const ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE = -1;
	const ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT = 1;
	const ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL = 0;
	const ___R$project$rome$$romejs$string$diff$index_ts$diffConstants = {
		DELETE: ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE,
		EQUAL: ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
		ADD: ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
	};

	function ___R$project$rome$$romejs$string$diff$index_ts$groupDiffByLines(
		rawDiffs,
	) {
		const diffsByLine = [];

		// Refers to the current line array being built
		let line = [];
		function flushLine() {
			if (line.length > 0) {
				diffsByLine.push(line);
				line = [];
			}
		}

		for (const tuple of rawDiffs) {
			const [type, text] = tuple;

			// Deleted lines don't affect the line count
			if (
				type ===
				___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE
			) {
				line.push(tuple);
				continue;
			}

			// Get all the lines
			const parts = text.split("\n");

			// Doesn't contain a newline
			if (parts.length <= 1) {
				line.push(tuple);
				continue;
			}

			// Deconstruct each text chunk
			const [currentLine, ...futureLines] = parts;

			// The first chunk belongs to the current line
			if (currentLine !== "") {
				line.push([type, currentLine]);
			}

			// Create unique lines for each other chunk
			for (const newLine of futureLines) {
				flushLine();
				line.push([type, newLine]);
			}
		}

		flushLine();

		return diffsByLine;
	}

	function ___R$project$rome$$romejs$string$diff$index_ts$default(text1, text2) {
		// only pass fix_unicode=true at the top level, not when main is
		// recursively invoked
		return ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(
			text1,
			text2,
			true,
		);
	}

	/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info
 * @return {Array} Array of diff tuples.
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(
		text1,
		text2,
		fixUnicode = false,
	) {
		// Check for equality
		if (text1 === text2) {
			if (text1) {
				return [
					[
						___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
						text1,
					],
				];
			}
			return [];
		}

		// Trim off common prefix (speedup).
		let commonlength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonPrefix(
			text1,
			text2,
		);
		let commonprefix = text1.substring(0, commonlength);
		text1 = text1.substring(commonlength);
		text2 = text2.substring(commonlength);

		// Trim off common suffix (speedup).
		commonlength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonSuffix(
			text1,
			text2,
		);
		let commonsuffix = text1.substring(text1.length - commonlength);
		text1 = text1.substring(0, text1.length - commonlength);
		text2 = text2.substring(0, text2.length - commonlength);

		// Compute the diff on the middle block.
		let diffs = ___R$$priv$project$rome$$romejs$string$diff$index_ts$compute(
			text1,
			text2,
		);

		// Restore the prefix and suffix.
		if (commonprefix) {
			diffs.unshift([
				___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
				commonprefix,
			]);
		}
		if (commonsuffix) {
			diffs.push([
				___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
				commonsuffix,
			]);
		}
		___R$$priv$project$rome$$romejs$string$diff$index_ts$cleanupMerge(
			diffs,
			fixUnicode,
		);
		return diffs;
	}

	/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$compute(
		text1,
		text2,
	) {
		let diffs = [];

		if (!text1) {
			// Just add some text (speedup).
			return [
				[
					___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
					text2,
				],
			];
		}

		if (!text2) {
			// Just delete some text (speedup).
			return [
				[
					___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE,
					text1,
				],
			];
		}

		let longtext = text1.length > text2.length ? text1 : text2;
		let shorttext = text1.length > text2.length ? text2 : text1;
		let i = longtext.indexOf(shorttext);
		if (i !== -1) {
			// Shorter text is inside the longer text (speedup).
			diffs = [
				[
					___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
					longtext.substring(0, i),
				],
				[
					___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
					shorttext,
				],
				[
					___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
					longtext.substring(i + shorttext.length),
				],
			];
			// Swap insertions for deletions if diff is reversed.
			if (text1.length > text2.length) {
				diffs[0][0] = diffs[2][0] = ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE;
			}
			return diffs;
		}

		if (shorttext.length === 1) {
			// Single character string.
			// After the previous speedup, the character can't be an equality.
			return [
				[
					___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE,
					text1,
				],
				[
					___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
					text2,
				],
			];
		}

		// Check to see if the problem can be split in two.
		let hm = ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatch(
			text1,
			text2,
		);
		if (hm) {
			// A half-match was found, sort out the return data.
			let text1A = hm[0];
			let text1B = hm[1];
			let text2A = hm[2];
			let text2B = hm[3];
			let midCommon = hm[4];
			// Send both pairs off for separate processing.
			let diffsA = ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(
				text1A,
				text2A,
			);
			let diffsB = ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(
				text1B,
				text2B,
			);
			// Merge the results.
			return diffsA.concat(
				[
					[
						___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
						midCommon,
					],
				],
				diffsB,
			);
		}

		return ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisect(
			text1,
			text2,
		);
	}

	/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisect(
		text1,
		text2,
	) {
		// Cache the text lengths to prevent multiple calls.
		let text1Length = text1.length;
		let text2Length = text2.length;
		let maxD = Math.ceil((text1Length + text2Length) / 2);
		let vOffset = maxD;
		let vLength = 2 * maxD;
		let v1 = new Array(vLength);
		let v2 = new Array(vLength);

		// Setting all elements to -1 is faster in Chrome & Firefox than mixing
		// integers and undefined.
		for (let x = 0; x < vLength; x++) {
			v1[x] = -1;
			v2[x] = -1;
		}
		v1[vOffset + 1] = 0;
		v2[vOffset + 1] = 0;
		let delta = text1Length - text2Length;

		// If the total number of characters is odd, then the front path will collide
		// with the reverse path.
		let front = delta % 2 !== 0;

		// Offsets for start and end of k loop.
		// Prevents mapping of space beyond the grid.
		let k1Start = 0;
		let k1End = 0;
		let k2Start = 0;
		let k2End = 0;
		for (let d = 0; d < maxD; d++) {
			// Walk the front path one step.
			for (let k1 = -d + k1Start; k1 <= d - k1End; k1 += 2) {
				let k1Offset = vOffset + k1;
				let x1;
				if (k1 === -d || (k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1])) {
					x1 = v1[k1Offset + 1];
				} else {
					x1 = v1[k1Offset - 1] + 1;
				}
				let y1 = x1 - k1;
				while (
					x1 < text1Length &&
					y1 < text2Length &&
					text1.charAt(x1) === text2.charAt(y1)
				) {
					x1++;
					y1++;
				}
				v1[k1Offset] = x1;
				if (x1 > text1Length) {
					// Ran off the right of the graph.
					k1End += 2;
				} else if (y1 > text2Length) {
					// Ran off the bottom of the graph.
					k1Start += 2;
				} else if (front) {
					let k2Offset = vOffset + delta - k1;
					if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
						// Mirror x2 onto top-left coordinate system.
						let x2 = text1Length - v2[k2Offset];
						if (x1 >= x2) {
							// Overlap detected.
							return ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisectSplit(
								text1,
								text2,
								x1,
								y1,
							);
						}
					}
				}
			}

			// Walk the reverse path one step.
			for (let k2 = -d + k2Start; k2 <= d - k2End; k2 += 2) {
				let k2Offset = vOffset + k2;
				let x2;
				if (k2 === -d || (k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1])) {
					x2 = v2[k2Offset + 1];
				} else {
					x2 = v2[k2Offset - 1] + 1;
				}
				let y2 = x2 - k2;
				while (
					x2 < text1Length &&
					y2 < text2Length &&
					text1.charAt(text1Length - x2 - 1) ===
					text2.charAt(text2Length - y2 - 1)
				) {
					x2++;
					y2++;
				}
				v2[k2Offset] = x2;
				if (x2 > text1Length) {
					// Ran off the left of the graph.
					k2End += 2;
				} else if (y2 > text2Length) {
					// Ran off the top of the graph.
					k2Start += 2;
				} else if (!front) {
					let k1Offset = vOffset + delta - k2;
					if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
						let x1 = v1[k1Offset];
						let y1 = vOffset + x1 - k1Offset;
						// Mirror x2 onto top-left coordinate system.
						x2 = text1Length - x2;
						if (x1 >= x2) {
							// Overlap detected.
							return ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisectSplit(
								text1,
								text2,
								x1,
								y1,
							);
						}
					}
				}
			}
		}

		// Diff took too long and hit the deadline or
		// number of diffs equals number of characters, no commonality at all.
		return [
			[___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE, text1],
			[___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT, text2],
		];
	}

	/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$bisectSplit(
		text1,
		text2,
		x,
		y,
	) {
		let text1A = text1.substring(0, x);
		let text2A = text2.substring(0, y);
		let text1B = text1.substring(x);
		let text2B = text2.substring(y);

		// Compute both diffs serially.
		let diffs = ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(
			text1A,
			text2A,
		);
		let diffsb = ___R$$priv$project$rome$$romejs$string$diff$index_ts$main(
			text1B,
			text2B,
		);

		return diffs.concat(diffsb);
	}

	/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonPrefix(
		text1,
		text2,
	) {
		// Quick check for common null cases.
		if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
			return 0;
		}

		// Binary search.
		// Performance analysis: http://neil.fraser.name/news/2007/10/09/
		let pointermin = 0;
		let pointermax = Math.min(text1.length, text2.length);
		let pointermid = pointermax;
		let pointerstart = 0;
		while (pointermin < pointermid) {
			if (
				text1.substring(pointerstart, pointermid) ===
				text2.substring(pointerstart, pointermid)
			) {
				pointermin = pointermid;
				pointerstart = pointermin;
			} else {
				pointermax = pointermid;
			}
			pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
		}

		if (
			___R$$priv$project$rome$$romejs$string$diff$index_ts$isSurrogatePairStart(
				text1.charCodeAt(pointermid - 1),
			)
		) {
			pointermid--;
		}

		return pointermid;
	}

	/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonSuffix(
		text1,
		text2,
	) {
		// Quick check for common null cases.
		if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
			return 0;
		}

		// Binary search.

		// Performance analysis: http://neil.fraser.name/news/2007/10/09/
		let pointermin = 0;
		let pointermax = Math.min(text1.length, text2.length);
		let pointermid = pointermax;
		let pointerend = 0;
		while (pointermin < pointermid) {
			if (
				text1.substring(text1.length - pointermid, text1.length - pointerend) ===
				text2.substring(text2.length - pointermid, text2.length - pointerend)
			) {
				pointermin = pointermid;
				pointerend = pointermin;
			} else {
				pointermax = pointermid;
			}
			pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
		}

		if (
			___R$$priv$project$rome$$romejs$string$diff$index_ts$isSurrogatePairEnd(
				text1.charCodeAt(text1.length - pointermid),
			)
		) {
			pointermid--;
		}

		return pointermid;
	}

	/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatch(
		text1,
		text2,
	) {
		let longtext = text1.length > text2.length ? text1 : text2;
		let shorttext = text1.length > text2.length ? text2 : text1;
		if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
			return undefined; // Pointless.
		}

		// First check if the second quarter is the seed for a half-match.
		let hm1 = ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatchI(
			longtext,
			shorttext,
			Math.ceil(longtext.length / 4),
		);

		// Check again based on the third quarter.
		let hm2 = ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatchI(
			longtext,
			shorttext,
			Math.ceil(longtext.length / 2),
		);

		let hm;
		if (!hm1 && !hm2) {
			return undefined;
		} else if (hm2) {
			if (hm1) {
				// Both matched.  Select the longest.
				hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
			} else {
				hm = hm2;
			}
		} else {
			hm = hm1;
		}

		if (hm === undefined) {
			throw new Error("Expected half match");
		}

		// A half-match was found, sort out the return data.
		let text1A;
		let text1B;
		let text2A;
		let text2B;
		if (text1.length > text2.length) {
			text1A = hm[0];
			text1B = hm[1];
			text2A = hm[2];
			text2B = hm[3];
		} else {
			text2A = hm[0];
			text2B = hm[1];
			text1A = hm[2];
			text1B = hm[3];
		}
		let midCommon = hm[4];
		return [text1A, text1B, text2A, text2B, midCommon];
	}

	/**
 * Does a substring of shorttext exist within longtext such that the substring
 * is at least half the length of longtext?
 * Closure, but does not reference any external variables.
 * @param {string} longtext Longer string.
 * @param {string} shorttext Shorter string.
 * @param {number} i Start index of quarter length substring within longtext.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
 *     of shorttext and the common middle.  Or null if there was no match.
 * @private
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$halfMatchI(
		longtext,
		shorttext,
		i,
	) {
		// Start with a 1/4 length substring at position i as a seed.
		let seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
		let j = -1;
		let bestCommon = "";
		let bestLongtextA = "";
		let bestLongtextB = "";
		let bestShorttextA = "";
		let bestShorttextB = "";
		while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
			let prefixLength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonPrefix(
				longtext.substring(i),
				shorttext.substring(j),
			);
			let suffixLength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonSuffix(
				longtext.substring(0, i),
				shorttext.substring(0, j),
			);
			if (bestCommon.length < suffixLength + prefixLength) {
				bestCommon =
					shorttext.substring(j - suffixLength, j) +
					shorttext.substring(j, j + prefixLength);
				bestLongtextA = longtext.substring(0, i - suffixLength);
				bestLongtextB = longtext.substring(i + prefixLength);
				bestShorttextA = shorttext.substring(0, j - suffixLength);
				bestShorttextB = shorttext.substring(j + prefixLength);
			}
		}

		if (bestCommon.length * 2 >= longtext.length) {
			return [
				bestLongtextA,
				bestLongtextB,
				bestShorttextA,
				bestShorttextB,
				bestCommon,
			];
		} else {
			return undefined;
		}
	}

	/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff
 */
	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$cleanupMerge(
		diffs,
		fixUnicode,
	) {
		diffs.push([
			___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
			"",
		]); // Add a dummy entry at the end.
		let pointer = 0;
		let countDelete = 0;
		let countInsert = 0;
		let textDelete = "";
		let textInsert = "";
		let commonlength;
		while (pointer < diffs.length) {
			if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
				diffs.splice(pointer, 1);
				continue;
			}
			switch (diffs[pointer][0]) {
				case ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT: {
					countInsert++;
					textInsert += diffs[pointer][1];
					pointer++;
					break;
				}
				case ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE: {
					countDelete++;
					textDelete += diffs[pointer][1];
					pointer++;
					break;
				}
				case ___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL: {
					let previousEquality = pointer - countInsert - countDelete - 1;
					if (fixUnicode) {
						// prevent splitting of unicode surrogate pairs.  when fix_unicode is true,
						// we assume that the old and new text in the diff are complete and correct
						// unicode-encoded JS strings, but the tuple boundaries may fall between
						// surrogate pairs.  we fix this by shaving off stray surrogates from the end
						// of the previous equality and the beginning of this equality.  this may create
						// empty equalities or a common prefix or suffix.  for example, if AB and AC are
						// emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and
						// inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this
						// particular case, both equalities go away, we absorb any previous inequalities,
						// and we keep scanning for the next equality before rewriting the tuples.
						if (
							previousEquality >= 0 &&
							___R$$priv$project$rome$$romejs$string$diff$index_ts$endsWithPairStart(
								diffs[previousEquality][1],
							)
						) {
							let stray = diffs[previousEquality][1].slice(-1);
							diffs[previousEquality][1] = diffs[previousEquality][1].slice(
								0,
								-1,
							);
							textDelete = stray + textDelete;
							textInsert = stray + textInsert;
							if (!diffs[previousEquality][1]) {
								// emptied out previous equality, so delete it and include previous delete/insert
								diffs.splice(previousEquality, 1);
								pointer--;
								let k = previousEquality - 1;
								if (
									diffs[k] &&
									diffs[k][0] ===
									___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT
								) {
									countInsert++;
									textInsert = diffs[k][1] + textInsert;
									k--;
								}
								if (
									diffs[k] &&
									diffs[k][0] ===
									___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE
								) {
									countDelete++;
									textDelete = diffs[k][1] + textDelete;
									k--;
								}
								previousEquality = k;
							}
						}
						if (
							___R$$priv$project$rome$$romejs$string$diff$index_ts$startsWithPairEnd(
								diffs[pointer][1],
							)
						) {
							let stray = diffs[pointer][1].charAt(0);
							diffs[pointer][1] = diffs[pointer][1].slice(1);
							textDelete += stray;
							textInsert += stray;
						}
					}
					if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
						// for empty equality not at end, wait for next equality
						diffs.splice(pointer, 1);
						break;
					}
					if (textDelete.length > 0 || textInsert.length > 0) {
						// note that commonPrefix and commonSuffix are unicode-aware
						if (textDelete.length > 0 && textInsert.length > 0) {
							// Factor out any common prefixes.
							commonlength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonPrefix(
								textInsert,
								textDelete,
							);
							if (commonlength !== 0) {
								if (previousEquality >= 0) {
									diffs[previousEquality][1] += textInsert.substring(
										0,
										commonlength,
									);
								} else {
									diffs.splice(
										0,
										0,
										[
											___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL,
											textInsert.substring(0, commonlength),
										],
									);
									pointer++;
								}
								textInsert = textInsert.substring(commonlength);
								textDelete = textDelete.substring(commonlength);
							}

							// Factor out any common suffixes.
							commonlength = ___R$$priv$project$rome$$romejs$string$diff$index_ts$commonSuffix(
								textInsert,
								textDelete,
							);
							if (commonlength !== 0) {
								diffs[pointer][1] =
									textInsert.substring(textInsert.length - commonlength) +
									diffs[pointer][1];
								textInsert = textInsert.substring(
									0,
									textInsert.length - commonlength,
								);
								textDelete = textDelete.substring(
									0,
									textDelete.length - commonlength,
								);
							}
						}

						// Delete the offending records and add the merged ones.
						let n = countInsert + countDelete;
						if (textDelete.length === 0 && textInsert.length === 0) {
							diffs.splice(pointer - n, n);
							pointer = pointer - n;
						} else if (textDelete.length === 0) {
							diffs.splice(
								pointer - n,
								n,
								[
									___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
									textInsert,
								],
							);
							pointer = pointer - n + 1;
						} else if (textInsert.length === 0) {
							diffs.splice(
								pointer - n,
								n,
								[
									___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE,
									textDelete,
								],
							);
							pointer = pointer - n + 1;
						} else {
							diffs.splice(
								pointer - n,
								n,
								[
									___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_DELETE,
									textDelete,
								],
								[
									___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_INSERT,
									textInsert,
								],
							);
							pointer = pointer - n + 2;
						}
					}
					if (
						pointer !== 0 &&
						diffs[pointer - 1][0] ===
						___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL
					) {
						// Merge this equality with the previous one.
						diffs[pointer - 1][1] += diffs[pointer][1];
						diffs.splice(pointer, 1);
					} else {
						pointer++;
					}
					countInsert = 0;
					countDelete = 0;
					textDelete = "";
					textInsert = "";
					break;
				}
			}
		}
		if (diffs[diffs.length - 1][1] === "") {
			// Remove the dummy entry at the end.
			diffs.pop();
		}

		// Second pass: look for single edits surrounded on both sides by equalities
		// which can be shifted sideways to eliminate an equality.
		// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
		let changes = false;
		pointer = 1;

		// Intentionally ignore the first and last element (don't need checking).
		while (pointer < diffs.length - 1) {
			if (
				diffs[pointer - 1][0] ===
				___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL &&
				diffs[pointer + 1][0] ===
				___R$$priv$project$rome$$romejs$string$diff$index_ts$DIFF_EQUAL
			) {
				// This is a single edit surrounded by equalities.
				if (
					diffs[pointer][1].substring(
						diffs[pointer][1].length - diffs[pointer - 1][1].length,
					) ===
					diffs[pointer - 1][1]
				) {
					// Shift the edit over the previous equality.
					diffs[pointer][1] =
						diffs[pointer - 1][1] +
						diffs[pointer][1].substring(
							0,
							diffs[pointer][1].length - diffs[pointer - 1][1].length,
						);
					diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
					diffs.splice(pointer - 1, 1);
					changes = true;
				} else if (
					diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ===
					diffs[pointer + 1][1]
				) {
					// Shift the edit over the next equality.
					diffs[pointer - 1][1] += diffs[pointer + 1][1];
					diffs[pointer][1] =
						diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
						diffs[pointer + 1][1];
					diffs.splice(pointer + 1, 1);
					changes = true;
				}
			}
			pointer++;
		}

		// If shifts were made, the diff needs reordering and another shift sweep.
		if (changes) {
			___R$$priv$project$rome$$romejs$string$diff$index_ts$cleanupMerge(
				diffs,
				fixUnicode,
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$isSurrogatePairStart(
		charCode,
	) {
		return charCode >= 55_296 && charCode <= 56_319;
	}

	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$isSurrogatePairEnd(
		charCode,
	) {
		return charCode >= 56_320 && charCode <= 57_343;
	}

	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$startsWithPairEnd(
		str,
	) {
		return ___R$$priv$project$rome$$romejs$string$diff$index_ts$isSurrogatePairEnd(
			str.charCodeAt(0),
		);
	}

	function ___R$$priv$project$rome$$romejs$string$diff$index_ts$endsWithPairStart(
		str,
	) {
		return ___R$$priv$project$rome$$romejs$string$diff$index_ts$isSurrogatePairStart(
			str.charCodeAt(str.length - 1),
		);
	}


  // project-rome/@romejs/js-compiler/lint/decisions.ts
const ___R$project$rome$$romejs$js$compiler$lint$decisions_ts = {
		deriveDecisionPositionKey: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$deriveDecisionPositionKey,
		parseDecisionStrings: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$parseDecisionStrings,
		buildLintDecisionGlobalString: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionGlobalString,
		buildLintDecisionString: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionString,
		buildLintDecisionAdviceAction: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionAdviceAction,
	};


	function ___R$$priv$project$rome$$romejs$js$compiler$lint$decisions_ts$validateAction(
		raw,
		unexpected,
	) {
		if (raw === "fix" || raw === "suppress" || raw === "ignore") {
			return raw;
		} else {
			unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT_COMMAND.INVALID_DECISION_ACTION(
					raw,
				),
			);
			return undefined;
		}
	}

	function ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$deriveDecisionPositionKey(
		action,
		loc,
	) {
		if (loc === undefined) {
			return undefined;
		}

		const {start} = loc;
		if (start === undefined) {
			return undefined;
		}

		if (action === "suppress") {
			return ___R$project$rome$$romejs$ob1$index_ts$ob1Get1(start.line);
		} else {
			return (
				___R$project$rome$$romejs$ob1$index_ts$ob1Get1(start.line) +
				":" +
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(start.column)
			);
		}
	}

	function ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$parseDecisionStrings(
		decisions,
		cwd,
		unexpected,
	) {
		const lintCompilerOptionsPerFile = {};
		const globalDecisions = [];

		function parseGlobalDecision(parts, i) {
			if (parts.length !== 2) {
				unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT_COMMAND.INVALID_DECISION_PART_COUNT(
						i,
					),
				);
			}

			const [rawAction, rawCategory] = parts;

			const action = ___R$$priv$project$rome$$romejs$js$compiler$lint$decisions_ts$validateAction(
				rawAction,
				unexpected,
			);
			if (action === undefined) {
				return;
			}

			const category = (rawCategory);
			globalDecisions.push({category, action});
		}

		function parseLineDecision(parts, i) {
			if (parts.length < 4 || parts.length > 5) {
				unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT_COMMAND.INVALID_DECISION_PART_COUNT(
						i,
					),
				);
			}

			const [rawAction, rawCategory, rawFilename, pos, id] = parts;

			const action = ___R$$priv$project$rome$$romejs$js$compiler$lint$decisions_ts$validateAction(
				rawAction,
				unexpected,
			);
			if (action === undefined) {
				return;
			}

			const category = (rawCategory);
			const resolvedFilename = cwd.resolve(rawFilename).join();

			let compilerOptions = lintCompilerOptionsPerFile[resolvedFilename];
			if (compilerOptions === undefined) {
				compilerOptions = {
					hasDecisions: true,
					globalDecisions: [],
					decisionsByPosition: {},
				};
				lintCompilerOptionsPerFile[resolvedFilename] = compilerOptions;
			}

			let decisionsForPosition = compilerOptions.decisionsByPosition[pos];
			if (decisionsForPosition === undefined) {
				decisionsForPosition = [];
				compilerOptions.decisionsByPosition[pos] = decisionsForPosition;
			}

			decisionsForPosition.push({
				action,
				category,
				id: id === undefined ? undefined : Number(id),
			});
		}

		for (let i = 0; i < decisions.length; i++) {
			const segment = decisions[i];
			const parts = ___R$project$rome$$romejs$string$utils$escapeSplit_ts$escapeSplit(
				segment,
				"-",
			);

			if (parts[0] === "global") {
				parseGlobalDecision(parts.slice(1), i);
			} else {
				parseLineDecision(parts, i);
			}
		}

		return {lintCompilerOptionsPerFile, globalDecisions};
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$decisions_ts$escapeFilename(
		filename,
	) {
		return filename.replace(/-/, "\\-");
	}

	function ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionGlobalString(
		action,
		category,
	) {
		return "global-" + action + "-" + category;
	}

	function ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionString(
		{
			filename,
			action,
			category,
			start,
			id,
		},
	) {
		const escapedFilename = ___R$$priv$project$rome$$romejs$js$compiler$lint$decisions_ts$escapeFilename(
			filename,
		);
		const pos = ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$deriveDecisionPositionKey(
			action,
			{start},
		);

		const parts = [action, category, escapedFilename, pos];

		if (id !== undefined) {
			parts.push(String(id));
		}

		return parts.join("-");
	}

	function ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionAdviceAction(
		{
			noun,
			instruction,
			filename,
			shortcut,
			decision,
			extra,
		},
	) {
		return {
			type: "action",
			extra,
			hidden: true,
			command: "lint",
			shortcut,
			args: filename === undefined
				? []
				: [
						___R$$priv$project$rome$$romejs$js$compiler$lint$decisions_ts$escapeFilename(
							filename,
						),
					],
			noun,
			instruction,
			commandFlags: {
				decisions: [decision],
			},
		};
	}


  // project-rome/@romejs/js-compiler/lib/CompilerContext.ts







	function ___R$$priv$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$getFormattedCodeFromExitResult(
		result,
	) {
		if (Array.isArray(result)) {
			// TODO?
			return "";
		} else if (
			result ===
			___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE
		) {
			return "";
		} else {
			return ___R$project$rome$$romejs$js$formatter$index_ts$formatJS(result).code;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default {
		constructor(arg) {
			const {
				ast,
				origin,
				ref,
				frozen = false,
				options = {},
				sourceText = "",
				project = {
					folder: undefined,
					config: ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
				},
				suppressions,
			} = arg;

			this.records = [];

			this.path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
				ast.filename,
			);
			this.filename = ast.filename;
			this.sourceText = sourceText;
			this.displayFilename =
				ref === undefined ? ast.filename : ref.relative.join();
			this.frozen = frozen;
			this.mtime = ast.mtime;
			this.project = project;
			this.options = options;
			this.origin = origin;
			this.cacheDependencies = new Set();
			this.sourceType = ast.sourceType;
			this.rootScope = new ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$RootScope(
				this,
				ast,
			);

			this.comments = new ___R$project$rome$$romejs$js$parser$CommentsConsumer_ts$default(
				ast.comments,
			);
			this.diagnostics = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default();

			if (suppressions === undefined) {
				const {suppressions, diagnostics} = ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromProgram(
					this,
					ast,
				);
				this.suppressions = suppressions;
				this.diagnostics.addDiagnostics(diagnostics);
			} else {
				this.suppressions = suppressions;
			}
		}

		async normalizeTransforms(transforms) {
			return Promise.all(
				transforms.map(async (visitor) => {
					if (typeof visitor === "function") {
						return await visitor(this);
					} else {
						return visitor;
					}
				}),
			);
		}

		getComments(ids) {
			return this.comments.getCommentsFromIds(ids);
		}

		hasLocSuppression(loc, category) {
			if (loc === undefined) {
				return false;
			}

			for (const suppression of this.suppressions) {
				if (
					suppression.category === category &&
					___R$project$rome$$romejs$js$compiler$suppressions_ts$matchesSuppression(
						loc,
						suppression,
					)
				) {
					return true;
				}
			}

			return false;
		}

		getRootScope() {
			const {rootScope} = this;
			if (rootScope === undefined) {
				throw new Error("Expected root scope");
			}
			return rootScope;
		}

		getCacheDependencies() {
			return Array.from(this.cacheDependencies);
		}

		addCacheDependency(filename) {
			this.cacheDependencies.add(filename);
		}

		reduceRoot(ast, visitors, pathOpts) {
			return ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(
				___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
					ast,
					[
						...___R$project$rome$$romejs$js$compiler$transforms$index_ts$hookVisitors,
						...(Array.isArray(visitors) ? visitors : [visitors]),
					],
					this,
					pathOpts,
				),
			);
		}

		reduce(ast, visitors, pathOpts) {
			return ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
				ast,
				Array.isArray(visitors) ? visitors : [visitors],
				this,
				pathOpts,
			);
		}

		record(record) {
			this.records.push(record);
		}

		hasLintDecisions() {
			const {lint} = this.options;
			return lint !== undefined && lint.hasDecisions === true;
		}

		getLintDecisions(key) {
			const {lint} = this.options;
			if (lint === undefined) {
				return [];
			}

			const {globalDecisions = []} = lint;

			if (key === undefined) {
				return globalDecisions;
			}

			const {decisionsByPosition} = lint;
			if (decisionsByPosition === undefined) {
				return globalDecisions;
			}

			return [...globalDecisions, ...(decisionsByPosition[key] || [])];
		}

		addFixableDiagnostic(nodes, description, diag = {}) {
			const {old, fixed: defaultFixed, suggestions} = nodes;
			const target = nodes.target === undefined ? nodes.old : nodes.target;

			const {category} = description;
			const advice = [...description.advice];
			const loc = this.getLoc(target);
			const oldCode =
				loc === undefined
					? ""
					: this.sourceText.slice(
							___R$project$rome$$romejs$ob1$index_ts$ob1Get0(loc.start.index),
							___R$project$rome$$romejs$ob1$index_ts$ob1Get0(loc.end.index),
						);

			let fixed = defaultFixed;

			// Add recommended fix
			if (defaultFixed !== undefined) {
				advice.push({
					type: "log",
					category: "info",
					text: "Recommended fix",
				});

				advice.push({
					type: "diff",
					diff: ___R$project$rome$$romejs$string$diff$index_ts$default(
						oldCode,
						___R$$priv$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$getFormattedCodeFromExitResult(
							defaultFixed,
						),
					),
				});
				if (loc === undefined) {
					advice.push({
						type: "log",
						category: "error",
						text: "Unable to find target location",
					});
				} else {
					advice.push(
						___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
							filename: this.displayFilename,
							decision: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionString({
								action: "fix",
								filename: this.displayFilename,
								category,
								start: loc.start,
							}),
							shortcut: "f",
							noun: "Apply fix",
							instruction: "To apply this fix run",
						}),
					);

					advice.push(
						___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
							extra: true,
							noun: "Apply fix for ALL files with this category",
							instruction: "To apply fix for ALL files with this category run",
							decision: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionGlobalString(
								"fix",
								category,
							),
						}),
					);
				}
			}

			if (suggestions !== undefined) {
				// If we have lint decisions then find the fix that corresponds with this suggestion
				if (this.hasLintDecisions()) {
					const decisions = this.getLintDecisions(
						___R$project$rome$$romejs$js$compiler$lint$decisions_ts$deriveDecisionPositionKey(
							"fix",
							loc,
						),
					);
					for (const decision of decisions) {
						if (
							decision.category === category &&
							decision.action === "fix" &&
							decision.id !== undefined
						) {
							const suggestion = suggestions[decision.id];
							if (suggestion !== undefined) {
								fixed = suggestion.fixed;
							}
						}
					}
				}

				// Add advice suggestions
				let index = 0;
				for (const suggestion of suggestions) {
					const num = index + 1;

					const titlePrefix =
						suggestions.length === 1 ? "Suggested fix" : "Suggested fix #" + num;
					advice.push({
						type: "log",
						category: "none",
						text: "<emphasis>" +
						titlePrefix +
						":</emphasis> " +
						suggestion.title,
					});

					advice.push({
						type: "diff",
						diff: ___R$project$rome$$romejs$string$diff$index_ts$default(
							oldCode,
							___R$$priv$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$getFormattedCodeFromExitResult(
								suggestion.fixed,
							),
						),
					});

					advice.push({
						type: "log",
						category: "info",
						text: suggestion.description,
					});

					if (loc === undefined) {
						advice.push({
							type: "log",
							category: "error",
							text: "Unable to find target location",
						});
					} else {
						advice.push(
							___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
								noun: suggestions.length === 1
									? "Apply suggested fix"
									: 'Apply suggested fix "' + suggestion.title + '"',
								shortcut: String(num),
								instruction: "To apply this fix run",
								filename: this.displayFilename,
								decision: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionString({
									filename: this.displayFilename,
									action: "fix",
									category,
									start: loc.start,
									id: index,
								}),
							}),
						);
					}

					index++;
				}
			}

			const {suppressed} = this.addLocDiagnostic(
				loc,
				Object.assign({}, description, {advice}),
				Object.assign({}, diag, {fixable: true}),
			);

			if (suppressed || fixed === undefined) {
				return old;
			}

			return fixed;
		}

		addLocDiagnostic(loc, description, contextDiag = {}) {
			let origins = [];
			if (this.origin !== undefined) {
				origins.push(this.origin);
			}
			if (contextDiag.origins !== undefined) {
				origins = origins.concat(contextDiag.origins);
			}

			if (loc !== undefined && loc.filename !== this.filename) {
				throw new Error(
					"Trying to add a location from " +
					loc.filename +
					" on a Context from " +
					this.path,
				);
			}

			const {category, advice = []} = description;
			if (loc !== undefined && loc.start !== undefined) {
				advice.push(
					___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
						noun: "Add suppression comment",
						shortcut: "s",
						instruction: "To suppress this error run",
						filename: this.displayFilename,
						decision: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionString({
							filename: this.displayFilename,
							action: "suppress",
							category,
							start: loc.start,
						}),
					}),
				);

				advice.push(
					___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionAdviceAction({
						extra: true,
						noun: "Add suppression comments for ALL files with this category",
						instruction: "To add suppression comments for ALL files with this category run",
						decision: ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$buildLintDecisionGlobalString(
							"suppress",
							category,
						),
					}),
				);
			}
			const ___R$ = contextDiag;
			const diag = Object.assign({}, ___R$);
			delete diag.marker;
			const {marker} = ___R$;
			const diagnostic = this.diagnostics.addDiagnostic(
				Object.assign(
					{},
					diag,
					{
						description: Object.assign({}, description, {advice}),
						location: {
							marker,
							mtime: this.mtime,
							filename: this.filename,
							start: loc === undefined ? undefined : loc.start,
							end: loc === undefined ? undefined : loc.end,
							language: "js",
							sourceType: this.sourceType,
						},
						origins,
					},
				),
			);

			let suppressed = this.hasLocSuppression(loc, description.category);

			// If we've been passed lint decisions then consider it suppressed unless we have been specifically told to fix it
			const diagCategory = description.category;
			if (this.hasLintDecisions()) {
				suppressed = true;

				const decisions = this.getLintDecisions(
					___R$project$rome$$romejs$js$compiler$lint$decisions_ts$deriveDecisionPositionKey(
						"fix",
						loc,
					),
				);
				for (const {category, action} of decisions) {
					if (category === diagCategory && action === "fix") {
						suppressed = false;
					}
				}
			}

			return {
				loc,
				diagnostic,
				suppressed,
			};
		}

		getLoc(node) {
			if (node === undefined) {
				return undefined;
			}

			if (Array.isArray(node)) {
				return ___R$project$rome$$romejs$parser$core$index_ts$extractSourceLocationRangeFromNodes(
					node,
				);
			} else {
				return node.loc;
			}
		}

		addNodeDiagnostic(node, description, diag = {}) {
			return this.addLocDiagnostic(this.getLoc(node), description, diag);
		}
	}


  // project-rome/@romejs/js-compiler/lib/Path.ts




	class ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default {
		constructor(node, context, opts) {
			const ancestryPaths = opts.ancestryPaths || [];
			this.ancestryPaths = ancestryPaths;

			if (
				node ===
				___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT
			) {
				this.parentPath = this;
			} else if (ancestryPaths.length === 0) {
				this.parentPath = new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(
					___R$project$rome$$romejs$js$ast$temp$MockParent_ts$MOCK_PARENT,
					context,
					{
						isMock: true,
					},
				);
			} else {
				this.parentPath = ancestryPaths[0];
			}

			this.node = node;
			this.parent = this.parentPath.node;
			this.context = context;

			const parentScope =
				opts.parentScope === undefined
					? context.getRootScope()
					: opts.parentScope;

			let scope = opts.scope;
			if (scope === undefined) {
				if (opts.noScopeCreation === true) {
					scope = parentScope;
				} else {
					scope = parentScope.evaluate(node, this.parent, true);
				}
			}
			this.scope = scope;

			this.nodeKey = opts.nodeKey;
			this.listKey = opts.listKey;

			this.isMock = opts.isMock === true;
			this.opts = opts;

			this.hooks = opts.hooks === undefined ? [] : opts.hooks;
		}

		callHook(
			// rome-ignore lint/js/noExplicitAny
			descriptor,
			arg,
			optionalRet,
			requiredDepth,
		) {
			const hook = this.findHook(descriptor, requiredDepth);
			if (hook === undefined) {
				if (optionalRet === undefined) {
					throw new Error("No " + descriptor.name + " hook found");
				} else {
					return optionalRet;
				}
			}
			if (descriptor.call === undefined) {
				throw new Error("Hook doesn't have a call method");
			}

			const {depth, ref} = hook;
			const {state, value, bubble} = descriptor.call(this, ref.state, arg);
			ref.state = state;

			if (bubble === true) {
				return this.callHook(descriptor, arg, value, depth + 1);
			} else {
				return value;
			}
		}

		provideHook(
			// rome-ignore lint/js/noExplicitAny
			descriptor,
			state,
		) {
			this.hooks.push({
				state: Object.assign({}, descriptor.initialState, state),
				descriptor,
			});

			return this.node;
		}

		findHook(descriptor, requiredDepth = 0) {
			let depth = 0;
			for (const {hooks} of this.ancestryPaths) {
				for (const hook of hooks) {
					if (hook.descriptor === descriptor) {
						if (depth === requiredDepth) {
							return {ref: hook, depth};
						} else {
							depth++;
						}
					}
				}
			}
			return undefined;
		}

		findAncestry(callback) {
			for (const path of this.ancestryPaths) {
				if (callback(path)) {
					return path;
				}
			}
			return undefined;
		}

		getChildPath(key) {
			// rome-ignore lint/js/noExplicitAny
			const node = (this.node)[key];
			if (node === undefined) {
				throw new Error(
					"Attempted to get child path for " + key + " but no such node existed",
				);
			}

			return new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(
				node,
				this.context,
				{
					parentScope: this.scope,
					ancestryPaths: this.ancestryPaths.concat([this]),
					nodeKey: key,
				},
			);
		}

		getChildPaths(key) {
			// rome-ignore lint/js/noExplicitAny
			const nodes = (this.node)[key];

			if (nodes === undefined) {
				throw new Error(
					"Attempted to get child paths for " +
					key +
					" but no such node existed",
				);
			}

			if (!Array.isArray(nodes)) {
				throw new Error("Expected child nodes for " + key + " to be an array");
			}

			const ancestryPaths = this.ancestryPaths.concat([this]);

			return nodes.map((node, i) => {
				return new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(
					node,
					this.context,
					{
						parentScope: this.scope,
						ancestryPaths,
						listKey: i,
						nodeKey: key,
					},
				);
			});
		}

		getPathKeys() {
			const parts = [];

			let path = this;
			while (path !== undefined && !path.isMock) {
				if (path.listKey !== undefined) {
					parts.push(String(path.listKey));
				}
				if (path.nodeKey !== undefined) {
					parts.push(path.nodeKey);
				}
				path = path.parentPath;
			}

			return parts.reverse();
		}

		fork(newNode) {
			return new ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default(
				newNode,
				this.context,
				this.getPathOptions(),
			);
		}

		getPathOptions() {
			return Object.assign(
				{},
				this.opts,
				{
					hooks: this.hooks,
					parentScope: this.scope === undefined
						? undefined
						: this.scope.parentScope,
				},
			);
		}

		traverse(name, callback) {
			this.reduce({
				name,
				enter(path) {
					callback(path);
					return path.node;
				},
			});
		}

		reduce(visitors, opts) {
			return ___R$project$rome$$romejs$js$compiler$methods$reduce_ts$default(
				this.node,
				Array.isArray(visitors) ? visitors : [visitors],
				this.context,
				Object.assign({}, this.getPathOptions(), opts),
			);
		}
	}


  // project-rome/@romejs/js-compiler/lib/Record.ts
class ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {}


  // project-rome/@romejs/js-compiler/lib/Cache.ts


	let ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectIdCounter = 0;
	const ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectToId = new WeakMap();

	class ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default {
		constructor() {
			this.cache = new WeakMap();
		}

		static buildQuery(req, additionalOptions) {
			const {ast, project, options} = req;
			const keyParts = [];

			let projectId = ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectToId.get(
				project,
			);
			if (projectId === undefined) {
				projectId = ___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectIdCounter++;
				___R$$priv$project$rome$$romejs$js$compiler$lib$Cache_ts$projectToId.set(
					project,
					projectId,
				);
			}

			// Add project config cache counter
			keyParts.push(String(projectId));

			// Add options if they exist
			const extra = Object.assign({}, options, additionalOptions);
			if (Object.keys(extra).length > 0) {
				keyParts.push(JSON.stringify(extra));
			}

			return {
				ast,
				key: keyParts.join(";"),
			};
		}

		get(query) {
			const astCache = this.cache.get(query.ast);
			if (astCache) {
				return astCache.get(query.key);
			} else {
				return undefined;
			}
		}

		set(query, value) {
			let astCache = this.cache.get(query.ast);
			if (astCache === undefined) {
				astCache = new Map();
				this.cache.set(query.ast, astCache);
			}
			astCache.set(query.key, value);
		}
	}


  // project-rome/@romejs/js-compiler/lint/rules/regular/camelCase.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$normalizeCamelCase(
		name,
	) {
		if (
			!___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(
				name,
			)
		) {
			return undefined;
		}

		if (name === "") {
			return undefined;
		}

		return name;
	}

	// Allow prefixed underscores
	function ___R$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$toVariableCamelCase(
		name,
		forceCapitalize,
	) {
		// Allow shouty constants
		if (name.toUpperCase() === name) {
			return ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$normalizeCamelCase(
				name,
			);
		}

		let prefix = "";
		let suffix = "";

		const prefixDashes = name.match(/^_+/);
		if (prefixDashes != null) {
			prefix = prefixDashes[0];
		}

		const suffixDashes = name.match(/_+$/);
		if (suffixDashes != null) {
			suffix = suffixDashes[0];
		}

		// Remove prefix and suffix
		let slicedName = name.slice(prefix.length);
		if (suffix.length > 0) {
			slicedName = slicedName.slice(0, -suffix.length);
		}

		const camelName =
			prefix +
			___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(
				slicedName,
				forceCapitalize,
			) +
			suffix;
		return ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$normalizeCamelCase(
			camelName,
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$default = {
		name: "camelCase",
		enter(path) {
			const {node, scope, context} = path;

			// Check variables
			if (node === scope.node) {
				const renames = new Map();

				for (const [name, binding] of scope.getOwnBindings()) {
					const camelName = ___R$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$toVariableCamelCase(
						name,
					);
					if (camelName !== undefined && camelName !== name) {
						const {suppressed} = context.addNodeDiagnostic(
							binding.node,
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.VARIABLE_CAMEL_CASE(
								name,
								camelName,
							),
							{fixable: true},
						);
						if (!suppressed) {
							renames.set(binding, camelName);
						}
					}
				}

				if (renames.size > 0) {
					return ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(
						path,
						renames,
					);
				}
			}

			// Check regular identifiers, variable identifiers have already been checked above
			if (
				___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node) &&
				!___R$project$rome$$romejs$js$ast$utils$isVariableIdentifier_ts$default(
					node,
				)
			) {
				const {name} = node;
				const camelName = ___R$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$toVariableCamelCase(
					name,
				);
				if (camelName !== undefined && camelName !== name) {
					return context.addFixableDiagnostic(
						{
							old: node,
							suggestions: [
								{
									title: "Convert to camelCase",
									description: "This may not be safe. Are you passing this into a third party module?",
									fixed: Object.assign({}, node, {name: camelName}),
								},
							],
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.IDENTIFIER_CAMEL_CASE(
							name,
							camelName,
						),
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/caseSingleStatement.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$caseSingleStatement_ts$default = {
		name: "caseSingleStatement",
		enter(path) {
			const {node, context} = path;

			if (node.type === "SwitchCase" && node.consequent.length > 1) {
				return context.addFixableDiagnostic(
					{
						old: node,
						fixed: Object.assign(
							{},
							node,
							{
								consequent: [
									___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.quick(
										node.consequent,
									),
								],
							},
						),
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.CASE_SINGLE_STATEMENT,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/confusingLanguage.json
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_json$default = [
		{
			"description": "<emphasis>whitelist</emphasis> can be considered raciallly charged language",
			"word": "whitelist",
			"suggestion": "allowlist",
			"advice": [
				{
					"type": "log",
					"category": "info",
					"text": 'See <hyperlink target="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6148600/" /> for a more detailed explanation',
				},
			],
		},
		{
			"description": "<emphasis>blacklist</emphasis> can be considered raciallly charged language",
			"word": "blacklist",
			"suggestion": "denylist",
			"advice": [
				{
					"type": "log",
					"category": "info",
					"text": 'See <hyperlink target="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6148600/" /> for a more detailed explanation',
				},
			],
		},
	];


  // project-rome/@romejs/js-compiler/lint/rules/regular/confusingLanguage.ts

	// Fast regex for checking if we need to validate a string
	const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_ts$regex = new RegExp(
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_json$default.map((
			term,
		) => term.word).join("|"),
		"gi",
	);



	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_ts$check(
		loc,
		input,
	) {
		let fixed = input;
		if (
			!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_ts$regex.test(
				input,
			)
		) {
			return {
				fixed,
				results: [],
			};
		}

		const lower = input.toLowerCase();
		const tracker = new ___R$project$rome$$romejs$parser$core$index_ts$PositionTracker(
			lower,
			loc.start,
		);
		const results = [];

		// This is a bit more complicated since we try to do the minimal amount of work
		for (let i = 0; i < lower.length; i++) {
			const char = lower[i];

			for (const {advice, word, description, suggestion} of (___R$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_json$default)) {
				if (char === word[0] && lower.startsWith(word, i)) {
					const wordWithSourceCasing = input.slice(i, i + word.length);

					results.push({
						// We want to preserve the original casing
						word: wordWithSourceCasing,
						description,
						advice,
						suggestion: ___R$project$rome$$romejs$string$utils$preserveCasing_ts$preserveCasing(
							wordWithSourceCasing,
							suggestion,
						),
						startIndex: i,
						endIndex: i + word.length,
						// Calculate the actual location of this
						loc: Object.assign(
							{},
							loc,
							{
								start: tracker.getPositionFromIndex(
									___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(i),
								),
								end: tracker.getPositionFromIndex(
									___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
										i + word.length,
									),
								),
							},
						),
					});

					i += word.length;
					break;
				}
			}
		}

		// Walk backwards through the results, autofixing with the suggestions
		// Walking backwards means we don't need to maintain offsets
		for (let i = results.length - 1; i >= 0; i--) {
			const result = results[i];
			fixed =
				fixed.slice(0, result.startIndex) +
				result.suggestion +
				fixed.slice(result.endIndex);
		}

		return {
			results,
			fixed,
		};
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_ts$default = {
		name: "inconsiderateLanguage",
		enter(path) {
			const {node, context} = path;

			const {loc} = node;
			if (loc !== undefined) {
				// Infer a string to check
				let value;
				if (node.type === "CommentBlock" || node.type === "CommentLine") {
					value = node.value;
				}
				if (
					___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(
						node,
					)
				) {
					value = node.name;
				}

				if (value !== undefined) {
					// Produce diagnostics
					const {results, fixed} = ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_ts$check(
						loc,
						value,
					);
					let suppressed = false;
					for (const {loc, word, description, suggestion, advice} of results) {
						({suppressed} = context.addLocDiagnostic(
							loc,
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.CONFUSING_LANGUAGE(
								description,
								word,
								suggestion,
								advice,
							),
							{fixable: true},
						));

						if (suppressed) {
							break;
						}
					}

					// Autofix if not suppressed
					if (results.length > 0 && !suppressed) {
						if (node.type === "CommentBlock" || node.type === "CommentLine") {
							return Object.assign({}, node, {value: fixed});
						}

						if (
							___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(
								node,
							)
						) {
							return Object.assign({}, node, {name: fixed});
						}
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/defaultExportSameBasename.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$defaultExportSameBasename_ts$isValidDeclaration(
		node,
	) {
		return (
			node.type === "FunctionDeclaration" || node.type === "ClassDeclaration"
		);
	}

	function ___R$project$rome$$romejs$js$compiler$lint$rules$regular$defaultExportSameBasename_ts$filenameToId(
		path,
		capitalize,
	) {
		let basename = path.getExtensionlessBasename();

		if (basename === "index") {
			// If the filename is `index` then use the parent directory name
			basename = path.getParent().getExtensionlessBasename();
		}

		return ___R$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$toVariableCamelCase(
			basename,
			capitalize,
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$defaultExportSameBasename_ts$default = {
		name: "defaultExportSameBasename",
		enter(path) {
			const {context, node} = path;

			if (node.type === "Program") {
				let defaultExport;
				for (const bodyNode of node.body) {
					if (bodyNode.type === "ExportDefaultDeclaration") {
						defaultExport = bodyNode;
						break;
					}
				}

				if (
					defaultExport !== undefined &&
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$defaultExportSameBasename_ts$isValidDeclaration(
						defaultExport.declaration,
					)
				) {
					const {declaration} = defaultExport;

					// Get the export default id
					const id = declaration.id;
					if (id !== undefined && context.path !== undefined) {
						const type =
							declaration.type === "FunctionDeclaration" ? "function" : "class";
						const basename = ___R$project$rome$$romejs$js$compiler$lint$rules$regular$defaultExportSameBasename_ts$filenameToId(
							context.path,
							type === "class",
						);

						if (basename !== undefined && basename !== id.name) {
							const correctFilename = id.name + context.path.getExtensions();

							return context.addFixableDiagnostic(
								{
									target: id,
									old: node,
									fixed: ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(
										path,
										new Map([[id.name, basename]]),
									),
								},
								___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.DEFAULT_EXPORT_SAME_BASENAME({
									defaultName: id.name,
									defaultType: type,
									actualFilename: basename,
									correctFilename,
								}),
							);
						}
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/doubleEquals.ts
const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$doubleEquals_ts$SUGGESTION_DESCRIPTION = "This may be unsafe if you are relying on type coercion";
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$doubleEquals_ts$default = {
		name: "doubleEquals",
		enter(path) {
			const {node, context} = path;

			if (
				node.type === "BinaryExpression" &&
				node.right.type !== "NullLiteral" &&
				node.left.type !== "NullLiteral"
			) {
				if (node.operator === "!=") {
					context.addFixableDiagnostic(
						{
							old: node,
							suggestions: [
								{
									title: "Use !==",
									description: ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$doubleEquals_ts$SUGGESTION_DESCRIPTION,
									fixed: Object.assign({}, node, {operator: "!=="}),
								},
							],
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NEGATE_DOUBLE_EQUALS,
					);
				}

				if (node.operator === "==") {
					context.addFixableDiagnostic(
						{
							old: node,
							suggestions: [
								{
									title: "Use ===",
									description: ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$doubleEquals_ts$SUGGESTION_DESCRIPTION,
									fixed: Object.assign({}, node, {operator: "==="}),
								},
							],
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.DOUBLE_EQUALS,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/duplicateImportSource.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$duplicateImportSource_ts$default = {
		name: "duplicateImport",
		enter(path) {
			const {node} = path;

			if (node.type === "Program") {
				const skipImports = new Set();
				const seenSources = new Map();
				let shouldFix = false;

				for (const bodyNode of node.body) {
					if (bodyNode.type === "ImportDeclaration") {
						const source = bodyNode.source.value;

						// Allow duplicate sources if the `importKind` is different
						const sourceKey =
							bodyNode.importKind === undefined
								? source
								: bodyNode.importKind + ":" + source;

						const seenLoc = seenSources.get(sourceKey);
						if (seenLoc === undefined) {
							seenSources.set(sourceKey, bodyNode.loc);
						} else {
							const {suppressed} = path.context.addNodeDiagnostic(
								bodyNode,
								___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.DUPLICATE_IMPORT_SOURCE(
									seenLoc,
								),
								{fixable: true},
							);

							if (suppressed) {
								skipImports.add(bodyNode);
							} else {
								shouldFix = true;
							}
						}
					}
				}

				// Defer fixing unless it's totally necessary since there's additional overhead
				if (shouldFix) {
					const newBody = [];

					for (let i = 0; i < node.body.length; i++) {
						const bodyNode = node.body[i];

						if (bodyNode.type === "ImportDeclaration") {
							// Skip import if it's already been consumed
							if (skipImports.has(bodyNode)) {
								continue;
							}

							let {
								namedSpecifiers,
								defaultSpecifier,
								namespaceSpecifier,
							} = bodyNode;

							// Find and concat all duplicate imports
							for (let x = i + 1; x < node.body.length; x++) {
								const possibleDuplicateNode = node.body[x];

								if (
									possibleDuplicateNode.type === "ImportDeclaration" &&
									bodyNode.source.value === possibleDuplicateNode.source.value &&
									bodyNode.importKind === possibleDuplicateNode.importKind &&
									!skipImports.has(possibleDuplicateNode)
								) {
									skipImports.add(possibleDuplicateNode);
									namedSpecifiers = [
										...namedSpecifiers,
										...possibleDuplicateNode.namedSpecifiers,
									];

									// We do not currently handle renaming duplicate namespace and default bindings
									if (defaultSpecifier === undefined) {
										defaultSpecifier = possibleDuplicateNode.defaultSpecifier;
									}
									if (namespaceSpecifier === undefined) {
										namespaceSpecifier = possibleDuplicateNode.namespaceSpecifier;
									}
								}
							}

							newBody.push(
								Object.assign(
									{},
									bodyNode,
									{defaultSpecifier, namespaceSpecifier, namedSpecifiers},
								),
							);
						} else {
							newBody.push(bodyNode);
						}
					}

					return Object.assign({}, node, {body: newBody});
				}
			}
			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/emptyBlocks.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyBlocks_ts$isEmpty(
		node,
	) {
		if (node.innerComments !== undefined && node.innerComments.length > 0) {
			return false;
		}

		if (node.type === "EmptyStatement") {
			return true;
		}

		if (node.type === "BlockStatement" && node.body.length === 0) {
			return true;
		}

		return false;
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$emptyBlocks_ts$default = {
		name: "emptyBlocks",
		enter(path) {
			const {node, context} = path;

			if (node.type === "IfStatement") {
				if (
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyBlocks_ts$isEmpty(
						node.consequent,
					)
				) {
					context.addNodeDiagnostic(
						node.consequent,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.EMPTY_BLOCKS,
					);
				}

				if (
					node.alternate !== undefined &&
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyBlocks_ts$isEmpty(
						node.alternate,
					)
				) {
					context.addNodeDiagnostic(
						node.alternate,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.EMPTY_BLOCKS,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/emptyMatches.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$isQuantifiedMinZero(
		el,
	) {
		return el.type === "RegExpQuantified" && el.min === 0;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$lintEmptyMatches(
		expr,
	) {
		if (expr.type === "RegExpSubExpression") {
			for (const item of expr.body) {
				let matches = false;
				if (
					item.type === "RegExpGroupNonCapture" ||
					item.type === "RegExpGroupCapture"
				) {
					matches = ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$lintEmptyMatches(
						item.expression,
					);
				} else {
					matches = ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$isQuantifiedMinZero(
						item,
					);
				}
				if (!matches) {
					return false;
				}
			}
			return true;
		} else {
			return (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$lintEmptyMatches(
					expr.left,
				) ||
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$lintEmptyMatches(
					expr.right,
				)
			);
		}
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$default = {
		name: "emptyMatches",
		enter(path) {
			const {context, node} = path;
			if (
				node.type === "RegExpLiteral" &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$lintEmptyMatches(
					node.expression,
				)
			) {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.EMPTY_MATCHES,
				);
			}
			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/getterReturn.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$getterReturn_ts$default = {
		name: "getterReturn",
		enter(path) {
			const {node} = path;

			if (
				(node.type === "ClassMethod" || node.type === "ObjectMethod") &&
				node.kind === "get"
			) {
				for (const record of ___R$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$default(
					node.body,
				)) {
					if (record.type === "INVALID") {
						path.context.addNodeDiagnostic(
							record.node,
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.GETTER_RETURN(
								record.description,
							),
						);
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/importDefaultBasename.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$importDefaultBasename_ts$default = {
		name: "importDefaultBasename",
		enter(path) {
			const {node} = path;

			if (node.type === "ImportDeclaration") {
				const {defaultSpecifier} = node;
				if (defaultSpecifier === undefined) {
					return node;
				}

				const expectedName = ___R$project$rome$$romejs$js$compiler$lint$rules$regular$defaultExportSameBasename_ts$filenameToId(
					___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
						node.source.value,
					),
					false,
				);
				if (expectedName === undefined) {
					return node;
				}

				const localName = defaultSpecifier.local.name.name;
				if (localName !== expectedName) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.IMPORT_DEFAULT_BASENAME(
							localName,
							expectedName,
						),
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yAltText.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasUndefinedAltValue(
		node,
	) {
		if (node.type !== "JSXExpressionContainer") {
			return false;
		}
		return (
			(node.expression.type === "ReferenceIdentifier" &&
			node.expression.name === "undefined") ||
			(node.expression.type === "TemplateLiteral" &&
			node.expression.expressions.some((expression) =>
				expression.type === "ReferenceIdentifier" &&
				expression.name === "undefined"
			))
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasImgAltText(
		node,
	) {
		return node.attributes.some((attr) =>
			attr.type === "JSXAttribute" &&
			attr.name.name === "alt" &&
			attr.value &&
			!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasUndefinedAltValue(
				attr.value,
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasObjectAltText(
		node,
	) {
		return (
			node.attributes.some((attr) =>
				attr.type === "JSXAttribute" &&
				attr.name.type === "JSXIdentifier" &&
				/(aria-label)|(aria-labelledby)|(title)/.test(attr.name.name) &&
				attr.value &&
				!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasUndefinedAltValue(
					attr.value,
				)
			) || node.children.length > 0
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasAreaAltText(
		node,
	) {
		return node.attributes.some((attr) =>
			attr.type === "JSXAttribute" &&
			attr.name.type === "JSXIdentifier" &&
			/(aria-label)|(aria-labelledby)|(alt)|(title)/.test(attr.name.name) &&
			attr.value &&
			!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasUndefinedAltValue(
				attr.value,
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasInputAltText(
		node,
	) {
		return node.attributes.some((attr) =>
			attr.type === "JSXAttribute" &&
			attr.name.type === "JSXIdentifier" &&
			/(aria-label)|(aria-labelledby)|(alt)|(title)/.test(attr.name.name) &&
			attr.value &&
			!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasUndefinedAltValue(
				attr.value,
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasTypeImage(
		node,
	) {
		return node.attributes.some((attr) =>
			attr.type === "JSXAttribute" &&
			attr.name.name === "type" &&
			attr.value &&
			attr.value.type === "StringLiteral" &&
			attr.value.value === "image"
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$default = {
		name: "jsxA11yAltText",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXElement" && node.name.type === "JSXIdentifier") {
				if (!/(img)|(area)|(input)|(object)/.test(node.name.name)) {
					return node;
				}

				if (
					(node.name.name === "img" &&
					!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasImgAltText(
						node,
					)) ||
					(node.name.name === "object" &&
					!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasObjectAltText(
						node,
					)) ||
					(node.name.name === "area" &&
					!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasAreaAltText(
						node,
					)) ||
					(node.name.name === "input" &&
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasTypeImage(
						node,
					) &&
					!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$hasInputAltText(
						node,
					))
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.JSX_A11Y_ALT_TEXT,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yHeadingHasContent.ts
const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHeadingHasContent_ts$HEADINGS = [
		"h1",
		"h2",
		"h3",
		"h4",
		"h5",
		"h6",
	];

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHeadingHasContent_ts$isInvalidHeading(
		node,
	) {
		if (!___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(node)) {
			return false;
		}

		return (
			___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHeadingHasContent_ts$HEADINGS.some((
				heading,
			) =>
				___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(
					node,
					heading,
				)
			) &&
			((node.children.length === 0 &&
			!___R$project$rome$$romejs$js$ast$utils$hasJSXAttribute_ts$default(
				node,
				"dangerouslySetInnerHTML",
			)) ||
			(node.children.length > 0 &&
			___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(
				node.children[0],
			) &&
			___R$project$rome$$romejs$js$ast$utils$hasJSXAttribute_ts$default(
				node.children[0],
				"aria-hidden",
			)))
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHeadingHasContent_ts$default = {
		name: "jsxA11yHeadingHasContent",
		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHeadingHasContent_ts$isInvalidHeading(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.JSX_A11Y_HEADING_HAS_CONTENT,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yHTMLHasLang.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHTMLHasLang_ts$jsxHTMLMissingLang(
		node,
	) {
		return (
			___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(
				node,
				"html",
			) &&
			!___R$project$rome$$romejs$js$ast$utils$hasJSXAttribute_ts$default(
				node,
				"lang",
			)
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHTMLHasLang_ts$default = {
		name: "jsxA11yHTMLHasLang",

		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHTMLHasLang_ts$jsxHTMLMissingLang(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_A11Y_HTML_HAS_LANG,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yIframeHasTitle.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yIframeHasTitle_ts$jsxIframeMissingTitle(
		node,
	) {
		return (
			___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(
				node,
				"iframe",
			) &&
			!___R$project$rome$$romejs$js$ast$utils$hasJSXAttribute_ts$default(
				node,
				"title",
			)
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yIframeHasTitle_ts$default = {
		name: "jsxA11yIframeHasTitle",

		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yIframeHasTitle_ts$jsxIframeMissingTitle(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_A11Y_IFRAME_HAS_TITLE,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yImgRedundantAlt.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yImgRedundantAlt_ts$jsxImgRedundantAlt(
		node,
	) {
		if (
			!___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(
				node,
				"img",
			)
		) {
			return false;
		}

		const attr = ___R$project$rome$$romejs$js$ast$utils$getJSXAttribute_ts$default(
			node,
			"alt",
		);
		return (
			attr !== undefined &&
			attr.value &&
			attr.value.type === "StringLiteral" &&
			/(image)|(picture)|(photo)/i.test(attr.value.value)
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yImgRedundantAlt_ts$default = {
		name: "jsxA11yImgRedundantAlt",

		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yImgRedundantAlt_ts$jsxImgRedundantAlt(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_A11Y_IMG_REDUNDANT_ALT,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yNoAccessKey.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoAccessKey_ts$default = {
		name: "jsxA11yNoAccessKey",

		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(node) &&
				___R$project$rome$$romejs$js$ast$utils$hasJSXAttribute_ts$default(
					node,
					"accessKey",
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_NO_ACCESS_KEY,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yNoAutofocus.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoAutofocus_ts$default = {
		name: "jsxA11yNoAutofocus",

		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(node) &&
				___R$project$rome$$romejs$js$ast$utils$hasJSXAttribute_ts$default(
					node,
					"autoFocus",
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_NO_AUTOFOCUS,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yNoDistractingElements.ts
const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoDistractingElements_ts$DISTRACTING_TYPES = [
		"blink",
		"marquee",
	];
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoDistractingElements_ts$default = {
		name: "jsxA11yNoDistractingElements",

		enter(path) {
			const {node} = path;

			const distractingType =
				___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(node) &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoDistractingElements_ts$DISTRACTING_TYPES.find((
					name,
				) =>
					___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(
						node,
						name,
					)
				);

			if (distractingType) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.JSX_A11Y_NO_DISTRACTING_ELEMENTS(
						distractingType,
					),
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yNoTargetBlank.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoTargetBlank_ts$jsxAnchorHasBlankTarget(
		node,
	) {
		return (
			___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(node, "a") &&
			node.attributes.some((attribute) =>
				attribute.type === "JSXAttribute" &&
				attribute.name.name === "target" &&
				attribute.value &&
				attribute.value.type === "StringLiteral" &&
				attribute.value.value === "_blank"
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoTargetBlank_ts$jsxAnchorHasNoReferrer(
		node,
	) {
		return (
			___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(node, "a") &&
			node.attributes.some((attribute) =>
				attribute.type === "JSXAttribute" &&
				attribute.name.name === "rel" &&
				attribute.value &&
				attribute.value.type === "StringLiteral" &&
				attribute.value.value.includes("noreferrer")
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoTargetBlank_ts$jsxAnchorHasExternalLink(
		node,
	) {
		return (
			___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(node, "a") &&
			node.attributes.some((attribute) =>
				attribute.type === "JSXAttribute" &&
				attribute.name.name === "href" &&
				attribute.value &&
				((attribute.value.type === "StringLiteral" &&
				/^(?:\w+:|\/\/)/.test(attribute.value.value)) ||
				attribute.value.type === "JSXExpressionContainer")
			)
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoTargetBlank_ts$default = {
		name: "jsxA11yNoTargetBlank",

		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoTargetBlank_ts$jsxAnchorHasBlankTarget(
					node,
				) &&
				!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoTargetBlank_ts$jsxAnchorHasNoReferrer(
					node,
				) &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoTargetBlank_ts$jsxAnchorHasExternalLink(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_NO_TARGET_BLANK,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxA11yScope.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yScope_ts$default = {
		name: "jsxA11yScope",

		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(node) &&
				___R$project$rome$$romejs$js$ast$utils$hasJSXAttribute_ts$default(
					node,
					"scope",
				) &&
				!___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(
					node,
					"th",
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_NO_SCOPE,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxKey.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxKey_ts$containsKeyAttr(
		node,
	) {
		const ATTR_NAME = "key";
		return !!node.attributes.find((attr) =>
			attr.type === "JSXAttribute" && attr.name.name === ATTR_NAME
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxKey_ts$default = {
		name: "jsxKey",
		enter(path) {
			const {node, context} = path;

			// JSXElement in array literal
			if (
				node.type === "JSXElement" &&
				!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxKey_ts$containsKeyAttr(
					node,
				) &&
				path.parentPath.node.type === "ArrayExpression"
			) {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_KEY(
						"array",
					),
				);
			}

			// Array.prototype.map
			if (
				node.type === "CallExpression" &&
				node.callee.type === "MemberExpression" &&
				node.callee.property.value.type === "Identifier" &&
				node.callee.property.value.name === "map"
			) {
				const fn = node.arguments[0];

				// Short hand arrow function
				if (
					fn.type === "ArrowFunctionExpression" &&
					fn.body.type === "JSXElement" &&
					!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxKey_ts$containsKeyAttr(
						fn.body,
					)
				) {
					context.addNodeDiagnostic(
						fn.body,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_KEY(
							"iterator",
						),
					);
				}

				// Function or arrow function with block statement
				if (
					fn &&
					(fn.type === "FunctionExpression" ||
					fn.type === "ArrowFunctionExpression") &&
					fn.body.type === "BlockStatement"
				) {
					fn.body.body.forEach((statement) => {
						if (
							statement.type === "ReturnStatement" &&
							(statement.argument == null ? undefined : statement.argument.type) ===
							"JSXElement" &&
							!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$jsxKey_ts$containsKeyAttr(
								statement.argument,
							)
						) {
							context.addNodeDiagnostic(
								statement.argument,
								___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_KEY(
									"iterator",
								),
							);
						}
					});
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/jsxNoCommentText.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxNoCommentText_ts$default = {
		name: "jsxNoCommentText",
		enter(path) {
			const {node} = path;

			if (node.type === "JSXText") {
				if (/^\s*\/(\/|\*)/m.test(node.value)) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_NO_COMMENT_TEXT,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/negationElse.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$negationElse_ts$isNegation(
		node,
	) {
		return (
			node.type === "UnaryExpression" &&
			node.prefix === true &&
			node.operator === "!"
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$negationElse_ts$default = {
		name: "negationElse",
		enter(path) {
			const {node} = path;

			if (
				node.type === "IfStatement" &&
				node.alternate !== undefined &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$negationElse_ts$isNegation(
					node.test,
				)
			) {
				return path.context.addFixableDiagnostic(
					{
						old: node,
						fixed: Object.assign(
							{},
							node,
							{
								test: node.test.argument,
								consequent: node.alternate,
								alternate: node.consequent,
							},
						),
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NEGATION_ELSE,
				);
			}

			if (
				node.type === "ConditionalExpression" &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$negationElse_ts$isNegation(
					node.test,
				)
			) {
				return path.context.addFixableDiagnostic(
					{
						old: node,
						fixed: Object.assign(
							{},
							node,
							{
								test: node.test.argument,
								consequent: node.alternate,
								alternate: node.consequent,
							},
						),
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NEGATION_ELSE,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noArguments.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noArguments_ts$default = {
		name: "noArguments",
		enter(path) {
			const {node, scope} = path;

			if (node.type === "ReferenceIdentifier" && node.name === "arguments") {
				const args = scope.getBinding("arguments");
				if (args && args.kind === "arguments") {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_ARGUMENTS,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noAsyncPromiseExecutor.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noAsyncPromiseExecutor_ts$default = {
		name: "noAsyncPromiseExecutor",
		enter(path) {
			const {node, context} = path;

			if (
				node.type === "NewExpression" &&
				node.callee.type === "ReferenceIdentifier" &&
				node.callee.name === "Promise" &&
				node.arguments.length > 0 &&
				(node.arguments[0].type === "ArrowFunctionExpression" ||
				node.arguments[0].type === "FunctionExpression") &&
				node.arguments[0].head.async
			) {
				context.addNodeDiagnostic(
					node.arguments[0],
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_ASYNC_PROMISE_EXECUTOR,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noCatchAssign.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noCatchAssign_ts$default = {
		name: "noCatchAssign",
		enter(path) {
			const {node, context, scope} = path;

			if (node.type === "AssignmentIdentifier") {
				const binding = scope.getBinding(node.name);

				if (binding !== undefined && binding.kind === "catch") {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_CATCH_ASSIGN,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/noChildrenProp.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noChildrenProp_ts$isAttributePassingChildrenProp(
		attribute,
	) {
		return (
			attribute.type === "JSXAttribute" && attribute.name.name === "children"
		);
	}
	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noChildrenProp_ts$isCreateElementPassingChildrenProp(
		property,
	) {
		return (
			property.type === "ObjectProperty" &&
			property.key.value.type === "Identifier" &&
			property.key.value.name === "children"
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$noChildrenProp_ts$default = {
		name: "noChildrenProp",
		enter(path) {
			const {node} = path;
			if (
				(node.type === "JSXElement" &&
				node.attributes.find(
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noChildrenProp_ts$isAttributePassingChildrenProp,
				)) ||
				(node.type === "CallExpression" &&
				___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
					node.callee,
					"React.createElement",
				) &&
				node.arguments[1].type === "ObjectExpression" &&
				node.arguments[1].properties.find(
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noChildrenProp_ts$isCreateElementPassingChildrenProp,
				))
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_CHILDREN_PROP,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noCommaOperator.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noCommaOperator_ts$default = {
		name: "noCommaOperator",
		enter(path) {
			const {node} = path;

			if (node.type === "SequenceExpression") {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_COMMA_OPERATOR,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noCompareNegZero.ts
const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noCompareNegZero_ts$OPERATORS_TO_CHECK = [
		">",
		">=",
		"<",
		"<=",
		"==",
		"===",
		"!=",
		"!==",
	];

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noCompareNegZero_ts$isNegZero(
		node,
	) {
		return (
			node.type === "UnaryExpression" &&
			node.operator === "-" &&
			node.argument.type === "NumericLiteral" &&
			node.argument.value === 0
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noCompareNegZero_ts$default = {
		name: "noCompareNegZero",
		enter(path) {
			const {node} = path;

			if (
				node.type === "BinaryExpression" &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noCompareNegZero_ts$OPERATORS_TO_CHECK.includes(
					node.operator,
				) &&
				(___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noCompareNegZero_ts$isNegZero(
					node.left,
				) ||
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noCompareNegZero_ts$isNegZero(
					node.right,
				))
			) {
				if (node.operator === "===") {
					return path.context.addFixableDiagnostic(
						{
							old: node,
							fixed: ___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression`Object.is(${node.left}, ${node.right})`,
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_COMPARE_NEG_ZERO(
							node.operator,
						),
					);
				} else {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_COMPARE_NEG_ZERO(
							node.operator,
						),
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noCondAssign.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noCondAssign_ts$default = {
		name: "noCondAssign",
		enter(path) {
			const {node} = path;

			if (
				(node.type === "IfStatement" ||
				node.type === "ForStatement" ||
				node.type === "WhileStatement" ||
				node.type === "DoWhileStatement") &&
				node.test &&
				node.test.type === "AssignmentExpression"
			) {
				path.context.addNodeDiagnostic(
					node.test,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_COND_ASSIGN,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/noDanger.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDanger_ts$jsxDanger(
		node,
	) {
		if (node.type !== "JSXElement") {
			return false;
		}
		const hasDangerAttribute = !!node.attributes.find((attribute) =>
			attribute.type === "JSXAttribute" &&
			attribute.name.name === "dangerouslySetInnerHTML"
		);
		return hasDangerAttribute;
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$noDanger_ts$default = {
		name: "noDanger",
		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDanger_ts$jsxDanger(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DANGER,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/noDangerWithChildren.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$jsxDangerWithChildren(
		node,
	) {
		if (node.type !== "JSXElement") {
			return false;
		}

		const hasAttribute = !!node.attributes.find((attribute) =>
			attribute.type === "JSXAttribute" &&
			attribute.name.name === "dangerouslySetInnerHTML"
		);

		return hasAttribute && node.children && node.children.length > 0;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$jsxDangerWithPropChildren(
		node,
	) {
		if (node.type !== "JSXElement") {
			return false;
		}

		const hasDangerAttribute = !!node.attributes.find((attribute) =>
			attribute.type === "JSXAttribute" &&
			attribute.name.name === "dangerouslySetInnerHTML"
		);

		const hasChildrenAttribute = !!node.attributes.find((attribute) =>
			attribute.type === "JSXAttribute" && attribute.name.name === "children"
		);

		return hasDangerAttribute && hasChildrenAttribute;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$createElementDangerWithChildren(
		node,
	) {
		if (node.type !== "CallExpression") {
			return false;
		}

		const propsArgument = node.arguments[node.arguments.length - 2];

		return (
			___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
				node.callee,
				"React.createElement",
			) &&
			node.arguments.length === 3 &&
			propsArgument.type === "ObjectExpression" &&
			propsArgument.properties.some((prop) =>
				prop.type === "ObjectProperty" &&
				prop.key.type === "StaticPropertyKey" &&
				prop.key.value.type === "Identifier" &&
				prop.key.value.name === "dangerouslySetInnerHTML"
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$createElementDangerWithPropChildren(
		node,
	) {
		if (node.type !== "CallExpression") {
			return false;
		}

		const propsArgument = node.arguments[1];

		function hasDangerAttribute(node) {
			return node.properties.some((prop) =>
				prop.type === "ObjectProperty" &&
				prop.key.type === "StaticPropertyKey" &&
				prop.key.value.type === "Identifier" &&
				prop.key.value.name === "dangerouslySetInnerHTML"
			);
		}

		function hasChildrenAttribute(node) {
			return node.properties.some((prop) =>
				prop.type === "ObjectProperty" &&
				prop.key.type === "StaticPropertyKey" &&
				prop.key.value.type === "Identifier" &&
				prop.key.value.name === "children"
			);
		}

		return (
			___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
				node.callee,
				"React.createElement",
			) &&
			propsArgument.type === "ObjectExpression" &&
			hasDangerAttribute(propsArgument) &&
			hasChildrenAttribute(propsArgument)
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$default = {
		name: "noDangerWithChildren",

		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$jsxDangerWithChildren(
					node,
				) ||
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$jsxDangerWithPropChildren(
					node,
				) ||
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$createElementDangerWithChildren(
					node,
				) ||
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$createElementDangerWithPropChildren(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DANGER_WITH_CHILDREN,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noDebugger.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDebugger_ts$default = {
		name: "noDebugger",
		enter(path) {
			const {node} = path;

			if (node.type === "DebuggerStatement") {
				return path.context.addFixableDiagnostic(
					{
						old: node,
						fixed: ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE,
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DEBUGGER,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noDelete.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDelete_ts$default = {
		name: "noDelete",
		enter(path) {
			const {context, node} = path;

			if (
				node.type === "UnaryExpression" &&
				node.operator === "delete" &&
				node.argument.type === "MemberExpression"
			) {
				const left = node.argument;
				return context.addFixableDiagnostic(
					{
						old: node,
						fixed: ___R$project$rome$$romejs$js$ast$expressions$AssignmentExpression_ts$assignmentExpression.create(
							{
								operator: "=",
								left: ___R$project$rome$$romejs$js$ast$expressions$MemberExpression_ts$memberExpression.create({
									object: left.object,
									property: left.property,
								}),
								right: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create({
									name: "undefined",
								}),
							},
							node,
						),
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DELETE,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noDeleteVars.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDeleteVars_ts$default = {
		name: "noDeleteVars",
		enter(path) {
			const {node} = path;

			if (
				node.type === "UnaryExpression" &&
				node.operator === "delete" &&
				node.argument.type === "ReferenceIdentifier"
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DELETE_VARS,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/noDidUpdateSetState.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDidUpdateSetState_ts$inComponentDidUpdate(
		path,
	) {
		const func =
			path.findAncestry(({node}) =>
				___R$project$rome$$romejs$js$ast$utils$isConditional_ts$default(node)
			) !== undefined;
		return (
			!func &&
			path.findAncestry(({node}) =>
				node.type === "ClassMethod" &&
				node.key.type === "StaticPropertyKey" &&
				node.key.value.type === "Identifier" &&
				node.key.value.name === "componentDidUpdate"
			) !== undefined
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$noDidUpdateSetState_ts$default = {
		name: "noDidUpdateSetState",
		enter(path) {
			const {node} = path;

			if (
				___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
					node,
					"this.setState",
				) &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noDidUpdateSetState_ts$inComponentDidUpdate(
					path,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DID_UPDATE_SET_STATE,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noDupeArgs.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDupeArgs_ts$default = {
		name: "noDupeArgs",
		enter(path) {
			const {node, context} = path;

			if (node.type === "FunctionHead") {
				const uniqueIdentifiers = new Set();

				for (const param of node.params) {
					for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
						param,
					)) {
						if (uniqueIdentifiers.has(name)) {
							context.addNodeDiagnostic(
								param,
								___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DUPE_ARGS(
									name,
								),
							);
						}

						uniqueIdentifiers.add(name);
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noDuplicateCase.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDuplicateCase_ts$default = {
		name: "noDuplicateCase",
		enter(path) {
			const {node, context} = path;

			if (node.type === "SwitchStatement") {
				const uniqueSwitchCases = new Set();

				for (const param of node.cases) {
					if (param.test && param.test.type === "StringLiteral") {
						const {test} = param;

						if (uniqueSwitchCases.has(test.value)) {
							context.addNodeDiagnostic(
								test,
								___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DUPLICATE_CASE(
									test.value,
								),
							);
						}

						uniqueSwitchCases.add(test.value);
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lib/DiagnosticsDuplicateHelper.ts


	class ___R$project$rome$$romejs$js$compiler$lib$DiagnosticsDuplicateHelper_ts$DiagnosticsDuplicateHelper {
		constructor(context, descriptionFactory) {
			this.context = context;
			this.category = descriptionFactory("").category;
			this.descriptionFactory = descriptionFactory;
			this.locations = new Map();
		}

		addLocation(key, location) {
			const isSuppressed = this.context.hasLocSuppression(
				location,
				this.category,
			);
			if (isSuppressed) {
				// If this location has had it's diagnostic suppressed then we don't want to return
				// that it was a duplicate even if there's multiple occurences
				return {duplicate: false};
			}

			let locations = this.locations.get(key);
			if (locations === undefined) {
				locations = [];
				this.locations.set(key, locations);
			}
			locations.push(location);
			return {duplicate: locations.length > 1};
		}

		process() {
			for (const [key, locations] of this.locations) {
				if (locations.length <= 1) {
					continue;
				}

				const description = this.descriptionFactory(key);
				const firstLocation = locations[0];
				const restLocations = locations.slice(1);

				this.context.addLocDiagnostic(
					firstLocation,
					Object.assign(
						{},
						description,
						{
							advice: [
								...description.advice,
								...___R$project$rome$$romejs$diagnostics$helpers_ts$buildDuplicateLocationAdvice(
									restLocations,
								),
							],
						},
					),
				);
			}
		}
	}


  // project-rome/@romejs/js-compiler/lint/rules/regular/noDuplicateGroupNamesInRegularExpressions.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDuplicateGroupNamesInRegularExpressions_ts$default = {
		name: "noDuplicateGroupNamesInRegularExpressions",
		enter(path) {
			const {context, node} = path;

			if (node.type === "RegExpSubExpression") {
				const duplicates = new ___R$project$rome$$romejs$js$compiler$lib$DiagnosticsDuplicateHelper_ts$DiagnosticsDuplicateHelper(
					context,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.DUPLICATE_REGEX_GROUP_NAME,
				);

				for (const bodyItem of node.body) {
					if (bodyItem.type === "RegExpGroupCapture") {
						const groupName = bodyItem.name;

						if (groupName !== undefined) {
							duplicates.addLocation(groupName, bodyItem.loc);
						}
					}
				}

				duplicates.process();
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noDuplicateKeys.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noDuplicateKeys_ts$extractPropertyKey(
		node,
	) {
		if (node.key.type === "StaticPropertyKey") {
			const {value} = node.key;

			if (value.type === "PrivateName") {
				return value.id.name;
			}

			if (value.type === "Identifier") {
				return value.name;
			}

			return String(value.value);
		}

		return undefined;
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDuplicateKeys_ts$default = {
		name: "noDuplicateKeys",
		enter(path) {
			const {node, context} = path;

			if (node.type === "ObjectExpression") {
				const duplicates = new ___R$project$rome$$romejs$js$compiler$lib$DiagnosticsDuplicateHelper_ts$DiagnosticsDuplicateHelper(
					context,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_DUPLICATE_KEYS,
				);

				for (const prop of node.properties) {
					if (prop.type === "SpreadProperty") {
						continue;
					}

					const key = ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noDuplicateKeys_ts$extractPropertyKey(
						prop,
					);
					if (key !== undefined) {
						duplicates.addLocation(key, prop.key.loc);
					}
				}

				duplicates.process();
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noEmptyCharacterClass.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noEmptyCharacterClass_ts$default = {
		name: "noEmptyCharacterClass",
		enter(path) {
			const {context, node} = path;

			if (
				node.type === "RegExpCharSet" &&
				node.body.length === 0 &&
				!node.invert
			) {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_EMPTY_CHAR_SET,
				);
				return ___R$project$rome$$romejs$js$compiler$constants_ts$REDUCE_REMOVE;
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noExplicitAny.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noExplicitAny_ts$default = {
		name: "noExplicitAny",
		enter(path) {
			const {context, node} = path;

			if (node.type === "TSAnyKeywordTypeAnnotation") {
				context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_EXPLICIT_ANY,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noExtraBooleanCast.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$isBooleanConstructorCall(
		node,
	) {
		return (
			node.type === "NewExpression" &&
			node.callee.type === "ReferenceIdentifier" &&
			node.callee.name === "Boolean"
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$isConditionalStatement(
		node,
	) {
		return node.type === "ConditionalExpression";
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$isInBooleanContext(
		node,
	) {
		return (
			node.type === "IfStatement" ||
			node.type === "DoWhileStatement" ||
			node.type === "WhileStatement" ||
			node.type === "ForStatement"
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$getNode(
		path,
	) {
		let {node} = path;

		if (
			___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$isBooleanConstructorCall(
				node,
			)
		) {
			if (node.type === "NewExpression" && node.arguments.length > 0) {
				return node.arguments[0];
			}
		}

		if (
			___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$isInBooleanContext(
				node,
			) ||
			___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$isConditionalStatement(
				node,
			)
		) {
			return node.test;
		}

		return undefined;
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$default = {
		name: "noExtraBooleanCast",
		enter(path) {
			const {context} = path;

			let node = ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$getNode(
				path,
			);

			if (node !== undefined) {
				if (
					(node.type === "UnaryExpression" &&
					node.operator === "!" &&
					node.argument.type === "UnaryExpression" &&
					node.argument.operator === "!") ||
					(node.type === "CallExpression" &&
					node.callee.type === "ReferenceIdentifier" &&
					node.callee.name === "Boolean")
				) {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_EXTRA_BOOLEAN_CAST,
					);
				}
			}

			return path.node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/noFindDOMNode.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noFindDOMNode_ts$hasFindMemberProperty(
		node,
	) {
		return (
			node.type === "StaticMemberProperty" &&
			___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
				node.value,
				"findDOMNode",
			)
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noFindDOMNode_ts$hasFindCallExpression(
		node,
	) {
		return (
			node.type === "CallExpression" &&
			___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
				node.callee,
				"findDOMNode",
			)
		);
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$noFindDOMNode_ts$default = {
		name: "noFindDOMNode",

		enter(path) {
			const {node} = path;

			if (
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noFindDOMNode_ts$hasFindMemberProperty(
					node,
				) ||
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$noFindDOMNode_ts$hasFindCallExpression(
					node,
				)
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_FIND_DOM_NODE,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noFunctionAssign.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noFunctionAssign_ts$default = {
		name: "noFunctionAssign",
		enter(path) {
			const {node, scope} = path;

			if (
				node.type === "AssignmentIdentifier" &&
				scope.getBinding(node.name) instanceof
				___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_FUNCTION_ASSIGN,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noImportAssign.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noImportAssign_ts$isAssignment(
		path,
	) {
		switch (path.parentPath.node.type) {
			case "AssignmentExpression":
			case "AssignmentArrayPattern":
			case "AssignmentObjectPatternProperty":
			case "UpdateExpression":
			case "AssignmentObjectPattern":
			case "ForInStatement":
				return true;

			default:
				return false;
		}
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noImportAssign_ts$default = {
		name: "noImportAssign",
		enter(path) {
			const {node, scope} = path;

			if (
				(node.type === "AssignmentIdentifier" &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noImportAssign_ts$isAssignment(
					path,
				)) ||
				(node.type === "ReferenceIdentifier" &&
				path.parentPath.node.type === "UpdateExpression")
			) {
				const binding = scope.getBinding(node.name);
				if (binding !== undefined && binding.kind === "import") {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_IMPORT_ASSIGN(
							node.name,
						),
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noLabelVar.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noLabelVar_ts$default = {
		name: "noLabelVar",
		enter(path) {
			const {node, scope} = path;

			if (node.type === "LabeledStatement") {
				const name = node.label.name;
				const binding = scope.getBinding(name);
				const isDefined =
					binding !== undefined || scope.getRootScope().isGlobal(name);

				if (isDefined) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_LABEL_VAR,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noMultipleSpacesInRegularExpressionLiterals.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
		node,
	) {
		return (
			node !== undefined &&
			node.type === "RegExpCharacter" &&
			node.value === " "
		);
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$checkRegex(
		node,
		context,
	) {
		for (let i = 0; i < node.body.length; i++) {
			const item = node.body[i];

			// Do some quick checks to see if we'll produce an error
			if (
				!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
					item,
				) ||
				!___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
					node.body[i + 1],
				)
			) {
				continue;
			}

			const spaceNodes = [];

			// Get all the space nodes
			for (let x = i; x < node.body.length; x++) {
				const item = node.body[i];
				if (
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$isSpaceChar(
						item,
					)
				) {
					spaceNodes.push(item);
					x++;
				} else {
					break;
				}
			}

			const quantifiedSpace = ___R$project$rome$$romejs$js$ast$regex$RegExpQuantified_ts$regExpQuantified.create({
				min: spaceNodes.length,
				max: spaceNodes.length,
				target: item,
			});

			const newRegex = Object.assign(
				{},
				node,
				{
					body: [
						// Get start
						...node.body.slice(0, i - 1),
						// Inject quantifier
						quantifiedSpace,
						// Get end
						...node.body.slice(i + spaceNodes.length),
					],
				},
			);

			return context.addFixableDiagnostic(
				{
					target: spaceNodes,
					old: node,
					fixed: ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$checkRegex(
						newRegex,
						context,
					),
				},
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_MULTIPLE_SPACES_IN_REGEX_LITERAL(
					spaceNodes.length,
				),
			);
		}

		return node;
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$default = {
		name: "noMultipleSpacesInRegularExpressionLiterals",
		enter(path) {
			const {context, node} = path;

			if (node.type === "RegExpSubExpression") {
				return ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$checkRegex(
					node,
					context,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noPosixInRegularExpression.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noPosixInRegularExpression_ts$checkRegEx(
		node,
		context,
	) {
		node.body.forEach((currNode, i) => {
			const nextNode = node.body[i + 1];
			const lastNode = node.body[node.body.length - 1];
			if (
				currNode.type === "RegExpCharacter" &&
				currNode.value === "[" &&
				nextNode &&
				nextNode.type === "RegExpCharacter" &&
				(nextNode.value === ":" || nextNode.value === ".") &&
				lastNode.type === "RegExpCharacter" &&
				lastNode.value === nextNode.value
			) {
				context.addNodeDiagnostic(
					currNode,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_POSIX_IN_REGULAR_EXPRESSION,
					{fixable: false},
				);
			}
		});

		return node;
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noPosixInRegularExpression_ts$default = {
		name: "noPosixInRegularExpression",
		enter(path) {
			const {context, node} = path;

			if (node.type === "RegExpCharSet" && node.body.length > 2) {
				return ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noPosixInRegularExpression_ts$checkRegEx(
					node,
					context,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noReferenceToNonExistingGroup.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noReferenceToNonExistingGroup_ts$findCaptureGroups(
		path,
	) {
		const regexLiteral = path.findAncestry((path) =>
			path.node.type === "RegExpLiteral"
		);
		if (regexLiteral === undefined) {
			return regexLiteral;
		}
		let captureGroups = [];
		regexLiteral.traverse(
			"RegExpLiteral",
			(path) => {
				if (path.node.type === "RegExpGroupCapture") {
					captureGroups.push(path.node);
				}
			},
		);
		return captureGroups;
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noReferenceToNonExistingGroup_ts$default = {
		name: "noReferenceToNonExistingGroup",
		enter(path) {
			const {node, context} = path;

			if (node.type === "RegExpNumericBackReference") {
				const allCaptureGroups = ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noReferenceToNonExistingGroup_ts$findCaptureGroups(
					path,
				);
				if (allCaptureGroups === undefined) {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_REFERENCE_TO_NON_EXISTING_GROUP(
							String(node.value),
						),
					);
				} else {
					if (node.value > allCaptureGroups.length) {
						context.addNodeDiagnostic(
							node,
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_REFERENCE_TO_NON_EXISTING_GROUP(
								String(node.value),
							),
						);
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noSetterReturn.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noSetterReturn_ts$default = {
		name: "noSetterReturn",
		enter(path) {
			const {node} = path;

			if (
				(node.type === "ClassMethod" || node.type === "ObjectMethod") &&
				node.kind === "set"
			) {
				for (const record of ___R$project$rome$$romejs$js$ast$utils$getCompletionRecords_ts$default(
					node.body,
				)) {
					if (
						record.type === "COMPLETION" &&
						record.node.type === "ReturnStatement" &&
						record.node.argument !== undefined
					) {
						path.context.addNodeDiagnostic(
							record.node,
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_SETTER_RETURN,
						);
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noShadowRestrictedNames.ts
const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noShadowRestrictedNames_ts$restrictedNames = new Set([
		...___R$project$rome$$romejs$js$compiler$scope$globals_ts$builtin,
		...___R$project$rome$$romejs$js$compiler$scope$globals_ts$es5,
		...___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2015,
		...___R$project$rome$$romejs$js$compiler$scope$globals_ts$es2017,
	]);
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noShadowRestrictedNames_ts$default = {
		name: "noShadowRestrictedNames",
		enter(path) {
			const {node, context, scope} = path;

			if (scope.node === node) {
				for (const [name, binding] of scope.getOwnBindings()) {
					if (
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$noShadowRestrictedNames_ts$restrictedNames.has(
							name,
						)
					) {
						context.addNodeDiagnostic(
							binding.node,
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_SHADOW_RESTRICTED_NAMES(
								name,
							),
						);
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noShorthandArrayType.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noShorthandArrayType_ts$default = {
		name: "noShorthandArrayType",
		enter(path) {
			const {node, context} = path;

			if (node.type === "TSArrayType") {
				return context.addFixableDiagnostic(
					{
						old: node,
						fixed: ___R$project$rome$$romejs$js$ast$typescript$TSTypeReference_ts$tsTypeReference.create({
							typeName: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
								"Array",
							),
							typeParameters: ___R$project$rome$$romejs$js$ast$typescript$TSTypeParameterInstantiation_ts$tsTypeParameterInstantiation.create({
								params: [node.elementType],
							}),
						}),
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_SHORTHAND_ARRAY_TYPE,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noTemplateCurlyInString.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noTemplateCurlyInString_ts$default = {
		name: "noTemplateCurlyInString",
		enter(path) {
			const {node, context} = path;

			if (node.type === "StringLiteral") {
				const regex = /\$\{[^}]+\}/u;

				if (regex.test(node.value)) {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_TEMPLATE_CURLY_IN_STRING,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noUnsafeFinally.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noUnsafeFinally_ts$default = {
		name: "noUnsafeFinally",
		enter(path) {
			const {node, context} = path;

			if (node.type === "TryStatement") {
				const {finalizer} = node;

				if (finalizer && finalizer.type === "BlockStatement") {
					for (const statement of finalizer.body) {
						if (
							statement.type === "ThrowStatement" ||
							statement.type === "ContinueStatement" ||
							statement.type === "BreakStatement" ||
							statement.type === "ReturnStatement"
						) {
							context.addNodeDiagnostic(
								statement,
								___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_UNSAFE_FINALLY(
									statement.type,
								),
							);
						}
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/noVar.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$noVar_ts$default = {
		name: "noVar",
		enter(path) {
			const {context, node: declaration} = path;

			if (
				declaration.type === "VariableDeclaration" &&
				declaration.kind === "var"
			) {
				context.addNodeDiagnostic(
					declaration,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.NO_VAR,
				);
			}

			return declaration;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/preferBlockStatements.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$preferBlockStatements_ts$default = {
		name: "preferBlockStatements",
		enter(path) {
			const {context, node} = path;

			if (node.type === "IfStatement") {
				let shouldFix = false;
				let consequent = node.consequent;
				let alternate = node.alternate;

				if (node.consequent.type !== "BlockStatement") {
					consequent = ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.quick([
						node.consequent,
					]);
					shouldFix = true;
				}

				if (
					node.alternate !== undefined &&
					node.alternate.type !== "BlockStatement" &&
					node.alternate.type !== "IfStatement"
				) {
					alternate = ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.quick([
						node.alternate,
					]);
					shouldFix = true;
				}

				if (shouldFix) {
					return context.addFixableDiagnostic(
						{
							old: node,
							fixed: Object.assign({}, node, {consequent, alternate}),
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.PREFER_BLOCK_STATEMENT,
					);
				}
			} else if (
				node.type === "ForStatement" ||
				node.type === "ForInStatement" ||
				node.type === "ForOfStatement" ||
				node.type === "DoWhileStatement" ||
				node.type === "WhileStatement" ||
				node.type === "WithStatement"
			) {
				if (node.body.type === "EmptyStatement") {
					const id = path.callHook(
						___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$commentInjector,
						{
							type: "CommentLine",
							value: " empty",
						},
					);

					return context.addFixableDiagnostic(
						{
							old: node,
							fixed: Object.assign(
								{},
								node,
								{
									body: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
										innerComments: [id],
										body: [],
									}),
								},
							),
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.PREFER_BLOCK_STATEMENT,
					);
				}

				if (node.body.type !== "BlockStatement") {
					return context.addFixableDiagnostic(
						{
							old: node,
							fixed: Object.assign(
								{},
								node,
								{
									body: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.quick([
										node.body,
									]),
								},
							),
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.PREFER_BLOCK_STATEMENT,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/preferFunctionDeclarations.ts



	// This hook is created with a list of initial VariableDeclarators that contain functions we want to convert
	// We then remove any ArrowFunctionExpression VariableDeclarators that contain a valid ThisExpression
	const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$preferFunctionDeclarations_ts$hook = ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default({
		name: "preferFunctionDeclarationsHook",
		initialState: {
			declarators: [],
		},
		call(path, state, {declarator, node}) {
			return {
				bubble: !state.declarators.includes(declarator),
				value: node,
				state: {
					declarators: state.declarators.filter((decl) => decl !== declarator),
				},
			};
		},
		exit(path, state) {
			const node = ___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.assert(
				path.node,
			);

			// We may have invalidated all declarations
			if (state.declarators.length === 0) {
				return node;
			}

			const nodes = [];

			const newNode = Object.assign(
				{},
				node,
				{
					declaration: Object.assign(
						{},
						node.declaration,
						{
							declarations: node.declaration.declarations.filter((decl) =>
								!state.declarators.includes(decl)
							),
						},
					),
				},
			);

			// We may have removed all the declarators
			if (newNode.declaration.declarations.length > 0) {
				nodes.push(newNode);
			}

			// Convert functions
			for (const decl of state.declarators) {
				const id = ___R$project$rome$$romejs$js$ast$patterns$BindingIdentifier_ts$bindingIdentifier.assert(
					decl.id,
				);
				const {init} = decl;

				if (
					init === undefined ||
					(init.type !== "FunctionExpression" &&
					init.type !== "ArrowFunctionExpression")
				) {
					throw new Error("Invalid declarator put into state");
				}

				// TODO if this is suppressed then don't transform
				path.context.addNodeDiagnostic(
					init,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.PREFER_FUNCTION_DECLARATIONS,
					{fixable: true},
				);

				// Convert arrow function body if necessary
				const body =
					init.body.type === "BlockStatement"
						? init.body
						: ___R$project$rome$$romejs$js$ast$statements$BlockStatement_ts$blockStatement.create({
								body: [
									___R$project$rome$$romejs$js$ast$statements$ReturnStatement_ts$returnStatement.quick(
										init.body,
									),
								],
							});

				nodes.push(
					___R$project$rome$$romejs$js$ast$statements$FunctionDeclaration_ts$functionDeclaration.create({
						id,
						head: init.head,
						body,
					}),
				);
			}

			return nodes;
		},
	});
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$preferFunctionDeclarations_ts$default = {
		name: "preferFunctionDeclarations",
		enter(path) {
			const {node} = path;

			if (
				node.type === "VariableDeclarationStatement" &&
				node.declaration.kind === "const"
			) {
				// Get all declarators that are function expressions, have no type annotation, and have a binding identifier id
				const declarators = node.declaration.declarations.filter((decl) => {
					return (
						decl.id.type === "BindingIdentifier" &&
						(decl.id.meta === undefined ||
						decl.id.meta.typeAnnotation === undefined) &&
						decl.init !== undefined &&
						(decl.init.type === "FunctionExpression" ||
						decl.init.type === "ArrowFunctionExpression")
					);
				});
				if (declarators.length > 0) {
					return path.provideHook(
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$preferFunctionDeclarations_ts$hook,
						{
							declarators,
						},
					);
				}
			}

			// If we have a `this` inside of an arrow function attached as a variable declarator then we should consider
			// it valid
			if (node.type === "ThisExpression") {
				// Try to find the arrow function owner, or stop if we get to another function
				const func = path.findAncestry((path) => {
					if (path.node.type === "ArrowFunctionExpression") {
						return path.parent.type === "VariableDeclarator";
					}

					if (
						___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(
							path.node,
						)
					) {
						return true;
					}

					return false;
				});

				// We'll only return an ArrowFunctionExpression if it was inside of a VariableDeclarator
				if (func !== undefined && func.node.type === "ArrowFunctionExpression") {
					return path.callHook(
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$preferFunctionDeclarations_ts$hook,
						{
							declarator: ___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclarator_ts$variableDeclarator.assert(
								func.parent,
							),
							node,
						},
						node,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/preferTemplate.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$preferTemplate_ts$default = {
		name: "preferTemplate",
		enter(path) {
			const {node} = path;

			if (
				node.type === "BinaryExpression" &&
				node.operator === "+" &&
				((node.left.type === "StringLiteral" && !node.left.value.includes("`")) ||
				(node.right.type === "StringLiteral" && !node.right.value.includes("`")))
			) {
				let autofix;

				if (node.right.type === "StringLiteral") {
					const quasis = [
						___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.create({
							raw: "",
							cooked: "",
						}),
						___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.create({
							raw: node.right.value,
							cooked: node.right.value,
						}),
					];
					const expressions = [
						___R$project$rome$$romejs$js$ast$utils$removeShallowLoc_ts$default(
							node.left,
						),
					];
					autofix = ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.create({
						expressions,
						quasis,
						loc: node.loc,
					});
				}

				if (node.left.type === "StringLiteral") {
					const quasis = [
						___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.create({
							raw: node.left.value,
							cooked: node.left.value,
						}),
						___R$project$rome$$romejs$js$ast$auxiliary$TemplateElement_ts$templateElement.create({
							raw: "",
							cooked: "",
						}),
					];

					// We need to remove the location or else if we were to show a preview the source map would resolve to the end of
					// this node
					const expressions = [
						___R$project$rome$$romejs$js$ast$utils$removeShallowLoc_ts$default(
							node.right,
						),
					];
					autofix = ___R$project$rome$$romejs$js$ast$literals$TemplateLiteral_ts$templateLiteral.create({
						expressions,
						quasis,
						loc: node.loc,
					});
				}

				if (autofix === undefined) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.PREFER_TEMPLATE,
					);
				} else {
					return path.context.addFixableDiagnostic(
						{
							old: node,
							fixed: autofix,
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.PREFER_TEMPLATE,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/preferWhile.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$preferWhile_ts$default = {
		name: "preferWhile",
		enter(path) {
			const {context, node} = path;

			if (
				node.type === "ForStatement" &&
				node.init === undefined &&
				node.update === undefined
			) {
				return context.addFixableDiagnostic(
					{
						old: node,
						fixed: ___R$project$rome$$romejs$js$ast$statements$WhileStatement_ts$whileStatement.create(
							{
								test: node.test !== undefined
									? node.test
									: ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.quick(
											true,
										),
								body: node.body,
								leadingComments: node.leadingComments,
								trailingComments: node.trailingComments,
							},
							node,
						),
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.PREFER_WHILE,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/reactInJsxScope.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$react$reactInJsxScope_ts$default = {
		name: "reactInJsxScope",
		enter(path) {
			const {node, scope, context} = path;

			if (node.type === "JSXElement") {
				const reactIsInScope = scope.getBinding("React") !== undefined;

				if (!reactIsInScope) {
					context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_IN_JSX_SCOPE,
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/restrictedGlobals.ts
const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$restrictedGlobals_ts$RESTRICTED_GLOBALS = [
		"event",
		"error",
	];
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$restrictedGlobals_ts$default = {
		name: "restrictedGlobal",
		enter(path) {
			const {node, scope} = path;

			if (
				(node.type === "ReferenceIdentifier" ||
				node.type === "JSXReferenceIdentifier") &&
				!___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(
					path,
				)
			) {
				const {name} = node;
				const binding = scope.getBinding(name);

				const isDefined = binding !== undefined;
				const isAGlobal = scope.getRootScope().isGlobal(name);

				if (
					!isDefined &&
					isAGlobal &&
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$restrictedGlobals_ts$RESTRICTED_GLOBALS.includes(
						name,
					)
				) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.RESTRICTED_GLOBALS(
							name,
						),
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/singleVarDeclarator.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$singleVarDeclarator_ts$default = {
		name: "singleVarDeclarator",
		enter(path) {
			const {node} = path;

			if (
				node.type === "VariableDeclarationStatement" &&
				node.declaration.declarations.length > 1
			) {
				const fixed = [];
				const {kind} = node.declaration;

				for (const declarator of node.declaration.declarations) {
					fixed.push(
						___R$project$rome$$romejs$js$ast$statements$VariableDeclarationStatement_ts$variableDeclarationStatement.quick(
							___R$project$rome$$romejs$js$ast$auxiliary$VariableDeclaration_ts$variableDeclaration.create({
								kind,
								declarations: [declarator],
							}),
						),
					);
				}

				return path.context.addFixableDiagnostic(
					{old: node, fixed},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.SINGLE_VAR_DECLARATOR,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/sortImportExportSpecifiers.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$compareImportSpecifiers(
		a,
		b,
	) {
		const order = ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
			a.local.name.name,
			b.local.name.name,
			false,
		);
		if (order === 0) {
			return ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
				a.imported.name,
				b.imported.name,
				false,
			);
		} else {
			return order;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$compareExportSpecifiers(
		a,
		b,
	) {
		const order = ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
			a.local.name,
			b.local.name,
			false,
		);
		if (order === 0) {
			return ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
				a.exported.name,
				b.exported.name,
				false,
			);
		} else {
			return order;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$shouldReorder(
		a,
		b,
	) {
		for (let i = 0; i < a.length && i < b.length; i++) {
			if (a[i] !== b[i]) {
				return true;
			}
		}

		return false;
	}
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$default = {
		name: "sortImportExportSpecifiers",
		enter(path) {
			const {context, node} = path;

			if (node.type === "ImportDeclaration") {
				if (node.namedSpecifiers.length > 1) {
					const specifiers = node.namedSpecifiers;
					const sortedSpecifiers = specifiers.slice().sort(
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$compareImportSpecifiers,
					);
					if (
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$shouldReorder(
							specifiers,
							sortedSpecifiers,
						)
					) {
						return context.addFixableDiagnostic(
							{
								old: node,
								fixed: Object.assign(
									{},
									node,
									{namedSpecifiers: sortedSpecifiers},
								),
							},
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.SORT_IMPORT_SPECIFIERS,
						);
					}
				}
			} else if (node.type === "ExportExternalDeclaration") {
				if (node.namedSpecifiers.length > 1) {
					const specifiers = node.namedSpecifiers;
					const sortedSpecifiers = specifiers.slice().sort(
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$compareExportSpecifiers,
					);
					if (
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$shouldReorder(
							specifiers,
							sortedSpecifiers,
						)
					) {
						return context.addFixableDiagnostic(
							{
								old: node,
								fixed: Object.assign(
									{},
									node,
									{namedSpecifiers: sortedSpecifiers},
								),
							},
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.SORT_EXPORT_SPECIFIERS,
						);
					}
				}
			} else if (node.type === "ExportLocalDeclaration") {
				if (node.specifiers !== undefined && node.specifiers.length > 1) {
					const specifiers = node.specifiers;
					const sortedSpecifiers = specifiers.slice().sort(
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$compareExportSpecifiers,
					);
					if (
						___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$shouldReorder(
							specifiers,
							sortedSpecifiers,
						)
					) {
						return context.addFixableDiagnostic(
							{
								old: node,
								fixed: Object.assign({}, node, {specifiers: sortedSpecifiers}),
							},
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.SORT_EXPORT_SPECIFIERS,
						);
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/sparseArray.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$sparseArray_ts$default = {
		name: "sparseArray",
		enter(path) {
			const {node, parent} = path;

			if (node.type === "ArrayHole" && parent.type === "ArrayExpression") {
				return path.context.addFixableDiagnostic(
					{
						old: node,
						fixed: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.create({
							name: "undefined",
						}),
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.SPARSE_ARRAY,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/stylePropObject.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$react$stylePropObject_ts$default = {
		name: "stylePropObject",
		enter(path) {
			const {node} = path;

			if (
				node.type === "JSXAttribute" &&
				node.name.name === "style" &&
				node.value !== undefined &&
				((node.value.type === "JSXExpressionContainer" &&
				node.value.expression.type !== "ObjectExpression") ||
				node.value.type !== "JSXExpressionContainer")
			) {
				path.context.addNodeDiagnostic(
					node,
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.STYLE_PROP_OBJECT,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/undeclaredVariables.ts
const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$undeclaredVariables_ts$NODE_VARIABLES = [
		"require",
		"__dirname",
		"__filename",
		"module",
		"exports",
	];

	const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$undeclaredVariables_ts$BROWSER_VARIABLES = [
		"fetch",
		"document",
		"window",
		"Worker",
		"cancelAnimationFrame",
		"requestAnimationFrame",
		"WebSocket",
		"alert",
		"Blob",
		"navigator",
		"Element",
		"Text",
		"Document",
		"performance",
	];
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$undeclaredVariables_ts$default = {
		name: "undeclaredVariables",
		enter(path) {
			const {node, scope} = path;

			if (
				(node.type === "ReferenceIdentifier" ||
				node.type === "JSXReferenceIdentifier") &&
				!___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(
					path,
				)
			) {
				const {name} = node;
				const binding = scope.getBinding(name);

				const isDefined =
					binding !== undefined ||
					scope.getRootScope().isGlobal(name) ||
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$undeclaredVariables_ts$BROWSER_VARIABLES.includes(
						name,
					) ||
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$undeclaredVariables_ts$NODE_VARIABLES.includes(
						name,
					);

				if (!isDefined) {
					path.context.addNodeDiagnostic(
						node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.UNDECLARED_VARIABLES(
							name,
						),
						{
							meta: {
								identifierName: name,
							},
						},
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/unsafeNegation.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$unsafeNegation_ts$default = {
		name: "unsafeNegation",
		enter(path) {
			const {node} = path;

			if (
				node.type === "BinaryExpression" &&
				(node.operator === "in" || node.operator === "instanceof") &&
				node.left.type === "UnaryExpression" &&
				node.left.operator === "!"
			) {
				return path.context.addFixableDiagnostic(
					{
						old: node,
						fixed: ___R$project$rome$$romejs$js$ast$expressions$UnaryExpression_ts$unaryExpression.create({
							operator: node.left.operator,
							argument: Object.assign({}, node, {left: node.left.argument}),
						}),
					},
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.UNSAFE_NEGATION,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/regular/unusedVariables.ts


	const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$unusedVariables_ts$initialState = {
		usedBindings: {},
		scope: undefined,
	};

	const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$unusedVariables_ts$provider = ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default({
		name: "unusedVariablesProvider",
		initialState: ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$unusedVariables_ts$initialState,
		call(path, state) {
			const {node} = path;
			if (
				node.type !== "ReferenceIdentifier" &&
				node.type !== "JSXReferenceIdentifier"
			) {
				throw new Error("Expected only Identifier to be dispatched");
			}

			const binding = path.scope.getBindingFromPath(path);

			// Check if this binding belongs to the scope we're tracking
			if (binding === undefined || binding.scope !== state.scope) {
				return {
					bubble: true,
					value: node,
					state,
				};
			}

			// Mark this binding as used
			return {
				value: node,
				state: Object.assign(
					{},
					state,
					{
						usedBindings: Object.assign(
							{},
							state.usedBindings,
							{[node.name]: true},
						),
					},
				),
			};
		},
		exit(path, state) {
			for (const name in state.usedBindings) {
				const used = state.usedBindings[name];
				const binding = path.scope.getBinding(name);

				if (used === false && binding !== undefined) {
					path.context.addNodeDiagnostic(
						binding.node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.UNUSED_VARIABLES(
							binding.kind,
							name,
						),
					);
				}
			}

			return path.node;
		},
	});
	const ___R$project$rome$$romejs$js$compiler$lint$rules$regular$unusedVariables_ts$default = {
		name: "unusedVariables",
		enter(path) {
			const {node, scope} = path;

			if (scope.node === node) {
				let hasBindings = false;
				const usedBindings = {};

				// Get all the non-exported bindings in this file and mark them as unused
				for (const [name, binding] of scope.getOwnBindings()) {
					if (
						binding instanceof
						___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ArgumentsBinding
					) {
						continue;
					}

					if (binding.isExported) {
						continue;
					}

					hasBindings = true;
					usedBindings[name] = false;
				}

				if (!hasBindings) {
					return node;
				}

				// For functions, consider all parameters except the last to be used
				if (
					node.type === "FunctionDeclaration" ||
					node.type === "FunctionExpression" ||
					node.type === "ObjectMethod" ||
					node.type === "ClassMethod" ||
					node.type === "ArrowFunctionExpression"
				) {
					for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
						node.head.params.slice(0, -1),
					)) {
						usedBindings[name] = true;
					}

					// For functions that have a single throw statement in the body, consider all their arguments
					// to be used as this is typically an interface definition
					const {body: block} = node;
					if (
						block.type === "BlockStatement" &&
						block.body.length === 1 &&
						block.body[0].type === "ThrowStatement"
					) {
						for (const {name} of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
							node.head.params,
						)) {
							usedBindings[name] = true;
						}
					}
				}

				if (
					node.type === "CatchClause" &&
					node.param &&
					node.param.type === "BindingIdentifier"
				) {
					// Mark error param as used as they are required
					usedBindings[node.param.name] = true;
				}

				// For a named function expression, don't consider the id to be unused
				if (node.type === "FunctionExpression" && node.id !== undefined) {
					usedBindings[node.id.name] = true;
				}

				return path.provideHook(
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$unusedVariables_ts$provider,
					{
						usedBindings,
						scope,
					},
				);
			}

			if (
				node.type === "JSXReferenceIdentifier" ||
				node.type === "ReferenceIdentifier"
			) {
				return path.callHook(
					___R$$priv$project$rome$$romejs$js$compiler$lint$rules$regular$unusedVariables_ts$provider,
					undefined,
					node,
				);
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/react/voidDomElementsNoChildren.ts
const ___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$voidDomElementsNoChildren_ts$VOID_DOM_ELEMENTS = new Set([
		"area",
		"base",
		"br",
		"col",
		"embed",
		"hr",
		"img",
		"input",
		"keygen",
		"link",
		"menuitem",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
	]);
	const ___R$project$rome$$romejs$js$compiler$lint$rules$react$voidDomElementsNoChildren_ts$default = {
		name: "voidDomElementsNoChildren",
		enter(path) {
			const {node, context} = path;

			if (
				node.type === "JSXElement" &&
				node.name.type === "JSXIdentifier" &&
				___R$$priv$project$rome$$romejs$js$compiler$lint$rules$react$voidDomElementsNoChildren_ts$VOID_DOM_ELEMENTS.has(
					node.name.name,
				)
			) {
				const element = node.name.name;

				let properties = new Set();

				if (node.children.length !== 0) {
					properties.add("children");
				}

				const newAttributes = [];
				for (const attribute of node.attributes) {
					if (attribute.type === "JSXAttribute") {
						const property = attribute.name.name;
						if (property === "children") {
							properties.add("children");
						} else if (property === "dangerouslySetInnerHTML") {
							properties.add("dangerouslySetInnerHTML");
						} else {
							newAttributes.push(attribute);
						}
					}
				}

				if (properties.size > 0) {
					return context.addFixableDiagnostic(
						{
							old: node,
							fixed: Object.assign(
								{},
								node,
								{attributes: newAttributes, children: [], selfClosing: true},
							),
						},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.REACT_JSX_VOID_DOM_ELEMENTS_NO_CHILDREN(
							element,
							Array.from(properties),
						),
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/lint/rules/index.ts
const ___R$project$rome$$romejs$js$compiler$lint$rules$index_ts$lintTransforms = [
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$camelCase_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$caseSingleStatement_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$confusingLanguage_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$defaultExportSameBasename_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$doubleEquals_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$duplicateImportSource_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$emptyBlocks_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$emptyMatches_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$getterReturn_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$importDefaultBasename_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yAltText_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHeadingHasContent_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yHTMLHasLang_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yIframeHasTitle_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yImgRedundantAlt_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoAccessKey_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoAutofocus_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoDistractingElements_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yNoTargetBlank_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxA11yScope_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxKey_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$jsxNoCommentText_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$negationElse_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noArguments_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noAsyncPromiseExecutor_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noCatchAssign_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$noChildrenProp_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noCommaOperator_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noCompareNegZero_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noCondAssign_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$noDanger_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$noDangerWithChildren_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDebugger_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDelete_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDeleteVars_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$noDidUpdateSetState_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDupeArgs_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDuplicateCase_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDuplicateGroupNamesInRegularExpressions_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noDuplicateKeys_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noEmptyCharacterClass_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noExplicitAny_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noExtraBooleanCast_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$noFindDOMNode_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noFunctionAssign_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noImportAssign_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noLabelVar_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noMultipleSpacesInRegularExpressionLiterals_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noPosixInRegularExpression_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noReferenceToNonExistingGroup_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noSetterReturn_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noShadowRestrictedNames_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noShorthandArrayType_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noTemplateCurlyInString_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noUnsafeFinally_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$noVar_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$preferBlockStatements_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$preferFunctionDeclarations_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$preferTemplate_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$preferWhile_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$reactInJsxScope_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$restrictedGlobals_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$singleVarDeclarator_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$sortImportExportSpecifiers_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$sparseArray_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$stylePropObject_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$undeclaredVariables_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$unsafeNegation_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$regular$unusedVariables_ts$default,
		___R$project$rome$$romejs$js$compiler$lint$rules$react$voidDomElementsNoChildren_ts$default,
	];


  // project-rome/@romejs/js-compiler/lint/suppressions.ts
function ___R$$priv$project$rome$$romejs$js$compiler$lint$suppressions_ts$getStartLine(
		node,
	) {
		const {loc} = node;
		if (loc === undefined) {
			return undefined;
		} else {
			return loc.start.line;
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$lint$suppressions_ts$buildSuppressionCommentValue(
		categories,
	) {
		return (
			___R$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START +
			" " +
			Array.from(categories).join(" ")
		);
	}

	function ___R$project$rome$$romejs$js$compiler$lint$suppressions_ts$addSuppressions(
		context,
		ast,
	) {
		if (!context.hasLintDecisions()) {
			return ast;
		}

		const visitedLines = new Set();

		function addComment(path, node, decisions) {
			// Find all suppression decisions
			const suppressionCategories = new Set();
			for (const {category, action} of decisions) {
				if (action === "suppress") {
					suppressionCategories.add(category);
				}
			}
			if (suppressionCategories.size === 0) {
				return node;
			}

			// Find existing suppression comment
			let updateComment;
			const lastComment = context.comments.getCommentsFromIds(
				node.leadingComments,
			).pop();
			if (
				lastComment !== undefined &&
				lastComment.value.includes(
					___R$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START,
				)
			) {
				updateComment = lastComment;
			}

			// Insert new comment if there's none to update
			if (updateComment === undefined) {
				const id = path.callHook(
					___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$commentInjector,
					{
						type: "CommentLine",
						value: " " +
						___R$$priv$project$rome$$romejs$js$compiler$lint$suppressions_ts$buildSuppressionCommentValue(
							suppressionCategories,
						),
					},
				);

				return Object.assign(
					{},
					node,
					{leadingComments: [...(node.leadingComments || []), id]},
				);
			}

			// Remove all categories that are already included in the suppression
			for (const category of suppressionCategories) {
				if (updateComment.value.includes(category)) {
					suppressionCategories.delete(category);
				}
			}

			// We may have eliminated them all
			if (suppressionCategories.size > 0) {
				path.callHook(
					___R$project$rome$$romejs$js$compiler$transforms$defaultHooks$index_ts$commentInjector,
					Object.assign(
						{},
						updateComment,
						{
							value: updateComment.value.replace(
								___R$project$rome$$romejs$js$compiler$suppressions_ts$SUPPRESSION_START,
								___R$$priv$project$rome$$romejs$js$compiler$lint$suppressions_ts$buildSuppressionCommentValue(
									suppressionCategories,
								),
							),
						},
					),
				);
			}

			return node;
		}

		// Find the best node to attach comments to. This is generally the node with the largest range per line.
		return context.reduceRoot(
			ast,
			{
				name: "suppressionVisitor",
				enter(path) {
					const {node} = path;

					// Don't allow attaching suppression comments to a comment or program...
					if (
						node.type === "CommentBlock" ||
						node.type === "CommentLine" ||
						node.type === "Program"
					) {
						return node;
					}

					const line = ___R$$priv$project$rome$$romejs$js$compiler$lint$suppressions_ts$getStartLine(
						node,
					);
					if (line === undefined || visitedLines.has(line)) {
						return node;
					}

					const decisions = context.getLintDecisions(
						String(___R$project$rome$$romejs$ob1$index_ts$ob1Get1(line)),
					);
					if (decisions.length === 0) {
						return node;
					}

					visitedLines.add(line);
					return addComment(path, node, decisions);
				},
			},
		);
	}


  // project-rome/@romejs/js-compiler/lint/index.ts


	const ___R$$priv$project$rome$$romejs$js$compiler$lint$index_ts$lintCache = new ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default();

	async function ___R$project$rome$$romejs$js$compiler$lint$index_ts$default(
		req,
	) {
		const {ast, sourceText, project, applyFixes, options} = req;

		const query = ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default.buildQuery(
			req,
			{applyFixes},
		);
		const cached = ___R$$priv$project$rome$$romejs$js$compiler$lint$index_ts$lintCache.get(
			query,
		);
		if (cached) {
			return cached;
		}

		// Perform autofixes
		const formatContext = new ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default({
			ref: req.ref,
			sourceText: req.sourceText,
			options,
			ast,
			project,
			frozen: false,
			origin: {
				category: "lint",
			},
		});

		let formatAst = ast;
		if (applyFixes) {
			formatAst = formatContext.reduceRoot(
				ast,
				___R$project$rome$$romejs$js$compiler$lint$rules$index_ts$lintTransforms,
			);
			formatAst = ___R$project$rome$$romejs$js$compiler$lint$suppressions_ts$addSuppressions(
				formatContext,
				formatAst,
			);
		}
		const formattedCode = ___R$project$rome$$romejs$js$formatter$index_ts$formatJS(
			formatAst,
			{
				typeAnnotations: true,
				sourceMaps: true,
				format: "pretty",
				sourceText,
			},
		).code;

		// Run lints (could be with the autofixed AST)
		const context = new ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default({
			ref: req.ref,
			sourceText: req.sourceText,
			ast,
			project,
			options,
			origin: {
				category: "lint",
			},
			frozen: true,
		});
		context.reduceRoot(
			ast,
			___R$project$rome$$romejs$js$compiler$lint$rules$index_ts$lintTransforms,
		);

		const diagnostics = context.diagnostics.getDiagnostics();
		const result = {
			suppressions: context.suppressions,
			diagnostics: [...ast.diagnostics, ...diagnostics],
			src: formattedCode,
		};
		___R$$priv$project$rome$$romejs$js$compiler$lint$index_ts$lintCache.set(
			query,
			result,
		);
		return result;
	}


  // project-rome/@romejs/js-compiler/methods/transform.ts


	const ___R$$priv$project$rome$$romejs$js$compiler$methods$transform_ts$transformCaches = ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageOrder.map(() =>
		new ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default()
	);

	async function ___R$project$rome$$romejs$js$compiler$methods$transform_ts$default(
		req,
	) {
		const stage = req.stage === undefined ? "compile" : req.stage;

		const {options, project} = req;
		let ast = req.ast;

		const cacheQuery = ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default.buildQuery(
			req,
		);

		const stageNo = ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageOrder.indexOf(
			stage,
		);

		// Check this exact stage cache
		const stageCache = ___R$$priv$project$rome$$romejs$js$compiler$methods$transform_ts$transformCaches[stageNo];
		const cached = stageCache.get(cacheQuery);
		if (cached !== undefined) {
			return cached;
		}

		let prevStageDiagnostics = [];
		let prevStageCacheDeps = [];
		let suppressions;

		// Run the previous stage
		if (stageNo > 0) {
			const prevStage = await ___R$project$rome$$romejs$js$compiler$methods$transform_ts$default(
				Object.assign(
					{},
					req,
					{
						stage: ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageOrder[stageNo -
						1],
					},
				),
			);
			prevStageDiagnostics = prevStage.diagnostics;
			prevStageCacheDeps = prevStage.cacheDependencies;
			ast = prevStage.ast;
			suppressions = prevStage.suppressions;
		}

		const context = new ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default({
			suppressions,
			ref: req.ref,
			sourceText: req.sourceText,
			ast,
			project,
			options,
			origin: {
				category: "transform",
			},
		});

		const transformFactory = ___R$project$rome$$romejs$js$compiler$transforms$index_ts$stageTransforms[stage];
		const transforms = transformFactory(project.config, options);

		let visitors = await context.normalizeTransforms(transforms);

		const compiledAst = context.reduceRoot(ast, visitors);

		const res = {
			suppressions: context.suppressions,
			diagnostics: [
				...prevStageDiagnostics,
				...context.diagnostics.getDiagnostics(),
			],
			cacheDependencies: [
				...prevStageCacheDeps,
				...context.getCacheDependencies(),
			],
			ast: compiledAst,
		};
		stageCache.set(cacheQuery, res);
		return res;
	}


  // project-rome/@romejs/js-compiler/api/compile.ts


	const ___R$$priv$project$rome$$romejs$js$compiler$api$compile_ts$compileCache = new ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default();

	async function ___R$project$rome$$romejs$js$compiler$api$compile_ts$default(
		req,
	) {
		const {sourceText, ast} = req;

		const query = ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default.buildQuery(
			req,
		);
		const cached = ___R$$priv$project$rome$$romejs$js$compiler$api$compile_ts$compileCache.get(
			query,
		);
		if (cached) {
			return cached;
		}

		const {
			ast: transformedAst,
			diagnostics,
			suppressions,
			cacheDependencies,
		} = await ___R$project$rome$$romejs$js$compiler$methods$transform_ts$default(
			req,
		);

		const formatted = ___R$project$rome$$romejs$js$formatter$index_ts$formatJS(
			transformedAst,
			{
				typeAnnotations: false,
				indent: req.stage === "compileForBundle" ? 1 : 0,
				sourceMaps: true,
				sourceText,
				allowInterpreterDirective: false,
			},
		);

		if (req.inputSourceMap !== undefined) {
			const inputSourceMap = ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default.fromJSON(
				req.inputSourceMap,
			);
			const mappings = [];

			for (const mapping of formatted.mappings) {
				const actual = inputSourceMap.exactOriginalPositionFor(
					mapping.original.line,
					mapping.original.column,
				);

				if (actual !== undefined) {
					if (
						mapping.original.line !== actual.line ||
						mapping.original.column !== actual.column
					) {
						mappings.push(
							Object.assign(
								{},
								mapping,
								{
									original: {
										line: actual.line,
										column: actual.column,
									},
								},
							),
						);
					} else {
						mappings.push(mapping);
					}
				}
			}

			formatted.mappings = mappings;
		}

		const res = {
			compiledCode: formatted.code,
			mappings: formatted.mappings,
			diagnostics: [...ast.diagnostics, ...diagnostics],
			cacheDependencies,
			suppressions,
			sourceText,
		};

		___R$$priv$project$rome$$romejs$js$compiler$api$compile_ts$compileCache.set(
			query,
			res,
		);
		return res;
	}


  // project-rome/@romejs/js-compiler/api/analyzeDependencies/records.ts
class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord
		extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
		constructor(data) {
			super();
			this.data = data;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord
		extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
		constructor(data) {
			super();
			this.data = data;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord
		extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
		constructor(node) {
			super();
			this.node = node;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord
		extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
		constructor(node) {
			super();
			this.node = node;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord
		extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
		constructor(node) {
			super();
			this.node = node;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord
		extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
		constructor(kind, node) {
			super();
			this.node = node;
			this.kind = kind;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord
		extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
		constructor(loc) {
			super();
			this.loc = loc;
		}
	}

	class ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord
		extends ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default {
		constructor(isTop, data) {
			super();
			this.isTop = isTop;
			this.data = data;
		}
	}


  // project-rome/@romejs/js-compiler/api/analyzeDependencies/utils.ts
function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(
		path,
	) {
		for (const {node} of path.ancestryPaths) {
			if (node.type === "TryStatement") {
				return true;
			}
		}

		return false;
	}

	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isTypeKind(
		kind,
	) {
		return kind === "type" || kind === "typeof";
	}

	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
		kind,
	) {
		return kind === undefined ? "value" : kind;
	}

	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(
		kind,
	) {
		return kind === undefined ? "value" : kind;
	}

	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
		kind,
		scope,
		id,
	) {
		const binding = scope.getBinding(id.name);
		if (
			kind === "value" &&
			binding instanceof
			___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding
		) {
			return "type";
		} else {
			return kind;
		}
	}

	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(
		rawKind,
		specifierKinds,
	) {
		const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
			rawKind,
		);
		if (
			___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isTypeKind(
				kind,
			) ||
			specifierKinds.length === 0
		) {
			return kind;
		}

		for (const specifierKind of specifierKinds) {
			if (specifierKind === "value") {
				return "value";
			}
		}
		return "type";
	}

	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
		scope,
		node,
	) {
		if (node === undefined) {
			return "other";
		}

		if (node.type === "Identifier") {
			const binding = scope.getBinding(node.name);

			if (
				binding instanceof
				___R$project$rome$$romejs$js$compiler$scope$bindings_ts$FunctionBinding
			) {
				return "function";
			}

			if (
				binding instanceof
				___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ClassBinding
			) {
				return "class";
			}

			if (
				binding instanceof
				___R$project$rome$$romejs$js$compiler$scope$bindings_ts$TypeBinding
			) {
				const {typeKind} = binding;
				switch (typeKind) {
					case "function":
					case "class":
						return typeKind;
				}
			}
		}

		if (node.type === "FunctionDeclaration") {
			return "function";
		}

		if (node.type === "ClassDeclaration" || node.type === "ClassExpression") {
			return "class";
		}

		return "other";
	}

	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
		scope,
		node,
	) {
		if (node.type === "ReferenceIdentifier") {
			const binding = scope.getBinding(node.name);
			if (binding !== undefined) {
				return binding.node.loc;
			}
		}

		return node.loc;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$arraySame(
		a,
		b,
		callback,
	) {
		if (a.length !== b.length) {
			return false;
		}

		for (let i = 0; i < a.length; i++) {
			if (!callback(a[i], b[i])) {
				return false;
			}
		}

		return true;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$syntaxSame(
		a,
		b,
	) {
		return a === b;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$exportsSame(
		a,
		b,
	) {
		if (a.type !== b.type) {
			return false;
		}

		if (a.kind !== b.kind) {
			return false;
		}

		switch (a.type) {
			case "local":
				return b.type === "local" && a.name === b.name;

			case "external":
				return (
					b.type === "external" &&
					a.imported === b.imported &&
					a.exported === b.exported &&
					a.source === b.source
				);

			case "externalAll":
				return b.type === "externalAll" && a.source === b.source;

			case "externalNamespace":
				return (
					b.type === "externalNamespace" &&
					a.source === b.source &&
					a.exported === b.exported
				);
		}
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$dependencyNameSame(
		a,
		b,
	) {
		return a.kind === b.kind && a.name === b.name;
	}

	function ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$dependenciesSame(
		a,
		b,
	) {
		return (
			a.all === b.all &&
			a.async === b.async &&
			a.optional === b.optional &&
			a.source === b.source &&
			a.type === b.type &&
			___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$arraySame(
				a.names,
				b.names,
				___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$dependencyNameSame,
			)
		);
	}

	// Check if the shape of two analyzeDependencyResults are equal. Ignoring location information
	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$areAnalyzeDependencyResultsEqual(
		a,
		b,
	) {
		if (
			(a.firstTopAwaitLocation === undefined &&
			b.firstTopAwaitLocation !== undefined) ||
			(b.firstTopAwaitLocation === undefined &&
			a.firstTopAwaitLocation !== undefined)
		) {
			return false;
		}

		if (a.moduleType !== b.moduleType) {
			return false;
		}

		if (
			!___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$arraySame(
				a.syntax,
				b.syntax,
				___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$syntaxSame,
			)
		) {
			return false;
		}

		if (
			!___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$arraySame(
				a.exports,
				b.exports,
				___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$exportsSame,
			)
		) {
			return false;
		}

		if (
			!___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$arraySame(
				a.dependencies,
				b.dependencies,
				___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$dependenciesSame,
			)
		) {
			return false;
		}

		return true;
	}


  // project-rome/@romejs/js-compiler/api/analyzeDependencies/visitors/es.ts
const ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$es_ts$default = {
		name: "analyzeDependenciesES",
		enter(path) {
			const {node, scope, context} = path;

			// import('./bar');
			if (node.type === "ImportCall" && node.argument.type === "StringLiteral") {
				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "es",
						async: true,
						kind: "value",
						names: [],
						loc: node.argument.loc,
						source: node.argument.value,
						optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						all: true,
					}),
				);
			}

			// Local bindings exports:
			// export const foo
			// export function foo() {}
			// export {};
			if (node.type === "ExportLocalDeclaration") {
				const valueType = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
					scope,
					node.declaration,
				);
				for (const id of ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
					node,
				)) {
					const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
						___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(
							node.exportKind,
						),
						scope,
						id,
					);
					context.record(
						new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
							type: "local",
							valueType,
							kind,
							loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
								scope,
								id,
							),
							name: id.name,
						}),
					);
				}

				const {specifiers} = node;
				if (specifiers !== undefined) {
					for (const specifier of specifiers) {
						const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$maybeTypeBinding(
							___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(
								specifier.exportKind || node.exportKind,
							),
							scope,
							specifier.local,
						);

						context.record(
							new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
								type: "local",
								loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
									scope,
									specifier.local,
								),
								valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
									scope,
									specifier.local,
								),
								kind,
								name: specifier.exported.name,
							}),
						);
					}
				}
			}

			// export default
			if (node.type === "ExportDefaultDeclaration") {
				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
						type: "local",
						loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
							scope,
							node.declaration,
						),
						valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
							scope,
							node.declaration,
						),
						kind: "value",
						name: "default",
					}),
				);
			}

			// External binding exports:
			// export {} from '';
			if (node.type === "ExportExternalDeclaration") {
				const {source} = node;
				const specifiersKinds = [];
				const exportedNames = [];

				const {namedSpecifiers, defaultSpecifier, namespaceSpecifier} = node;

				if (defaultSpecifier !== undefined) {
					context.record(
						new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
							type: "external",
							kind: "value",
							loc: defaultSpecifier.loc,
							imported: "default",
							exported: defaultSpecifier.exported.name,
							source: source.value,
						}),
					);
				}

				if (namespaceSpecifier !== undefined) {
					context.record(
						new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
							type: "externalNamespace",
							kind: "value",
							loc: namespaceSpecifier.loc,
							exported: namespaceSpecifier.exported.name,
							source: source.value,
						}),
					);
				}

				for (const specifier of namedSpecifiers) {
					const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
						specifier.exportKind || node.exportKind,
					);
					specifiersKinds.push(kind);

					exportedNames.push({
						name: specifier.local.name,
						kind,
						loc: specifier.loc,
					});

					context.record(
						new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
							type: "external",
							kind,
							loc: specifier.loc,
							imported: specifier.local.name,
							exported: specifier.exported.name,
							source: source.value,
						}),
					);
				}

				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "es",
						async: false,
						kind: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(
							node.exportKind,
							specifiersKinds,
						),
						names: exportedNames,
						loc: source.loc,
						source: source.value,
						optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						all: false,
					}),
				);
			}

			// TS: import A = require('B');
			if (
				node.type === "TSImportEqualsDeclaration" &&
				node.moduleReference.type === "TSExternalModuleReference"
			) {
				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "cjs",
						kind: "value",
						optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						loc: node.loc,
						source: node.moduleReference.expression.value,
						names: [],
						all: true,
						async: false,
					}),
				);
			}

			// export * from '';
			if (node.type === "ExportAllDeclaration") {
				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "es",
						async: false,
						kind: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(
							node.exportKind,
						),
						optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						loc: node.source.loc,
						names: [],
						source: node.source.value,
						all: true,
					}),
				);

				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
						type: "externalAll",
						loc: node.loc,
						kind: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(
							node.exportKind,
						),
						source: node.source.value,
					}),
				);
			}

			if (
				node.type === "ExportAllDeclaration" ||
				node.type === "ExportDefaultDeclaration" ||
				node.type === "ExportLocalDeclaration"
			) {
				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord(
						___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getExportKind(
							node.exportKind,
						),
						node,
					),
				);
			}

			// import {} from '';

			// import * as foo from '';
			if (node.type === "ImportDeclaration") {
				let hasNamespaceSpecifier = false;
				const specifierKinds = [];
				const names = [];

				for (const specifier of ___R$project$rome$$romejs$js$ast$utils$getImportSpecifiers_ts$default(
					node,
				)) {
					if (specifier.type === "ImportNamespaceSpecifier") {
						hasNamespaceSpecifier = true;
						break;
					}

					const kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
						node.importKind,
					);
					specifierKinds.push(kind);

					if (specifier.type === "ImportDefaultSpecifier") {
						names.push({
							kind,
							loc: specifier.loc,
							name: "default",
						});
					}

					if (specifier.type === "ImportSpecifier") {
						names.push({
							kind,
							loc: specifier.loc,
							name: specifier.imported.name,
						});
					}
				}

				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
						type: "es",
						async: false,
						kind: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getKindWithSpecifiers(
							node.importKind,
							specifierKinds,
						),
						loc: node.source.loc,
						optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(
							path,
						),
						source: node.source.value,
						all: hasNamespaceSpecifier,
						names,
					}),
				);
			}

			// Detect top level await
			if (
				node.type === "AwaitExpression" &&
				path.findAncestry((path) =>
					___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(
						path.node,
					)
				) === undefined
			) {
				const {loc} = node;
				if (loc === undefined) {
					throw new Error("loc is undefined on AwaitExpression we want to mark");
				}
				context.record(
					new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord(
						loc,
					),
				);
			}

			if (node.type === "ReferenceIdentifier") {
				const binding = path.scope.getBinding(node.name);

				// Mark references to imports outside of functions
				if (
					binding !== undefined &&
					binding instanceof
					___R$project$rome$$romejs$js$compiler$scope$bindings_ts$ImportBinding
				) {
					const {meta} = binding;

					// We can skip this if it's referencing a namespace
					if (meta.type !== "name") {
						return node;
					}

					// These are nodes that will defer the execution of code outside the init path

					// (They could still be triggered with an actual function call but this is just for some basic analysis)
					const deferredExecution = path.findAncestry((path) =>
						___R$project$rome$$romejs$js$ast$utils$isFunctionNode_ts$default(
							path.node,
						) || path.node.type === "ClassProperty"
					);
					const isTop = deferredExecution === undefined;

					let kind = ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getImportKind(
						meta.kind,
					);
					if (
						___R$project$rome$$romejs$js$ast$utils$isInTypeAnnotation_ts$default(
							path,
						)
					) {
						kind = "type";
					}

					context.record(
						new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord(
							isTop,
							{
								kind,
								loc: node.loc,
								local: node.name,
								imported: meta.imported,
								source: meta.source,
							},
						),
					);
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/api/analyzeDependencies/visitors/cjs.ts
const ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$cjs_ts$default = {
		name: "analyzeDependenciesCJS",
		enter(path) {
			const {node, parent, scope, context} = path;

			// Handle require()
			if (node.type === "CallExpression") {
				const {callee, arguments: args} = node;

				const isRequire =
					callee.type === "ReferenceIdentifier" &&
					callee.name === "require" &&
					path.scope.hasBinding("require") === false;
				const sourceArg = args[0];

				if (isRequire && args.length === 1 && sourceArg.type === "StringLiteral") {
					context.record(
						new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord({
							type: "cjs",
							kind: "value",
							optional: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$isOptional(
								path,
							),
							loc: node.loc,
							source: sourceArg.value,
							names: [],
							all: true,
							async: false,
						}),
					);
				}
			}

			// Detect assignments to exports and module.exports as definitely being an CJS module
			if (node.type === "AssignmentExpression") {
				const isModuleExports =
					path.scope.getBinding("module") === undefined &&
					(___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
						node.left,
						"module.exports",
					) ||
					___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
						node.left,
						"module.exports.**",
					));
				const isExports =
					path.scope.getBinding("exports") === undefined &&
					(___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
						node.left,
						"exports",
					) ||
					___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
						node.left,
						"exports.**",
					));

				if (isModuleExports || isExports) {
					context.record(
						new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord(
							node,
						),
					);
				}

				if (isModuleExports) {
					const {right} = node;

					if (
						___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.is(
							right,
						)
					) {
						context.record(
							new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
								type: "local",
								loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
									scope,
									node.right,
								),
								valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
									scope,
									node.right,
								),
								kind: "value",
								name: "default",
							}),
						);

						for (const prop of right.properties) {
							// Don't allow spread, unknown, or computed properties
							if (
								prop.type === "SpreadProperty" ||
								(prop.key.type === "ComputedPropertyKey" &&
								prop.key.value.type !== "StringLiteral")
							) {
								context.record(
									new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(
										prop,
									),
								);
								continue;
							}

							const key = prop.key.value;
							let name;
							if (key.type === "Identifier") {
								name = key.name;
							} else if (key.type === "StringLiteral") {
								name = key.value;
							} else {
								// Unknown key literal
								context.record(
									new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(
										key,
									),
								);
								continue;
							}

							let target = prop.type === "ObjectMethod" ? prop : prop.value;

							context.record(
								new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
									type: "local",
									loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
										scope,
										target,
									),
									valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
										scope,
										target,
									),
									kind: "value",
									name,
								}),
							);
						}
					} else {
						const source = ___R$project$rome$$romejs$js$ast$utils$getRequireSource_ts$default(
							node.right,
							scope,
						);
						if (source === undefined) {
							context.record(
								new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
									type: "local",
									loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
										scope,
										node.right,
									),
									valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
										scope,
										node.right,
									),
									kind: "value",
									name: "default",
								}),
							);
						} else {
							context.record(
								new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
									type: "externalAll",
									loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
										scope,
										node.right,
									),
									kind: "value",
									source,
								}),
							);

							context.record(
								new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
									type: "external",
									kind: "value",
									loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
										scope,
										node.right,
									),
									imported: "default",
									exported: "default",
									source,
								}),
							);
						}
					}
				}

				if (isExports) {
					const {parts} = ___R$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$default(
						node.left,
					);

					if (parts.length >= 2) {
						// parts[0] is exports
						const name = parts[1].value;

						context.record(
							new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord({
								type: "local",
								loc: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getDeclarationLoc(
									scope,
									node.right,
								),
								valueType: ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$getAnalyzeExportValueType(
									scope,
									node.right,
								),
								kind: "value",
								name,
							}),
						);
					}
				}
			}

			if (node.type === "ReferenceIdentifier") {
				const binding = path.scope.getBinding(node.name);

				// Detect references to exports and module
				if (binding === undefined) {
					if (
						node.name === "__filename" ||
						node.name === "__dirname" ||
						node.name === "require" ||
						node.name === "module" ||
						node.name === "exports"
					) {
						context.record(
							new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord(
								node,
							),
						);
					}

					if (node.name === "module" || node.name === "exports") {
						const inMemberExpression =
							parent.type === "MemberExpression" && parent.object === node;
						if (!inMemberExpression) {
							context.record(
								new ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord(
									node,
								),
							);
						}
					}
				}
			}

			return node;
		},
	};


  // project-rome/@romejs/js-compiler/api/analyzeDependencies/visitors/index.ts
const ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$index_ts$default = [
		___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$es_ts$default,
		___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$cjs_ts$default,
	];


  // project-rome/@romejs/js-compiler/api/analyzeDependencies/index.ts
const ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache = new ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default();

	async function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$default(
		req,
	) {
		let {ast, project} = req;

		const query = ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default.buildQuery(
			req,
		);
		const cached = ___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache.get(
			query,
		);
		if (cached) {
			return cached;
		}

		const context = new ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default({
			ref: req.ref,
			sourceText: req.sourceText,
			ast,
			project,
			origin: {
				category: "analyzeDependencies",
			},
		});
		({ast} = await ___R$project$rome$$romejs$js$compiler$methods$transform_ts$default(
			Object.assign({}, req, {stage: "pre"}),
		));
		context.reduce(
			ast,
			___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$visitors$index_ts$default,
		);

		//
		const importFirstUsage = [];
		const seenImportFirstUsage = new Set();

		// Extract records
		const exports = [];
		const dependenciesBySource = new Map();

		const esValueExports = [];
		const cjsExports = [];
		let firstTopAwaitLocation;

		// TODO description
		let hasCJSRef = false;

		// Whether we have a default export, used to automatically add one for CJS
		let hasDefaultExport = false;

		// Find the import sources that are only used as a type
		const sourcesUsedAsType = new Set();
		const sourcesUsedAsValue = new Set();
		for (const record of context.records) {
			let data;

			if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord
			) {
				data = record.data;
			}

			// This has to be a separate if or else TS wont refine it...
			if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord &&
				record.data.type !== "local"
			) {
				data = record.data;
			}

			if (data !== undefined) {
				const {kind, source} = data;
				if (kind === "type") {
					sourcesUsedAsType.add(source);
				} else {
					sourcesUsedAsValue.add(source);
				}
			}
		}
		for (const source of sourcesUsedAsValue) {
			sourcesUsedAsType.delete(source);
		}

		// Process rest of the records
		for (const record of context.records) {
			if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$EscapedCJSRefRecord
			) {
				exports.push({
					type: "local",
					loc: record.node.loc,
					kind: "value",
					valueType: "other",
					name: "*",
				});
			}

			if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportRecord
			) {
				let {data} = record;

				// If this source was only ever used as a type then convert us to a value
				if (
					data.type === "es" &&
					data.kind === "value" &&
					sourcesUsedAsType.has(data.source)
				) {
					const names = [];

					for (const name of data.names) {
						names.push(Object.assign({}, name, {kind: "type"}));
					}

					data = Object.assign({}, data, {kind: "type", names});
				}

				// If we have multiple import records for this file, then merge them together
				const existing = dependenciesBySource.get(data.source);
				if (existing === undefined) {
					dependenciesBySource.set(data.source, data);
				} else {
					let kind;
					if (data.kind === existing.kind) {
						kind = data.kind;
					} else {
						kind = "value";
					}

					const combinedRecord = {
						type: data.type === "es" && existing.type === "es" ? "es" : "cjs",
						kind,
						optional: existing.optional && data.optional,
						async: existing.async || data.async,
						source: data.source,
						all: existing.all || data.all,
						names: [...existing.names, ...data.names],
						loc: existing.loc || data.loc,
					};

					// Map ordering is by insertion time, so in the case where the previous import was a type import
					// then we don't want to place our combined record in that position, it should be at the end.
					// Inserting a type import statement at the top of the file shouldn't change the execution order
					// if it was imported later
					if (existing.kind === "type" && data.kind === "value") {
						dependenciesBySource.delete(data.source);
					}

					dependenciesBySource.set(data.source, combinedRecord);
				}
			} else if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ExportRecord
			) {
				exports.push(record.data);
			} else if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord
			) {
				hasCJSRef = true;
			} else if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord
			) {
				cjsExports.push(record.node);
			} else if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ESExportRecord
			) {
				// No point checking for ES imported in CJS because it would have been a syntax error
				if (record.kind === "value") {
					esValueExports.push(record.node);
				}
			} else if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$TopLevelAwaitRecord
			) {
				if (firstTopAwaitLocation === undefined) {
					firstTopAwaitLocation = record.loc;
				}
			} else if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$ImportUsageRecord &&
				record.isTop &&
				record.data.kind === "value"
			) {
				// Track the first reference to a value import that's not in a function
				// This is used to detect module cycles
				const {data} = record;
				const key = data.source + ":" + data.imported;
				if (seenImportFirstUsage.has(key)) {
					continue;
				}

				seenImportFirstUsage.add(key);
				importFirstUsage.push(data);
			}
		}

		// Build dependencies
		const dependencies = Array.from(dependenciesBySource.values());

		// Infer the module type
		let moduleType = ast.sourceType === "script" ? "cjs" : "es";

		// Infer module type in legacy mode
		if (project.config.bundler.mode === "legacy") {
			if (cjsExports.length > 0) {
				moduleType = "cjs";
			} else if (esValueExports.length > 0) {
				moduleType = "es";
			} else if (hasCJSRef) {
				moduleType = "cjs";
			} else {
				moduleType = "unknown";
			}
		}

		//
		for (const record of context.records) {
			if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSVarRefRecord
			) {
				if (project.config.bundler.mode === "modern" && moduleType === "es") {
					/*context.addNodeDiagnostic(record.node, {
          category: 'analyzeDependencies',
          message: `CommonJS variable <emphasis>${
            record.node.name
          }</emphasis> is not available in an ES module`,
        });*/
				}
			} else if (
				record instanceof
				___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$records_ts$CJSExportRecord
			) {
				if (moduleType === "es") {
					context.addNodeDiagnostic(
						record.node,
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.ANALYZE_DEPENDENCIES.CJS_EXPORT_IN_ES,
					);
				}
			}
		}

		// Add an implicit default import for CJS if there is none
		if (moduleType === "cjs" && !hasDefaultExport) {
			exports.push({
				type: "local",
				loc: undefined,
				kind: "value",
				valueType: "other",
				name: "default",
			});
		}

		const topLevelLocalBindings = {};

		// Get all top level bindings
		for (const [name, binding] of context.getRootScope().evaluate(ast).getOwnBindings()) {
			topLevelLocalBindings[name] = binding.node.loc;
		}

		const res = {
			topLevelLocalBindings,
			moduleType,
			firstTopAwaitLocation,
			exports,
			dependencies,
			importFirstUsage,
			syntax: ast.syntax,
			diagnostics: [...ast.diagnostics, ...context.diagnostics.getDiagnostics()],
		};
		___R$$priv$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$analyzeCache.set(
			query,
			res,
		);
		return res;
	}

	function ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$mergeAnalyzeDependencies(
		main,
		second,
	) {
		const exports = [...main.exports];

		// Take only local type exports
		for (const exp of second.exports) {
			if (exp.type === "local" && exp.kind === "type") {
				exports.push(exp);
			}

			// Ensure that all external exports are only reachable with `type`
			if (exp.type === "external" || exp.type === "externalAll") {
				exports.push(Object.assign({}, exp, {kind: "type"}));
			}
		}

		return Object.assign(
			{},
			main,
			{exports, diagnostics: [...main.diagnostics, ...second.diagnostics]},
		);
	}


  // project-rome/@romejs/js-compiler/api/createHook.ts






	function ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default(
		descriptor,
	) {
		return descriptor;
	}


  // project-rome/@romejs/js-compiler/types.ts
const ___R$project$rome$$romejs$js$compiler$types_ts = {};









































  // project-rome/@romejs/js-compiler/index.ts
const ___R$project$rome$$romejs$js$compiler$index_ts = {
		get CompilerContext() {
			return ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default;
		},
		get PathOptions() {
			return ___R$project$rome$$romejs$js$compiler$lib$Path_ts$PathOptions;
		},
		get Path() {
			return ___R$project$rome$$romejs$js$compiler$lib$Path_ts$default;
		},
		get Record() {
			return ___R$project$rome$$romejs$js$compiler$lib$Record_ts$default;
		},
		get Cache() {
			return ___R$project$rome$$romejs$js$compiler$lib$Cache_ts$default;
		},
		get lint() {
			return ___R$project$rome$$romejs$js$compiler$lint$index_ts$default;
		},
		get compile() {
			return ___R$project$rome$$romejs$js$compiler$api$compile_ts$default;
		},
		get analyzeDependencies() {
			return ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$default;
		},
		get mergeAnalyzeDependencies() {
			return ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$index_ts$mergeAnalyzeDependencies;
		},
		get Scope() {
			return ___R$project$rome$$romejs$js$compiler$scope$Scope_ts$default;
		},
		get areAnalyzeDependencyResultsEqual() {
			return ___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$areAnalyzeDependencyResultsEqual;
		},
		get getPrefixedBundleNamespace() {
			return ___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace;
		},
		get createHook() {
			return ___R$project$rome$$romejs$js$compiler$api$createHook_ts$default;
		},
		get extractSuppressionsFromProgram() {
			return ___R$project$rome$$romejs$js$compiler$suppressions_ts$extractSuppressionsFromProgram;
		},
		get matchesSuppression() {
			return ___R$project$rome$$romejs$js$compiler$suppressions_ts$matchesSuppression;
		},
		get LintResult() {
			return ___R$project$rome$$romejs$js$compiler$lint$index_ts$LintResult;
		},
		get CompileResult() {
			return ___R$project$rome$$romejs$js$compiler$api$compile_ts$CompileResult;
		},
		get HookDescriptor() {
			return ___R$project$rome$$romejs$js$compiler$api$createHook_ts$HookDescriptor;
		},
	};
	Object.keys(___R$project$rome$$romejs$js$compiler$lint$decisions_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$compiler$lint$decisions_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$compiler$scope$bindings_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$compiler$scope$bindings_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$compiler$constants_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$compiler$constants_ts[key];
				},
			},
		);
	});
	Object.keys(___R$project$rome$$romejs$js$compiler$types_ts).forEach(function(
		key,
	) {
		if (key === "default") return undefined;
		Object.defineProperty(
			___R$project$rome$$romejs$js$compiler$index_ts,
			key,
			{
				enumerable: true,
				configurable: true,
				get: function get() {
					return ___R$project$rome$$romejs$js$compiler$types_ts[key];
				},
			},
		);
	});


  // project-rome/@romejs/js-ast-utils/removeLoc.ts
function ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeProp(
		obj,
	) {
		const ___R$ = obj;
		const locless = Object.assign({}, ___R$);
		delete locless.loc;
		const {loc} = ___R$;
		loc;
		return locless;
	}

	const ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeLocTransform = [
		{
			name: "removeLocTransform",
			enter(path) {
				const {node} = path;
				if (node.loc === undefined) {
					return node;
				} else {
					const newNode = ___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeProp(
						node,
					);

					// Also remove any `undefined` properties
					// rome-ignore lint/js/noExplicitAny
					const escaped = newNode;
					for (const key in newNode) {
						if (escaped[key] === undefined) {
							// rome-ignore lint/js/noDelete
							delete escaped[key];
						}
					}

					return (newNode);
				}
			},
		},
	];

	function ___R$project$rome$$romejs$js$ast$utils$removeLoc_ts$default(ast) {
		const context = new ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default({
			sourceText: "",
			ast: ___R$project$rome$$romejs$js$ast$core$Program_ts$MOCK_PROGRAM,
			project: {
				folder: undefined,
				config: ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
			},
		});
		return context.reduce(
			ast,
			___R$$priv$project$rome$$romejs$js$ast$utils$removeLoc_ts$removeLocTransform,
		);
	}


  // project-rome/@romejs/js-ast-utils/removeShallowLoc.ts
function ___R$project$rome$$romejs$js$ast$utils$removeShallowLoc_ts$default(
		node,
	) {
		return Object.assign({}, node, {loc: undefined});
	}


  // project-rome/@romejs/js-ast-utils/renameBindings.ts
function ___R$project$rome$$romejs$js$ast$utils$renameBindings_ts$default(
		path,
		oldToNewMapping,
	) {
		if (oldToNewMapping.size === 0) {
			return path.node;
		}

		const oldBindingToNewName = new Map();

		// get a list of the current bindings for this scope
		const oldNameToBinding = new Map();
		for (const [oldName, newName] of oldToNewMapping) {
			if (typeof oldName === "string") {
				const binding = path.scope.getBinding(oldName);
				oldNameToBinding.set(oldName, binding);
			} else {
				oldBindingToNewName.set(oldName, newName);
			}
		}

		// discover nodes to replace first without manipulating the AST as that will change the scope and binding objects
		const replaceNodesWithName = new Map();
		path.traverse(
			"renameBindingsCollector",
			(path) => {
				const {node, scope} = path;
				if (
					!___R$project$rome$$romejs$js$ast$utils$isVariableIdentifier_ts$default(
						node,
					)
				) {
					return;
				}

				const binding = scope.getBinding(node.name);

				// oldName -> newName
				if (
					oldToNewMapping.has(node.name) &&
					binding === oldNameToBinding.get(node.name)
				) {
					const newName = oldToNewMapping.get(node.name);
					if (newName === undefined) {
						throw new Error("Should exist");
					}
					replaceNodesWithName.set(node, newName);
				}

				// Binding -> newName
				if (binding !== undefined && oldBindingToNewName.has(binding)) {
					const newName = oldBindingToNewName.get(binding);
					if (newName === undefined) {
						throw new Error("Should exist");
					}
					replaceNodesWithName.set(node, newName);
				}
			},
		);
		if (replaceNodesWithName.size === 0) {
			return path.node;
		}

		//
		const replaced = new Set();

		// replace the nodes
		const renamedNode = path.reduce(
			{
				name: "renameBindings",
				enter(path) {
					const {node} = path;

					// Retain the correct exported name for `export function` and `export class`
					if (
						node.type === "ExportLocalDeclaration" &&
						node.declaration !== undefined &&
						(node.declaration.type === "FunctionDeclaration" ||
						node.declaration.type === "ClassDeclaration")
					) {
						const newName = replaceNodesWithName.get(node.declaration.id);

						if (newName !== undefined) {
							replaced.add(node.declaration.id);

							const oldName = node.declaration.id.name;

							return ([
								node.declaration,
								___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.create({
									specifiers: [
										___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier.create({
											loc: node.declaration.id.loc,
											local: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
												newName,
											),
											exported: ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
												oldName,
											),
										}),
									],
								}),
							]);
						}
					}

					// Retain the correct exported names for `export const`
					if (
						node.type === "ExportLocalDeclaration" &&
						node.declaration !== undefined
					) {
						const bindings = ___R$project$rome$$romejs$js$ast$utils$getBindingIdentifiers_ts$default(
							node.declaration,
						);
						let includesAny = false;
						for (const node of bindings) {
							if (replaceNodesWithName.has(node)) {
								includesAny = true;
								break;
							}
						}

						if (includesAny) {
							return ([
								node.declaration,
								___R$project$rome$$romejs$js$ast$modules$ExportLocalDeclaration_ts$exportLocalDeclaration.create({
									specifiers: bindings.map((node) => {
										let local = node.name;

										const newName = replaceNodesWithName.get(node);
										if (newName !== undefined) {
											local = newName;
											replaced.add(node);
										}

										return ___R$project$rome$$romejs$js$ast$modules$ExportLocalSpecifier_ts$exportLocalSpecifier.create({
											loc: node.loc,
											local: ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
												local,
											),
											exported: ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
												node.name,
											),
										});
									}),
								}),
							]);
						}
					}

					if (
						___R$project$rome$$romejs$js$ast$utils$isVariableIdentifier_ts$default(
							node,
						)
					) {
						const newName = replaceNodesWithName.get(node);
						if (newName !== undefined) {
							replaced.add(node);
							return Object.assign(
								{},
								node,
								{
									name: newName,
									loc: ___R$project$rome$$romejs$js$ast$utils$inheritLoc_ts$default(
										node,
										node.name,
									),
								},
							);
						}
					}

					return node;
				},
			},
			{
				noScopeCreation: true,
			},
		);

		//
		if (replaced.size !== replaceNodesWithName.size) {
			console.log({replaced, replaceNodesWithName});
			throw new Error("Missed some bindings");
		}

		return ___R$project$rome$$romejs$js$ast$utils$assertSingleOrMultipleNodes_ts$default(
			renamedNode,
		);
	}


  // project-rome/@romejs/js-ast-utils/template.ts






	const ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$templateCache = new Map();

	function ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$getTemplate(
		strs,
	) {
		const cached = ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$templateCache.get(
			strs,
		);
		if (cached) {
			return cached;
		}

		// calculate amount of placeholders to insert
		const pathCount = strs.length - 1;

		// create path ids
		let placeholders = {};
		const placeholderIds = [];
		for (let i = 0; i < pathCount; i++) {
			const id = "__" + String(i) + "__";
			placeholderIds.push(id);
			placeholders[id] = undefined;
		}

		// interpolate placeholders and original code
		let code = "";
		for (let i = 0; i < strs.length; i++) {
			// add original part of code
			code += strs[i];

			// add in placeholder
			const placeholder = placeholderIds[i];
			if (placeholder) {
				code += placeholder;
			}
		}

		// parse the interpolated code
		let ast = ___R$project$rome$$romejs$js$parser$index_ts$parseJS({
			input: code,
			sourceType: "template",
			path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
				"template",
			),
		});

		// remove `loc` properties
		ast = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(
			___R$project$rome$$romejs$js$ast$utils$removeLoc_ts$default(ast),
		);

		// traverse and find placeholders paths
		function collectPlaceholderPaths(path) {
			const {node} = path;
			if (
				___R$project$rome$$romejs$js$ast$utils$isIdentifierish_ts$default(node) &&
				node.name in placeholders
			) {
				placeholders[node.name] = {
					type: node.type,
					path: path.getPathKeys(),
				};
			}
			return node;
		}

		const context = new ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default({
			ast,
		});
		context.reduce(
			ast,
			[{name: "collectPlaceholderPaths", enter: collectPlaceholderPaths}],
		);

		const placeholderPaths = [];
		for (const id in placeholders) {
			const path = placeholders[id];
			if (path === undefined) {
				throw new Error("Failed to find placeholder path for " + id);
			} else {
				placeholderPaths.push(path);
			}
		}

		return {ast, placeholderPaths};
	}



	function ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$createIdentifier(
		substitute,
		expectedIdType,
	) {
		if (typeof substitute === "string") {
			// @ts-ignore: No idea why this error exists
			return {
				type: expectedIdType,
				name: substitute,
			};
		} else {
			return substitute;
		}
	}

	function ___R$project$rome$$romejs$js$ast$utils$template_ts$default(
		strs,
		...substitutions
	) {
		const {ast, placeholderPaths} = ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$getTemplate(
			strs,
		);

		// no substitutions so we can just return the ast!
		if (!substitutions.length) {
			return ast;
		}

		// this case should never be hit
		if (placeholderPaths.length !== substitutions.length) {
			throw new Error("Expected subtituions to be the same length as paths");
		}

		const newAst = Object.assign({}, ast);

		for (let i = 0; i < placeholderPaths.length; i++) {
			const {type, path} = placeholderPaths[i];

			const substitute = ___R$$priv$project$rome$$romejs$js$ast$utils$template_ts$createIdentifier(
				substitutions[i],
				type,
			);
			// rome-ignore lint/js/noExplicitAny
			let target = newAst;

			for (let i = 0; i < path.length; i++) {
				const key = path[i];
				const isLast = i === path.length - 1;

				if (isLast) {
					target[key] = substitute;
				} else {
					let currTarget = target[key];
					if (Array.isArray(currTarget)) {
						currTarget = currTarget.slice();
					} else {
						currTarget = Object.assign({}, currTarget);
					}
					target[key] = currTarget;
					target = currTarget;
				}
			}
		}

		return newAst;
	}

	___R$project$rome$$romejs$js$ast$utils$template_ts$default.expression = (
		strs,
		...substitutions
	) => {
		var ___R$;
		const first =
			(___R$ = ___R$project$rome$$romejs$js$ast$utils$template_ts$default,
			___R$.statement.apply(___R$, [strs, ...substitutions]));

		// Ensure that the single statement is an ExpressionStatement
		if (first.type !== "ExpressionStatement") {
			throw new Error("Single statement should be an ExpressionStatement");
		}

		return first.expression;
	};

	___R$project$rome$$romejs$js$ast$utils$template_ts$default.statement = (
		strs,
		...substitutions
	) => {
		// Parse the template, with caching
		const ast = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(
			___R$project$rome$$romejs$js$ast$utils$template_ts$default.apply(
				null,
				[strs, ...substitutions],
			),
		);

		// Ensure that there's only a single statement in the Program body
		const body = ast.body;
		if (body.length !== 1) {
			throw new Error("More than one statement isn't allowed for a template.");
		}
		return body[0];
	};


  // project-rome/@romejs/js-ast-utils/createPropertyKey.ts
function ___R$project$rome$$romejs$js$ast$utils$createPropertyKey_ts$default(
		name,
	) {
		if (
			___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(
				name,
			)
		) {
			return ___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
				name,
			);
		} else {
			return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(
				name,
			);
		}
	}


  // project-rome/@romejs/js-ast-utils/valueToNode.ts
function ___R$project$rome$$romejs$js$ast$utils$valueToNode_ts$default(
		value,
		ancestry = [],
	) {
		if (ancestry.includes(value)) {
			throw new Error("Recursion detected");
		}

		switch (typeof value) {
			case "string":
				return ___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(
					value,
				);

			case "boolean":
				return ___R$project$rome$$romejs$js$ast$literals$BooleanLiteral_ts$booleanLiteral.quick(
					value,
				);

			case "number":
				return ___R$project$rome$$romejs$js$ast$literals$NumericLiteral_ts$numericLiteral.quick(
					value,
				);

			case "undefined":
				return ___R$project$rome$$romejs$js$ast$expressions$ReferenceIdentifier_ts$referenceIdentifier.quick(
					"undefined",
				);

			case "object": {
				if (value === null) {
					return ___R$project$rome$$romejs$js$ast$literals$NullLiteral_ts$nullLiteral.create({

					});
				}

				const subAncestry = [...ancestry, value];

				if (Array.isArray(value)) {
					return ___R$project$rome$$romejs$js$ast$expressions$ArrayExpression_ts$arrayExpression.quick(
						value.map((elem) =>
							___R$project$rome$$romejs$js$ast$utils$valueToNode_ts$default(
								elem,
								subAncestry,
							)
						),
					);
				}

				const obj = (value);
				const props = [];

				for (let key in obj) {
					props.push(
						___R$project$rome$$romejs$js$ast$objects$ObjectProperty_ts$objectProperty.create({
							key: ___R$project$rome$$romejs$js$ast$objects$StaticPropertyKey_ts$staticPropertyKey.create({
								value: ___R$project$rome$$romejs$js$ast$utils$createPropertyKey_ts$default(
									key,
								),
							}),
							value: ___R$project$rome$$romejs$js$ast$utils$valueToNode_ts$default(
								obj[key],
								subAncestry,
							),
						}),
					);
				}

				return ___R$project$rome$$romejs$js$ast$objects$ObjectExpression_ts$objectExpression.quick(
					props,
				);
			}

			default:
				throw new Error("Do not know how to turn this value into a literal");
		}
	}


  // project-rome/@romejs/js-ast-utils/createMemberProperty.ts
function ___R$project$rome$$romejs$js$ast$utils$createMemberProperty_ts$default(
		name,
	) {
		if (
			___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(
				name,
			)
		) {
			return ___R$project$rome$$romejs$js$ast$auxiliary$StaticMemberProperty_ts$staticMemberProperty.quick(
				___R$project$rome$$romejs$js$ast$auxiliary$Identifier_ts$identifier.quick(
					name,
				),
			);
		} else {
			return ___R$project$rome$$romejs$js$ast$auxiliary$ComputedMemberProperty_ts$computedMemberProperty.quick(
				___R$project$rome$$romejs$js$ast$literals$StringLiteral_ts$stringLiteral.quick(
					name,
				),
			);
		}
	}


  // project-rome/@romejs/js-ast-utils/getJSXAttribute.ts
function ___R$$priv$project$rome$$romejs$js$ast$utils$getJSXAttribute_ts$isEmptyAttributeValue(
		node,
	) {
		switch (node.type) {
			case "StringLiteral":
				return node.value === "";

			case "JSXExpressionContainer":
				return ___R$$priv$project$rome$$romejs$js$ast$utils$getJSXAttribute_ts$isEmptyAttributeValue(
					node.expression,
				);

			case "ReferenceIdentifier":
				return node.name === "undefined";

			case "JSXEmptyExpression":
				return true;

			default:
				return false;
		}
	}

	function ___R$project$rome$$romejs$js$ast$utils$getJSXAttribute_ts$default(
		tag,
		name,
		allowEmpty = false,
	) {
		for (const attr of tag.attributes) {
			if (attr.type === "JSXAttribute" && attr.name.name === name) {
				const {value} = attr;

				if (
					value !== undefined &&
					!allowEmpty &&
					___R$$priv$project$rome$$romejs$js$ast$utils$getJSXAttribute_ts$isEmptyAttributeValue(
						value,
					)
				) {
					return undefined;
				}

				return attr;
			}
		}
		return undefined;
	}


  // project-rome/@romejs/js-ast-utils/hasJSXAttribute.ts
function ___R$project$rome$$romejs$js$ast$utils$hasJSXAttribute_ts$default(
		tag,
		name,
		allowEmpty = false,
	) {
		return (
			___R$project$rome$$romejs$js$ast$utils$getJSXAttribute_ts$default(
				tag,
				name,
				allowEmpty,
			) !== undefined
		);
	}


  // project-rome/@romejs/js-ast-utils/isJSXElement.ts
function ___R$project$rome$$romejs$js$ast$utils$isJSXElement_ts$default(
		node,
		name,
	) {
		return (
			node.type === "JSXElement" &&
			(name
				? ___R$project$rome$$romejs$js$ast$utils$doesNodeMatchPattern_ts$default(
						node.name,
						name,
					)
				: true)
		);
	}


  // project-rome/@romejs/js-ast-utils/index.ts



  // project-rome/@romejs/consume/Consumer.ts


	function ___R$$priv$project$rome$$romejs$consume$Consumer_ts$isComputedPart(
		part,
	) {
		return (
			typeof part === "number" ||
			!___R$project$rome$$romejs$js$ast$utils$isValidIdentifierName_ts$default(
				part,
			)
		);
	}

	class ___R$project$rome$$romejs$consume$Consumer_ts$default {
		constructor(opts) {
			this.path = opts.filePath;
			this.filename = this.path === undefined ? undefined : this.path.join();

			this.value = opts.value;
			this.parent = opts.parent;
			this.keyPath = opts.objectPath;
			this.context = opts.context;
			this.onDefinition = opts.onDefinition;
			this.propertyMetadata = opts.propertyMetadata;
			this.usedNames = new Set(opts.usedNames);
			this.forkCache = new Map();
			this.forceDiagnosticTarget = opts.forceDiagnosticTarget;
			this.declared = false;

			// See shouldDispatchUnexpected for explanation
			this.hasHandledUnexpected = false;
			this.handleUnexpected = opts.handleUnexpectedDiagnostic;
		}

		capture() {
			let diagnostics = [];
			const definitions = [];

			const consumer = this.clone({
				onDefinition: (def, consumer) => {
					if (this.onDefinition !== undefined) {
						this.onDefinition(def, consumer);
					}

					definitions.push(def);
				},
				handleUnexpectedDiagnostic(diag) {
					diagnostics.push(diag);
				},
			});
			return {consumer, definitions, diagnostics};
		}

		async bufferDiagnostics(callback) {
			const {diagnostics, consumer} = await this.capture();
			const result = await callback(consumer);
			if (result === undefined || diagnostics.length > 0) {
				throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
					"Captured diagnostics",
					diagnostics,
				);
			}
			return result;
		}

		handleThrownDiagnostics(callback) {
			if (this.handleUnexpected === undefined) {
				callback();
			} else {
				const {diagnostics} = ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnosticsSync(
					callback,
				);

				if (diagnostics !== undefined) {
					for (const diag of diagnostics) {
						this.handleUnexpected(diag);
					}
				}
			}
		}

		declareDefinition(partialDef, inputName) {
			if (this.declared) {
				return;
			}

			if (this.onDefinition === undefined) {
				return;
			}

			const metadata = Object.assign({inputName}, this.propertyMetadata);

			const def = Object.assign(
				{},
				partialDef,
				{objectPath: this.keyPath, metadata},
			);

			this.declared = true;

			this.onDefinition(def, this);
		}

		getDiagnosticLocation(target = "all") {
			const {getDiagnosticPointer} = this.context;
			if (getDiagnosticPointer === undefined) {
				return {};
			}

			const {forceDiagnosticTarget} = this;
			if (forceDiagnosticTarget !== undefined) {
				target = forceDiagnosticTarget;
			}
			return getDiagnosticPointer(this.keyPath, target);
		}

		getLocation(target) {
			const location = this.getDiagnosticLocation(target);
			if (
				location === undefined ||
				location.start === undefined ||
				location.end === undefined
			) {
				return {
					filename: this.filename,
					start: ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION,
					end: ___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION,
				};
			} else {
				return {
					filename: location.filename,
					start: location.start,
					end: location.end,
				};
			}
		}

		getLocationRange(startIndex, endIndex = startIndex, target) {
			const loc = this.getLocation(target);
			if (
				loc.start ===
				___R$project$rome$$romejs$parser$core$types_ts$UNKNOWN_POSITION
			) {
				return loc;
			}

			const {start, end} = loc;

			// We don't support handling line differences here... yet?
			if (start.line !== end.line) {
				return loc;
			}

			return Object.assign(
				{},
				loc,
				{
					start: Object.assign(
						{},
						start,
						{
							column: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								start.column,
								startIndex,
							),
							index: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								start.index,
								startIndex,
							),
						},
					),
					end: Object.assign(
						{},
						start,
						{
							column: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								start.column,
								endIndex,
							),
							index: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								start.index,
								endIndex,
							),
						},
					),
				},
			);
		}

		getKey() {
			return this.clone({
				forceDiagnosticTarget: "key",
				value: this.getParentKey(),
			});
		}

		getParentKey() {
			return this.keyPath[this.keyPath.length - 1];
		}

		hasChangedFromSource() {
			const {getOriginalValue} = this.context;
			if (getOriginalValue === undefined) {
				return false;
			}

			const originalValue = getOriginalValue(this.keyPath);
			return !this.wasInSource() || this.value !== originalValue;
		}

		wasInSource() {
			return this.getDiagnosticLocation() !== undefined;
		}

		getKeyPathString(path = this.keyPath) {
			const {normalizeKey} = this.context;
			let str = "";

			for (let i = 0; i < path.length; i++) {
				let part = path[i];
				const nextPart = path[i + 1];

				if (typeof part === "string" && normalizeKey !== undefined) {
					part = normalizeKey(part);
				}

				// If we are a computed property then wrap in brackets, the previous part would not have inserted a dot
				// We allow a computed part at the beginning of a path
				if (
					___R$$priv$project$rome$$romejs$consume$Consumer_ts$isComputedPart(
						part,
					) &&
					i > 0
				) {
					const inner =
						typeof part === "number"
							? String(part)
							: ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
									part,
									{
										quote: "'",
									},
								);

					str += "[" + inner + "]";
				} else {
					if (
						nextPart === undefined ||
						___R$$priv$project$rome$$romejs$consume$Consumer_ts$isComputedPart(
							nextPart,
						)
					) {
						// Don't append a dot if there are no parts or the next is computed
						str += part;
					} else {
						str += part + ".";
					}
				}
			}

			return str;
		}

		generateUnexpectedMessage(msg, opts) {
			const {at = "suffix", atParent = false} = opts;
			const {parent} = this;

			let target = this;

			if (atParent) {
				if (parent === undefined) {
					// Cannot target the parent if it does not exist
					return msg;
				} else {
					target = parent;
				}
			}

			if (at === "suffix") {
				msg += " at <emphasis>" + target.getKeyPathString() + "</emphasis>";
			} else {
				msg = "<emphasis>" + target.getKeyPathString() + "</emphasis> " + msg;
			}

			return msg;
		}

		unexpected(
			description = ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.INVALID,
			opts = {},
		) {
			const {target = "value"} = opts;

			const {filename} = this;
			let location = this.getDiagnosticLocation(target);
			const fromSource = location !== undefined;

			const message = this.generateUnexpectedMessage(
				description.message.value,
				opts,
			);
			description = Object.assign(
				{},
				description,
				{
					message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
						message,
					),
				},
			);

			const advice = [...(description.advice || [])];

			// Make the errors more descriptive
			if (fromSource) {
				if (this.hasChangedFromSource()) {
					advice.push({
						type: "log",
						category: "warn",
						text: "Our internal value has been modified since we read the original source",
					});
				}
			} else {
				// Go up the consumer tree and take the position from the first consumer found in the source
				let consumer = this;
				do {
					const possibleLocation = consumer.getDiagnosticLocation(target);
					if (possibleLocation !== undefined) {
						location = possibleLocation;
						break;
					}
					consumer = consumer.parent;
				} while (consumer !== undefined);

				// If consumer is undefined and we have no filename then we were not able to find a location,
				// in this case, just throw a normal error
				if (consumer === undefined && filename === undefined) {
					throw new Error(message);
				}

				// Warn that we didn't find this value in the source if it's parent wasn't either
				if (this.parent === undefined || !this.parent.wasInSource()) {
					advice.push({
						type: "log",
						category: "warn",
						text: "This value was expected to be found at <emphasis>" +
						this.getKeyPathString() +
						"</emphasis> but was not in the original source",
					});
				}
			}

			if (opts.loc !== undefined) {
				location = opts.loc;
			}

			if (location === undefined) {
				throw new Error(message);
			}

			const diagnostic = {
				description: Object.assign(
					{category: this.context.category},
					description,
					{advice},
				),
				location: Object.assign({}, location, {filename: this.filename}),
			};

			const err = ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
				diagnostic,
			);

			if (this.handleUnexpected === undefined) {
				throw err;
			} else {
				if (this.shouldDispatchUnexpected()) {
					this.handleUnexpected(diagnostic);
					this.hasHandledUnexpected = true;
				}

				// Still allow throwing the diagnostic
				return err;
			}
		}

		// Only dispatch a single error for the current consumer, and suppress any if we have a parent consumer with errors
		// We do this since we could be producing redundant stale errors based on
		// results we've normalized to allow us to continue
		shouldDispatchUnexpected() {
			if (this.hasHandledUnexpected) {
				return false;
			}

			const {parent} = this;
			if (parent !== undefined) {
				return parent.shouldDispatchUnexpected();
			}

			return true;
		}

		clone(opts) {
			return new ___R$project$rome$$romejs$consume$Consumer_ts$default(
				Object.assign(
					{
						usedNames: this.usedNames,
						onDefinition: this.onDefinition,
						handleUnexpectedDiagnostic: this.handleUnexpected,
						filePath: this.path,
						context: this.context,
						value: this.value,
						parent: this.parent,
						objectPath: this.keyPath,
						propertyMetadata: this.propertyMetadata,
					},
					opts,
				),
			);
		}

		fork(key, value, propertyMetadata) {
			// We require this cache as we sometimes want to store state about a forked property such as used items
			const cached = this.forkCache.get(String(key));
			if (
				cached !== undefined &&
				cached.value === value &&
				(cached.propertyMetadata === undefined ||
				cached.propertyMetadata === propertyMetadata)
			) {
				return cached;
			}

			const forked = this.clone({
				propertyMetadata,
				value,
				parent: this,
				objectPath: [...this.keyPath, key],
			});
			this.forkCache.set(String(key), forked);
			return forked;
		}

		_normalizeValueForSet(value) {
			if (value instanceof Set) {
				return Array.from(value);
			}

			if (value instanceof Map) {
				const obj = {};
				for (const [key, val] of value) {
					obj[key] = val;
				}
				return obj;
			}

			return value;
		}

		getValue(def) {
			if (this.exists()) {
				return this.value;
			} else {
				return def;
			}
		}

		setValue(rawValue) {
			const value = this._normalizeValueForSet(rawValue);
			this.value = value;

			// If we're at the root (as indicated by the lack of these properties) then go no where else
			const {parent, keyPath} = this;
			if (parent === undefined || keyPath.length === 0) {
				return this;
			}

			// Validate the parent is an object
			const parentValue = parent.asUnknown();
			if (
				parentValue === undefined ||
				parentValue === null ||
				typeof parentValue !== "object"
			) {
				throw parent.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.SET_PROPERTY_NON_OBJECT,
				);
			}

			// Mutate the parent
			const parentObj = parent.asOriginalUnknownObject();
			const key = this.getParentKey();
			parentObj[String(key)] = value;
			parent.setValue(parentObj);

			return this;
		}

		has(key) {
			return this.get(key).asUnknown() != null;
		}

		setProperty(key, value) {
			return this.get(key).setValue(value);
		}

		get(key, metadata) {
			const value = this.asOriginalUnknownObject();
			this.markUsedProperty(key);
			return this.fork(key, value[key], metadata);
		}

		markUsedProperty(name) {
			this.usedNames.add(name);
		}

		enforceUsedProperties(type = "property", recursive = true) {
			if (!this.isObject()) {
				return;
			}

			let knownProperties = Array.from(this.usedNames.keys());

			const {normalizeKey} = this.context;
			if (normalizeKey !== undefined) {
				knownProperties = knownProperties.map((key) => normalizeKey(key));
			}

			for (const [key, value] of this.asMap(false, false)) {
				if (!this.usedNames.has(key)) {
					value.unexpected(
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.UNUSED_PROPERTY(
							this.getKeyPathString([key]),
							type,
							knownProperties,
						),
						{
							target: "key",
							at: "suffix",
							atParent: true,
						},
					);
				}

				if (recursive) {
					value.enforceUsedProperties(type, true);
				}
			}
		}

		asPossibleParsedJSON() {
			if (typeof this.asUnknown() === "string") {
				return this.clone({
					value: JSON.parse(this.asString()),
				});
			} else {
				return this;
			}
		}

		// JSON
		asJSONValue() {
			const {value} = this;

			switch (typeof value) {
				case "number":
				case "string":
				case "boolean":
					return value;
			}

			if (value === null) {
				return null;
			}

			if (Array.isArray(value)) {
				return this.asJSONArray();
			}

			if (this.isObject()) {
				return this.asJSONObject();
			}

			this.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_JSON_VALUE,
			);
			return "";
		}

		asJSONArray() {
			const arr = [];
			for (const value of this.asArray()) {
				arr.push(value.asJSONValue());
			}
			return arr;
		}

		asJSONObject() {
			const obj = {};
			for (const [key, value] of this.asMap()) {
				obj[key] = value.asJSONPropertyValue();
			}
			return obj;
		}

		asJSONPropertyValue() {
			if (this.exists()) {
				return this.asJSONValue();
			} else {
				return undefined;
			}
		}

		exists() {
			return this.value != null;
		}

		isObject() {
			const {value} = this;
			return (
				typeof value === "object" &&
				value !== null &&
				value.constructor === Object
			);
		}

		asUnknownObject(optional = false) {
			this.declareDefinition({
				type: "object",
				default: undefined,
				required: !optional,
			});

			return Object.assign({}, this.asOriginalUnknownObject(optional));
		}

		asOriginalUnknownObject(optional = false) {
			if (optional === true && !this.exists()) {
				return {};
			}

			const {value} = this;
			if (
				!___R$project$rome$$romejs$typescript$helpers$index_ts$isPlainObject(
					value,
				)
			) {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_OBJECT,
				);
				return {};
			}

			return value;
		}

		asMap(optional, markUsed = true) {
			this.declareDefinition({
				type: "object",
				default: undefined,
				required: !optional,
			});

			const value = this.asOriginalUnknownObject(optional);
			const map = new Map();
			for (const key in value) {
				if (markUsed) {
					this.markUsedProperty(key);
				}
				map.set(key, this.fork(key, value[key]));
			}
			return map;
		}

		asPlainArray(optional = false) {
			this.declareDefinition({
				type: "array",
				default: undefined,
				required: !optional,
			});

			if (optional === true && !this.exists()) {
				return [];
			}

			const {value} = this;

			if (!Array.isArray(value)) {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_ARRAY,
				);
				return [];
			}

			return [...value];
		}

		asArray(optional) {
			const arr = this.asPlainArray(optional);

			return arr.map((val, index) => {
				return this.fork(index, val);
			});
		}

		asImplicitArray() {
			if (Array.isArray(this.asUnknown())) {
				return this.asArray();
			} else if (this.exists()) {
				return [this];
			} else {
				return [];
			}
		}

		asDateOrVoid(def) {
			this.declareDefinition({
				type: "date",
				default: def,
				required: false,
			});
			if (this.exists()) {
				return this.asUndeclaredDate(def);
			} else {
				return undefined;
			}
		}

		asDate(def) {
			this.declareDefinition({
				type: "date",
				default: def,
				required: def === undefined,
			});
			return this.asUndeclaredDate(def);
		}

		asUndeclaredDate(def) {
			const value = this.getValue(def);
			if (!(value instanceof Date)) {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_DATE,
				);
				return new Date();
			}
			return value;
		}

		asBooleanOrVoid(def) {
			this.declareDefinition({
				type: "boolean",
				default: def,
				required: false,
			});
			if (this.exists()) {
				return this.asUndeclaredBoolean(def);
			} else {
				return undefined;
			}
		}

		asBoolean(def) {
			this.declareDefinition({
				type: "boolean",
				default: def,
				required: def === undefined,
			});
			return this.asUndeclaredBoolean(def);
		}

		asUndeclaredBoolean(def) {
			const value = this.getValue(def);
			if (typeof value !== "boolean") {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_BOOLEAN,
				);
				return false;
			}
			return value;
		}

		asStringOrVoid(def) {
			this.declareDefinition({
				type: "string",
				default: def,
				required: false,
			});

			if (this.exists()) {
				return this.asUndeclaredString(def);
			} else {
				return undefined;
			}
		}

		asString(def) {
			this.declareDefinition({
				type: "string",
				default: def,
				required: def === undefined,
			});
			return this.asUndeclaredString(def);
		}

		asUndeclaredString(def) {
			const value = this.getValue(def);
			if (typeof value !== "string") {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_STRING,
				);
				return "";
			}
			return value;
		}

		asStringSet(validValues, def) {
			this.declareDefinition({
				type: "string",
				default: def,
				required: def === undefined,
				allowedValues: validValues,
			});
			return this.asUndeclaredStringSet(validValues, def);
		}

		asUndeclaredStringSet(validValues, def) {
			const value = this.asUndeclaredString(String(def));

			// @ts-ignore
			if (validValues.includes(value)) {
				// @ts-ignore
				return value;
			} else {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.INVALID_STRING_SET_VALUE(
						value,
						// rome-ignore lint/js/noExplicitAny
						((validValues)),
					),
					{
						target: "value",
					},
				);
				return validValues[0];
			}
		}

		asStringSetOrVoid(validValues, def) {
			this.declareDefinition({
				type: "string",
				default: def,
				required: false,
				allowedValues: validValues,
			});

			if (this.exists()) {
				return this.asUndeclaredStringSet(validValues, def);
			} else {
				return undefined;
			}
		}

		asBigIntOrVoid(def) {
			this.declareDefinition({
				type: "bigint",
				default: def,
				required: false,
			});
			if (this.exists()) {
				return this.asUndeclaredBigInt(def);
			} else {
				return undefined;
			}
		}

		asBigInt(def) {
			this.declareDefinition({
				type: "bigint",
				default: def,
				required: def === undefined,
			});
			return this.asUndeclaredBigInt(def);
		}

		asUndeclaredBigInt(def) {
			const value = this.getValue(def);

			if (typeof value === "number") {
				return BigInt(value);
			}

			if (typeof value === "bigint") {
				return value;
			}

			this.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_BIGINT,
			);
			return BigInt("0");
		}

		_declareOptionalFilePath(def) {
			this.declareDefinition(
				{
					type: "string",
					default: def,
					required: false,
				},
				"path",
			);
		}

		asURLFilePath(def) {
			const path = this.asUnknownFilePath(def);
			if (path.isURL()) {
				return path.assertURL();
			} else {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_URL,
				);
				return ___R$project$rome$$romejs$path$index_ts$createURLFilePath(
					"unknown://",
				).append(path);
			}
		}

		asURLFilePathOrVoid(def) {
			if (this.exists()) {
				return this.asURLFilePath(def);
			} else {
				this._declareOptionalFilePath(def);
				return undefined;
			}
		}

		asUnknownFilePath(def) {
			this.declareDefinition(
				{
					type: "string",
					default: def,
					required: def === undefined,
				},
				"path",
			);

			return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
				this.asUndeclaredString(def),
			);
		}

		asUnknownFilePathOrVoid(def) {
			if (this.exists()) {
				return this.asUnknownFilePath(def);
			} else {
				this._declareOptionalFilePath(def);
				return undefined;
			}
		}

		asAbsoluteFilePath(def, cwd) {
			const path = this.asUnknownFilePath(def);
			if (path.isAbsolute()) {
				return path.assertAbsolute();
			} else if (cwd !== undefined && path.isRelative()) {
				return cwd.resolve(path);
			} else {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_ABSOLUTE_PATH,
				);
				return ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
					"/",
				).append(path);
			}
		}

		asAbsoluteFilePathOrVoid(def, cwd) {
			if (this.exists()) {
				return this.asAbsoluteFilePath(def, cwd);
			} else {
				this._declareOptionalFilePath(def);
				return undefined;
			}
		}

		asRelativeFilePath(def) {
			const path = this.asUnknownFilePath(def);
			if (path.isRelative()) {
				return path.assertRelative();
			} else {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_RELATIVE_PATH,
				);
				return path.toExplicitRelative();
			}
		}

		asRelativeFilePathOrVoid(def) {
			if (this.exists()) {
				return this.asRelativeFilePath(def);
			} else {
				this._declareOptionalFilePath(def);
				return undefined;
			}
		}

		asExplicitRelativeFilePath(def) {
			const path = this.asRelativeFilePath(def);

			if (path.isExplicitRelative()) {
				return path;
			} else {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_EXPLICIT_RELATIVE_PATH,
				);
				return path.toExplicitRelative();
			}
		}

		asExplicitRelativeFilePathOrVoid(def) {
			if (this.exists()) {
				return this.asExplicitRelativeFilePath(def);
			} else {
				this._declareOptionalFilePath(def);
				return undefined;
			}
		}

		asNumberOrVoid(def) {
			this.declareDefinition({
				type: "number",
				default: def,
				required: false,
			});

			if (this.exists()) {
				return this.asUndeclaredNumber(def);
			} else {
				return undefined;
			}
		}

		asZeroIndexedNumber() {
			return ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(this.asNumber());
		}

		asOneIndexedNumber() {
			return ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(this.asNumber());
		}

		asNumberFromString(def) {
			this.declareDefinition({
				type: "number",
				default: def,
				required: def === undefined,
			});
			return this.asUndeclaredNumberFromString(def);
		}

		asNumberFromStringOrVoid(def) {
			this.declareDefinition({
				type: "number",
				default: def,
				required: false,
			});

			if (this.exists()) {
				return this.asUndeclaredNumberFromString(def);
			} else {
				return undefined;
			}
		}

		asUndeclaredNumberFromString(def) {
			if (def !== undefined && !this.exists()) {
				return def;
			}

			const str = this.asUndeclaredString();
			const num = Number(str);
			if (isNaN(num)) {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_VALID_NUMBER,
				);
				return NaN;
			} else {
				return num;
			}
		}

		asNumber(def) {
			this.declareDefinition({
				type: "number",
				default: def,
				required: def === undefined,
			});
			return this.asUndeclaredNumber(def);
		}







		asNumberInRange(opts) {
			const num = this.asUndeclaredNumber(opts.default);
			const min = ___R$project$rome$$romejs$ob1$index_ts$ob1Get(opts.min);
			const max = ___R$project$rome$$romejs$ob1$index_ts$ob1Get(opts.max);

			this.declareDefinition({
				type: "number",
				default: opts.default,
				required: opts.default !== undefined,
				min,
				max,
			});

			// Nice error message when both min and max are specified
			if (min !== undefined && max !== undefined && (num < min || num > max)) {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_NUMBER_BETWEEN(
						min,
						max,
					),
				);
				return num;
			}

			if (min !== undefined && num < min) {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_NUMBER_HIGHER(
						min,
					),
				);
			}

			if (max !== undefined && num > max) {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_NUMBER_LOWER(
						max,
					),
				);
			}

			return num;
		}

		asUndeclaredNumber(def) {
			const value = this.getValue(def);
			if (typeof value !== "number") {
				this.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.CONSUME.EXPECTED_NUMBER,
				);
				return 0;
			}
			return value;
		}

		asUnknown() {
			return this.value;
		}

		// rome-ignore lint/js/noExplicitAny
		asAny() {
			return this.value;
		}
	}


  // project-rome/@romejs/consume/index.ts
const ___R$$priv$project$rome$$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS = {
		propertyMetadata: undefined,
		value: undefined,
		handleUnexpectedDiagnostic: undefined,
		onDefinition: undefined,
		filePath: undefined,
		objectPath: [],
		parent: undefined,
	};

	function ___R$project$rome$$romejs$consume$index_ts$consume(opts) {
		return new ___R$project$rome$$romejs$consume$Consumer_ts$default(
			Object.assign(
				{},
				___R$$priv$project$rome$$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS,
				opts,
			),
		);
	}

	function ___R$project$rome$$romejs$consume$index_ts$consumeUnknown(
		value,
		category,
	) {
		return new ___R$project$rome$$romejs$consume$Consumer_ts$default(
			Object.assign(
				{},
				___R$$priv$project$rome$$romejs$consume$index_ts$EMPTY_CONSUME_OPTIONS,
				{
					context: {
						category,
					},
					value,
				},
			),
		);
	}


  // project-rome/@romejs/codec-json/stringify.ts
function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$joinList(
		open,
		close,
		indent,
		items,
	) {
		if (items.length === 0) {
			return open + close;
		}

		if (items.length === 1) {
			// Trim to remove indentation
			const first = items[0].trim();

			// We never want to place a comment in between braces because it will break for line comments

			// and look weird for blocks
			if (first[0] !== "/") {
				return open + first + close;
			}
		}

		return [open, ...items, indent + close].join("\n");
	}

	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyKey(
		key,
	) {
		if (___R$project$rome$$romejs$codec$json$parse_ts$isValidWord(key)) {
			// A property key doesn't need quotes if it's a valid word
			return key;
		} else {
			return ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
				key,
				{
					quote: '"',
					ignoreWhitespaceEscapes: true,
					json: true,
				},
			);
		}
	}

	function ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(
		indent,
		comments,
	) {
		return comments.map((node) => {
			if (node.type === "BlockComment") {
				return indent + "/*" + node.value + "*/";
			} else {
				// node.type === 'LineComment'
				return indent + "//" + node.value;
			}
		});
	}

	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyPrimitives(
		value,
	) {
		if (value === null) {
			return "null";
		}

		// Coerce primitive objects to their primitive form, as specified in ECMA262 24.5.2.1
		if (
			value instanceof Number ||
			value instanceof String ||
			value instanceof Boolean
		) {
			value = value.valueOf();
		}

		// Basic primitive types
		switch (typeof value) {
			case "symbol":
			case "function":
			case "undefined":
				return "null";

			case "boolean":
				return value ? "true" : "false";

			case "string":
				return ___R$project$rome$$romejs$string$escape$escapeString_ts$default(
					value,
					{
						quote: '"',
						json: true,
						ignoreWhitespaceEscapes: true,
					},
				);

			case "bigint":
				// This is the actual V8 message lol
				throw new Error("Do not know how to serialize a BigInt");

			case "number":
				return ___R$project$rome$$romejs$pretty$format$index_ts$formatNumber(
					value,
				);
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$sortMapKeys(
		map,
	) {
		return new Set(
			Array.from(map.keys()).sort(
				___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare,
			),
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$sortMap(map) {
		const sortedMap = new Map();
		const sortedKeys = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$sortMapKeys(
			map,
		);

		// Add any prioritized keys so they're before anything alphabetized
		for (const key of ___R$project$rome$$romejs$pretty$format$index_ts$PRIORITIZE_KEYS) {
			if (sortedKeys.has(key)) {
				sortedKeys.delete(key);

				const val = map.get(key);
				if (val === undefined) {
					throw new Error("Expected value");
				}

				sortedMap.set(key, val);
			}
		}

		// Now add the rest
		for (const key of sortedKeys) {
			const val = map.get(key);
			if (val === undefined) {
				throw new Error("Expected value");
			}

			sortedMap.set(key, val);
		}

		return sortedMap;
	}





	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(
		consumer,
		opts,
	) {
		const comments = opts.comments.get(consumer.keyPath.join("."));
		if (comments === undefined) {
			return {
				inner: [],
				outer: [],
			};
		} else {
			return comments;
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyArray(
		consumer,
		info,
	) {
		const {level, prevIndent, nextIndent, stack} = info;

		let buff = [];

		const arr = consumer.asArray();
		for (const consumer of arr) {
			// Add element comments
			const comments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(
				consumer,
				info,
			).outer;
			buff = buff.concat(
				___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(
					nextIndent,
					comments,
				),
			);

			// Add the actual element line
			const element = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyConsumer(
				consumer,
				{
					comments: info.comments,
					isTopLevel: false,
					level: level + 1,
					stack,
				},
			);
			buff.push("" + nextIndent + element);
		}

		// Add inner comments
		const innerComments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(
			consumer,
			info,
		).inner;
		buff = buff.concat(
			___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(
				nextIndent,
				innerComments,
			),
		);

		return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$joinList(
			"[",
			"]",
			prevIndent,
			buff,
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyPlainObject(
		consumer,
		info,
	) {
		const {level, prevIndent, stack, isTopLevel} = info;
		let {nextIndent} = info;

		// Must be an object if we failed all the other conditions
		let buff = [];
		const map = consumer.asMap();

		// Remove function, symbol, and undefined properties
		for (const [key, consumer] of map) {
			const value = consumer.asUnknown();

			if (
				typeof value === "function" ||
				typeof value === "undefined" ||
				typeof value === "symbol"
			) {
				map.delete(key);
			}
		}

		let propLevel = level + 1;

		// We only want to increase the level for properties when we aren't at the top
		if (isTopLevel && level === 0) {
			propLevel = 0;
			nextIndent = "";
		}

		// Build properties
		for (const [key, consumer] of ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$sortMap(
			map,
		)) {
			// Add property comments
			const comments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(
				consumer,
				info,
			).outer;
			buff = buff.concat(
				___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(
					nextIndent,
					comments,
				),
			);

			// Add the actual property line
			const propKey = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyKey(
				key,
			);
			const propValue = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyConsumer(
				consumer,
				{
					comments: info.comments,
					isTopLevel: false,
					level: propLevel,
					stack,
				},
			);
			buff.push("" + nextIndent + propKey + ": " + propValue);
		}

		// We track this so we know whether we can safely put everything at the top level

		// If we only have comments then there's no way the parser could infer it was originally an object
		const hasProps = buff.length > 0;

		// Add inner comments
		const innerComments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(
			consumer,
			info,
		).inner;
		buff = buff.concat(
			___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(
				nextIndent,
				innerComments,
			),
		);

		if (level === 0 && isTopLevel) {
			if (hasProps) {
				return buff.join("\n");
			} else if (buff.length > 0) {
				// Otherwise we just have a bunch of comments
				// Indent them correctly and just output it as a normal object
				buff = buff.map((str) => {
					return "  " + str;
				});
			}
		}

		return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$joinList(
			"{",
			"}",
			prevIndent,
			buff,
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyObject(
		consumer,
		value,
		opts,
	) {
		const {isTopLevel, level, stack} = opts;

		const info = {
			comments: opts.comments,
			isTopLevel,
			nextIndent: "\t".repeat(level + 1),
			prevIndent: level === 0 ? "" : "\t".repeat(level - 1),
			level,
			stack,
		};

		try {
			stack.add(value);

			if (Array.isArray(value) || value instanceof Set) {
				return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyArray(
					consumer,
					info,
				);
			}

			return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyPlainObject(
				consumer,
				info,
			);
		} finally {
			stack.delete(value);
		}
	}

	function ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyRootConsumer(
		consumer,
		pathToComments,
	) {
		const opts = {
			comments: pathToComments,
			isTopLevel: true,
			level: 0,
			stack: new Set(),
		};

		// Nothing else handles comments at the top level
		const inner = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyConsumer(
			consumer,
			opts,
		);
		const comments = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$getComments(
			consumer,
			opts,
		);
		const outer = ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyComments(
			"",
			comments.outer,
		);

		return [...outer, inner].join("\n");
	}

	function ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyConsumer(
		consumer,
		opts,
	) {
		const value = consumer.asUnknown();

		// Stringify primitives
		const asPrim = ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyPrimitives(
			value,
		);
		if (asPrim !== undefined) {
			return asPrim;
		}

		// Check if we're already stringfying this value to prevent recursion
		if (opts.stack.has(value)) {
			throw new TypeError("Recursive");
		}

		return ___R$$priv$project$rome$$romejs$codec$json$stringify_ts$stringifyObject(
			consumer,
			value,
			opts,
		);
	}


  // project-rome/@romejs/codec-json/index.ts


	function ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON(opts) {
		return ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra(opts).consumer;
	}

	function ___R$project$rome$$romejs$codec$json$index_ts$consumeJSONExtra(opts) {
		const parser = ___R$project$rome$$romejs$codec$json$parse_ts$createJSONParser(
			opts,
		);
		const {value, context} = parser.parse();

		return {
			hasExtensions: parser.hasExtensions,
			consumer: ___R$project$rome$$romejs$consume$index_ts$consume({
				filePath: parser.path,
				context,
				objectPath: [],
				value,
				parent: undefined,
			}),
			comments: parser.pathToComments,
		};
	}

	function ___R$project$rome$$romejs$codec$json$index_ts$parseJSON(opts) {
		return ___R$project$rome$$romejs$codec$json$parse_ts$createJSONParser(opts).parse().value;
	}

	function ___R$project$rome$$romejs$codec$json$index_ts$tokenizeJSON(opts) {
		return ___R$project$rome$$romejs$codec$json$parse_ts$createJSONParser(opts).tokenizeAll();
	}

	function ___R$project$rome$$romejs$codec$json$index_ts$stringifyRJSONFromConsumer(
		opts,
	) {
		return ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyRootConsumer(
			opts.consumer,
			opts.comments,
		);
	}

	function ___R$project$rome$$romejs$codec$json$index_ts$stringifyRJSON(value) {
		return ___R$project$rome$$romejs$codec$json$stringify_ts$stringifyRootConsumer(
			___R$project$rome$$romejs$consume$index_ts$consumeUnknown(
				value,
				"parse/json",
			),
			new Map(),
		);
	}

	function ___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(value) {
		return JSON.stringify(value, null, "\t");
	}


  // project-rome/@romejs/v8/InspectorClient.ts


	class ___R$project$rome$$romejs$v8$InspectorClient_ts$InspectorClientCloseError
		extends Error {
		constructor() {
			super("Inspector connection closed");
		}
	}

	class ___R$project$rome$$romejs$v8$InspectorClient_ts$default {
		constructor(socket) {
			this.socket = socket;
			this.id = 0;

			this.subscriptions = new Map();
			this.callbacks = new Map();

			this.alive = true;

			this.init();
		}

		end() {
			this.socket.end();
		}

		init() {
			const {socket} = this;

			socket.errorEvent.subscribe((err) => {
				this.alive = false;
				for (const [, {reject}] of this.callbacks) {
					reject(err);
				}
				this.callbacks.clear();
				this.end();
			});

			socket.endEvent.subscribe(() => {
				this.alive = false;
				for (const [, {reject}] of this.callbacks) {
					reject(
						new ___R$project$rome$$romejs$v8$InspectorClient_ts$InspectorClientCloseError(),
					);
				}
				this.callbacks.clear();
			});

			socket.completeFrameEvent.subscribe((frame) => {
				const json = frame.payload.toString();
				const data = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON({
					input: json,
				});

				// Message reply
				const id = data.get("id").asNumberOrVoid();
				if (id !== undefined) {
					const handler = this.callbacks.get(id);
					if (handler !== undefined) {
						if (data.has("error")) {
							const errorMessage = data.get("error").get("message").asString();
							handler.reject(new Error(errorMessage));
						} else {
							handler.resolve(data.get("result"));
						}
						this.callbacks.delete(id);
					}
					return;
				}

				// Event
				const method = data.get("method").asStringOrVoid();
				if (method !== undefined) {
					const subs = this.subscriptions.get(method);
					if (subs !== undefined) {
						for (const sub of subs) {
							const {callback, once} = sub;
							callback(data.get("params"));
							if (once) {
								subs.delete(sub);
							}
						}
					}
				}
			});
		}

		subscribe(method, sub) {
			let subs = this.subscriptions.get(method);
			if (subs === undefined) {
				subs = new Set();
				this.subscriptions.set(method, subs);
			}
			subs.add(sub);
		}

		assertAlive() {
			if (!this.alive) {
				throw new Error("InspectorClient has no active socket");
			}
		}

		async wait(method) {
			return new Promise((resolve) => {
				this.assertAlive();
				this.subscribe(
					method,
					{
						once: true,
						callback: resolve,
					},
				);
			});
		}

		call(method, params) {
			const id = ++this.id;

			return new Promise((resolve, reject) => {
				this.assertAlive();
				this.callbacks.set(id, {resolve, reject});

				this.socket.sendJSON({
					id,
					method,
					params,
				});
			});
		}
	}


  // project-rome/@romejs/v8/CoverageCollector.ts
const ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$inspector = require(
		"inspector",
	);
	function ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
		covered,
		uncovered,
	) {
		const total = uncovered + covered;
		return {
			uncovered,
			covered,
			total,
			percent: total === 0 ? 100 : 100 / total * covered,
		};
	}

	class ___R$project$rome$$romejs$v8$CoverageCollector_ts$default {
		constructor() {
			this.sourceMaps = new Map();
		}

		addSourceMap(filename, code, map) {
			this.sourceMaps.set(
				filename,
				{
					ranges: [],
					map,
					code,
				},
			);
		}

		addCoverage(entries) {
			for (const entry of entries) {
				const filename = ___R$project$rome$$romejs$v8$utils_ts$urlToFilename(
					entry.url,
				);

				const data = this.sourceMaps.get(filename);
				if (data === undefined) {
					continue;
				}

				for (const {ranges, functionName, isBlockCoverage} of entry.functions) {
					data.ranges = data.ranges.concat(
						ranges.map((range) => {
							let kind = "expression";
							if (functionName !== "") {
								kind = "function";
							} else if (isBlockCoverage) {
								kind = "branch";
							}

							return Object.assign({kind}, range);
						}),
					);
				}
			}
		}

		generate() {
			const insertedLocs = new Map();
			const locs = [];

			for (const data of this.sourceMaps.values()) {
				const {ranges, code, map} = data;

				// Turn an index into a position in the compiled source
				let line = ___R$project$rome$$romejs$ob1$index_ts$ob1Number1;
				let column = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
				let index = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
				const indexCache = new Map();
				function findIndex(newIndex) {
					const cached = indexCache.get(newIndex);
					if (cached !== undefined) {
						return cached;
					}

					if (newIndex < index) {
						throw new Error(
							"Expected newIndex(" + newIndex + ") >= index(" + index + ")",
						);
					}

					if (
						___R$project$rome$$romejs$ob1$index_ts$ob1Get0(newIndex) >
						code.length
					) {
						throw new Error(
							"Expected newIndex(" +
							newIndex +
							") <= code.length(" +
							code.length +
							")",
						);
					}

					while (index < newIndex) {
						const char = code[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
							index,
						)];
						if (char === "\n") {
							line = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(line);
							column = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
						} else {
							column = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(column);
						}
						index = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(index);
					}

					const pos = {
						index: newIndex,
						line,
						column,
					};
					indexCache.set(newIndex, pos);
					return pos;
				}

				// Prefetch all sorted indexes
				const offsets = [];
				for (const {startOffset, endOffset} of ranges) {
					offsets.push(
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(startOffset),
					);
					offsets.push(
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(endOffset),
					);
				}
				offsets.sort((a, b) =>
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(a) -
					___R$project$rome$$romejs$ob1$index_ts$ob1Get0(b)
				);
				for (const index of offsets) {
					findIndex(index);
				}

				//
				for (const {kind, startOffset, endOffset, count} of ranges) {
					const originalStart = findIndex(
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(startOffset),
					);
					const originalEnd = findIndex(
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(endOffset),
					);

					const sourceStart = map.approxOriginalPositionFor(
						originalStart.line,
						originalStart.column,
					);
					if (sourceStart === undefined) {
						continue;
					}

					const sourceEnd = map.approxOriginalPositionFor(
						originalEnd.line,
						originalEnd.column,
					);
					if (sourceEnd === undefined) {
						continue;
					}

					if (sourceStart.source !== sourceEnd.source) {
						throw new Error(
							"Expected the same source for start and end: " +
							sourceStart.source +
							" !== " +
							sourceEnd.source,
						);
					}

					const key =
						sourceStart.source +
						":" +
						String(startOffset) +
						"-" +
						String(endOffset);
					const alreadyInserted = insertedLocs.get(key);
					if (alreadyInserted !== undefined) {
						alreadyInserted.count += count;
						continue;
					}

					const loc = {
						kind,
						filename: sourceStart.source,
						count,
						start: {
							index: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
								startOffset,
							),
							line: sourceStart.line,
							column: sourceStart.column,
						},
						end: {
							index: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
								endOffset,
							),
							line: sourceEnd.line,
							column: sourceEnd.column,
						},
					};
					insertedLocs.set(key, loc);
					locs.push(loc);
				}

				map.clearCache();
			}

			// Assemble files
			const rangesByFile = new Map();
			for (const loc of locs) {
				let ranges = rangesByFile.get(loc.filename);
				if (ranges === undefined) {
					ranges = [];
					rangesByFile.set(loc.filename, ranges);
				}
				ranges.push(loc);
			}

			const files = [];
			for (const [filename, ranges] of rangesByFile) {
				const coveredLines = new Set();
				const uncoveredLines = new Set();

				let uncoveredFunctions = new Set();
				let coveredFunctions = new Set();
				let uncoveredBranches = new Set();
				let coveredBranches = new Set();

				for (const {count, kind, start, end} of ranges) {
					// Fill in lines
					for (
						let i = start.line;
						i <= end.line;
						i = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(i)
					) {
						if (count === 0) {
							uncoveredLines.add(i);
						} else {
							coveredLines.add(i);
						}
					}

					// Mark covered kind
					if (kind === "function") {
						if (count === 0) {
							uncoveredBranches.add(start.index);
							uncoveredFunctions.add(start.line);
						} else {
							coveredFunctions.add(start.line);
							coveredBranches.add(start.index);
						}
					} else if (kind === "branch") {
						if (count === 0) {
							uncoveredBranches.add(start.index);
						} else {
							coveredBranches.add(start.index);
						}
					}
				}

				for (const line of coveredLines) {
					uncoveredLines.delete(line);
				}

				for (const index of coveredBranches) {
					uncoveredBranches.delete(index);
				}

				for (const index of coveredFunctions) {
					uncoveredFunctions.delete(index);
				}

				// No point showing fully covered files
				if (
					uncoveredLines.size === 0 &&
					uncoveredBranches.size === 0 &&
					uncoveredFunctions.size === 0
				) {
					continue;
				}

				files.push({
					filename,
					lines: ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
						coveredLines.size,
						uncoveredLines.size,
					),
					branches: ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
						coveredBranches.size,
						uncoveredBranches.size,
					),
					functions: ___R$$priv$project$rome$$romejs$v8$CoverageCollector_ts$createCoverageFileStats(
						coveredFunctions.size,
						uncoveredFunctions.size,
					),
				});
			}
			return files;
		}
	}


  // project-rome/@romejs/v8/index.ts



  // project-rome/@romejs/events/Bridge.ts


	class ___R$project$rome$$romejs$events$Bridge_ts$default {
		constructor(opts) {
			this.errorTransports = new Map();

			this.alive = true;
			this.type = opts.type;
			this.opts = opts;

			this.messageIdCounter = 0;
			this.events = new Map();

			this.hasHandshook = false;
			this.handshakeEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Bridge.handshake",
			});
			this.endEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Bridge.end",
				serial: true,
			});
			this.updatedListenersEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Bridge.updatedListenersEvent",
			});

			// A Set of event names that are being listened to on the other end

			// We track this to avoid sending over subscriptions that aren't needed
			this.listeners = new Set();

			this.prioritizedResponses = new Set();
			this.deprioritizedResponseQueue = [];

			this.postHandshakeQueue = [];

			this.heartbeatEvent = this.createEvent({
				name: "Bridge.heartbeat",
				direction: "server<->client",
			});

			if (this.type !== "server&client") {
				this.heartbeatEvent.subscribe(() => {
					return undefined;
				});
			}

			this.clear();
			this.init();
		}

		attachEndSubscriptionRemoval(subscription) {
			this.endEvent.subscribe(() => {
				subscription.unsubscribe();
			});
		}

		monitorHeartbeat(timeout, onExceeded) {
			if (this.type === "server&client") {
				// No point in monitoring this since we're the same process
				return;
			}

			this.heartbeatTimeout = setTimeout(
				async () => {
					try {
						await this.heartbeatEvent.call(undefined, {timeout});
						this.monitorHeartbeat(timeout, onExceeded);
					} catch (err) {
						if (
							err instanceof
							___R$project$rome$$romejs$events$BridgeError_ts$default
						) {
							if (this.alive) {
								onExceeded();
							}
						} else {
							throw err;
						}
					}
				},
				1_000,
			);
		}

		clearPrioritization(id) {
			this.prioritizedResponses.delete(id);

			if (this.prioritizedResponses.size === 0) {
				for (const msg of this.deprioritizedResponseQueue) {
					this.sendMessage(msg);
				}
				this.deprioritizedResponseQueue = [];
			}
		}

		async handshake(opts = {}) {
			if (this.hasHandshook) {
				throw new Error("Already performed handshake");
			}

			const {timeout, second = false} = opts;

			// Send a handshake in case we were the first
			if (!second) {
				this.sendMessage({
					type: "handshake",
					first: true,
					subscriptions: this.getSubscriptions(),
				});
			}

			// Wait for a handshake from the other end
			const res = await this.handshakeEvent.wait(undefined, timeout);

			if (res.first) {
				// Send the handshake again, as it wouldn't have received the first
				this.sendMessage({
					type: "handshake",
					first: false,
					subscriptions: this.getSubscriptions(),
				});
			}

			this.receivedSubscriptions(res.subscriptions);

			this.hasHandshook = true;

			for (const msg of this.postHandshakeQueue) {
				this.sendMessage(msg);
			}
			this.postHandshakeQueue = [];
		}

		getSubscriptions() {
			const names = [];
			for (const event of this.events.values()) {
				if (event.hasSubscriptions()) {
					names.push(event.name);
				}
			}
			return names;
		}

		sendSubscriptions() {
			if (!this.hasHandshook) {
				// If we haven't had the handshake then no point sending them. They'll be sent all at once after
				return;
			}

			// Notify the other side of what we're currently subscribed to
			// We send over a list of all of our subscriptions every time
			// This is fine since we don't change subscriptions often and they aren't very large
			// If we have a lot of subscriptions, or are changing them a lot in the future then this could be optimized
			this.sendMessage({
				type: "subscriptions",
				names: this.getSubscriptions(),
			});
		}

		receivedSubscriptions(names) {
			this.listeners = new Set(names);
			this.updatedListenersEvent.send(this.listeners);
		}

		init() {
			// This method can be overridden by subclasses, it allows you to add logic such as error serializers
		}

		clear() {
			for (const [, event] of this.events) {
				event.clear();
			}
		}

		getNextMessageId() {
			return ++this.messageIdCounter;
		}

		createEvent(opts) {
			if (this.events.has(opts.name)) {
				throw new Error("Duplicate event");
			}

			const event = new ___R$project$rome$$romejs$events$BridgeEvent_ts$default(
				opts,
				this,
			);
			this.events.set(opts.name, event);
			return event;
		}

		//# Connection death
		assertAlive() {
			if (this.alive === false) {
				throw new Error("Bridge is dead");
			}
		}

		endWithError(err) {
			if (this.alive === false) {
				return;
			}

			this.alive = false;

			// Reject any pending requests
			for (const [, event] of this.events) {
				event.end(err);
			}
			this.clear();

			// Clear any currently processing heartbeat
			if (this.heartbeatTimeout !== undefined) {
				clearTimeout(this.heartbeatTimeout);
			}

			// Notify listeners
			this.endEvent.callSync(err);
		}

		end(message = "Connection died") {
			this.endWithError(
				new ___R$project$rome$$romejs$events$BridgeError_ts$default(
					message,
					this,
				),
			);
		}

		//# Error serialization
		buildError(struct, data) {
			const transport = this.errorTransports.get(struct.name);
			if (transport === undefined) {
				const err = new Error(struct.message);
				err.name = struct.name || "Error";
				err.stack = struct.stack;
				err[___R$project$rome$$romejs$v8$errors_ts$ERROR_FRAMES_PROP] = struct.frames;
				return err;
			} else {
				return transport.hydrate(struct, data);
			}
		}

		buildErrorResponse(id, event, errRaw) {
			// Just in case something that wasn't an Error was thrown
			const err = errRaw instanceof Error ? errRaw : new Error(String(errRaw));

			// Fetch some metadata for hydration
			const tranport = this.errorTransports.get(err.name);
			const metadata = tranport === undefined ? {} : tranport.serialize(err);

			return {
				id,
				event,
				type: "response",
				responseStatus: "error",
				value: ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err),
				metadata,
			};
		}

		addErrorTransport(name, transport) {
			this.errorTransports.set(name, transport);
		}

		//# Message transmission
		sendMessage(msg) {
			// There's no try-catch gated around sendMessage because the call stack here will include some other error handler
			// We need to be specific for handleMessage because it could come from anywhere
			if (msg.type !== "handshake" && !this.hasHandshook) {
				this.postHandshakeQueue.push(msg);
				return;
			}

			this.assertAlive();

			if (msg.type === "response") {
				if (
					this.prioritizedResponses.size > 0 &&
					!this.prioritizedResponses.has(msg.id)
				) {
					this.deprioritizedResponseQueue.push(msg);
					return;
				}

				if (this.prioritizedResponses.has(msg.id)) {
					this.clearPrioritization(msg.id);
				}
			}

			const {opts} = this;
			opts.sendMessage(msg);
			if (opts.onSendMessage !== undefined) {
				opts.onSendMessage(msg);
			}
		}

		handleJSONMessage(str) {
			try {
				const data = JSON.parse(str);
				this.handleMessage(data);
			} catch (err) {
				if (err instanceof SyntaxError) {
					this.endWithError(
						new ___R$project$rome$$romejs$events$BridgeError_ts$default(
							"Error parsing message JSON: " + err.message,
							this,
						),
					);
				} else {
					this.endWithError(err);
				}
			}
		}

		handleMessage(msg) {
			try {
				this.assertAlive();

				if (msg.type === "handshake") {
					this.handshakeEvent.send({
						subscriptions: msg.subscriptions,
						first: msg.first,
					});
				}

				if (msg.type === "subscriptions") {
					this.receivedSubscriptions(msg.names);
				}

				if (msg.type === "request") {
					this.handleMessageRequest(msg);
				}

				if (msg.type === "response") {
					this.handleMessageResponse(msg);
				}
			} catch (err) {
				this.endWithError(err);
			}
		}

		handleMessageResponse(data) {
			const {id, event} = data;
			if (id === undefined) {
				throw new Error("Expected id");
			}
			if (event === undefined) {
				throw new Error("Expected event");
			}

			const eventHandler = this.events.get(event);
			if (eventHandler === undefined) {
				throw new Error("Unknown event");
			}

			eventHandler.dispatchResponse(id, data);
		}

		handleMessageRequest(data) {
			const {id, event, param, priority} = data;
			if (event === undefined) {
				throw new Error("Expected event in message request but received none");
			}

			const eventHandler = this.events.get(event);
			if (eventHandler === undefined) {
				throw new Error("Unknown event " + event);
			}

			if (id === undefined) {
				// We don't need to do anything with the return value of this since
				// there's nothing on the other end to catch it
				eventHandler.dispatchRequest(param);
			} else {
				if (priority) {
					this.prioritizedResponses.add(id);
				}

				eventHandler.dispatchRequest(param).then((value) => {
					this.sendMessage({
						event,
						id,
						type: "response",
						responseStatus: "success",
						value,
					});
				}).catch((err) => {
					this.sendMessage(this.buildErrorResponse(id, event, err));
				}).catch((err) => this.endWithError(err));
			}
		}
	}


  // project-rome/@romejs/events/bridgeCreators.ts
const ___R$project$rome$$romejs$events$bridgeCreators_ts = {
		createBridgeFromWebSocketInterface: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface,
		createBridgeFromBrowserWebSocket: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromBrowserWebSocket,
		createBridgeFromSocket: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromSocket,
		createBridgeFromLocal: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromLocal,
		createBridgeFromChildProcess: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess,
		createBridgeFromParentProcess: ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess,
	};
	const ___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$SOCKET_LENGTH = /^(\d+):/;

	// JSON.stringify but throw on bad data types
	// Most likely slower... But safer and our data structures are usually fairly shallow
	function ___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$stringify(
		obj,
	) {
		return JSON.stringify(
			obj,
			(key, value) => {
				const type = typeof value;

				if (value === undefined || value === null) {
					return value;
				}

				// Primitives
				if (type === "string" || type === "number" || type === "boolean") {
					return value;
				}

				// Arrays and plain objects
				if (Array.isArray(value) || value.constructor === Object) {
					return value;
				}

				throw new Error(
					"Illegal data type not allowed in JSON: " +
					___R$project$rome$$romejs$pretty$format$index_ts$default(value) +
					" in " +
					___R$project$rome$$romejs$pretty$format$index_ts$default(obj),
				);
			},
		);
	}

	function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface(
		CustomBridge,
		inf,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						inf.sendJSON(data);
					},
				},
			),
		);

		const {socket} = inf;

		bridge.endEvent.subscribe(() => {
			socket.end();
		});

		inf.completeFrameEvent.subscribe((frame) => {
			const json = frame.payload.toString();
			bridge.handleJSONMessage(json);
		});

		socket.on(
			"error",
			(err) => {
				bridge.endWithError(err);
			},
		);

		socket.on(
			"end",
			() => {
				bridge.end("RPC WebSocket died");
			},
		);

		return bridge;
	}

	function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromBrowserWebSocket(
		CustomBridge,
		socket,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						socket.send(
							___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$stringify(
								data,
							),
						);
					},
				},
			),
		);

		bridge.endEvent.subscribe(() => {
			socket.close();
		});

		socket.onmessage = function(event) {
			bridge.handleJSONMessage(String(event.data));
		};

		socket.onclose = () => {
			bridge.end("RPC WebSocket disconnected");
		};

		return bridge;
	}

	function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromSocket(
		CustomBridge,
		socket,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						const serialized = ___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$stringify(
							data,
						);
						socket.write(serialized.length + ":" + serialized);
					},
				},
			),
		);

		bridge.endEvent.subscribe(() => {
			socket.end();
		});

		// buffer data and parse message on newline
		let buff = "";
		let messageLength = 0;
		socket.setEncoding("utf8");
		function checkForPossibleMessage() {
			// we're awaiting a message and have received it
			if (messageLength > 0 && buff.length >= messageLength) {
				// retrieve the message from the buffer
				const msg = buff.slice(0, messageLength);

				// clear the next message length and remove the current message from the buffer
				buff = buff.slice(messageLength);
				messageLength = 0;

				// parse it
				bridge.handleJSONMessage(msg);
			}

			// if we aren't waiting for a message and we have a buffer then check for an incoming message
			if (messageLength === 0 && buff !== "") {
				// check if we've received the starting info of a message
				const possibleLength = buff.match(
					___R$$priv$project$rome$$romejs$events$bridgeCreators_ts$SOCKET_LENGTH,
				);
				if (possibleLength != null) {
					// get the message length
					messageLength = Number(possibleLength[1]);

					// remove the length designator
					buff = buff.slice(possibleLength[0].length);

					// check if we have a full message
					checkForPossibleMessage();
				}
			}
		}

		socket.on(
			"data",
			(chunk) => {
				buff += chunk;
				checkForPossibleMessage();
			},
		);

		socket.on(
			"error",
			(err) => {
				bridge.endWithError(err);
			},
		);

		socket.on(
			"end",
			() => {
				bridge.end("Socket disconnected");
			},
		);

		return bridge;
	}

	function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromLocal(
		CustomBridge,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					type: "server&client",
					sendMessage: (msg) => {
						bridge.handleMessage(msg);
					},
				},
			),
		);

		return bridge;
	}

	function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(
		CustomBridge,
		proc,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						proc.send(data);
					},
				},
			),
		);

		bridge.endEvent.subscribe(() => {
			proc.kill();
		});

		proc.on(
			"error",
			(err) => {
				bridge.endWithError(err);
			},
		);

		proc.on(
			"message",
			(msg) => {
				bridge.handleMessage((msg));
			},
		);

		// Catch process dying and reject any requests in flight
		proc.on(
			"close",
			() => {
				bridge.end("RPC child process died");
			},
		);

		return bridge;
	}

	function ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(
		CustomBridge,
		opts,
	) {
		const bridge = new CustomBridge(
			Object.assign(
				{},
				opts,
				{
					sendMessage: (data) => {
						if (typeof process.send === "function") {
							process.send(data);
						} else {
							throw new Error("No process.send found");
						}
					},
				},
			),
		);

		process.on(
			"message",
			(data) => {
				bridge.handleMessage(data);
			},
		);

		// I doubt any of these will have time to dispatch but for consistency sake...
		process.on(
			"exit",
			() => {
				bridge.end("RPC self process died");
			},
		);

		return bridge;
	}


  // project-rome/@romejs/events/types.ts
const ___R$project$rome$$romejs$events$types_ts = {};

























  // project-rome/@romejs/events/utils.ts
const ___R$project$rome$$romejs$events$utils_ts = {
		mergeEventSubscriptions: ___R$project$rome$$romejs$events$utils_ts$mergeEventSubscriptions,
	};
	function ___R$project$rome$$romejs$events$utils_ts$mergeEventSubscriptions(
		subs,
	) {
		return {
			unsubscribe() {
				for (const sub of subs) {
					sub.unsubscribe();
				}
			},
		};
	}


  // project-rome/@romejs/events/index.ts



  // project-rome/@romejs/cli-reporter/util.ts
const ___R$$priv$project$rome$$romejs$cli$reporter$util_ts$readline = require(
		"readline",
	);
	function ___R$project$rome$$romejs$cli$reporter$util_ts$mergeProgresses(
		progresses,
	) {
		if (progresses.length === 1) {
			return progresses[0];
		}

		return {
			render: () => {
				for (const progress of progresses) {
					progress.render();
				}
			},
			setCurrent: (current) => {
				for (const progress of progresses) {
					progress.setCurrent(current);
				}
			},
			setTotal: (total, approximate) => {
				for (const progress of progresses) {
					progress.setTotal(total, approximate);
				}
			},
			setText: (text) => {
				for (const progress of progresses) {
					progress.setText(text);
				}
			},
			pushText: (text) => {
				for (const progress of progresses) {
					progress.pushText(text);
				}
			},
			popText: (text) => {
				for (const progress of progresses) {
					progress.popText(text);
				}
			},
			setApproximateETA: (duration) => {
				for (const progress of progresses) {
					progress.setApproximateETA(duration);
				}
			},
			tick: () => {
				for (const progress of progresses) {
					progress.tick();
				}
			},
			end: () => {
				for (const progress of progresses) {
					progress.end();
				}
			},
			pause: () => {
				for (const progress of progresses) {
					progress.pause();
				}
			},
			resume: () => {
				for (const progress of progresses) {
					progress.resume();
				}
			},
		};
	}



	function ___R$project$rome$$romejs$cli$reporter$util_ts$onKeypress(
		reporter,
		callback,
	) {
		const stdin = reporter.getStdin();

		___R$project$rome$$romejs$cli$reporter$util_ts$setRawMode(stdin, true);
		___R$$priv$project$rome$$romejs$cli$reporter$util_ts$readline.emitKeypressEvents(
			stdin,
		);

		function onkeypress(chunk, key) {
			switch (key.name) {
				case "c": {
					if (key.ctrl) {
						reporter.br(true);
						reporter.warn("Cancelled by user");
						process.exit(1);
					}
					return;
				}

				case "escape": {
					reporter.br(true);
					reporter.warn("Cancelled by user");
					process.exit(1);
					return;
				}
			}

			callback(key);
		}

		stdin.addListener("keypress", onkeypress);

		return {
			finish() {
				stdin.removeListener("keypress", onkeypress);
				___R$project$rome$$romejs$cli$reporter$util_ts$setRawMode(stdin, false);
			},
		};
	}

	function ___R$project$rome$$romejs$cli$reporter$util_ts$setRawMode(stdin, raw) {
		if (stdin.isTTY && stdin.setRawMode !== undefined) {
			stdin.setRawMode(raw);
		}

		if (raw) {
			stdin.resume();
		} else {
			stdin.pause();
		}
	}


  // project-rome/@romejs/cli-reporter/select.ts
function ___R$$priv$project$rome$$romejs$cli$reporter$select_ts$formatShortcut(
		{shortcut},
	) {
		if (shortcut === undefined) {
			return "";
		} else {
			return " <dim>(shortcut " + shortcut + ")</dim>";
		}
	}

	async function ___R$project$rome$$romejs$cli$reporter$select_ts$default(
		reporter,
		message,
		{
			options,
			defaults = [],
			radio = false,
			yes = false,
		},
	) {
		const optionNames = [];
		const seenShortcuts = new Set();

		// Verify there's no shortcut collisions and remove empty options
		for (const key in options) {
			const option = options[key];

			if (option !== undefined) {
				optionNames.push(key);

				const {shortcut} = option;
				if (shortcut !== undefined) {
					if (seenShortcuts.has(shortcut)) {
						throw new Error("Multiple options have the shortcut " + shortcut);
					} else {
						seenShortcuts.add(shortcut);
					}
				}
			}
		}

		let optionCount = optionNames.length;
		if (optionCount === 0) {
			return new Set();
		}

		if (yes) {
			return new Set(defaults);
		}

		let prompt = "<dim>\u276f</dim> <emphasis>" + message + "</emphasis>";
		reporter.logAll(prompt);

		if (radio) {
			reporter.info(
				"Use arrow keys and then <emphasis>enter</emphasis> to select an option",
			);
		} else {
			reporter.info(
				"Use arrow keys and <emphasis>space</emphasis> to select or deselect options and then <emphasis>enter</emphasis> to confirm",
			);
		}

		const selectedOptions = new Set(defaults);
		let activeOption = 0;

		// Set first option if this is a radio
		if (radio && !defaults.length) {
			selectedOptions.add(optionNames[0]);
		}

		function boundActive() {
			activeOption = Math.min(activeOption, optionCount - 1);
			activeOption = Math.max(activeOption, 0);

			if (radio) {
				selectedOptions.clear();
				selectedOptions.add(optionNames[activeOption]);
			}
		}

		// If we aren't a radio then set the active option to the bottom of any that are enabled
		if (!radio) {
			while (selectedOptions.has(optionNames[activeOption])) {
				activeOption++;
			}
		}

		function render() {
			const optionNames = Object.keys(options);
			for (let i = 0; i < optionNames.length; i++) {
				const key = optionNames[i];
				const option = options[key];
				const {label} = option;
				const shortcut = ___R$$priv$project$rome$$romejs$cli$reporter$select_ts$formatShortcut(
					option,
				);

				let formattedLabel =
					optionNames.indexOf(key) === activeOption
						? "<underline>" + label + "</underline>"
						: label;

				let symbol = "";
				if (radio) {
					symbol = selectedOptions.has(key) ? "\u25c9" : "\u25ef";
				} else {
					symbol = selectedOptions.has(key) ? "\u2611" : "\u2610";
				}

				reporter.logAll(
					"  " + symbol + " " + formattedLabel + shortcut,
					{
						// Don't put a newline on the last option
						newline: i !== optionNames.length - 1,
					},
				);
			}
		}
		function cleanup() {
			for (let i = 0; i < optionCount; i++) {
				reporter.writeAll(
					___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.eraseLine,
				);

				// Don't move above the top line
				if (i !== optionCount - 1) {
					reporter.writeAll(
						___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorUp(),
					);
				}
			}
			reporter.writeAll(
				___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorTo(0),
			);
		}
		function toggleOption(optionName) {
			if (selectedOptions.has(optionName)) {
				selectedOptions.delete(optionName);
			} else {
				selectedOptions.add(optionName);
			}
		}

		const stdin = reporter.getStdin();

		render();

		___R$project$rome$$romejs$cli$reporter$util_ts$setRawMode(stdin, true);

		await new Promise((resolve) => {
			const keypress = ___R$project$rome$$romejs$cli$reporter$util_ts$onKeypress(
				reporter,
				(key) => {
					// Check if this is an option shortcut
					if (!key.ctrl) {
						for (const optionName in options) {
							const option = options[optionName];
							if (option === undefined) {
								continue;
							}

							const {shortcut} = option;
							if (shortcut === key.name) {
								if (radio) {
									selectedOptions.clear();
									selectedOptions.add(optionName);
									finish();
								} else {
									toggleOption(optionName);
								}
								return;
							}
						}
					}

					switch (key.name) {
						case "up": {
							activeOption--;
							break;
						}

						case "down": {
							activeOption++;
							break;
						}

						case "space": {
							if (!radio) {
								toggleOption((optionNames[activeOption]));
							}
							break;
						}

						case "return": {
							finish();
							return;
						}

						default:
							return;
					}

					boundActive();
					cleanup();
					render();
				},
			);

			function finish() {
				cleanup();

				// Remove initial help message
				reporter.writeAll(
					___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorUp(),
				);
				reporter.writeAll(
					___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.eraseLine,
				);

				// Remove initial log message
				reporter.writeAll(
					___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorUp(),
				);
				reporter.writeAll(
					___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.eraseLine,
				);

				prompt += ": ";
				if (selectedOptions.size > 0) {
					prompt += Array.from(selectedOptions, (key) => options[key].label).join(
						", ",
					);
				} else {
					prompt += "<dim>none</dim>";
				}
				reporter.logAll(prompt);

				// Stop listening for keypress
				keypress.finish();
				resolve();
			}
		});

		return selectedOptions;
	}


  // project-rome/@romejs/cli-reporter/Reporter.ts
const ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$stream = require(
		"stream",
	);
	const ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$readline = require(
		"readline",
	);













	let ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$remoteProgressIdCounter = 0;



	function ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$getStreamFormat(
		stdout,
	) {
		return stdout !== undefined && stdout.isTTY === true ? "ansi" : "none";
	}

	class ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default {
		constructor(opts = {}) {
			this.wrapCallback = (callback) => {
				const {wrapperFactory} = this;
				if (wrapperFactory === undefined) {
					return callback;
				} else {
					return wrapperFactory(callback);
				}
			};
			this.programName =
				opts.programName === undefined ? "rome" : opts.programName;
			this.programVersion = opts.programVersion;

			this.noProgress = process.env.CI === "1";
			this.isVerbose = Boolean(opts.verbose);

			this.startTime =
				opts.startTime === undefined ? Date.now() : opts.startTime;
			this.hasClearScreen =
				opts.hasClearScreen === undefined ? true : opts.hasClearScreen;
			this.activeElements = new Set();
			this.indentLevel = 0;
			this.indentString = "";
			this.enabled = opts.disabled === true ? 0 : 1;
			this.markupOptions =
				opts.markupOptions === undefined ? {} : opts.markupOptions;
			this.streamsWithDoubleNewlineEnd = new Set();
			this.streamsWithNewlineEnd = new Set();
			this.shouldRedirectOutToErr = false;
			this.stdin = opts.stdin;

			this.wrapperFactory = opts.wrapperFactory;

			this.remoteClientProgressBars = new Map();
			this.remoteServerProgressBars = new Map();

			this.sendRemoteServerMessage = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "sendRemoteServerMessage",
			});
			this.sendRemoteClientMessage = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "sendRemoteClientMessage",
			});

			this.isRemote = opts.useRemoteProgressBars === true;

			this.outStreams = new Set();
			this.errStreams = new Set();
			this.streams = new Set();

			if (opts.streams !== undefined) {
				for (const stream of opts.streams) {
					this.addStream(stream);
				}
			}
		}

		attachStdoutStreams(stdout, stderr) {
			const columns =
				stdout === undefined || stdout.columns === undefined
					? ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS
					: stdout.columns;

			const columnsUpdated = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "columnsUpdated",
			});

			// Windows terminals are awful
			const unicode = process.platform !== "win32";

			const outStream = {
				type: "out",
				format: ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$getStreamFormat(
					stdout,
				),
				columns,
				unicode,
				write(chunk) {
					if (stdout !== undefined) {
						stdout.write(chunk);
					}
				},
				teardown() {},
			};

			const errStream = {
				type: "error",
				format: ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$getStreamFormat(
					stderr,
				),
				columns,
				unicode,
				write(chunk) {
					if (stderr !== undefined) {
						stderr.write(chunk);
					}
				},
			};

			// Watch for resizing
			if (outStream.format === "ansi" && stdout !== undefined) {
				const onStdoutResize = () => {
					if ((stdout == null ? undefined : stdout.columns) !== undefined) {
						const {columns} = stdout;
						columnsUpdated.send(columns);
						this.setStreamColumns([outStream, errStream], columns);
					}
				};

				outStream.teardown = () => {
					stdout.off("resize", onStdoutResize);
				};

				stdout.on("resize", onStdoutResize);
			}

			this.addStream(outStream);
			this.addStream(errStream);

			return {
				columnsUpdated,
				stdout: outStream,
				stderr: errStream,
			};
		}

		attachCaptureStream(format = "none") {
			let buff = "";

			const stream = {
				format,
				type: "all",
				columns: ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS,
				unicode: true,
				write(chunk) {
					buff += chunk;
				},
			};

			this.addStream(stream);

			return {
				read() {
					return buff;
				},
				remove: () => {
					this.removeStream(stream);
				},
			};
		}

		static fromProcess(opts = {}) {
			const reporter = new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default(
				Object.assign(
					{},
					opts,
					{
						markupOptions: Object.assign(
							{cwd: ___R$project$rome$$romejs$path$index_ts$CWD_PATH},
							opts.markupOptions,
						),
					},
				),
			);

			reporter.attachStdoutStreams(process.stdout, process.stderr);

			return reporter;
		}

		processRemoteClientMessage(msg) {
			if (msg.type === "PROGRESS_CREATE") {
				this.remoteClientProgressBars.set(
					msg.id,
					this.progressLocal(
						msg.opts,
						() => {
							this.sendRemoteServerMessage.call({
								type: "ENDED",
								id: msg.id,
							});
						},
					),
				);
				return;
			}

			let bar = this.remoteClientProgressBars.get(msg.id);
			if (bar === undefined) {
				throw new Error(
					"Remote reporter message for progress bar " +
					msg.id +
					" that does not exist",
				);
			}

			bar.processRemoteClientMessage(msg);

			if (msg.type === "PROGRESS_END") {
				this.remoteClientProgressBars.delete(msg.id);
			}
		}

		receivedRemoteServerMessage(msg) {
			// Currently the only message a remote Reporter can send is that it has ended
			switch (msg.type) {
				case "ENDED": {
					const progress = this.remoteServerProgressBars.get(msg.id);
					if (progress !== undefined) {
						progress.end();
					}
				}
			}
		}

		getMessagePrefix() {
			return "";
		}

		normalizeMessage(stream, tty, opts) {
			let msg =
				stream.format !== "none" || opts.nonTTY === undefined
					? tty
					: opts.nonTTY;

			if (opts.noPrefix !== true) {
				msg = this.getMessagePrefix() + msg;
			}

			// Don't indent if there is no indent, or the message is empty
			const {indentString} = this;
			if (
				this.streamsWithNewlineEnd.has(stream) &&
				indentString !== "" &&
				msg !== ""
			) {
				// Indent each line, leaving out the indentation for empty lines
				msg =
					indentString + msg.replace(/\n([^\n])/g, "\n" + indentString + "$1");
			}

			return msg;
		}

		redirectOutToErr(should) {
			const old = this.shouldRedirectOutToErr;
			this.shouldRedirectOutToErr = should;
			return old;
		}

		setStreamColumns(streams, columns) {
			for (const stream of streams) {
				if (!this.streams.has(stream)) {
					throw new Error(
						"Trying to setStreamColumns on a stream that isn't attached to this Reporter",
					);
				}

				stream.columns = columns;
			}

			for (const elem of this.activeElements) {
				elem.render();
			}
		}

		addStream(stream) {
			this.streamsWithNewlineEnd.add(stream);
			this.streams.add(stream);

			if (stream.type === "error" || stream.type === "all") {
				this.errStreams.add(stream);
			}

			if (stream.type === "out" || stream.type === "all") {
				this.outStreams.add(stream);
			}
		}

		removeStream(stream) {
			if (stream.teardown !== undefined) {
				stream.teardown();
			}
			this.streams.delete(stream);
			this.outStreams.delete(stream);
			this.errStreams.delete(stream);
		}

		//# Stdin
		getStdin() {
			const {stdin} = this;
			if (stdin === undefined) {
				throw new Error("This operation expected a stdin but we have none");
			}
			return stdin;
		}

		async question(message, {hint, default: def = "", yes = false} = {}) {
			if (yes) {
				return def;
			}

			const stdin = this.getStdin();

			const origPrompt =
				"<dim emphasis>?</dim> <emphasis>" + message + "</emphasis>";
			let prompt = origPrompt;
			if (hint !== undefined) {
				prompt += " <dim>" + hint + "</dim>";
			}
			if (def !== "") {
				prompt += " (" + def + ")";
			}
			prompt += ": ";
			this.logAll(
				prompt,
				{
					newline: false,
				},
			);

			const rl = ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$readline.createInterface({
				input: stdin,
				output: new ___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$stream.Writable({
					write: (chunk, encoding, callback) => {
						this.writeAll(chunk);
						callback();
					},
				}),
				terminal: false,
			});

			return new Promise((resolve) => {
				rl.on(
					"line",
					(line) => {
						rl.close();

						const normalized = line === "" ? def : line;

						// Replace initial prompt
						this.writeAll(
							___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorUp(),
						);
						this.writeAll(
							___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.eraseLine,
						);

						let prompt = origPrompt;
						prompt += ": ";
						if (normalized === "") {
							prompt += "<dim>empty</dim>";
						} else {
							prompt += normalized;
						}
						this.logAll(prompt);

						resolve(normalized);
					},
				);
			});
		}

		async questionValidate(message, validate, options = {}) {
			while (true) {
				let res;

				await this.question(
					message,
					Object.assign(
						{},
						options,
						{
							normalize: (value) => {
								res = validate(value);

								if (res[0] === true && typeof res[1] === "string") {
									return res[1];
								} else {
									return value;
								}
							},
						},
					),
				);

				if (res === undefined) {
					throw new Error("normalize should have been called");
				}

				if (res[0] === false) {
					this.error(res[1]);
					continue;
				} else {
					return res[1];
				}
			}
		}

		async radioConfirm(message) {
			const answer = await this.radio(
				message,
				{
					options: {
						yes: {
							label: "Yes",
							shortcut: "y",
						},
						no: {
							label: "No",
							shortcut: "n",
						},
					},
				},
			);
			return answer === "yes";
		}

		async confirm(message = "Press any key to continue") {
			this.logAll("<dim>" + message + "</dim>", {newline: false});

			await new Promise((resolve) => {
				const keypress = ___R$project$rome$$romejs$cli$reporter$util_ts$onKeypress(
					this,
					() => {
						keypress.finish();
						resolve();
					},
				);
			});

			// Newline
			this.logAll("");
		}

		async radio(message, arg) {
			const set = await this.select(
				message,
				Object.assign({}, arg, {radio: true}),
			);

			// Should always have at least one element
			return Array.from(set)[0];
		}

		async select(message, args) {
			return ___R$project$rome$$romejs$cli$reporter$select_ts$default(
				this,
				message,
				args,
			);
		}

		//# Control
		isEnabled(stderr) {
			return this.getStreams(stderr).size > 0;
		}

		getStreams(stderr) {
			if (this.enabled === 0) {
				return new Set();
			}

			if (this.shouldRedirectOutToErr) {
				return this.errStreams;
			}

			if (stderr) {
				return this.errStreams;
			}

			return this.outStreams;
		}

		enable() {
			let alreadyDisabled = false;

			this.enabled++;

			return () => {
				if (alreadyDisabled) {
					throw new Error("Already disabled Reporter");
				}

				this.enabled--;
				alreadyDisabled = true;
			};
		}

		//# LIFECYCLE
		teardown() {
			for (const stream of this.streams) {
				this.removeStream(stream);
			}

			for (const elem of this.activeElements) {
				elem.end();
			}
			this.activeElements.clear();
		}

		fork(opts = {}) {
			return new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default(
				Object.assign(
					{
						streams: [...this.streams],
						verbose: this.isVerbose,
						markupOptions: this.markupOptions,
						wrapperFactory: this.wrapperFactory,
					},
					opts,
				),
			);
		}

		//# INDENTATION METHODS
		indent(callback) {
			this.indentLevel++;
			this.updateIndent();

			callback();
			this.indentLevel--;
			this.updateIndent();
		}

		noIndent(callback) {
			const prevIndentLevel = this.indentLevel;
			this.indentLevel = 0;
			this.updateIndent();
			callback();
			this.indentLevel = prevIndentLevel;
			this.updateIndent();
		}

		updateIndent() {
			this.indentString = "  ".repeat(this.indentLevel);
		}

		//# INTERNAL
		prependEmoji(stream, msg, emoji, fallback) {
			if (stream.format === "none") {
				return emoji + " " + msg;
			} else {
				if (fallback === undefined) {
					return msg;
				} else {
					return fallback + " " + msg;
				}
			}
		}

		//# VISUALISATION
		table(head, rawBody) {
			let body = "";

			if (head.length > 0) {
				body += "<tr>";
				for (const field of head) {
					body += "<td><emphasis>" + field + "</emphasis></td>";
				}
				body += "</tr>";
			}

			for (const row of rawBody) {
				body += "<tr>";
				for (let field of row) {
					if (typeof field === "string" || typeof field === "number") {
						field = {align: "left", value: field};
					}

					let {value, align} = field;
					if (typeof value === "number") {
						value = "<number>" + value + "</number>";
					}
					body += '<td align="' + align + '">' + value + "</td>";
				}
				body += "</tr>";
			}

			this.logAll("<table>" + body + "</table>");
		}

		verboseInspect(val) {
			if (this.isVerbose) {
				this.inspect(val);
			}
		}

		inspect(value) {
			if (!this.isEnabled(false)) {
				return;
			}

			let formatted = value;

			if (typeof formatted !== "number" && typeof formatted !== "string") {
				formatted = ___R$project$rome$$romejs$pretty$format$index_ts$default(
					formatted,
					{markup: true},
				);
			}

			this.logAll(String(formatted));
		}

		//# ESCAPE HATCHES
		clearLineAll() {
			for (const stream of this.getStreams(false)) {
				this.clearLineSpecific(stream);
			}
		}

		clearLineSpecific(stream) {
			stream.write(
				___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.eraseLine,
			);
			stream.write(
				___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorTo(0),
			);
		}

		writeAll(msg, opts = {}) {
			for (const stream of this.getStreams(opts.stderr)) {
				this.writeSpecific(stream, msg, opts);
			}
		}

		writeSpecific(stream, msg, opts = {}) {
			if (!this.isEnabled(opts.stderr)) {
				return;
			}

			this.hasClearScreen = false;

			if (stream.format === "ansi" && this.activeElements.size > 0) {
				// A progress bar is active and has probably drawn to the screen
				this.clearLineSpecific(stream);
			}

			stream.write(msg);
		}

		//# UTILITIES
		getTotalTime() {
			return Date.now() - this.startTime;
		}

		clearScreen() {
			for (const stream of this.getStreams(false)) {
				if (stream.format === "ansi") {
					stream.write(
						___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.clearScreen,
					);
				}
			}
			this.hasClearScreen = true;
		}

		//# SECTIONS
		heading(text) {
			this.br();
			this.logAll(
				"<inverse><emphasis>" + text + "</emphasis></inverse>",
				{
					nonTTY: "# " + text,
				},
			);
			this.br();
		}

		section(title, callback) {
			this.hr(
				title === undefined ? undefined : "<emphasis>" + title + "</emphasis>",
			);
			this.indent(() => {
				callback();
				this.br();
			});
		}

		hr(text = "") {
			const {hasClearScreen} = this;

			this.br();

			if (hasClearScreen && text === undefined) {
				return;
			}

			this.logAll("<hr>" + text + "</hr>");
			this.br();
		}

		async steps(callbacks) {
			const total = callbacks.length;
			let current = 1;
			for (const {clear, message, callback} of callbacks) {
				this.step(current, total, message);

				if (clear) {
					this.hasClearScreen = true;
				}

				await callback();
				current++;

				// If a step doesn't produce any output, or just progress bars that are cleared, we can safely remove the previous `step` message line
				if (clear && this.hasClearScreen) {
					for (const stream of this.getStreams(false)) {
						if (stream.format === "ansi") {
							stream.write(
								___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorTo(
									0,
								),
							);
							stream.write(
								___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.cursorUp(),
							);
							stream.write(
								___R$project$rome$$romejs$string$markup$ansi_ts$ansiEscapes.eraseLine,
							);
						}
					}
				}
			}
		}

		step(current, total, msg) {
			if (msg.endsWith("?")) {
				msg =
					___R$project$rome$$romejs$string$utils$removeSuffix_ts$removeSuffix(
						msg,
						"?",
					) + "...?";
			} else {
				msg += "...";
			}

			this.logAll("<dim>[" + current + "/" + total + "]</dim> " + msg);
		}

		br(force = false) {
			for (const stream of this.getStreams(false)) {
				if (!this.streamsWithDoubleNewlineEnd.has(stream) || force) {
					this.logOne(stream, "");
				}
			}
		}

		stripMarkup(str) {
			return ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainText(
				str,
				this.markupOptions,
			).lines.join("\n");
		}

		markupify(stream, str, viewportShrink = 0) {
			if (str === "") {
				return {lines: [""], width: 0};
			}

			const gridMarkupOptions = Object.assign(
				{},
				this.markupOptions,
				{columns: stream.columns - this.indentString.length - viewportShrink},
			);

			switch (stream.format) {
				case "ansi":
					return ___R$project$rome$$romejs$string$markup$format_ts$markupToAnsi(
						str,
						gridMarkupOptions,
					);

				case "html":
					// TODO
					return ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainText(
						str,
						gridMarkupOptions,
					);

				case "none":
					return ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainText(
						str,
						gridMarkupOptions,
					);

				case "markup":
					return {
						width: 0,
						lines: [str],
					};
			}
		}

		logAll(tty, opts = {}) {
			for (const stream of this.getStreams(opts.stderr)) {
				this.logOne(stream, tty, opts);
			}
		}

		logAllNoMarkup(tty, opts = {}) {
			for (const stream of this.getStreams(opts.stderr)) {
				this.logOneNoMarkup(stream, tty, opts);
			}
		}

		logOne(stream, tty, opts = {}) {
			const msg =
				stream.format !== "none" || opts.nonTTY === undefined
					? tty
					: opts.nonTTY;
			const {lines} = this.markupify(stream, msg);
			for (const line of lines) {
				this.logOneNoMarkup(stream, line, opts);
			}
		}

		logOneNoMarkup(stream, tty, opts = {}) {
			if (!this.isEnabled(opts.stderr)) {
				return;
			}

			let msg = this.normalizeMessage(stream, tty, opts);
			if (opts.newline !== false) {
				msg += "\n";
			}

			// Track if there's going to be a completely empty line
			const hasDoubleNewline = msg === "\n" || msg.endsWith("\n\n");
			if (hasDoubleNewline) {
				this.streamsWithDoubleNewlineEnd.add(stream);
			} else {
				this.streamsWithDoubleNewlineEnd.delete(stream);
			}
			if (msg.endsWith("\n")) {
				this.streamsWithNewlineEnd.add(stream);
			} else {
				this.streamsWithNewlineEnd.delete(stream);
			}

			this.writeSpecific(stream, msg, opts);
		}

		logAllWithCategory(rawInner, args, opts) {
			if (!this.isEnabled(opts.stderr)) {
				return;
			}

			const inner = ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
				opts.markupTag,
				rawInner,
			);

			for (const stream of this.getStreams(opts.stderr)) {
				// Format the prefix, selecting it depending on if we're a unicode stream
				const prefixInner = stream.unicode ? opts.unicodePrefix : opts.rawPrefix;
				const prefix = ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
					"emphasis",
					___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
						opts.markupTag,
						this.getMessagePrefix() + prefixInner,
					),
				);

				// Should only be one line
				const {lines: prefixLines, width: prefixWidth} = this.markupify(
					stream,
					prefix,
				);
				const prefixLine = prefixLines[0];
				if (prefixLines.length !== 1) {
					throw new Error("Expected 1 prefix line");
				}

				const {lines} = this.markupify(stream, inner, prefixWidth);
				for (let i = 0; i < lines.length; i++) {
					let line = lines[i];
					if (i === 0) {
						line = "" + prefixLine + line;
					} else {
						line = "" + " ".repeat(prefixWidth) + line;
					}
					this.logOneNoMarkup(
						stream,
						line,
						Object.assign({noPrefix: true}, opts),
					);
				}
			}
		}

		success(msg, ...args) {
			this.logAllWithCategory(
				msg,
				args,
				{
					unicodePrefix: "\u2714 ",
					rawPrefix: "\u221a ",
					markupTag: "success",
				},
			);
		}

		error(msg, ...args) {
			this.logAllWithCategory(
				msg,
				args,
				{
					markupTag: "error",
					unicodePrefix: "\u2716 ",
					rawPrefix: "\xd7 ",
					stderr: true,
				},
			);
		}

		errorObj(err) {
			this.error(err.stack || err.message || err.name || "Unknown Error");
		}

		info(msg, ...args) {
			this.logAllWithCategory(
				msg,
				args,
				{
					unicodePrefix: "\u2139 ",
					rawPrefix: "i ",
					markupTag: "info",
				},
			);
		}

		warn(msg, ...args) {
			this.logAllWithCategory(
				msg,
				args,
				{
					unicodePrefix: "\u26a0 ",
					rawPrefix: "! ",
					markupTag: "warn",
					stderr: true,
				},
			);
		}

		verbose(msg, ...args) {
			if (this.isVerbose) {
				this.verboseForce(msg, args);
			}
		}

		verboseForce(msg, ...args) {
			this.logAllWithCategory(
				msg,
				args,
				{
					unicodePrefix: "\u26a1 ",
					rawPrefix: "* ",
					markupTag: "dim",
				},
			);
		}

		command(command) {
			this.logAll(
				"<dim>$ " + command + "</dim>",
				{
					nonTTY: "$ " + command,
				},
			);
		}

		processedList(items, callback, opts = {}) {
			if (items.length === 0) {
				// We make some assumptions that there's at least one item
				return {truncated: false};
			}

			let truncatedCount = 0;

			let start = opts.start || 0;
			if (opts.truncate !== undefined && items.length > opts.truncate) {
				truncatedCount = items.length - opts.truncate;
				items = items.slice(0, opts.truncate);
				start += truncatedCount;
			}

			let buff = "";

			for (const item of items) {
				const reporter = this.fork({
					streams: [],
				});
				const stream = reporter.attachCaptureStream("markup");
				callback(reporter, item);
				stream.remove();
				buff += "<li>" + stream.read() + "</li>";
			}

			if (opts.ordered) {
				this.logAll(
					___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
						"ol",
						buff,
						{start, reversed: opts.reverse},
					),
				);
			} else {
				this.logAll("<ul>" + buff + "</ul>");
			}

			if (truncatedCount > 0) {
				this.logAll(
					"<dim>and <number>" + truncatedCount + "</number> others...</dim>",
				);
				return {truncated: true};
			} else {
				return {truncated: false};
			}
		}

		list(items, opts = {}) {
			return this.processedList(
				items,
				(reporter, str) => {
					reporter.logAll(str, {newline: false});
				},
				opts,
			);
		}

		progress(opts) {
			if (this.isRemote) {
				return this.progressRemote(opts);
			} else {
				return this.progressLocal(opts);
			}
		}

		progressLocal(opts, onEnd) {
			const bar = new ___R$project$rome$$romejs$cli$reporter$Progress_ts$default(
				this,
				opts,
				() => {
					this.activeElements.delete(bar);
					if (onEnd !== undefined) {
						onEnd();
					}
				},
			);
			this.activeElements.add(bar);
			return bar;
		}

		progressRemote(opts) {
			const id =
				process.pid +
				":" +
				___R$$priv$project$rome$$romejs$cli$reporter$Reporter_ts$remoteProgressIdCounter++;

			this.sendRemoteClientMessage.send({
				type: "PROGRESS_CREATE",
				opts,
				id,
			});

			let closed = false;

			const dispatch = (message) => {
				if (!closed) {
					this.sendRemoteClientMessage.send(message);
				}
			};

			const end = () => {
				this.activeElements.delete(progress);
				this.remoteServerProgressBars.delete(id);
				closed = true;
			};

			const progress = {
				render() {
					// Don't do anything
					// This is called when columns have updated and we want to force a rerender
				},
				setCurrent: (current) => {
					dispatch({
						type: "PROGRESS_SET_CURRENT",
						current,
						id,
					});
				},
				setTotal: (total, approximate = false) => {
					dispatch({
						type: "PROGRESS_SET_TOTAL",
						total,
						approximate,
						id,
					});
				},
				setText: (text) => {
					dispatch({
						type: "PROGRESS_SET_TEXT",
						text,
						id,
					});
				},
				setApproximateETA: (duration) => {
					dispatch({
						type: "PROGRESS_SET_APPROXIMATE_ETA",
						duration,
						id,
					});
				},
				pushText: (text) => {
					dispatch({
						type: "PROGRESS_PUSH_TEXT",
						text,
						id,
					});
				},
				popText: (text) => {
					dispatch({
						type: "PROGRESS_POP_TEXT",
						text,
						id,
					});
				},
				tick: () => {
					dispatch({
						type: "PROGRESS_TICK",
						id,
					});
				},
				end: () => {
					dispatch({
						type: "PROGRESS_END",
						id,
					});
				},
				pause: () => {
					dispatch({
						type: "PROGRESS_PAUSE",
						id,
					});
				},
				resume: () => {
					dispatch({
						type: "PROGRESS_RESUME",
						id,
					});
				},
			};

			this.remoteServerProgressBars.set(
				id,
				{
					end,
				},
			);

			this.activeElements.add(progress);

			return progress;
		}
	}
	___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS = 100;


  // project-rome/@romejs/cli-reporter/types.ts
const ___R$project$rome$$romejs$cli$reporter$types_ts = {};

























  // project-rome/@romejs/cli-reporter/index.ts



  // project-rome/@romejs/cli-diagnostics/highlightCode.ts
// 100KB
	const ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$FILE_SIZE_MAX = 100_000;



	function ___R$project$rome$$romejs$cli$diagnostics$highlightCode_ts$default(
		opts,
	) {
		if (
			opts.input.length >
			___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$FILE_SIZE_MAX
		) {
			return ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
				opts.input,
			);
		}

		if (opts.language === "js") {
			// js-parser does not accept an "unknown" sourceType
			return ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$highlightJS(
				opts.input,
				opts.sourceType === undefined || opts.sourceType === "unknown"
					? "script"
					: opts.sourceType,
			);
		}

		if (opts.language === "json") {
			return ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$highlightJSON(
				opts.path,
				opts.input,
			);
		}

		return ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
			opts.input,
		);
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$reduce(
		input,
		tokens,
		callback,
	) {
		let prevEnd = 0;
		let buff = "";

		for (const token of tokens) {
			const start = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(token.start);
			const end = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(token.end);
			let value = input.slice(start, end);

			// Add on text between tokens
			buff += ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
				input.slice(prevEnd, start),
			);
			prevEnd = end;

			// We need to break up the token text into lines, so that we can easily split the highlighted newlines and have the ansi codes be unbroken
			const lines = value.split("\n");

			const values = lines.map((line) => {
				return callback(
					token,
					___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(line),
				);
			});

			buff += values.join("\n");
		}

		return buff;
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$invalidHighlight(
		line,
	) {
		return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
			"emphasis",
			___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
				"color",
				line,
				{bg: "red"},
			),
		);
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$highlightJSON(
		path,
		input,
	) {
		const tokens = ___R$project$rome$$romejs$codec$json$index_ts$tokenizeJSON({
			input,
			// Wont be used anywhere but activates JSON extensions if necessary
			path,
		});

		return ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$reduce(
			input,
			tokens,
			(token, value) => {
				// Try to keep the highlighting in line with JS where possible
				switch (token.type) {
					case "BlockComment":
					case "LineComment":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "brightBlack"},
						);

					case "String":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "green"},
						);

					case "Number":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "magenta"},
						);

					case "Word":
						switch (token.value) {
							case "true":
							case "false":
							case "null":
								return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
									"color",
									value,
									{fg: "cyan"},
								);

							default:
								return value;
						}

					case "Comma":
					case "Colon":
					case "Dot":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "yellow"},
						);

					case "BracketOpen":
					case "BracketClose":
					case "BraceOpen":
					case "BraceClose":
					case "Minus":
					case "Plus":
						return value;

					case "Invalid":
						return ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$invalidHighlight(
							value,
						);

					// Will never be hit
					case "EOF":
					case "SOF":
						return "";
				}
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$highlightJS(
		input,
		sourceType,
	) {
		const tokens = ___R$project$rome$$romejs$js$parser$index_ts$tokenizeJS(
			input,
			{
				sourceType,
				// js-parser requires a filename. Doesn't really matter since we'll never be producing an AST or diagnostics
				path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
					"unknown",
				),
			},
		);

		return ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$reduce(
			input,
			tokens,
			(token, value) => {
				const {type} = token;

				switch (type.label) {
					case "break":
					case "case":
					case "catch":
					case "continue":
					case "debugger":
					case "default":
					case "do":
					case "else":
					case "finally":
					case "for":
					case "function":
					case "if":
					case "return":
					case "switch":
					case "throw":
					case "try":
					case "var":
					case "const":
					case "while":
					case "with":
					case "new":
					case "this":
					case "super":
					case "class":
					case "extends":
					case "export":
					case "import":
					case "null":
					case "true":
					case "false":
					case "in":
					case "instanceof":
					case "typeof":
					case "void":
					case "delete":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "cyan"},
						);

					case "num":
					case "bigint":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "magenta"},
						);

					case "regexp":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "magenta"},
						);

					case "string":
					case "template":
					case "`":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "green"},
						);

					case "invalid":
						return ___R$$priv$project$rome$$romejs$cli$diagnostics$highlightCode_ts$invalidHighlight(
							value,
						);

					case "comment":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "brightBlack"},
						);

					case ",":
					case ";":
					case ":":
					case "::":
					case "${":
					case ".":
					case "?":
					case "?.":
						return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"color",
							value,
							{fg: "yellow"},
						);

					case "[":
					case "]":
					case "{":
					case "{|":
					case "}":
					case "|}":
					case "(":
					case ")":
						return value;

					case "=>":
					case "...":
					case "@":
					case "#":
					case "=":
					case "_=":
					case "++/--":
					case "!":
					case "~":
					case "??":
					case "||":
					case "&&":
					case "|":
					case "^":
					case "&":
					case "==/!=":
					case "</>":
					case "<</>>":
					case "+/-":
					case "%":
					case "*":
					case "/":
					case "**":
					case "jsxName":
					case "jsxText":
					case "jsxTagStart":
					case "jsxTagEnd":
					case "name":
					case "eof":
						return value;
				}
			},
		);
	}


  // project-rome/@romejs/cli-diagnostics/utils.ts
function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$normalizeTabs(str) {
		return str.replace(/\t/g, "  ");
	}

	function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$showInvisibles(
		str,
	) {
		let ret = "";
		for (const cha of str) {
			switch (cha) {
				case " ": {
					ret += "\xb7"; // Middle Dot, \u00B7
					break;
				}
				case "\r": {
					ret += "\u240d";
					break;
				}
				case "\n": {
					ret += "\u23ce"; // Return Symbol, \u23ce
					break;
				}
				case "\t": {
					ret += "\u21b9"; // Left Arrow To Bar Over Right Arrow To Bar, \u21b9
					break;
				}
				default: {
					ret += cha;
					break;
				}
			}
		}
		return ret;
	}

	function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(
		str,
	) {
		str = ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainTextString(
			str,
		);

		// Replace all whitespace with spaces
		str = str.replace(/[\s\n]+/g, " ");

		// Remove trailing dot
		str = str.replace(/\.+$/, "");

		// Remove surrounding quotes
		str = str.replace(/^"(.*?)"$/, "$1");

		return str;
	}

	function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$joinNoBreak(lines) {
		return "<nobr>" + lines.join("\n") + "</nobr>";
	}

	function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$splitLines(src) {
		return src.replace(/\t/g, " ").split(
			___R$project$rome$$romejs$js$parser$utils$whitespace_ts$NEWLINE,
		);
	}



	function ___R$project$rome$$romejs$cli$diagnostics$utils_ts$toLines(opts) {
		const raw = ___R$project$rome$$romejs$cli$diagnostics$utils_ts$splitLines(
			opts.input,
		);
		const highlighted = ___R$project$rome$$romejs$cli$diagnostics$utils_ts$splitLines(
			___R$project$rome$$romejs$cli$diagnostics$highlightCode_ts$default(opts),
		);

		if (raw.length !== highlighted.length) {
			throw new Error(
				"raw and highlighted line count mismatch " +
				raw.length +
				" !== " +
				highlighted.length,
			);
		}

		return {
			length: raw.length,
			raw,
			highlighted,
		};
	}


  // project-rome/@romejs/cli-diagnostics/constants.ts
const ___R$project$rome$$romejs$cli$diagnostics$constants_ts = {
		get GUTTER() {
			return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER;
		},
		get CODE_FRAME_INDENT() {
			return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT;
		},
		get CODE_FRAME_SELECTED_INDENT() {
			return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT;
		},
		get MAX_CODE_FRAME_LINES() {
			return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES;
		},
		get HALF_MAX_CODE_FRAME_LINES() {
			return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES;
		},
		get CODE_FRAME_CONTEXT_LINES() {
			return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
		},
		get RAW_CODE_MAX_LENGTH() {
			return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$RAW_CODE_MAX_LENGTH;
		},
		get MAX_PATCH_LINES() {
			return ___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_PATCH_LINES;
		},
	};
	const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER = " \u2502 ";
	const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT = "  ";
	const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT = "<error>></error> ";

	const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES = 8;
	const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES =
		___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES /
		2;
	const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES = 2;

	const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$RAW_CODE_MAX_LENGTH = 500;
	const ___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_PATCH_LINES = 50;


  // project-rome/@romejs/cli-diagnostics/buildPatchCodeFrame.ts
function ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(
		diffs,
	) {
		return diffs.map(([type, text]) => {
			if (
				type ===
				___R$project$rome$$romejs$string$diff$index_ts$diffConstants.DELETE
			) {
				return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
					"error",
					___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
						___R$project$rome$$romejs$cli$diagnostics$utils_ts$showInvisibles(
							text,
						),
					),
				);
			} else if (
				type ===
				___R$project$rome$$romejs$string$diff$index_ts$diffConstants.ADD
			) {
				return ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
					"success",
					___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
						___R$project$rome$$romejs$cli$diagnostics$utils_ts$showInvisibles(
							text,
						),
					),
				);
			} else {
				// type === diffConstants.EQUAL
				return ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					___R$project$rome$$romejs$cli$diagnostics$utils_ts$normalizeTabs(text),
				);
			}
		}).join("");
	}

	const ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$DELETE_MARKER = ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
		"error",
		"-",
	);
	const ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$ADD_MARKER = ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
		"success",
		"+",
	);

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatSingleLineMarker(
		text,
	) {
		return ___R$project$rome$$romejs$string$markup$escape_ts$markup`<emphasis>${text}</emphasis>:`;
	}

	function ___R$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$default(
		item,
		verbose,
	) {
		const diffsByLine = ___R$project$rome$$romejs$string$diff$index_ts$groupDiffByLines(
			item.diff,
		);
		let lastVisibleLine = -1;

		// Calculate the parts of the diff we should show
		const shownLines = new Set();
		for (let i = 0; i < diffsByLine.length; i++) {
			const diffs = diffsByLine[i];

			let hasChange = false;
			for (const [type] of diffs) {
				if (
					type ===
					___R$project$rome$$romejs$string$diff$index_ts$diffConstants.DELETE ||
					type ===
					___R$project$rome$$romejs$string$diff$index_ts$diffConstants.ADD
				) {
					hasChange = true;
					break;
				}
			}

			if (hasChange) {
				for (
					let start =
						i -
						___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
					start <
					i +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES;
					start++
				) {
					shownLines.add(start);

					if (start > lastVisibleLine) {
						lastVisibleLine = start;
					}
				}
			}
		}

		const lineLength = String(lastVisibleLine).length;

		// Don't output a gutter if there's only a single line
		const singleLine = diffsByLine.length === 1;

		const {legend} = item;
		const frame = [];
		let displayedLines = 0;
		let truncated = false;
		let lastDisplayedLine = -1;

		const skippedLine =
			"<emphasis>" +
			___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
			".".repeat(lineLength) +
			___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER +
			"</emphasis>";

		// Build the actual frame
		for (let i = 0; i < diffsByLine.length; i++) {
			if (shownLines.has(i) === false) {
				continue;
			}

			displayedLines++;

			if (
				!verbose &&
				displayedLines >
				___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_PATCH_LINES
			) {
				truncated = true;
				continue;
			}

			const diffs = diffsByLine[i];
			const lineNo = i + 1;

			const deletions = [];
			const addition = [];

			let hasDeletions = false;
			let hasAddition = false;

			for (const tuple of diffs) {
				let [type] = tuple;

				if (
					type ===
					___R$project$rome$$romejs$string$diff$index_ts$diffConstants.DELETE
				) {
					hasDeletions = true;
					deletions.push(tuple);
				}

				if (
					type ===
					___R$project$rome$$romejs$string$diff$index_ts$diffConstants.ADD
				) {
					hasAddition = true;
					addition.push(tuple);
				}

				if (
					type ===
					___R$project$rome$$romejs$string$diff$index_ts$diffConstants.EQUAL
				) {
					addition.push(tuple);
					deletions.push(tuple);
				}
			}

			if (lastDisplayedLine !== lineNo - 1 && lastDisplayedLine !== -1) {
				frame.push(skippedLine);
			}

			let gutterWithLine = "";
			let gutterNoLine = "";
			let deleteMarker = ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$DELETE_MARKER;
			let addMarker = ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$ADD_MARKER;

			if (!singleLine) {
				gutterWithLine =
					"<emphasis>" +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
					'<pad align="right" width="' +
					lineLength +
					'">' +
					lineNo +
					"</pad>" +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER +
					"</emphasis>";
				gutterNoLine =
					"<emphasis>" +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
					" ".repeat(lineLength) +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER +
					"</emphasis>";
			}

			if (singleLine && legend !== undefined) {
				addMarker = ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatSingleLineMarker(
					legend.add,
				);
				deleteMarker = ___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatSingleLineMarker(
					legend.delete,
				);
			}

			if (hasDeletions) {
				const gutter = hasAddition ? gutterNoLine : gutterWithLine;
				frame.push(
					"" +
					gutter +
					deleteMarker +
					" " +
					___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(
						deletions,
					),
				);
			}

			if (hasAddition) {
				frame.push(
					"" +
					gutterWithLine +
					addMarker +
					" " +
					___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(
						addition,
					),
				);
			}

			if (!hasAddition && !hasDeletions) {
				// Output one of the lines, they're the same
				frame.push(
					gutterWithLine +
					"  " +
					___R$$priv$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$formatDiffLine(
						addition,
					),
				);
			}

			lastDisplayedLine = lineNo;
		}

		if (truncated) {
			frame.push(
				skippedLine +
				" <dim><number>" +
				(displayedLines -
				___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_PATCH_LINES) +
				"</number> more lines truncated</dim>",
			);
		}

		if (legend !== undefined && !singleLine) {
			frame.push("");
			frame.push(
				"<error>- " +
				___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					legend.delete,
				) +
				"</error>",
			);
			frame.push(
				"<success>+ " +
				___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					legend.add,
				) +
				"</success>",
			);
			frame.push("");
		}

		return {
			truncated,
			frame: ___R$project$rome$$romejs$cli$diagnostics$utils_ts$joinNoBreak(
				frame,
			),
		};
	}


  // project-rome/@romejs/cli-diagnostics/buildMessageCodeFrame.ts
function ___R$$priv$project$rome$$romejs$cli$diagnostics$buildMessageCodeFrame_ts$createPointer(
		markerMessage,
		line,
		markerStart,
		markerEnd,
	) {
		let result = "";

		let markerSize = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
			___R$project$rome$$romejs$ob1$index_ts$ob1Sub(markerEnd, markerStart),
		);

		// If the range contains tabs then increase the marker size
		for (
			let i = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(markerStart);
			i < ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(markerEnd);
			i++
		) {
			const char = line[i];
			if (char === "\t") {
				markerSize++;
			}
		}

		const pointerLength = Math.max(markerSize, 1);

		// Skip the pointer if it's pointing at the last character
		let skipPointer =
			pointerLength === 1 &&
			___R$project$rome$$romejs$ob1$index_ts$ob1Get0(markerEnd) >= line.length;

		if (!skipPointer) {
			// Add indentation, handling hard tabs as two soft spaces
			for (
				let i = 0;
				i < ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(markerStart);
				i++
			) {
				const char = line[i];
				if (char === "\t") {
					// normalizeTabs will be called on this line and this replacement made
					result += "  ";
				} else {
					result += " ";
				}
			}

			// Add pointer
			result +=
				"<error><emphasis>" + "^".repeat(pointerLength) + "</emphasis></error>";
		}

		// Add marker
		if (markerMessage !== "") {
			result += " " + markerMessage;
		}

		if (result === "") {
			return undefined;
		} else {
			return result;
		}
	}

	function ___R$project$rome$$romejs$cli$diagnostics$buildMessageCodeFrame_ts$default(
		sourceText,
		allLines,
		start,
		end,
		markerMessage,
	) {
		if (allLines.length === 0 || start === undefined || end === undefined) {
			if (markerMessage === "") {
				return "";
			} else {
				return "<nobr>" + markerMessage + "</nobr>";
			}
		}

		const startLineIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1To0(
			start.line,
		);
		let endLineIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1To0(
			end.line,
		);

		// Increase the amount of lines we should show for "context"
		let contextStartIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
			Math.max(
				0,
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(startLineIndex) -
				___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES,
			),
		);
		let contextEndIndex = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
			Math.min(
				allLines.length - 1,
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(endLineIndex) +
				___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_CONTEXT_LINES,
			),
		);

		let maxVisibleLineNo = 0;

		let formattedLines = [];
		for (
			let i = contextStartIndex;
			i <= contextEndIndex;
			i = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(i)
		) {
			let rawLine = allLines.raw[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				i,
			)];
			let highlightLine = allLines.highlighted[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				i,
			)];
			if (highlightLine === undefined || rawLine === undefined) {
				continue;
			}

			// Ensure that the frame doesn't start with whitespace
			if (
				rawLine.trim() === "" &&
				formattedLines.length === 0 &&
				i !== startLineIndex
			) {
				continue;
			}

			let pointer;

			// If this is within the highlighted line range
			const shouldHighlight = i >= startLineIndex && i <= endLineIndex;

			if (shouldHighlight) {
				if (i === startLineIndex && i === endLineIndex) {
					// Only line in the selection
					pointer = ___R$$priv$project$rome$$romejs$cli$diagnostics$buildMessageCodeFrame_ts$createPointer(
						markerMessage,
						rawLine,
						start.column,
						end.column,
					);
				} else if (i === startLineIndex) {
					// First line in selection
					pointer = ___R$$priv$project$rome$$romejs$cli$diagnostics$buildMessageCodeFrame_ts$createPointer(
						"",
						rawLine,
						start.column,
						// line could be highlighted
						___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(rawLine.length),
					);
				} else if (i === endLineIndex) {
					// Last line in selection
					pointer = ___R$$priv$project$rome$$romejs$cli$diagnostics$buildMessageCodeFrame_ts$createPointer(
						markerMessage,
						rawLine,
						___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
						end.column,
					);
				}
			}

			// Replace hard tabs with two spaces
			highlightLine = ___R$project$rome$$romejs$cli$diagnostics$utils_ts$normalizeTabs(
				highlightLine,
			);

			const lineNo = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0To1(i);
			let gutter =
				"" +
				String(lineNo) +
				___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER;

			if (shouldHighlight) {
				gutter =
					"" +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_SELECTED_INDENT +
					gutter;
			} else {
				gutter =
					"" +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
					gutter;
			}

			formattedLines.push({
				pointer,
				gutter,
				line: highlightLine,
			});

			maxVisibleLineNo = ___R$project$rome$$romejs$ob1$index_ts$ob1Get0(i) + 1;
		}

		// If we have too many lines in our selection, then collapse them to an ellipsis
		const pruned =
			formattedLines.length >
			___R$project$rome$$romejs$cli$diagnostics$constants_ts$MAX_CODE_FRAME_LINES +
			2;
		if (pruned) {
			const start = formattedLines.slice(
				0,
				___R$project$rome$$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES,
			);
			const end = formattedLines.slice(
				-___R$project$rome$$romejs$cli$diagnostics$constants_ts$HALF_MAX_CODE_FRAME_LINES,
			);
			formattedLines = start.concat([undefined], end);
		}

		// Remove trailing blank lines
		for (let i = formattedLines.length - 1; i >= 0; i--) {
			const info = formattedLines[i];
			if (info !== undefined && info.line === "") {
				formattedLines.pop();
			} else {
				break;
			}
		}

		// If there's no lines to target then return the normal marker
		if (
			formattedLines.length === 0 ||
			end.line === ___R$project$rome$$romejs$ob1$index_ts$ob1Number1Neg1 ||
			start.line === ___R$project$rome$$romejs$ob1$index_ts$ob1Number1Neg1
		) {
			if (markerMessage === "") {
				return "";
			} else {
				return "<nobr>" + markerMessage + "</nobr>";
			}
		}

		// Calculate max size of gutter, this is the maximum visible line plus the futter length plus the frame indent
		const lastLine = formattedLines[formattedLines.length - 1];
		if (lastLine === undefined) {
			throw new Error("Expected there to be a last line");
		}

		const maxGutterLength =
			String(maxVisibleLineNo).length +
			___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER.length +
			___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT.length;

		// If what the marker is highlighting equals the marker message then it's redundant so don't show the message
		if (markerMessage !== "") {
			const text = sourceText.slice(
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(start.index),
				___R$project$rome$$romejs$ob1$index_ts$ob1Get0(end.index),
			);
			if (
				___R$project$rome$$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(
					text,
				) ===
				___R$project$rome$$romejs$cli$diagnostics$utils_ts$cleanEquivalentString(
					___R$project$rome$$romejs$string$markup$format_ts$markupToPlainTextString(
						markerMessage,
					),
				)
			) {
				markerMessage = "";
			}
		}

		// Output no gutter with a soft indent if this is true
		if (formattedLines.length === 1) {
			const selection = formattedLines[0];
			if (selection === undefined) {
				throw new Error(
					"Expected a selection? undefined is only valid here as an omitted line signifier",
				);
			}

			const result = [
				"" +
				___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
				selection.line,
			];
			if (selection.pointer !== undefined) {
				result.push(
					"" +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$CODE_FRAME_INDENT +
					selection.pointer,
				);
			}

			return ___R$project$rome$$romejs$cli$diagnostics$utils_ts$joinNoBreak(
				result,
			);
		}

		// Build up the line we display when source lines are omitted
		const omittedLine =
			'<emphasis><pad align="right" width="' +
			maxGutterLength +
			'">...</pad></emphasis>' +
			___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER;

		// Build the frame
		const result = [];
		for (const selection of formattedLines) {
			if (!selection) {
				result.push(omittedLine);
				continue;
			}

			const {pointer, gutter, line} = selection;

			result.push(
				'<pad align="right" width="' +
				maxGutterLength +
				'"><emphasis>' +
				gutter +
				"</emphasis></pad>" +
				line,
			);

			if (pointer !== undefined) {
				result.push(
					'<pad align="right" width="' +
					maxGutterLength +
					'"><emphasis>' +
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$GUTTER +
					"</emphasis></pad>" +
					pointer,
				);
			}
		}

		return ___R$project$rome$$romejs$cli$diagnostics$utils_ts$joinNoBreak(
			result,
		);
	}


  // project-rome/@romejs/cli-flags/serializeCLIFlags.ts
const ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts = {
		serializeCLIFlags: ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags,
	};




	function ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
		{
			args = [],
			flags = {},
			programName,
			commandName,
			defaultFlags = {},
			shorthandFlags = new Set(),
			incorrectCaseFlags = new Set(),
			prefix = "$ ",
		},
		target,
	) {
		let startColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1;
		let endColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1;
		let code = prefix;

		function setStartColumn() {
			startColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
				code.length,
			);
		}

		function setEndColumn() {
			// Never point to a space
			if (code[code.length - 1] === " ") {
				endColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
					code.length - 1,
				);
			} else {
				endColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
					code.length,
				);
			}
		}

		if (programName !== undefined) {
			if (target.type === "program") {
				setStartColumn();
			}

			code += programName + " ";

			if (target.type === "program") {
				setEndColumn();
			}
		}

		if (commandName !== undefined) {
			if (target.type === "command") {
				setStartColumn();
			}

			code += commandName + " ";

			if (target.type === "command") {
				setEndColumn();
			}
		}

		// Add args
		for (let i = 0; i < args.length; i++) {
			const arg = args[i];

			let isTarget = false;
			if (target.type === "arg" && i === target.key) {
				isTarget = true;
			}
			if (target.type === "arg-range" && target.from === i) {
				isTarget = true;
			}

			if (isTarget) {
				setStartColumn();
			}

			code += arg + " ";

			let isEndTarget = isTarget;

			// We are the end target if we're within the from-to range or we're greater than from with no to
			if (
				target.type === "arg-range" &&
				i > target.from &&
				(target.to === undefined || target.to <= i)
			) {
				isEndTarget = true;
			}

			if (isEndTarget) {
				setEndColumn();
			}
		}

		// Add flags
		for (const key in flags) {
			const val = flags[key];

			// Ignore pointless default values
			if (val === defaultFlags[key]) {
				continue;
			}

			const values = Array.isArray(val) ? val : [val];

			const isTarget = target.type === "flag" && key === target.key;

			if (isTarget) {
				setStartColumn();
			}

			for (const val of values) {
				const flagPrefix = shorthandFlags.has(key) ? "-" : "--";
				const kebabKey = incorrectCaseFlags.has(key)
					? key
					: ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(
							key,
						);
				if (val === false) {
					code += flagPrefix + "no-" + kebabKey + " ";
				} else {
					code += "" + flagPrefix + kebabKey + " ";
				}

				// Booleans are always indicated with just their flag
				if (typeof val !== "boolean") {
					// Only point to the value for flags that specify it
					if (
						isTarget &&
						target.type === "flag" &&
						(target.target === "value" || target.target === "inner-value")
					) {
						startColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
							code.length,
						);
					}

					// Number or string
					code += String(val) + " ";
				}
			}

			if (isTarget) {
				setEndColumn();
			}
		}

		if (
			startColumn === ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1 ||
			endColumn === ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1
		) {
			startColumn = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
				code.length - 1,
			);
			endColumn = startColumn;
		}

		return {
			language: "shell",
			mtime: undefined,
			sourceText: code,
			filename: "argv",
			start: {
				line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
				column: startColumn,
				index: startColumn,
			},
			end: {
				line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
				column: endColumn,
				index: endColumn,
			},
		};
	}


  // project-rome/@romejs/cli-flags/Parser.ts












	function ___R$$priv$project$rome$$romejs$cli$flags$Parser_ts$splitCommandName(
		cmd,
	) {
		return cmd.split(" ");
	}

	// Whether we can display this value in help
	function ___R$$priv$project$rome$$romejs$cli$flags$Parser_ts$isDisplayableHelpValue(
		value,
	) {
		return typeof value === "string" || typeof value === "number";
	}







	class ___R$project$rome$$romejs$cli$flags$Parser_ts$default {
		constructor(reporter, opts, rawArgs) {
			this.reporter = reporter;
			this.opts = opts;

			this.shorthandFlags = new Set();
			this.incorrectCaseFlags = new Set();
			this.declaredFlags = new Map();
			this.defaultFlags = new Map();
			this.flags = new Map();
			this.args = [];

			// These are used to track where we should insert an argument for a boolean flag value
			this.flagToArgIndex = new Map();
			this.flagToArgOffset = 0;

			this.consumeRawArgs(rawArgs);

			this.commands = new Map();
			this.ranCommand = undefined;
			this.currentCommand = undefined;
		}

		looksLikeFlag(flag) {
			return (flag == null ? undefined : flag[0]) === "-";
		}

		toCamelCase(name) {
			const camelName = ___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(
				name,
			);

			// Don't allow passing in straight camelcased names
			if (
				___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(name) !==
				name
			) {
				this.incorrectCaseFlags.add(name);
			}

			return camelName;
		}

		setFlag(key, value) {
			let newValue = value;
			const existing = this.flags.get(key);
			if (existing !== undefined) {
				if (Array.isArray(existing)) {
					newValue = [...existing, value];
				} else {
					newValue = [existing, value];
				}
			}
			this.flags.set(key, newValue);
		}

		consumeRawArgs(rawArgs) {
			while (rawArgs.length > 0) {
				const arg = String(rawArgs.shift());

				if (arg === "--") {
					// We consider a -- by itself to halt parsing of args, the rest of the remaining args are added to _
					this.args = this.args.concat(rawArgs);
					break;
				} else if (arg[0] === "-") {
					// Clean the argument by stripping off the dashes
					const name = arg[1] === "-" ? arg.slice(2) : arg.slice(1);

					// Flags beginning with no- are always false
					if (name.startsWith("no-")) {
						const camelName = this.toCamelCase(name.slice(3));
						this.setFlag(camelName, false);
						continue;
					}

					// Allow for arguments to be passed as --foo=bar
					const equalsIndex = name.indexOf("=");
					if (equalsIndex !== -1) {
						const cleanName = this.toCamelCase(name.slice(0, equalsIndex));
						const value = name.slice(equalsIndex + 1);
						this.setFlag(cleanName, value);
						continue;
					}

					const camelName = this.toCamelCase(name);

					// If the next argument is a flag or we're at the end of the args then just set it to `true`
					if (rawArgs.length === 0 || this.looksLikeFlag(rawArgs[0])) {
						this.setFlag(camelName, true);
					} else {
						// Otherwise, take that value
						this.setFlag(camelName, String(rawArgs.shift()));
					}

					this.flagToArgIndex.set(camelName, this.args.length);

					if (arg[0] === "-" && arg[1] !== "-") {
						this.shorthandFlags.add(camelName);
					}
				} else {
					// Not a flag and hasn't been consumed already by a previous arg so it must be a file
					this.args.push(arg);
				}
			}
		}

		getFlagsConsumer() {
			const defaultFlags = {};

			const flags = {};
			for (const [key, value] of this.flags) {
				flags[___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(
					key,
				)] = value;
			}

			return ___R$project$rome$$romejs$consume$index_ts$consume({
				filePath: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
					"argv",
				),
				value: flags,
				onDefinition: (def, valueConsumer) => {
					const key = def.objectPath.join(".");

					// Detect root object
					if (key === "") {
						return;
					}

					const value = flags[key];

					// Allow omitting a string flag value
					if (def.type === "string" && value === true) {
						valueConsumer.setValue("");
					}

					this.declareArgument({
						name: key,
						command: this.currentCommand,
						definition: def,
					});
					defaultFlags[key] = (def.default);

					// We've parsed arguments like `--foo bar` as `{foo: 'bar}`
					// However, --foo may be a boolean flag, so `bar` needs to be correctly added to args
					if (
						def.type === "boolean" &&
						value !== true &&
						value !== false &&
						value !== undefined
					) {
						const argIndex = this.flagToArgIndex.get(key);
						if (argIndex === undefined) {
							throw new Error("No arg index. Should always exist.");
						}

						// Insert the argument at the correct place
						this.args.splice(argIndex + this.flagToArgOffset, 0, String(value));

						// Increase offset to correct subsequent insertions
						this.flagToArgOffset++;

						//
						valueConsumer.setValue(true);
					}
				},
				context: {
					category: "flags/invalid",
					normalizeKey: (key) => {
						return this.incorrectCaseFlags.has(key)
							? key
							: ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(
									key,
								);
					},
					getOriginalValue: (keys) => {
						return flags[keys[0]];
					},
					getDiagnosticPointer: (keys, target) => {
						const {programName} = this.opts;

						return ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
							{
								programName,
								commandName: this.currentCommand,
								args: this.args,
								defaultFlags,
								flags,
								incorrectCaseFlags: this.incorrectCaseFlags,
								shorthandFlags: this.shorthandFlags,
							},
							{
								type: "flag",
								key: String(keys[0]),
								target,
							},
						);
					},
				},
			});
		}

		hasArg(name) {
			return this.flags.has(name) && this.flags.get(name) !== undefined;
		}

		declareArgument(decl) {
			// Commands may have colliding flags, this is only a problem in help mode, so make it unique
			const key =
				decl.command === undefined ? decl.name : decl.command + "." + decl.name;

			// Ensure it hasn't been declared more than once
			if (this.declaredFlags.has(key)) {
				throw new Error("Already declared argument " + key);
			}

			// Declare argument
			this.declaredFlags.set(key, decl);
			this.defaultFlags.set(key, decl.definition.default);
		}

		getInterface() {
			return new ___R$project$rome$$romejs$cli$flags$Parser_ts$ParserInterface(
				this,
			);
		}

		async maybeDefineCommandFlags(command, consumer) {
			// A command name could be made of multiple strings
			const commandParts = ___R$$priv$project$rome$$romejs$cli$flags$Parser_ts$splitCommandName(
				command.name,
			);
			for (let i = 0; i < commandParts.length; i++) {
				if (commandParts[i] !== this.args[i]) {
					return;
				}
			}

			// Remove command name from arguments
			this.args = this.args.slice(commandParts.length);
			return await this.defineCommandFlags(command, consumer);
		}

		checkBadFlags(consumer, definedCommand) {
			// Ignore flags from command and root parser options
			const ignoreFlags = [
				...((definedCommand !== undefined && definedCommand.command.ignoreFlags) || []),
				...(this.opts.ignoreFlags || []),
			];
			for (const key of ignoreFlags) {
				this.shorthandFlags.delete(key);
				this.incorrectCaseFlags.delete(key);
				consumer.markUsedProperty(key);
			}

			for (const shorthandName of this.shorthandFlags) {
				consumer.get(shorthandName).unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.FLAGS.UNSUPPORTED_SHORTHANDS,
				);
			}

			for (const incorrectName of this.incorrectCaseFlags) {
				consumer.get(incorrectName).unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.FLAGS.INCORRECT_CASED_FLAG(
						incorrectName,
					),
				);
			}

			consumer.enforceUsedProperties("flag", false);
		}

		async init() {
			const consumer = this.getFlagsConsumer();

			// Show help for --version
			const version = this.opts.version;
			if (version !== undefined) {
				const shouldDisplayVersion = consumer.get(
					"version",
					{
						description: "Show the version",
					},
				).asBoolean(false);
				if (shouldDisplayVersion) {
					this.reporter.logAll(version);
					process.exit(0);
				}
			}

			// i could add a flag for dev-rome itself
			// i could take the input command name from the flag
			const generateAutocomplete = consumer.get(
				"generateAutocomplete",
				{
					description: "Generate a shell autocomplete",
					inputName: "shell",
				},
			).asStringSetOrVoid(["fish", "bash"]);
			if (generateAutocomplete !== undefined) {
				await this.generateAutocomplete(generateAutocomplete);
				process.exit(0);
			}

			// Show help for --help
			const shouldShowHelp = consumer.get(
				"help",
				{
					description: "Show this help screen",
				},
			).asBoolean(false);

			let definedCommand;

			const rootFlags = await consumer.bufferDiagnostics(async (consumer) => {
				const rootFlags = this.opts.defineFlags(consumer);

				for (const [key, command] of this.commands) {
					const definedFlags = await this.maybeDefineCommandFlags(
						command,
						consumer,
					);
					if (definedFlags !== undefined) {
						this.currentCommand = key;
						definedCommand = {flags: definedFlags, command};
						break;
					}
				}

				if (!shouldShowHelp) {
					this.checkBadFlags(consumer, definedCommand);
				}

				this.currentCommand = undefined;

				return rootFlags;
			});

			// Show help for --help
			if (shouldShowHelp) {
				await this.showHelp(
					definedCommand === undefined ? undefined : definedCommand.command,
				);
				process.exit(1);
			}

			if (definedCommand !== undefined) {
				this.ranCommand = definedCommand.command;
				await definedCommand.command.callback(definedCommand.flags);
			}

			return rootFlags;
		}

		buildOptionsHelp(keys) {
			const optionOutput = [];
			let argColumnLength = 0;

			// Build up options, we need to do this to line up the columns correctly
			for (const key of keys) {
				const decl = this.declaredFlags.get(key);

				const {definition: def} = decl;
				const {metadata} = def;
				let argName = decl.name;
				let argCol = ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(
					decl.name,
				);

				// For booleans that default to `true`, show the --no- version as that'll be what users should use
				if (def.type === "boolean" && def.default === true) {
					argCol = "--no-" + argCol;
					argName = "no-" + argName;
				} else {
					argCol = "--" + argCol;
				}

				// Add input specifier unless a boolean
				if (def.type !== "boolean") {
					let {inputName} = metadata;

					if (inputName === undefined) {
						if (def.type === "number") {
							inputName = "num";
						} else {
							inputName = "input";
						}
					}

					argCol += " <" + inputName + ">";
				}

				// Set arg col length if we'll be longer
				if (argColumnLength < argCol.length) {
					argColumnLength = argCol.length;
				}

				let descCol =
					metadata.description === undefined
						? "no description found"
						: metadata.description;

				const {default: defaultValue} = def;
				if (
					defaultValue !== undefined &&
					___R$$priv$project$rome$$romejs$cli$flags$Parser_ts$isDisplayableHelpValue(
						defaultValue,
					)
				) {
					descCol += " (default: " + JSON.stringify(defaultValue) + ")";
				}

				if (def.type === "string" && def.allowedValues !== undefined) {
					const displayAllowedValues = def.allowedValues.filter((item) =>
						___R$$priv$project$rome$$romejs$cli$flags$Parser_ts$isDisplayableHelpValue(
							item,
						)
					);
					if (displayAllowedValues !== undefined) {
						descCol += " (values: " + displayAllowedValues.join("|") + ")";
					}
				}

				optionOutput.push({
					argName,
					arg: ___R$project$rome$$romejs$string$markup$escape_ts$markup`<color fg="brightBlack">${argCol}</color>`,
					description: descCol,
				});
			}

			// Sort options by argument name
			optionOutput.sort((a, b) =>
				___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
					a.argName,
					b.argName,
				)
			);

			// Build table rows
			return optionOutput.map((opt) => [
				{align: "right", value: opt.arg},
				opt.description,
			]);
		}

		showUsageHelp(description, usage = "[flags]", prefix) {
			const {reporter} = this;
			const {programName} = this.opts;

			reporter.section(
				"Usage",
				() => {
					if (description !== undefined) {
						reporter.logAll(description);
						reporter.br(true);
					}

					const commandParts = [programName];
					if (prefix !== undefined) {
						commandParts.push(prefix);
					}
					commandParts.push(usage);

					const command = commandParts.join(" ");
					reporter.command(command);
				},
			);
		}

		showFocusedCommandHelp(command) {
			const {reporter} = this;
			const {name, usage, description, examples} = command;

			reporter.br(true);
			this.showUsageHelp(description, usage, name);
			this.showHelpExamples(examples, name);

			// Find arguments that belong to this command
			const argKeys = [];
			for (const [key, decl] of this.declaredFlags) {
				if (decl.command === name) {
					argKeys.push(key);
				}
			}

			const optRows = this.buildOptionsHelp(argKeys);
			if (optRows.length > 0) {
				reporter.section(
					"Command Flags",
					() => {
						reporter.table([], optRows);
					},
				);
			}

			reporter.section(
				"Global Flags",
				() => {
					reporter.info("To view global flags run");
					reporter.command("rome --help");
				},
			);
		}

		showGlobalFlags() {
			const {reporter} = this;
			reporter.section(
				"Global Flags",
				() => {
					// Show options not attached to any commands
					const lonerArgKeys = [];
					for (const [key, decl] of this.declaredFlags) {
						if (decl.command === undefined) {
							lonerArgKeys.push(key);
						}
					}

					reporter.table([], this.buildOptionsHelp(lonerArgKeys));
				},
			);
		}

		async generateAutocomplete(shell) {
			const {reporter} = this;

			// Execute all command defineFlags. Only one is usually ran when the arguments match the command name.
			// But to generate autocomplete we want all the flags to be declared for all commands.

			const flags = this.getFlagsConsumer();
			for (const command of this.commands.values()) {
				// capture() will cause diagnostics to be suppressed
				const {consumer} = flags.capture();
				await this.defineCommandFlags(command, consumer);
			}

			const {programName} = this.opts;

			switch (shell) {
				case "bash": {
					reporter.logAllNoMarkup(this.genBashCompletions(programName));
					break;
				}
				case "fish": {
					reporter.logAllNoMarkup(this.genFishCompletions(programName));
					break;
				}
			}
		}

		genFishCompletions(prg) {
			let script = "";
			const scriptPre = "complete -c " + prg;

			// add rome
			script += scriptPre + " -f\n";

			// add command completions
			for (let [subcmd, meta] of this.commands.entries()) {
				script +=
					scriptPre +
					" -n '__fish_use_subcommand' -a '" +
					subcmd +
					"' -d '" +
					meta.description +
					"'\n";
			}

			// add flag completions
			for (let meta of this.declaredFlags.values()) {
				const subcmdCond =
					meta.command === undefined
						? ""
						: "-n '__fish_seen_subcommand_from " + meta.command + "'";
				script += scriptPre + " " + subcmdCond + " -l '" + meta.name + "'\n";
			}

			return script;
		}

		genBashCompletions(prg) {
			let romeCmds = "";
			let commandFuncs = "";
			let globalFlags = "";
			let cmdFlagMap = new Map();

			for (let subcmd of this.commands.keys()) {
				romeCmds += subcmd + " ";
			}

			for (let meta of this.declaredFlags.values()) {
				if (meta.command === undefined) {
					globalFlags += "--" + meta.name + " ";
				} else {
					if (cmdFlagMap.has(meta.command)) {
						cmdFlagMap.set(
							meta.command,
							cmdFlagMap.get(meta.command) + " --" + meta.name,
						);
					} else {
						cmdFlagMap.set(meta.command, "--" + meta.name);
					}
				}
			}

			for (let [cmd, flags] of cmdFlagMap.entries()) {
				commandFuncs +=
					"\n      __" +
					prg +
					"_" +
					cmd +
					'()\n      {\n        cmds="";\n        local_flags="' +
					flags +
					'"\n      }\n      ';
			}

			let romeFunc =
				"\n      __" +
				prg +
				'()\n      {\n          cmds="' +
				romeCmds +
				'"\n          local_flags="";\n      }\n    ';

			let mainScript =
				'\n      #!/usr/bin/env bash\n      global_flags="' +
				globalFlags +
				'"\n\n      # initial state\n      cmds=""\n      local_flags=""\n      \n      __is_flag()\n      {\n        case $1 in\n          -*) echo "true"\n        esac\n      }\n      \n      __' +
				prg +
				'_gen_completions()\n      {\n        local suggestions func flags index\n         \n        index="$((${#COMP_WORDS[@]} - 1))"\n      \n        flags="$global_flags $local_flags"\n      \n        func="_"\n      \n        for ((i=0; i < index; i++))\n        do\n          leaf=$(echo ${COMP_WORDS[$i]} | grep -o \'[^/]*$\')\n          if [[ ! $(__is_flag $leaf) ]]; then\n            func="${func}_${leaf}"\n          fi\n        done\n          \n        $func 2> /dev/null\n      \n        if [[ $(__is_flag ${COMP_WORDS[$index]}) ]]; then\n          suggestions=$flags \n        else\n          suggestions=$cmds\n        fi\n\n        COMPREPLY=($(compgen -W "$suggestions" -- "${COMP_WORDS[$index]}"))\n      }\n    ';

			return ___R$project$rome$$romejs$string$utils$dedent_ts$dedent`
      ${mainScript}
      ${commandFuncs}
      ${romeFunc}
      complete -F __${prg}_gen_completions ${prg}
    `;
		}

		async showHelp(command = this.ranCommand) {
			if (command !== undefined) {
				this.showFocusedCommandHelp(command);
				return;
			}

			const {reporter} = this;
			const {description, usage, examples, programName} = this.opts;

			this.showUsageHelp(description, usage);
			this.showGlobalFlags();

			// Sort commands into their appropriate categories for output
			const commandsByCategory = new Map();
			const categoryNames = new Set();
			for (const [name, command] of this.commands) {
				if (name[0] === "_") {
					continue;
				}

				const {category} = command;
				let commandsForCategory = commandsByCategory.get(category);
				if (commandsForCategory === undefined) {
					commandsForCategory = [];
					commandsByCategory.set(category, commandsForCategory);
				}
				commandsForCategory.push(command);
				categoryNames.add(category);
			}

			reporter.section(
				"Commands",
				() => {
					const sortedCategoryNames = Array.from(categoryNames).sort();

					// Always make sure categoryless commands are displayed first
					if (sortedCategoryNames.includes(undefined)) {
						sortedCategoryNames.splice(
							sortedCategoryNames.indexOf(undefined),
							1,
						);
						sortedCategoryNames.unshift(undefined);
					}

					for (const category of sortedCategoryNames) {
						const commands = commandsByCategory.get(category);

						if (category !== undefined) {
							reporter.logAll("<emphasis>" + category + " Commands</emphasis>");
						}

						// Sort by name
						commands.sort((a, b) => a.name.localeCompare(b.name));

						reporter.list(
							commands.map((cmd) => {
								return (
									"<emphasis>" +
									cmd.name +
									"</emphasis> " +
									(cmd.description === undefined ? "" : cmd.description)
								);
							}),
						);
						reporter.br();
					}

					reporter.info("To view help for a specific command run");
					reporter.command(programName + " command_name --help");
				},
			);

			this.showHelpExamples(examples);
		}

		showHelpExamples(examples, prefix) {
			const {programName} = this.opts;
			const {reporter} = this;

			if (examples === undefined || examples.length === 0) {
				return;
			}

			reporter.section(
				"Examples",
				() => {
					for (const {description, command} of examples) {
						const commandParts = [];
						if (programName !== undefined) {
							commandParts.push(programName);
						}
						if (prefix !== undefined) {
							commandParts.push(prefix);
						}
						commandParts.push(command);

						const builtCommand = commandParts.join(" ");

						reporter.br();
						if (description !== undefined) {
							reporter.logAll(description);
						}
						reporter.command(builtCommand);
					}
				},
			);
		}

		commandRequired() {
			if (this.ranCommand) {
				return;
			}

			if (this.args.length === 0) {
				this.reporter.error(
					"No command specified. Run --help to see available commands.",
				);
			} else {
				// TODO command name is not sanitized for markup
				// TODO produce a diagnostic instead
				this.reporter.error(
					"Unknown command <emphasis>" +
					this.args.join(" ") +
					"</emphasis>. Run --help to see available commands.",
				);
			}

			process.exit(1);
		}

		addCommand(opts) {
			if (this.currentCommand !== undefined) {
				throw new Error("Nested commands aren't allowed");
			}

			this.commands.set(opts.name, opts);
		}

		async defineCommandFlags(command, consumer) {
			this.currentCommand = command.name;

			let flags = {};
			if (command.defineFlags !== undefined) {
				flags = command.defineFlags(consumer);
			}

			this.currentCommand = undefined;

			return flags;
		}
	}

	class ___R$project$rome$$romejs$cli$flags$Parser_ts$ParserInterface {
		constructor(parser) {
			this.parser = parser;
		}

		init() {
			return this.parser.init();
		}

		showHelp() {
			return this.parser.showHelp();
		}

		getArgs() {
			return this.parser.args;
		}

		commandRequired() {
			this.parser.commandRequired();
		}

		command(opts) {
			this.parser.addCommand(opts);
		}
	}


  // project-rome/@romejs/cli-flags/index.ts
function ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlags(
		reporter,
		args,
		opts,
	) {
		const parser = new ___R$project$rome$$romejs$cli$flags$Parser_ts$default(
			reporter,
			opts,
			args,
		);
		return parser.getInterface();
	}

	function ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlagsFromProcess(
		opts,
	) {
		return ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlags(
			___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.fromProcess(),
			process.argv.slice(2),
			Object.assign(
				{},
				opts,
				{
					programName: opts.programName === undefined
						? process.argv[1]
						: opts.programName,
				},
			),
		);
	}


  // project-rome/@romejs/cli-diagnostics/printAdvice.ts




	const ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_PRINT = {
		printed: true,
		truncated: false,
	};

	const ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT = {
		printed: false,
		truncated: false,
	};

	function ___R$project$rome$$romejs$cli$diagnostics$printAdvice_ts$default(
		item,
		opts,
	) {
		switch (item.type) {
			case "log":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printLog(
					item,
					opts,
				);

			case "action":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printAction(
					item,
					opts,
				);

			case "list":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printList(
					item,
					opts,
				);

			case "diff":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printDiff(
					item,
					opts,
				);

			case "code":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printCode(
					item,
					opts,
				);

			case "command":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printCommand(
					item,
					opts,
				);

			case "frame":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printFrame(
					item,
					opts,
				);

			case "stacktrace":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printStacktrace(
					item,
					opts,
				);

			case "inspect":
				return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printInspect(
					item,
					opts,
				);
		}
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printAction(
		item,
		opts,
	) {
		if (item.hidden && !opts.printer.flags.verboseDiagnostics) {
			return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		}

		opts.reporter.info(item.instruction);

		const command = ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
			{
				prefix: "",
				programName: "rome",
				commandName: item.command,
				args: item.args,
				flags: Object.assign({}, item.commandFlags, item.requestFlags),
			},
			{type: "none"},
		).sourceText;
		opts.reporter.command(command);
		return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printCommand(
		item,
		opts,
	) {
		opts.reporter.command(item.command);
		return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printInspect(
		item,
		opts,
	) {
		const {reporter} = opts;
		reporter.indent(() => {
			reporter.inspect(item.data);
		});
		return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$generateDiffHint(
		diffs,
	) {
		let expected = "";
		let received = "";

		for (const [type, text] of diffs) {
			switch (type) {
				case ___R$project$rome$$romejs$string$diff$index_ts$diffConstants.ADD: {
					received += text;
					break;
				}

				case ___R$project$rome$$romejs$string$diff$index_ts$diffConstants.DELETE: {
					expected += text;
					break;
				}

				case ___R$project$rome$$romejs$string$diff$index_ts$diffConstants.EQUAL: {
					expected += text;
					received += text;
					break;
				}
			}
		}

		if (expected.trim() === received.trim()) {
			return {
				type: "log",
				category: "info",
				text: "Only difference is leading and trailing whitespace",
			};
		}

		const receivedNoCRLF = ___R$project$rome$$romejs$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
			received,
		);
		if (expected === receivedNoCRLF) {
			return {
				type: "log",
				category: "info",
				text: "Identical except the received uses CRLF newlines, while the expected does not",
			};
		}

		const expectedNoCRLF = ___R$project$rome$$romejs$string$utils$removeCarriageReturn_ts$removeCarriageReturn(
			expected,
		);
		if (received === expectedNoCRLF) {
			return {
				type: "log",
				category: "info",
				text: "Identical except the expected uses CRLF newlines, while the received does not",
			};
		}

		return undefined;
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printDiff(
		item,
		opts,
	) {
		const {frame, truncated} = ___R$project$rome$$romejs$cli$diagnostics$buildPatchCodeFrame_ts$default(
			item,
			opts.flags.verboseDiagnostics,
		);
		if (frame === "") {
			return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		}

		opts.reporter.logAll(frame);

		const hint = ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$generateDiffHint(
			item.diff,
		);
		if (hint !== undefined) {
			opts.reporter.br();
			___R$project$rome$$romejs$cli$diagnostics$printAdvice_ts$default(
				hint,
				opts,
			);
			opts.reporter.br();
		}

		return {
			printed: true,
			truncated,
		};
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printList(
		item,
		opts,
	) {
		if (item.list.length === 0) {
			return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		} else {
			const {truncated} = opts.reporter.list(
				item.list,
				{
					truncate: opts.flags.verboseDiagnostics ? undefined : 20,
					reverse: item.reverse,
					ordered: item.ordered,
				},
			);
			return {
				printed: true,
				truncated,
			};
		}
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printCode(
		item,
		opts,
	) {
		const {reporter} = opts;

		const truncated =
			!opts.flags.verboseDiagnostics &&
			item.code.length >
			___R$project$rome$$romejs$cli$diagnostics$constants_ts$RAW_CODE_MAX_LENGTH;
		let code = truncated
			? item.code.slice(
					0,
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$RAW_CODE_MAX_LENGTH,
				)
			: item.code;

		reporter.indent(() => {
			if (code === "") {
				reporter.logAll("<dim>empty input</dim>");
			} else {
				// If it's a string with only whitespace then make it obvious
				if (code.trim() === "") {
					code = ___R$project$rome$$romejs$cli$diagnostics$utils_ts$showInvisibles(
						code,
					);
				}

				reporter.logAll(
					"<nobr>" +
					___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(code) +
					"</nobr>",
				);
			}

			if (truncated) {
				reporter.logAll(
					"<dim><number>" +
					(item.code.length -
					___R$project$rome$$romejs$cli$diagnostics$constants_ts$RAW_CODE_MAX_LENGTH) +
					"</number> more characters truncated</dim>",
				);
			}
		});

		return {
			printed: true,
			truncated,
		};
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printFrame(
		item,
		opts,
	) {
		const {reporter} = opts;
		const {marker, start, end, filename} = item.location;
		let {sourceText} = item.location;
		const path = opts.printer.createFilePath(filename);

		let cleanMarker = "";
		if (marker !== undefined) {
			cleanMarker = ___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
				"emphasis",
				___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$cleanMessage(
					marker,
				),
			);
		}

		let lines = {
			length: 0,
			raw: [],
			highlighted: [],
		};
		if (sourceText !== undefined) {
			lines = ___R$project$rome$$romejs$cli$diagnostics$utils_ts$toLines({
				path,
				input: sourceText,
				sourceType: item.location.sourceType,
				language: item.location.language,
			});
		} else if (filename !== undefined) {
			const source = opts.fileSources.get(path);
			if (source !== undefined) {
				lines = source.lines;
				sourceText = source.sourceText;
			}
		} else if (
			path.isAbsolute() &&
			opts.missingFileSources.has(path.assertAbsolute())
		) {
			lines = {
				length: 1,
				raw: ["File does not exist"],
				highlighted: ["<dim>File does not exist</dim>"],
			};
		}

		if (sourceText === undefined) {
			sourceText = "";
		}

		const frame = ___R$project$rome$$romejs$cli$diagnostics$buildMessageCodeFrame_ts$default(
			sourceText,
			lines,
			start,
			end,
			cleanMarker,
		);
		if (frame.trim() === "") {
			return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT;
		}

		reporter.logAll(frame);
		return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printStacktrace(
		item,
		opts,
	) {
		const {diagnostic} = opts;
		const {frames} = item;

		let shownCodeFrames = 0;

		const isFirstPart = diagnostic.description.advice[0] === item;
		if (!isFirstPart) {
			const {title} = item;
			if (title !== undefined) {
				opts.reporter.info(
					___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(title),
				);
				opts.reporter.br(true);
			}
		}

		opts.reporter.processedList(
			frames,
			(reporter, frame) => {
				const {
					filename,
					object,
					suffix,
					property,
					prefix,
					line,
					column,
					language,
					sourceText: code,
				} = frame;

				const logParts = [];

				// Add prefix
				if (prefix !== undefined) {
					logParts.push(
						___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"dim",
							___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
								prefix,
							),
						),
					);
				}

				// Build path
				const objParts = [];
				if (object !== undefined) {
					objParts.push(
						___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"highlight",
							___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
								object,
							),
							{i: 0},
						),
					);
				}
				if (property !== undefined) {
					objParts.push(
						___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"highlight",
							___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
								property,
							),
							{i: 1},
						),
					);
				}
				if (objParts.length > 0) {
					logParts.push(objParts.join("."));
				}

				// Add suffix
				if (suffix !== undefined) {
					logParts.push(
						___R$project$rome$$romejs$string$markup$escape_ts$markupTag(
							"success",
							___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
								suffix,
							),
						),
					);
				}

				// Add source
				if (filename !== undefined && line !== undefined && column !== undefined) {
					const header = ___R$project$rome$$romejs$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink({
						filename,
						start: {
							index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1,
							line,
							column,
						},
					});

					if (logParts.length === 0) {
						logParts.push(header);
					} else {
						logParts.push("(<dim>" + header + "</dim>)");
					}
				}

				reporter.logAll(logParts.join(" "));

				if (
					shownCodeFrames < 2 &&
					filename !== undefined &&
					line !== undefined &&
					column !== undefined
				) {
					const pos = {
						index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1,
						line,
						column,
					};

					const skipped = ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printFrame(
						{
							type: "frame",
							location: {
								language,
								filename,
								sourceType: "module",
								start: pos,
								end: pos,
								sourceText: code,
							},
						},
						Object.assign({}, opts, {reporter}),
					);
					if (!skipped) {
						reporter.br(true);
						shownCodeFrames++;
					}
				}
			},
			{
				ordered: true,
				truncate: opts.flags.verboseDiagnostics ? undefined : 20,
			},
		);

		return ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$printLog(
		item,
		opts,
	) {
		const {reporter} = opts;
		const {text: message, category} = item;

		if (message !== undefined) {
			switch (category) {
				case "none": {
					reporter.logAll(message);
					break;
				}

				case "warn": {
					reporter.warn(message);
					break;
				}

				case "info": {
					reporter.info(message);
					break;
				}

				case "error": {
					reporter.error(message);
					break;
				}

				default:
					throw new Error("Unknown message item log category " + category);
			}
		}

		return item.compact
			? ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_NOT_PRINT
			: ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$DID_PRINT;
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$printAdvice_ts$cleanMessage(
		msg,
	) {
		msg = msg.trim();
		if (msg.endsWith(".")) {
			msg = msg.slice(0, -1);
		}
		return msg;
	}


  // project-rome/@romejs/cli-diagnostics/banners/success.json
const ___R$project$rome$$romejs$cli$diagnostics$banners$success_json$default = {
		"palettes": [
			[240, 240, 240],
			[240, 240, 225],
			[225, 225, 210],
			[225, 210, 210],
			[240, 225, 225],
			[210, 210, 195],
			[210, 195, 180],
			[195, 195, 165],
			[195, 180, 165],
			[225, 210, 195],
			[195, 195, 180],
			[225, 225, 225],
			[180, 180, 150],
			[180, 165, 150],
			[195, 180, 150],
			[195, 165, 150],
			[180, 165, 135],
			[180, 150, 135],
			[195, 165, 135],
			[225, 225, 195],
			[210, 210, 180],
			[210, 180, 150],
			[210, 180, 165],
			[225, 180, 180],
			[240, 180, 165],
			[240, 195, 195],
			[225, 195, 180],
			[165, 135, 120],
			[165, 150, 120],
			[195, 135, 120],
			[225, 150, 135],
			[240, 165, 165],
			[225, 180, 165],
			[225, 195, 165],
			[150, 120, 105],
			[150, 135, 105],
			[180, 150, 120],
			[195, 120, 105],
			[210, 135, 105],
			[210, 150, 120],
			[195, 150, 135],
			[210, 195, 165],
			[180, 105, 75],
			[195, 105, 90],
			[180, 90, 75],
			[240, 180, 180],
			[240, 225, 210],
			[240, 240, 210],
			[150, 120, 90],
			[180, 135, 120],
			[210, 150, 135],
			[210, 165, 150],
			[195, 150, 120],
			[225, 180, 150],
			[195, 120, 90],
			[180, 105, 90],
			[225, 165, 135],
			[225, 210, 180],
			[240, 210, 195],
			[225, 195, 195],
			[180, 135, 105],
			[225, 180, 135],
			[210, 135, 120],
			[225, 165, 150],
			[240, 180, 150],
			[210, 180, 180],
			[165, 135, 90],
			[180, 120, 90],
			[195, 135, 105],
			[225, 150, 120],
			[180, 135, 135],
			[210, 150, 150],
			[210, 195, 195],
			[210, 195, 210],
			[150, 135, 135],
			[195, 195, 195],
			[225, 210, 225],
			[180, 180, 135],
			[165, 120, 90],
			[240, 150, 135],
			[240, 165, 135],
			[240, 165, 150],
			[180, 90, 60],
			[180, 165, 165],
			[165, 135, 135],
			[180, 180, 180],
			[165, 150, 135],
			[150, 90, 45],
			[150, 75, 45],
			[210, 165, 135],
			[165, 165, 165],
			[165, 120, 75],
			[180, 135, 90],
			[150, 60, 45],
			[165, 105, 60],
			[165, 90, 60],
			[150, 105, 105],
			[210, 210, 210],
			[165, 105, 75],
			[225, 165, 165],
			[180, 120, 75],
			[165, 90, 75],
			[135, 90, 75],
			[195, 180, 180],
			[240, 195, 180],
			[135, 120, 120],
			[165, 135, 105],
			[150, 105, 75],
			[225, 150, 150],
			[240, 210, 180],
			[165, 150, 150],
			[165, 150, 105],
			[225, 135, 120],
			[210, 120, 105],
			[150, 90, 75],
			[180, 120, 105],
			[180, 150, 105],
			[240, 195, 165],
			[180, 165, 120],
			[225, 135, 135],
			[180, 105, 105],
			[195, 120, 120],
			[150, 75, 60],
			[105, 15, 15],
			[105, 15, 0],
			[120, 30, 30],
			[120, 30, 15],
			[105, 45, 30],
			[150, 90, 60],
			[210, 120, 120],
			[165, 75, 75],
			[90, 30, 30],
			[90, 15, 15],
			[120, 15, 30],
			[120, 15, 15],
			[90, 0, 0],
			[135, 45, 45],
			[165, 105, 90],
			[210, 105, 90],
			[135, 75, 45],
			[240, 210, 210],
			[225, 240, 225],
			[60, 30, 15],
			[45, 0, 0],
			[60, 15, 15],
			[75, 30, 15],
			[120, 60, 60],
			[195, 90, 75],
			[150, 45, 45],
			[75, 0, 15],
			[60, 0, 0],
			[75, 0, 0],
			[150, 105, 60],
			[135, 90, 45],
			[60, 45, 30],
			[105, 30, 30],
			[120, 15, 0],
			[150, 75, 75],
			[120, 105, 90],
			[105, 60, 45],
			[120, 75, 45],
			[60, 15, 0],
			[75, 15, 15],
			[105, 30, 15],
			[195, 105, 105],
			[165, 60, 60],
			[135, 15, 15],
			[180, 180, 165],
			[105, 90, 90],
			[30, 15, 15],
			[60, 30, 30],
			[135, 60, 60],
			[150, 45, 30],
			[150, 75, 30],
			[240, 225, 195],
			[75, 15, 0],
			[90, 15, 0],
			[120, 45, 30],
			[240, 150, 150],
			[105, 90, 75],
			[105, 75, 60],
			[105, 105, 105],
			[45, 45, 45],
			[30, 30, 15],
			[180, 60, 45],
			[165, 60, 30],
			[180, 90, 45],
			[135, 75, 30],
			[195, 135, 90],
			[135, 60, 45],
			[135, 75, 60],
			[90, 60, 30],
			[90, 60, 45],
			[30, 15, 0],
			[15, 15, 15],
			[45, 30, 15],
			[195, 90, 60],
			[180, 105, 60],
			[120, 75, 30],
			[105, 60, 30],
			[120, 60, 30],
			[15, 0, 0],
			[75, 45, 45],
			[180, 75, 30],
			[180, 120, 60],
			[90, 45, 30],
			[60, 45, 45],
			[60, 45, 60],
			[45, 30, 30],
			[75, 45, 30],
			[75, 45, 15],
			[195, 105, 75],
			[165, 45, 30],
			[165, 45, 15],
			[30, 0, 15],
			[45, 15, 15],
			[135, 60, 30],
			[210, 105, 60],
			[195, 120, 75],
			[75, 60, 30],
			[120, 120, 105],
			[165, 75, 60],
			[135, 45, 15],
			[195, 60, 45],
			[90, 30, 45],
			[165, 75, 30],
			[135, 90, 60],
			[135, 105, 60],
			[165, 90, 90],
			[120, 45, 45],
			[165, 75, 45],
			[210, 135, 60],
			[135, 90, 30],
			[165, 60, 45],
			[105, 75, 45],
			[195, 135, 45],
			[135, 105, 75],
			[75, 30, 30],
			[135, 105, 90],
			[195, 120, 45],
			[180, 105, 30],
			[135, 120, 90],
			[150, 60, 60],
			[180, 75, 75],
			[150, 60, 15],
			[150, 75, 15],
			[165, 120, 105],
			[180, 90, 90],
			[195, 90, 105],
			[210, 105, 105],
			[0, 0, 0],
			[15, 0, 15],
			[180, 105, 45],
			[120, 60, 45],
			[120, 60, 15],
			[90, 30, 15],
			[30, 0, 0],
			[15, 15, 0],
			[165, 90, 45],
			[180, 90, 30],
			[105, 30, 0],
			[180, 75, 45],
			[135, 45, 0],
			[120, 45, 15],
			[105, 45, 15],
			[45, 15, 0],
			[195, 90, 90],
			[90, 60, 60],
			[120, 75, 60],
			[135, 45, 30],
			[90, 45, 15],
			[225, 240, 240],
			[105, 75, 75],
			[150, 60, 30],
			[165, 180, 180],
			[180, 45, 60],
			[150, 45, 15],
			[135, 135, 135],
			[180, 60, 30],
			[90, 105, 105],
			[150, 135, 120],
			[105, 60, 60],
			[105, 45, 45],
			[225, 150, 105],
			[120, 120, 120],
			[105, 30, 45],
			[210, 150, 105],
			[90, 90, 90],
			[15, 30, 15],
			[45, 0, 15],
			[135, 30, 30],
			[180, 45, 30],
			[135, 30, 15],
			[75, 75, 75],
			[15, 15, 30],
			[0, 0, 15],
			[195, 60, 30],
			[210, 60, 45],
			[195, 90, 45],
			[210, 105, 75],
			[120, 90, 90],
			[45, 30, 45],
			[90, 45, 45],
			[0, 15, 0],
			[195, 75, 45],
			[195, 75, 60],
			[30, 30, 0],
			[135, 120, 105],
			[225, 195, 210],
			[60, 60, 60],
			[0, 15, 15],
			[15, 30, 45],
			[45, 45, 60],
			[30, 15, 30],
			[150, 30, 15],
			[30, 30, 30],
			[90, 75, 90],
			[90, 15, 30],
			[165, 165, 150],
			[120, 105, 60],
			[120, 120, 60],
			[60, 60, 45],
			[30, 45, 30],
			[60, 15, 30],
			[120, 30, 45],
			[60, 30, 45],
			[90, 90, 75],
			[135, 150, 60],
			[90, 90, 30],
			[30, 45, 45],
			[90, 75, 75],
			[120, 105, 105],
			[75, 30, 45],
			[60, 75, 60],
			[75, 15, 30],
			[45, 15, 30],
			[45, 60, 45],
			[120, 120, 90],
			[90, 15, 45],
			[75, 75, 60],
			[150, 150, 135],
			[75, 75, 45],
			[225, 120, 120],
			[75, 60, 60],
			[105, 105, 75],
			[120, 135, 90],
			[90, 90, 60],
			[135, 45, 60],
			[135, 30, 45],
			[75, 90, 75],
			[60, 75, 45],
			[210, 90, 60],
			[120, 45, 60],
			[150, 150, 150],
			[105, 120, 60],
			[105, 105, 60],
			[30, 30, 45],
			[135, 75, 75],
			[150, 45, 60],
			[225, 135, 90],
			[195, 105, 60],
			[195, 210, 195],
			[120, 75, 75],
			[90, 60, 75],
			[195, 135, 75],
			[210, 120, 75],
			[210, 225, 225],
			[150, 75, 90],
			[225, 135, 75],
			[210, 90, 75],
			[165, 120, 120],
			[210, 135, 75],
			[225, 105, 75],
			[180, 75, 60],
			[105, 45, 60],
			[225, 120, 75],
			[150, 90, 30],
			[165, 60, 75],
			[75, 45, 60],
			[225, 105, 60],
			[225, 90, 45],
			[225, 60, 30],
			[150, 30, 30],
			[150, 90, 90],
			[210, 135, 90],
			[150, 135, 90],
			[240, 75, 45],
			[135, 60, 75],
			[150, 105, 90],
			[240, 90, 60],
			[240, 105, 75],
			[210, 105, 45],
			[195, 150, 105],
			[240, 90, 45],
			[210, 120, 90],
			[45, 45, 30],
			[240, 105, 45],
			[210, 120, 45],
			[240, 90, 30],
			[210, 90, 45],
			[225, 120, 90],
			[195, 240, 195],
			[135, 240, 135],
			[75, 255, 60],
			[45, 255, 30],
			[45, 240, 30],
			[90, 225, 60],
			[105, 210, 75],
			[120, 135, 75],
			[195, 165, 165],
			[120, 150, 60],
			[30, 255, 0],
			[180, 180, 105],
			[165, 105, 105],
			[45, 240, 0],
			[45, 210, 0],
			[75, 105, 30],
			[30, 195, 0],
			[30, 225, 0],
			[30, 240, 0],
			[60, 240, 15],
			[90, 225, 30],
			[60, 195, 15],
			[30, 120, 15],
			[45, 105, 30],
			[105, 195, 30],
			[90, 225, 15],
			[75, 240, 30],
			[120, 195, 45],
			[105, 135, 30],
			[150, 165, 75],
			[180, 195, 30],
			[240, 75, 30],
			[165, 165, 45],
			[90, 225, 45],
			[105, 210, 45],
			[195, 165, 90],
			[135, 255, 135],
			[75, 255, 75],
			[90, 255, 90],
			[135, 240, 120],
			[165, 240, 150],
			[225, 240, 210],
			[90, 180, 75],
			[30, 135, 0],
			[135, 165, 45],
			[75, 210, 60],
			[90, 180, 30],
			[45, 210, 15],
			[150, 150, 60],
			[165, 195, 30],
			[225, 135, 60],
			[150, 210, 15],
			[135, 180, 45],
			[135, 225, 60],
			[210, 240, 210],
			[210, 240, 195],
			[195, 225, 195],
			[45, 165, 30],
			[30, 210, 15],
			[30, 150, 15],
			[15, 135, 0],
			[120, 165, 45],
			[45, 195, 15],
			[105, 90, 30],
			[105, 135, 45],
			[120, 180, 45],
			[105, 210, 30],
			[105, 195, 60],
			[120, 210, 45],
			[90, 120, 30],
			[210, 180, 105],
			[180, 180, 90],
			[135, 195, 60],
			[120, 210, 60],
			[135, 165, 60],
			[240, 135, 45],
			[180, 165, 75],
			[120, 165, 75],
			[195, 150, 75],
			[165, 180, 45],
			[120, 225, 30],
			[105, 165, 15],
			[75, 255, 45],
			[165, 240, 165],
			[150, 240, 150],
			[45, 135, 45],
			[30, 210, 0],
			[45, 120, 15],
			[150, 165, 60],
			[135, 195, 30],
			[90, 210, 30],
			[210, 120, 60],
			[135, 225, 105],
			[90, 255, 75],
			[120, 150, 45],
			[150, 240, 135],
			[90, 210, 75],
			[105, 90, 45],
			[60, 210, 15],
			[195, 180, 105],
			[195, 165, 105],
			[150, 165, 45],
			[195, 75, 15],
			[195, 60, 0],
			[135, 210, 15],
			[60, 240, 0],
			[150, 120, 15],
			[60, 195, 0],
			[75, 240, 15],
			[180, 240, 180],
			[105, 255, 90],
			[105, 150, 45],
			[105, 150, 30],
			[60, 240, 30],
			[75, 240, 60],
			[45, 225, 0],
			[150, 120, 75],
			[195, 180, 120],
			[210, 165, 120],
			[180, 165, 105],
			[210, 180, 120],
			[240, 105, 15],
			[165, 180, 30],
			[105, 240, 0],
			[135, 210, 30],
			[150, 165, 15],
			[120, 180, 30],
			[105, 240, 90],
			[60, 255, 45],
			[45, 255, 15],
			[90, 150, 30],
			[90, 240, 75],
			[90, 210, 15],
			[120, 90, 45],
			[105, 225, 60],
			[225, 195, 135],
			[165, 150, 90],
			[150, 165, 90],
			[225, 105, 30],
			[225, 120, 15],
			[120, 210, 15],
			[195, 120, 30],
			[150, 255, 150],
			[75, 135, 15],
			[105, 165, 75],
			[105, 210, 15],
			[180, 150, 90],
			[225, 165, 120],
			[210, 195, 135],
			[165, 135, 75],
			[210, 165, 105],
			[195, 165, 30],
			[75, 240, 0],
			[135, 210, 0],
			[165, 165, 30],
			[120, 165, 105],
			[75, 225, 0],
			[150, 180, 90],
			[180, 195, 105],
			[165, 180, 75],
			[150, 210, 30],
			[90, 240, 0],
			[210, 90, 30],
			[165, 90, 30],
			[195, 150, 90],
			[75, 210, 30],
			[225, 180, 120],
			[180, 135, 75],
			[225, 165, 90],
			[150, 180, 75],
			[225, 90, 30],
			[195, 120, 60],
			[210, 120, 30],
			[210, 180, 30],
			[135, 225, 0],
			[195, 150, 15],
			[225, 75, 30],
			[210, 75, 30],
			[195, 195, 150],
			[60, 255, 30],
			[195, 240, 180],
			[195, 30, 0],
			[165, 30, 15],
			[120, 150, 75],
			[210, 165, 75],
			[225, 165, 60],
			[195, 195, 45],
			[150, 165, 30],
			[195, 135, 60],
			[210, 195, 120],
			[240, 75, 15],
			[225, 150, 15],
			[240, 180, 15],
			[210, 165, 15],
			[210, 165, 45],
			[225, 90, 15],
			[210, 90, 15],
			[240, 120, 30],
			[210, 225, 180],
			[150, 120, 30],
			[45, 75, 0],
			[75, 120, 15],
			[75, 180, 30],
			[75, 195, 15],
			[195, 150, 60],
			[90, 195, 15],
			[120, 210, 30],
			[180, 165, 60],
			[195, 195, 105],
			[150, 225, 90],
			[135, 225, 75],
			[210, 150, 90],
			[195, 180, 30],
			[180, 180, 45],
			[225, 120, 30],
			[165, 195, 0],
			[165, 180, 15],
			[195, 165, 15],
			[225, 180, 30],
			[240, 180, 30],
			[225, 195, 15],
			[150, 225, 15],
			[135, 75, 15],
			[180, 180, 15],
			[195, 135, 30],
			[135, 225, 90],
			[180, 240, 165],
			[105, 255, 105],
			[150, 225, 135],
			[75, 225, 15],
			[195, 150, 45],
			[210, 165, 60],
			[120, 195, 30],
			[120, 225, 60],
			[195, 195, 75],
			[225, 180, 105],
			[225, 180, 45],
			[180, 225, 15],
			[180, 195, 90],
			[195, 210, 180],
			[90, 195, 30],
			[60, 225, 0],
			[105, 195, 45],
			[135, 150, 75],
			[165, 105, 45],
			[150, 135, 30],
			[105, 240, 15],
			[90, 240, 45],
			[195, 210, 105],
			[195, 195, 90],
			[210, 180, 90],
			[210, 195, 45],
			[150, 240, 0],
			[210, 180, 45],
			[225, 150, 90],
			[225, 150, 75],
			[60, 180, 0],
			[75, 210, 15],
			[90, 240, 15],
			[90, 240, 60],
			[210, 135, 45],
			[210, 150, 15],
			[225, 165, 30],
			[120, 90, 75],
			[225, 195, 120],
			[225, 165, 105],
			[240, 195, 30],
			[240, 195, 15],
			[210, 135, 30],
			[240, 165, 60],
			[210, 150, 30],
			[240, 195, 45],
			[240, 210, 30],
			[240, 180, 45],
			[225, 165, 45],
			[225, 150, 45],
			[225, 90, 60],
			[240, 150, 45],
			[150, 105, 45],
			[165, 105, 30],
			[210, 180, 135],
			[225, 195, 45],
			[225, 120, 45],
			[225, 180, 75],
			[225, 135, 30],
			[210, 165, 90],
			[240, 165, 45],
			[210, 105, 30],
			[225, 105, 45],
			[225, 75, 45],
			[225, 135, 45],
			[240, 150, 30],
			[150, 120, 60],
			[165, 120, 60],
			[180, 135, 15],
			[210, 150, 45],
			[225, 165, 75],
			[225, 150, 30],
			[240, 210, 15],
			[195, 90, 30],
			[240, 210, 150],
		],
		"rows": [
			[[0, 95]],
			[[0, 95]],
			[[0, 95]],
			[[0, 25], 1, 1, 2, 1, 1, 3, 4, 1, 1, 5, 5, 2, 0, [1, 3], [0, 54]],
			[[0, 24], 2, 2, 5, 6, 7, 7, 8, 7, 9, 9, 7, 7, 10, 1, 5, 5, 1, [0, 54]],
			[
				[0, 22],
				11,
				1,
				2,
				12,
				6,
				13,
				14,
				15,
				14,
				14,
				13,
				[14, 3],
				8,
				10,
				7,
				10,
				11,
				[0, 54],
			],
			[
				[0, 21],
				11,
				3,
				6,
				7,
				12,
				15,
				[16, 3],
				14,
				14,
				16,
				16,
				[14, 4],
				8,
				8,
				2,
				1,
				1,
				[0, 52],
			],
			[
				[0, 20],
				11,
				2,
				8,
				[14, 3],
				15,
				15,
				16,
				16,
				17,
				18,
				15,
				17,
				[15, 4],
				14,
				8,
				19,
				20,
				20,
				1,
				[0, 18],
				1,
				3,
				3,
				1,
				[0, 29],
			],
			[
				[0, 19],
				11,
				5,
				8,
				14,
				14,
				21,
				22,
				16,
				21,
				14,
				15,
				15,
				17,
				17,
				15,
				17,
				15,
				18,
				15,
				16,
				14,
				8,
				12,
				5,
				1,
				[0, 18],
				23,
				24,
				25,
				26,
				1,
				[0, 28],
			],
			[
				[0, 17],
				1,
				1,
				10,
				12,
				13,
				15,
				14,
				[21, 4],
				18,
				15,
				17,
				15,
				27,
				17,
				28,
				16,
				16,
				15,
				28,
				13,
				16,
				13,
				6,
				5,
				11,
				[0, 16],
				4,
				29,
				30,
				31,
				32,
				4,
				[0, 28],
			],
			[
				[0, 17],
				2,
				10,
				8,
				14,
				16,
				15,
				15,
				21,
				22,
				18,
				22,
				33,
				21,
				14,
				17,
				17,
				34,
				35,
				16,
				15,
				17,
				36,
				17,
				16,
				16,
				13,
				8,
				5,
				[0, 16],
				6,
				37,
				38,
				39,
				30,
				2,
				[0, 28],
			],
			[
				[0, 17],
				11,
				6,
				14,
				16,
				16,
				18,
				40,
				17,
				41,
				17,
				17,
				[22, 3],
				17,
				22,
				21,
				15,
				21,
				15,
				17,
				16,
				36,
				17,
				27,
				16,
				14,
				9,
				1,
				[0, 15],
				6,
				42,
				43,
				37,
				39,
				2,
				[0, 4],
				1,
				1,
				[0, 22],
			],
			[
				[0, 17],
				1,
				10,
				16,
				18,
				15,
				22,
				27,
				27,
				18,
				17,
				17,
				15,
				22,
				22,
				16,
				21,
				15,
				22,
				22,
				21,
				18,
				36,
				36,
				27,
				27,
				16,
				13,
				8,
				5,
				[0, 15],
				8,
				42,
				44,
				43,
				39,
				9,
				0,
				0,
				1,
				26,
				45,
				26,
				46,
				[0, 21],
			],
			[
				[0, 17],
				2,
				47,
				41,
				18,
				15,
				21,
				15,
				48,
				49,
				50,
				51,
				40,
				51,
				40,
				40,
				52,
				40,
				51,
				53,
				51,
				27,
				18,
				18,
				17,
				28,
				16,
				13,
				16,
				10,
				[0, 15],
				15,
				54,
				42,
				55,
				56,
				57,
				1,
				0,
				6,
				56,
				24,
				58,
				59,
				4,
				[0, 20],
			],
			[
				[0, 17],
				11,
				8,
				14,
				[36, 3],
				52,
				60,
				29,
				[50, 5],
				[39, 4],
				52,
				18,
				15,
				21,
				21,
				27,
				27,
				28,
				15,
				16,
				8,
				1,
				[0, 14],
				17,
				54,
				54,
				38,
				61,
				33,
				0,
				1,
				29,
				62,
				63,
				64,
				24,
				65,
				3,
				2,
				1,
				[0, 17],
			],
			[
				[0, 17],
				11,
				8,
				18,
				66,
				67,
				67,
				68,
				39,
				[30, 7],
				62,
				[69, 3],
				40,
				15,
				22,
				18,
				36,
				18,
				15,
				14,
				14,
				8,
				1,
				[0, 14],
				70,
				67,
				67,
				37,
				56,
				53,
				1,
				9,
				55,
				37,
				38,
				38,
				71,
				72,
				73,
				74,
				75,
				3,
				76,
				[0, 15],
			],
			[
				[0, 15],
				1,
				5,
				7,
				77,
				18,
				78,
				54,
				37,
				38,
				69,
				30,
				79,
				80,
				80,
				30,
				80,
				81,
				30,
				69,
				38,
				38,
				52,
				15,
				22,
				22,
				21,
				16,
				16,
				15,
				14,
				14,
				2,
				[0, 14],
				15,
				54,
				42,
				55,
				38,
				30,
				26,
				40,
				42,
				82,
				82,
				54,
				22,
				0,
				83,
				84,
				3,
				76,
				85,
				85,
				2,
				[0, 13],
			],
			[
				[0, 15],
				1,
				19,
				86,
				16,
				18,
				78,
				54,
				38,
				62,
				30,
				81,
				64,
				[81, 3],
				24,
				24,
				63,
				30,
				69,
				38,
				52,
				15,
				14,
				22,
				21,
				14,
				15,
				14,
				15,
				8,
				2,
				[0, 14],
				65,
				38,
				68,
				68,
				39,
				54,
				42,
				67,
				42,
				87,
				88,
				42,
				89,
				26,
				27,
				8,
				4,
				72,
				72,
				90,
				90,
				[0, 13],
			],
			[
				[0, 16],
				1,
				5,
				14,
				36,
				91,
				67,
				38,
				39,
				81,
				[24, 6],
				45,
				24,
				63,
				69,
				38,
				52,
				51,
				21,
				21,
				14,
				[15, 3],
				16,
				14,
				32,
				26,
				46,
				1,
				[0, 11],
				22,
				67,
				67,
				92,
				92,
				42,
				93,
				42,
				94,
				95,
				95,
				54,
				69,
				39,
				39,
				40,
				18,
				96,
				15,
				11,
				97,
				[0, 13],
			],
			[
				[0, 17],
				2,
				7,
				36,
				98,
				54,
				68,
				69,
				81,
				[24, 8],
				81,
				30,
				62,
				29,
				18,
				21,
				51,
				[16, 4],
				18,
				52,
				63,
				31,
				99,
				22,
				46,
				[0, 9],
				9,
				60,
				42,
				98,
				42,
				100,
				42,
				101,
				67,
				98,
				88,
				88,
				67,
				63,
				64,
				81,
				56,
				39,
				67,
				102,
				103,
				11,
				11,
				[0, 12],
			],
			[
				[0, 17],
				2,
				13,
				36,
				98,
				54,
				38,
				39,
				81,
				31,
				31,
				[24, 6],
				64,
				79,
				62,
				62,
				40,
				40,
				51,
				18,
				40,
				36,
				18,
				36,
				52,
				30,
				81,
				31,
				31,
				99,
				23,
				58,
				46,
				4,
				1,
				0,
				1,
				2,
				15,
				60,
				68,
				68,
				42,
				98,
				67,
				37,
				39,
				68,
				98,
				98,
				42,
				39,
				33,
				104,
				64,
				56,
				56,
				39,
				50,
				27,
				105,
				103,
				[0, 12],
			],
			[
				[0, 17],
				2,
				8,
				106,
				107,
				54,
				38,
				39,
				63,
				[31, 3],
				[24, 5],
				81,
				30,
				[62, 3],
				40,
				40,
				18,
				[36, 4],
				60,
				39,
				30,
				81,
				31,
				31,
				24,
				81,
				108,
				50,
				51,
				22,
				51,
				50,
				68,
				68,
				29,
				68,
				37,
				68,
				68,
				29,
				39,
				50,
				78,
				95,
				82,
				39,
				[109, 2],
				63,
				39,
				69,
				56,
				56,
				39,
				96,
				110,
				[0, 12],
			],
			[
				[0, 17],
				1,
				12,
				111,
				98,
				54,
				68,
				39,
				81,
				63,
				[81, 4],
				31,
				24,
				63,
				56,
				112,
				113,
				37,
				37,
				67,
				114,
				78,
				52,
				29,
				[115, 2],
				116,
				52,
				62,
				81,
				81,
				31,
				24,
				64,
				56,
				50,
				39,
				39,
				30,
				56,
				50,
				50,
				29,
				115,
				[67, 4],
				37,
				68,
				68,
				67,
				100,
				89,
				109,
				117,
				39,
				39,
				56,
				63,
				64,
				56,
				49,
				83,
				[0, 12],
			],
			[
				[0, 17],
				1,
				2,
				118,
				98,
				37,
				38,
				62,
				69,
				56,
				81,
				63,
				30,
				119,
				62,
				50,
				120,
				121,
				122,
				123,
				124,
				[125, 2],
				126,
				127,
				78,
				52,
				37,
				44,
				49,
				47,
				22,
				39,
				30,
				81,
				63,
				56,
				50,
				50,
				62,
				68,
				39,
				89,
				56,
				56,
				39,
				67,
				98,
				95,
				[128, 2],
				95,
				94,
				42,
				67,
				68,
				39,
				53,
				64,
				56,
				81,
				[24, 4],
				51,
				5,
				[0, 12],
			],
			[
				[0, 18],
				5,
				118,
				128,
				98,
				101,
				37,
				37,
				62,
				30,
				30,
				129,
				130,
				[131, 2],
				132,
				133,
				134,
				[135, 2],
				123,
				[136, 2],
				137,
				52,
				52,
				38,
				138,
				37,
				3,
				1,
				72,
				49,
				39,
				38,
				39,
				62,
				38,
				38,
				68,
				89,
				89,
				50,
				69,
				62,
				54,
				98,
				94,
				[87, 3],
				[139, 3],
				128,
				92,
				68,
				56,
				30,
				63,
				64,
				24,
				63,
				24,
				24,
				140,
				[0, 12],
			],
			[
				[0, 18],
				141,
				12,
				142,
				143,
				144,
				145,
				146,
				122,
				147,
				44,
				148,
				123,
				149,
				[150, 3],
				[151, 2],
				124,
				136,
				43,
				38,
				37,
				67,
				68,
				37,
				138,
				68,
				13,
				97,
				0,
				4,
				6,
				18,
				60,
				[67, 4],
				68,
				52,
				68,
				68,
				54,
				98,
				128,
				[87, 3],
				128,
				152,
				[128, 2],
				139,
				153,
				98,
				68,
				39,
				30,
				81,
				64,
				64,
				24,
				24,
				32,
				4,
				[0, 11],
			],
			[
				[0, 19],
				5,
				154,
				[143, 4],
				155,
				44,
				112,
				130,
				156,
				124,
				[123, 3],
				[134, 2],
				157,
				62,
				69,
				38,
				54,
				54,
				[38, 3],
				37,
				36,
				5,
				[0, 4],
				1,
				9,
				158,
				159,
				160,
				114,
				[98, 5],
				94,
				[128, 2],
				87,
				[153, 2],
				87,
				139,
				87,
				128,
				139,
				101,
				68,
				62,
				39,
				81,
				64,
				81,
				69,
				98,
				18,
				1,
				[0, 10],
			],
			[
				[0, 19],
				1,
				105,
				[143, 2],
				161,
				162,
				163,
				164,
				81,
				30,
				165,
				156,
				166,
				156,
				166,
				148,
				164,
				30,
				69,
				62,
				37,
				54,
				54,
				62,
				69,
				113,
				68,
				16,
				167,
				2,
				1,
				0,
				0,
				11,
				168,
				169,
				170,
				171,
				172,
				173,
				88,
				128,
				95,
				94,
				98,
				[100, 3],
				[98, 3],
				128,
				[87, 4],
				128,
				68,
				38,
				80,
				63,
				80,
				62,
				78,
				21,
				174,
				[0, 10],
			],
			[
				[0, 19],
				1,
				167,
				161,
				151,
				175,
				176,
				177,
				62,
				178,
				81,
				30,
				[129, 2],
				113,
				62,
				[81, 3],
				30,
				62,
				38,
				37,
				37,
				54,
				62,
				38,
				67,
				48,
				179,
				180,
				16,
				10,
				181,
				182,
				183,
				170,
				136,
				184,
				185,
				186,
				42,
				42,
				[88, 3],
				128,
				95,
				94,
				94,
				[98, 3],
				128,
				[87, 3],
				187,
				128,
				188,
				62,
				81,
				24,
				50,
				107,
				36,
				57,
				1,
				[0, 9],
			],
			[
				[0, 20],
				2,
				114,
				189,
				190,
				101,
				55,
				30,
				81,
				81,
				63,
				30,
				81,
				31,
				24,
				24,
				81,
				81,
				30,
				62,
				38,
				38,
				113,
				54,
				38,
				37,
				43,
				191,
				160,
				145,
				192,
				193,
				194,
				169,
				195,
				145,
				184,
				185,
				196,
				54,
				54,
				42,
				95,
				197,
				94,
				94,
				87,
				87,
				153,
				187,
				198,
				199,
				198,
				160,
				187,
				87,
				187,
				200,
				101,
				37,
				63,
				25,
				104,
				64,
				68,
				16,
				5,
				[0, 9],
			],
			[
				[0, 20],
				1,
				67,
				113,
				30,
				119,
				55,
				112,
				[30, 3],
				62,
				29,
				63,
				24,
				24,
				63,
				30,
				69,
				[38, 3],
				37,
				54,
				37,
				43,
				67,
				127,
				185,
				144,
				194,
				201,
				[169, 2],
				202,
				95,
				203,
				82,
				54,
				68,
				68,
				67,
				94,
				[197, 2],
				204,
				[94, 3],
				128,
				205,
				[206, 2],
				207,
				208,
				154,
				209,
				210,
				205,
				60,
				62,
				63,
				32,
				117,
				89,
				8,
				11,
				[0, 9],
			],
			[
				[0, 20],
				1,
				60,
				211,
				62,
				113,
				44,
				112,
				79,
				30,
				119,
				62,
				62,
				68,
				30,
				80,
				30,
				69,
				69,
				[38, 3],
				37,
				54,
				42,
				82,
				94,
				212,
				213,
				214,
				201,
				[169, 2],
				215,
				131,
				216,
				217,
				218,
				68,
				62,
				68,
				42,
				197,
				42,
				[100, 3],
				98,
				98,
				94,
				128,
				200,
				205,
				[209, 2],
				[205, 2],
				219,
				220,
				1,
				51,
				62,
				32,
				109,
				22,
				1,
				[0, 10],
			],
			[
				[0, 21],
				18,
				100,
				38,
				42,
				122,
				37,
				62,
				37,
				164,
				62,
				30,
				37,
				38,
				69,
				39,
				39,
				38,
				38,
				37,
				37,
				54,
				54,
				42,
				221,
				222,
				223,
				126,
				169,
				194,
				[169, 2],
				224,
				155,
				225,
				186,
				54,
				68,
				29,
				68,
				[42, 3],
				[100, 4],
				98,
				98,
				152,
				87,
				87,
				139,
				187,
				153,
				226,
				227,
				167,
				0,
				3,
				53,
				104,
				58,
				32,
				1,
				[0, 10],
			],
			[
				[0, 21],
				14,
				197,
				54,
				95,
				88,
				[122, 2],
				228,
				55,
				55,
				37,
				37,
				54,
				[38, 4],
				37,
				[54, 4],
				55,
				229,
				212,
				230,
				143,
				[169, 3],
				215,
				180,
				189,
				230,
				231,
				60,
				[68, 3],
				42,
				94,
				42,
				[100, 4],
				91,
				98,
				94,
				87,
				[187, 2],
				232,
				153,
				227,
				48,
				46,
				1,
				4,
				63,
				117,
				104,
				23,
				1,
				[0, 10],
			],
			[
				[0, 21],
				9,
				98,
				42,
				94,
				216,
				95,
				101,
				115,
				55,
				37,
				55,
				55,
				95,
				[38, 3],
				37,
				37,
				54,
				55,
				67,
				54,
				55,
				177,
				233,
				144,
				[169, 2],
				194,
				169,
				215,
				234,
				199,
				216,
				235,
				67,
				[68, 3],
				100,
				94,
				98,
				100,
				67,
				100,
				91,
				91,
				98,
				128,
				87,
				187,
				198,
				232,
				226,
				236,
				5,
				0,
				0,
				1,
				51,
				117,
				104,
				24,
				1,
				[0, 10],
			],
			[
				[0, 21],
				1,
				106,
				98,
				218,
				139,
				95,
				54,
				68,
				37,
				54,
				55,
				55,
				101,
				54,
				38,
				37,
				54,
				54,
				55,
				42,
				42,
				100,
				101,
				127,
				131,
				214,
				169,
				[194, 2],
				169,
				237,
				221,
				82,
				173,
				235,
				128,
				[68, 3],
				100,
				94,
				94,
				98,
				[100, 2],
				91,
				98,
				152,
				87,
				87,
				139,
				232,
				153,
				238,
				20,
				1,
				[0, 3],
				22,
				24,
				24,
				53,
				46,
				[0, 10],
			],
			[
				[0, 22],
				6,
				98,
				218,
				87,
				216,
				177,
				101,
				55,
				228,
				177,
				189,
				190,
				98,
				38,
				54,
				54,
				42,
				98,
				98,
				42,
				42,
				160,
				193,
				201,
				[169, 2],
				[194, 3],
				144,
				95,
				225,
				239,
				240,
				187,
				67,
				68,
				68,
				67,
				[94, 5],
				[128, 2],
				87,
				[187, 3],
				198,
				241,
				2,
				[0, 5],
				72,
				24,
				117,
				32,
				2,
				[0, 10],
			],
			[
				[0, 23],
				17,
				42,
				67,
				128,
				189,
				125,
				242,
				[243, 2],
				130,
				189,
				101,
				54,
				54,
				42,
				98,
				101,
				98,
				42,
				114,
				144,
				[201, 2],
				[169, 2],
				[194, 3],
				170,
				101,
				244,
				245,
				94,
				232,
				160,
				100,
				92,
				67,
				42,
				95,
				87,
				88,
				[139, 2],
				187,
				216,
				[200, 3],
				160,
				9,
				[0, 6],
				2,
				63,
				45,
				58,
				46,
				[0, 10],
			],
			[
				[0, 23],
				4,
				246,
				54,
				67,
				29,
				101,
				247,
				248,
				249,
				130,
				37,
				98,
				188,
				100,
				42,
				95,
				98,
				42,
				98,
				237,
				169,
				250,
				251,
				169,
				[194, 3],
				201,
				193,
				170,
				127,
				252,
				173,
				199,
				253,
				226,
				78,
				137,
				98,
				94,
				128,
				187,
				200,
				254,
				200,
				[254, 2],
				199,
				160,
				255,
				140,
				[0, 7],
				22,
				32,
				26,
				4,
				[0, 10],
			],
			[
				[0, 24],
				2,
				48,
				98,
				37,
				62,
				130,
				129,
				71,
				115,
				62,
				54,
				95,
				42,
				94,
				95,
				42,
				42,
				159,
				256,
				194,
				250,
				194,
				169,
				194,
				[169, 2],
				194,
				257,
				102,
				258,
				203,
				259,
				258,
				216,
				127,
				159,
				128,
				94,
				94,
				[87, 3],
				187,
				216,
				[200, 2],
				159,
				145,
				124,
				6,
				[0, 7],
				1,
				3,
				2,
				1,
				[0, 10],
			],
			[
				[0, 25],
				6,
				226,
				67,
				37,
				37,
				129,
				71,
				121,
				37,
				54,
				101,
				122,
				95,
				95,
				42,
				128,
				215,
				169,
				251,
				256,
				169,
				[194, 6],
				142,
				144,
				260,
				261,
				262,
				263,
				[205, 2],
				264,
				200,
				139,
				187,
				216,
				[200, 2],
				[139, 2],
				199,
				265,
				144,
				124,
				17,
				[0, 21],
			],
			[
				[0, 25],
				1,
				17,
				98,
				42,
				43,
				266,
				[249, 2],
				42,
				54,
				55,
				127,
				122,
				95,
				94,
				205,
				169,
				257,
				251,
				237,
				170,
				[194, 6],
				257,
				267,
				268,
				177,
				93,
				189,
				131,
				162,
				127,
				264,
				260,
				264,
				[263, 2],
				216,
				88,
				253,
				265,
				201,
				144,
				163,
				114,
				1,
				[0, 20],
			],
			[
				[0, 25],
				1,
				2,
				102,
				98,
				101,
				247,
				44,
				221,
				44,
				55,
				98,
				205,
				253,
				122,
				253,
				215,
				194,
				257,
				215,
				268,
				237,
				[194, 6],
				[257, 2],
				209,
				145,
				139,
				264,
				269,
				255,
				162,
				127,
				270,
				264,
				163,
				260,
				263,
				93,
				155,
				215,
				201,
				143,
				134,
				189,
				5,
				[0, 20],
			],
			[
				[0, 26],
				271,
				272,
				98,
				98,
				87,
				226,
				98,
				42,
				42,
				137,
				[131, 2],
				205,
				195,
				169,
				194,
				169,
				202,
				148,
				144,
				194,
				[251, 2],
				[194, 4],
				251,
				201,
				159,
				263,
				177,
				222,
				172,
				124,
				175,
				145,
				163,
				216,
				273,
				230,
				216,
				145,
				195,
				193,
				201,
				123,
				93,
				274,
				[0, 20],
			],
			[
				[0, 26],
				1,
				267,
				190,
				68,
				100,
				67,
				67,
				54,
				67,
				190,
				144,
				142,
				265,
				[169, 2],
				201,
				215,
				267,
				275,
				144,
				[194, 8],
				193,
				144,
				255,
				264,
				263,
				276,
				185,
				172,
				263,
				126,
				173,
				258,
				88,
				255,
				145,
				142,
				215,
				257,
				161,
				269,
				277,
				[0, 20],
			],
			[
				[0, 25],
				1,
				15,
				125,
				142,
				246,
				98,
				42,
				95,
				55,
				98,
				205,
				215,
				237,
				142,
				169,
				194,
				169,
				170,
				272,
				134,
				215,
				[194, 8],
				214,
				237,
				256,
				131,
				126,
				269,
				273,
				278,
				217,
				258,
				216,
				200,
				163,
				264,
				270,
				145,
				144,
				257,
				256,
				216,
				279,
				[0, 20],
			],
			[
				[0, 24],
				1,
				280,
				148,
				162,
				169,
				237,
				190,
				94,
				88,
				139,
				205,
				144,
				237,
				255,
				161,
				[194, 2],
				215,
				237,
				281,
				127,
				215,
				[194, 2],
				251,
				[194, 5],
				256,
				282,
				170,
				[256, 2],
				265,
				175,
				230,
				203,
				283,
				101,
				270,
				177,
				[264, 2],
				255,
				142,
				194,
				145,
				233,
				182,
				11,
				[0, 19],
			],
			[
				[0, 23],
				11,
				284,
				282,
				132,
				169,
				194,
				169,
				205,
				87,
				139,
				199,
				255,
				177,
				155,
				145,
				193,
				194,
				[215, 2],
				155,
				285,
				237,
				169,
				[194, 6],
				251,
				194,
				214,
				282,
				205,
				[201, 2],
				256,
				215,
				155,
				185,
				211,
				286,
				98,
				127,
				[264, 2],
				270,
				142,
				251,
				177,
				222,
				169,
				97,
				[0, 19],
			],
			[
				[0, 22],
				11,
				287,
				144,
				215,
				257,
				[194, 2],
				169,
				145,
				198,
				187,
				200,
				216,
				222,
				163,
				162,
				169,
				250,
				288,
				145,
				229,
				155,
				170,
				[194, 9],
				251,
				255,
				253,
				144,
				[250, 2],
				251,
				289,
				290,
				291,
				196,
				69,
				226,
				[127, 2],
				270,
				142,
				256,
				292,
				216,
				183,
				75,
				[0, 19],
			],
			[
				[0, 21],
				97,
				293,
				[169, 2],
				201,
				194,
				257,
				194,
				294,
				169,
				205,
				200,
				216,
				95,
				216,
				163,
				205,
				214,
				250,
				215,
				134,
				292,
				255,
				215,
				[194, 5],
				251,
				[194, 4],
				265,
				253,
				127,
				193,
				250,
				295,
				201,
				143,
				233,
				296,
				69,
				37,
				255,
				205,
				270,
				142,
				162,
				172,
				264,
				257,
				75,
				[0, 19],
			],
			[
				[0, 20],
				11,
				293,
				194,
				169,
				250,
				[194, 4],
				294,
				194,
				193,
				215,
				131,
				221,
				93,
				190,
				192,
				201,
				250,
				289,
				123,
				273,
				255,
				208,
				169,
				[194, 5],
				251,
				[194, 3],
				193,
				127,
				177,
				145,
				201,
				[250, 2],
				201,
				131,
				297,
				298,
				299,
				253,
				142,
				205,
				215,
				126,
				225,
				199,
				288,
				85,
				[0, 19],
			],
			[
				[0, 20],
				284,
				[194, 2],
				169,
				201,
				[194, 2],
				251,
				[194, 2],
				[169, 2],
				194,
				144,
				177,
				101,
				22,
				300,
				[250, 2],
				251,
				301,
				302,
				145,
				169,
				[194, 6],
				[251, 2],
				[194, 2],
				257,
				144,
				189,
				253,
				215,
				201,
				303,
				250,
				251,
				290,
				304,
				305,
				255,
				265,
				151,
				163,
				263,
				255,
				306,
				257,
				75,
				[0, 19],
			],
			[
				[0, 19],
				85,
				169,
				[194, 5],
				251,
				201,
				251,
				[194, 2],
				[169, 3],
				307,
				59,
				308,
				309,
				[201, 2],
				310,
				311,
				312,
				313,
				[169, 3],
				[194, 3],
				257,
				[194, 5],
				214,
				302,
				253,
				155,
				256,
				201,
				250,
				295,
				214,
				82,
				223,
				[134, 2],
				314,
				123,
				169,
				194,
				169,
				315,
				85,
				[0, 19],
			],
			[
				[0, 18],
				97,
				315,
				[194, 3],
				182,
				181,
				168,
				206,
				[194, 7],
				316,
				73,
				103,
				194,
				[201, 2],
				[194, 2],
				294,
				194,
				[169, 4],
				215,
				162,
				317,
				162,
				215,
				256,
				[194, 3],
				215,
				[253, 2],
				145,
				256,
				169,
				265,
				256,
				145,
				296,
				213,
				184,
				177,
				169,
				313,
				315,
				313,
				301,
				318,
				[0, 19],
			],
			[
				[0, 17],
				97,
				287,
				[194, 2],
				169,
				315,
				287,
				319,
				320,
				321,
				322,
				[194, 3],
				251,
				[194, 3],
				83,
				110,
				257,
				201,
				250,
				194,
				[169, 7],
				323,
				155,
				324,
				136,
				253,
				285,
				289,
				256,
				[194, 2],
				209,
				253,
				229,
				144,
				194,
				215,
				162,
				144,
				273,
				298,
				263,
				[169, 2],
				[194, 2],
				315,
				325,
				277,
				[0, 19],
			],
			[
				[0, 16],
				2,
				309,
				[194, 3],
				313,
				309,
				326,
				327,
				328,
				321,
				329,
				[194, 7],
				330,
				331,
				201,
				[250, 2],
				[194, 2],
				[169, 10],
				215,
				302,
				229,
				162,
				169,
				194,
				214,
				229,
				160,
				159,
				289,
				251,
				143,
				155,
				317,
				142,
				169,
				208,
				332,
				[194, 2],
				215,
				170,
				277,
				[0, 19],
			],
			[
				[0, 15],
				141,
				287,
				[194, 2],
				294,
				194,
				315,
				[333, 3],
				309,
				333,
				182,
				315,
				194,
				169,
				[194, 4],
				251,
				169,
				295,
				250,
				[194, 2],
				[169, 8],
				[313, 3],
				[169, 2],
				145,
				229,
				255,
				214,
				194,
				144,
				160,
				139,
				200,
				144,
				313,
				334,
				189,
				162,
				215,
				335,
				146,
				215,
				194,
				224,
				317,
				287,
				[0, 19],
			],
			[
				[0, 15],
				85,
				169,
				170,
				[169, 3],
				315,
				207,
				309,
				336,
				326,
				337,
				326,
				182,
				[194, 6],
				201,
				144,
				256,
				303,
				194,
				[169, 10],
				[313, 3],
				183,
				313,
				144,
				253,
				131,
				214,
				194,
				205,
				[128, 2],
				253,
				335,
				313,
				159,
				242,
				144,
				294,
				302,
				170,
				169,
				282,
				338,
				309,
				141,
				[0, 18],
			],
			[
				[0, 15],
				168,
				96,
				121,
				180,
				[169, 2],
				315,
				309,
				339,
				337,
				340,
				220,
				341,
				182,
				[194, 7],
				144,
				237,
				144,
				193,
				194,
				[169, 10],
				[313, 2],
				169,
				[313, 2],
				144,
				253,
				127,
				169,
				144,
				190,
				[107, 2],
				136,
				334,
				170,
				242,
				177,
				[215, 2],
				267,
				215,
				229,
				131,
				206,
				3,
				[0, 18],
			],
			[
				[0, 14],
				11,
				208,
				120,
				342,
				228,
				215,
				169,
				194,
				343,
				344,
				345,
				346,
				287,
				293,
				321,
				[194, 5],
				251,
				194,
				257,
				162,
				347,
				237,
				[169, 9],
				[313, 6],
				315,
				313,
				237,
				189,
				255,
				215,
				237,
				98,
				91,
				196,
				348,
				335,
				302,
				122,
				132,
				183,
				302,
				237,
				347,
				317,
				170,
				103,
				[0, 18],
			],
			[
				[0, 14],
				97,
				251,
				120,
				112,
				55,
				142,
				294,
				194,
				315,
				309,
				333,
				349,
				[350, 2],
				182,
				315,
				[194, 6],
				257,
				256,
				127,
				282,
				169,
				313,
				[169, 2],
				313,
				[169, 2],
				[313, 3],
				[169, 2],
				[313, 5],
				315,
				127,
				171,
				144,
				208,
				159,
				196,
				351,
				101,
				282,
				144,
				171,
				136,
				169,
				131,
				224,
				352,
				237,
				208,
				105,
				[0, 18],
			],
			[
				[0, 14],
				353,
				169,
				115,
				62,
				43,
				145,
				294,
				169,
				315,
				301,
				329,
				350,
				354,
				355,
				287,
				356,
				201,
				[194, 7],
				215,
				229,
				[169, 2],
				215,
				237,
				335,
				169,
				183,
				315,
				313,
				[183, 2],
				315,
				[313, 2],
				169,
				313,
				335,
				313,
				208,
				357,
				146,
				183,
				144,
				351,
				196,
				78,
				101,
				317,
				170,
				358,
				144,
				237,
				334,
				144,
				224,
				208,
				343,
				2,
				[0, 17],
			],
			[
				[0, 13],
				11,
				182,
				209,
				62,
				62,
				44,
				142,
				294,
				[169, 2],
				183,
				315,
				309,
				326,
				168,
				287,
				194,
				201,
				[194, 5],
				169,
				194,
				169,
				282,
				142,
				169,
				215,
				224,
				335,
				208,
				323,
				335,
				215,
				313,
				[335, 2],
				313,
				169,
				[313, 2],
				[335, 2],
				315,
				170,
				228,
				131,
				170,
				359,
				360,
				78,
				91,
				122,
				162,
				131,
				237,
				335,
				208,
				170,
				157,
				209,
				170,
				10,
				[0, 17],
			],
			[
				[0, 13],
				361,
				194,
				362,
				62,
				38,
				114,
				193,
				[169, 2],
				[194, 3],
				182,
				363,
				330,
				315,
				194,
				251,
				[194, 6],
				[169, 2],
				282,
				177,
				169,
				215,
				282,
				323,
				332,
				352,
				171,
				229,
				131,
				215,
				[313, 5],
				[335, 2],
				313,
				315,
				302,
				228,
				145,
				364,
				365,
				101,
				78,
				91,
				165,
				162,
				142,
				[215, 2],
				170,
				165,
				282,
				208,
				74,
				[0, 17],
			],
			[
				[0, 13],
				366,
				154,
				37,
				62,
				37,
				146,
				194,
				[169, 3],
				[194, 2],
				201,
				[169, 4],
				[194, 4],
				[251, 2],
				[194, 3],
				237,
				122,
				145,
				215,
				352,
				131,
				215,
				313,
				144,
				282,
				189,
				282,
				145,
				169,
				[313, 2],
				335,
				313,
				[335, 2],
				208,
				195,
				[367, 2],
				94,
				368,
				172,
				55,
				211,
				351,
				369,
				299,
				94,
				195,
				215,
				242,
				131,
				208,
				168,
				1,
				[0, 16],
			],
			[
				[0, 12],
				1,
				2,
				49,
				30,
				39,
				78,
				237,
				251,
				[169, 3],
				194,
				257,
				250,
				289,
				[169, 2],
				194,
				169,
				251,
				[194, 3],
				251,
				194,
				169,
				313,
				215,
				[171, 2],
				142,
				334,
				171,
				144,
				313,
				315,
				215,
				335,
				237,
				[282, 2],
				144,
				313,
				335,
				315,
				215,
				323,
				[208, 2],
				202,
				370,
				102,
				371,
				196,
				148,
				196,
				360,
				196,
				299,
				364,
				101,
				215,
				282,
				352,
				169,
				206,
				2,
				[0, 16],
			],
			[
				[0, 11],
				1,
				20,
				246,
				98,
				54,
				68,
				114,
				215,
				251,
				[169, 3],
				194,
				[201, 2],
				323,
				169,
				313,
				[169, 2],
				251,
				169,
				[194, 3],
				[169, 2],
				313,
				169,
				237,
				157,
				171,
				144,
				347,
				171,
				[335, 2],
				[313, 2],
				169,
				215,
				282,
				189,
				237,
				313,
				169,
				334,
				224,
				[335, 2],
				195,
				96,
				78,
				82,
				372,
				172,
				102,
				106,
				55,
				157,
				145,
				190,
				281,
				215,
				146,
				323,
				315,
				5,
				[0, 16],
			],
			[
				[0, 11],
				72,
				107,
				42,
				95,
				128,
				55,
				190,
				256,
				310,
				251,
				169,
				194,
				251,
				201,
				256,
				317,
				[169, 4],
				[194, 2],
				[169, 2],
				[194, 2],
				313,
				169,
				313,
				335,
				159,
				130,
				229,
				237,
				101,
				131,
				313,
				315,
				169,
				335,
				195,
				215,
				[189, 2],
				162,
				169,
				282,
				131,
				215,
				323,
				162,
				122,
				42,
				101,
				[360, 2],
				163,
				246,
				67,
				228,
				324,
				335,
				170,
				208,
				237,
				224,
				335,
				340,
				[0, 16],
			],
			[
				[0, 10],
				46,
				137,
				82,
				211,
				43,
				122,
				128,
				226,
				193,
				310,
				201,
				257,
				[251, 3],
				144,
				285,
				256,
				169,
				313,
				169,
				313,
				194,
				313,
				169,
				[194, 2],
				315,
				183,
				315,
				335,
				302,
				247,
				171,
				162,
				44,
				347,
				[313, 3],
				[208, 3],
				282,
				44,
				189,
				215,
				155,
				131,
				237,
				229,
				44,
				147,
				[351, 2],
				261,
				365,
				373,
				253,
				78,
				137,
				130,
				323,
				313,
				285,
				144,
				374,
				206,
				321,
				11,
				[0, 15],
			],
			[
				[0, 9],
				1,
				28,
				258,
				95,
				95,
				112,
				42,
				128,
				268,
				[201, 4],
				[251, 2],
				194,
				334,
				324,
				256,
				194,
				[169, 2],
				313,
				194,
				[169, 3],
				214,
				[194, 3],
				214,
				302,
				171,
				145,
				144,
				242,
				136,
				215,
				315,
				[208, 4],
				237,
				228,
				221,
				317,
				155,
				189,
				[195, 2],
				215,
				144,
				157,
				43,
				211,
				138,
				375,
				273,
				228,
				48,
				44,
				285,
				208,
				229,
				282,
				352,
				282,
				136,
				103,
				[0, 15],
			],
			[
				[0, 9],
				14,
				376,
				42,
				67,
				95,
				43,
				42,
				101,
				237,
				257,
				201,
				142,
				169,
				201,
				251,
				194,
				237,
				324,
				193,
				[194, 2],
				[169, 2],
				313,
				[169, 2],
				335,
				323,
				[169, 2],
				335,
				237,
				137,
				228,
				170,
				208,
				114,
				101,
				155,
				301,
				335,
				[313, 2],
				169,
				144,
				190,
				221,
				324,
				302,
				130,
				334,
				[335, 3],
				202,
				115,
				67,
				43,
				365,
				217,
				93,
				107,
				98,
				347,
				215,
				242,
				155,
				377,
				157,
				184,
				370,
				[0, 15],
			],
			[
				[0, 8],
				9,
				88,
				261,
				43,
				54,
				68,
				37,
				54,
				98,
				268,
				209,
				265,
				205,
				170,
				201,
				[295, 2],
				237,
				324,
				193,
				251,
				194,
				[169, 2],
				313,
				[169, 2],
				215,
				237,
				313,
				315,
				215,
				142,
				98,
				101,
				142,
				208,
				146,
				55,
				242,
				[208, 2],
				335,
				315,
				183,
				215,
				242,
				95,
				136,
				205,
				130,
				155,
				208,
				315,
				335,
				195,
				102,
				106,
				78,
				95,
				299,
				351,
				197,
				98,
				130,
				162,
				130,
				131,
				253,
				44,
				82,
				127,
				4,
				[0, 14],
			],
			[
				[0, 7],
				2,
				236,
				230,
				95,
				43,
				54,
				67,
				54,
				38,
				38,
				68,
				68,
				67,
				114,
				159,
				142,
				201,
				250,
				265,
				155,
				215,
				251,
				[194, 2],
				[169, 2],
				315,
				169,
				144,
				131,
				294,
				313,
				378,
				363,
				98,
				211,
				229,
				145,
				323,
				101,
				44,
				125,
				208,
				301,
				170,
				[208, 2],
				157,
				55,
				221,
				145,
				228,
				148,
				144,
				[315, 2],
				335,
				170,
				48,
				78,
				78,
				82,
				379,
				304,
				373,
				130,
				131,
				130,
				125,
				317,
				373,
				304,
				165,
				5,
				[0, 14],
			],
			[
				[0, 7],
				6,
				87,
				173,
				95,
				54,
				37,
				55,
				54,
				38,
				38,
				62,
				39,
				30,
				69,
				38,
				29,
				246,
				281,
				201,
				237,
				144,
				[251, 2],
				194,
				[169, 2],
				208,
				315,
				131,
				253,
				214,
				313,
				325,
				343,
				128,
				95,
				130,
				228,
				282,
				229,
				101,
				122,
				131,
				325,
				285,
				[170, 2],
				101,
				67,
				247,
				131,
				357,
				266,
				131,
				170,
				[315, 2],
				335,
				159,
				66,
				246,
				98,
				217,
				379,
				297,
				373,
				125,
				101,
				290,
				317,
				290,
				304,
				351,
				103,
				[0, 14],
			],
			[
				[0, 6],
				4,
				280,
				88,
				173,
				95,
				113,
				38,
				38,
				42,
				101,
				42,
				54,
				68,
				62,
				62,
				38,
				39,
				108,
				30,
				202,
				256,
				170,
				169,
				[194, 3],
				294,
				313,
				315,
				229,
				130,
				289,
				[313, 2],
				208,
				102,
				101,
				155,
				268,
				55,
				253,
				190,
				137,
				157,
				133,
				229,
				323,
				155,
				44,
				67,
				247,
				131,
				237,
				[247, 2],
				131,
				208,
				[301, 2],
				170,
				236,
				106,
				66,
				211,
				379,
				380,
				381,
				382,
				101,
				136,
				[215, 2],
				216,
				304,
				83,
				[0, 14],
			],
			[
				[0, 6],
				3,
				236,
				173,
				87,
				94,
				54,
				37,
				38,
				38,
				62,
				38,
				55,
				122,
				189,
				122,
				114,
				55,
				50,
				62,
				202,
				201,
				[215, 2],
				257,
				[194, 2],
				[169, 3],
				282,
				130,
				215,
				313,
				315,
				335,
				357,
				247,
				285,
				144,
				226,
				42,
				177,
				383,
				98,
				305,
				136,
				323,
				155,
				147,
				188,
				384,
				93,
				237,
				282,
				43,
				157,
				170,
				[208, 3],
				209,
				106,
				385,
				211,
				380,
				372,
				386,
				223,
				130,
				387,
				215,
				313,
				215,
				185,
				89,
				[0, 14],
			],
			[
				[0, 6],
				5,
				36,
				88,
				87,
				98,
				54,
				42,
				42,
				54,
				38,
				39,
				30,
				56,
				39,
				115,
				388,
				268,
				159,
				237,
				215,
				[201, 2],
				215,
				169,
				201,
				194,
				[169, 3],
				282,
				242,
				323,
				[313, 2],
				215,
				281,
				44,
				189,
				215,
				142,
				98,
				221,
				177,
				98,
				188,
				95,
				170,
				215,
				157,
				94,
				54,
				54,
				101,
				155,
				268,
				55,
				189,
				142,
				[208, 2],
				237,
				102,
				60,
				211,
				389,
				390,
				379,
				391,
				197,
				221,
				162,
				335,
				313,
				162,
				373,
				9,
				[0, 13],
			],
			[
				[0, 6],
				83,
				48,
				88,
				88,
				95,
				54,
				54,
				42,
				44,
				54,
				54,
				68,
				[39, 4],
				50,
				63,
				246,
				265,
				169,
				201,
				169,
				215,
				144,
				193,
				[215, 2],
				169,
				237,
				228,
				237,
				313,
				169,
				215,
				237,
				114,
				122,
				170,
				313,
				253,
				211,
				155,
				190,
				392,
				42,
				136,
				334,
				190,
				91,
				101,
				122,
				42,
				44,
				125,
				107,
				91,
				200,
				334,
				155,
				224,
				255,
				44,
				82,
				[393, 2],
				365,
				394,
				371,
				373,
				127,
				[144, 2],
				170,
				131,
				37,
				47,
				[0, 12],
			],
			[
				[0, 6],
				72,
				281,
				[216, 2],
				88,
				98,
				113,
				68,
				78,
				42,
				221,
				128,
				98,
				67,
				43,
				37,
				62,
				63,
				115,
				161,
				145,
				331,
				395,
				143,
				145,
				162,
				237,
				282,
				334,
				215,
				[114, 2],
				323,
				313,
				335,
				215,
				190,
				101,
				131,
				335,
				237,
				82,
				93,
				237,
				38,
				100,
				373,
				131,
				159,
				66,
				137,
				165,
				190,
				78,
				101,
				229,
				137,
				42,
				253,
				242,
				334,
				173,
				196,
				211,
				396,
				393,
				217,
				37,
				371,
				211,
				233,
				101,
				233,
				125,
				144,
				136,
				89,
				[0, 12],
			],
			[
				[0, 6],
				11,
				202,
				253,
				88,
				139,
				216,
				114,
				33,
				51,
				30,
				108,
				39,
				54,
				137,
				146,
				132,
				127,
				146,
				255,
				175,
				161,
				5,
				181,
				289,
				[255, 2],
				215,
				323,
				282,
				237,
				159,
				247,
				136,
				208,
				335,
				208,
				205,
				98,
				189,
				215,
				208,
				95,
				221,
				144,
				98,
				188,
				95,
				357,
				131,
				246,
				78,
				101,
				317,
				101,
				91,
				189,
				146,
				67,
				365,
				221,
				132,
				397,
				244,
				373,
				393,
				398,
				399,
				115,
				188,
				359,
				261,
				189,
				298,
				400,
				139,
				162,
				230,
				59,
				[0, 11],
			],
			[
				0,
				0,
				401,
				402,
				403,
				404,
				403,
				405,
				406,
				407,
				408,
				357,
				409,
				13,
				410,
				[411, 3],
				412,
				30,
				30,
				413,
				151,
				414,
				[411, 2],
				415,
				11,
				284,
				256,
				255,
				127,
				416,
				417,
				418,
				414,
				419,
				420,
				421,
				422,
				423,
				335,
				208,
				137,
				101,
				334,
				424,
				425,
				426,
				[414, 2],
				427,
				426,
				428,
				429,
				98,
				78,
				430,
				[411, 9],
				431,
				259,
				292,
				380,
				432,
				433,
				434,
				420,
				414,
				[420, 2],
				426,
				435,
				436,
				177,
				282,
				42,
				174,
				401,
				437,
				438,
				404,
				403,
				439,
				440,
				441,
				442,
				0,
			],
			[
				0,
				441,
				[411, 8],
				443,
				272,
				300,
				202,
				444,
				[411, 3],
				445,
				101,
				62,
				120,
				151,
				414,
				[411, 2],
				446,
				0,
				90,
				201,
				205,
				447,
				419,
				[411, 7],
				448,
				323,
				208,
				357,
				37,
				447,
				419,
				[411, 7],
				421,
				122,
				78,
				449,
				[411, 9],
				450,
				451,
				126,
				217,
				452,
				[411, 8],
				453,
				360,
				162,
				173,
				454,
				[411, 8],
				401,
				0,
			],
			[
				455,
				[411, 2],
				403,
				456,
				1,
				1,
				457,
				458,
				459,
				460,
				208,
				[201, 2],
				461,
				[411, 3],
				462,
				200,
				255,
				162,
				175,
				414,
				[411, 2],
				440,
				0,
				75,
				201,
				463,
				[411, 3],
				459,
				423,
				191,
				464,
				465,
				466,
				467,
				334,
				208,
				237,
				468,
				[411, 3],
				469,
				470,
				199,
				471,
				472,
				473,
				474,
				136,
				60,
				475,
				[411, 3],
				475,
				221,
				190,
				115,
				128,
				114,
				100,
				476,
				203,
				477,
				[411, 2],
				420,
				478,
				78,
				226,
				479,
				480,
				481,
				482,
				211,
				200,
				429,
				[411, 2],
				483,
				455,
				1,
				1,
				442,
				401,
				402,
				401,
				0,
			],
			[
				484,
				[411, 2],
				485,
				[0, 3],
				1,
				340,
				193,
				[251, 2],
				295,
				310,
				461,
				[411, 3],
				462,
				253,
				145,
				144,
				161,
				414,
				[411, 2],
				402,
				0,
				0,
				486,
				[411, 3],
				487,
				313,
				169,
				162,
				136,
				162,
				190,
				55,
				229,
				144,
				488,
				[411, 3],
				454,
				100,
				253,
				130,
				68,
				61,
				188,
				92,
				221,
				98,
				430,
				[411, 3],
				489,
				44,
				163,
				388,
				137,
				132,
				128,
				391,
				399,
				490,
				[411, 2],
				491,
				128,
				114,
				139,
				365,
				492,
				[298, 2],
				189,
				42,
				422,
				[411, 2],
				493,
				[0, 8],
			],
			[
				441,
				[411, 2],
				494,
				442,
				[0, 3],
				11,
				179,
				195,
				[201, 3],
				444,
				[411, 3],
				495,
				253,
				142,
				215,
				161,
				419,
				[411, 2],
				496,
				0,
				0,
				497,
				[411, 2],
				419,
				498,
				[169, 2],
				317,
				377,
				131,
				268,
				107,
				98,
				177,
				499,
				[411, 2],
				414,
				500,
				392,
				101,
				[114, 2],
				152,
				91,
				501,
				286,
				101,
				327,
				[411, 3],
				502,
				373,
				172,
				189,
				197,
				131,
				127,
				503,
				504,
				505,
				[411, 2],
				506,
				507,
				185,
				82,
				492,
				196,
				503,
				298,
				189,
				211,
				508,
				[411, 2],
				509,
				456,
				[0, 7],
			],
			[
				510,
				[411, 4],
				511,
				441,
				401,
				141,
				10,
				234,
				191,
				[205, 2],
				512,
				[411, 3],
				513,
				199,
				142,
				161,
				144,
				514,
				[411, 2],
				496,
				0,
				0,
				515,
				[411, 2],
				516,
				228,
				202,
				169,
				285,
				243,
				282,
				302,
				517,
				92,
				216,
				420,
				[411, 2],
				421,
				518,
				519,
				[60, 3],
				106,
				66,
				520,
				521,
				92,
				327,
				[411, 3],
				489,
				373,
				189,
				42,
				239,
				273,
				127,
				298,
				522,
				523,
				[411, 4],
				524,
				525,
				526,
				376,
				391,
				186,
				122,
				365,
				527,
				[411, 4],
				528,
				441,
				401,
				141,
				[0, 3],
			],
			[
				141,
				529,
				[411, 6],
				530,
				485,
				12,
				199,
				127,
				177,
				429,
				[411, 3],
				531,
				179,
				340,
				83,
				103,
				532,
				[411, 2],
				496,
				0,
				0,
				[411, 3],
				533,
				216,
				268,
				170,
				229,
				130,
				282,
				237,
				78,
				116,
				534,
				[411, 3],
				535,
				521,
				536,
				392,
				60,
				60,
				78,
				78,
				66,
				521,
				537,
				538,
				[411, 9],
				163,
				221,
				539,
				540,
				506,
				[411, 6],
				419,
				541,
				542,
				186,
				211,
				239,
				506,
				[411, 6],
				530,
				543,
				0,
				0,
			],
			[
				0,
				455,
				494,
				[411, 7],
				402,
				6,
				180,
				270,
				544,
				[411, 3],
				545,
				3,
				[0, 3],
				494,
				[411, 2],
				496,
				0,
				0,
				[411, 3],
				546,
				273,
				192,
				323,
				131,
				242,
				155,
				208,
				92,
				547,
				227,
				[411, 3],
				491,
				548,
				549,
				392,
				92,
				[78, 3],
				550,
				551,
				537,
				538,
				[411, 9],
				225,
				122,
				298,
				398,
				552,
				553,
				[411, 7],
				554,
				380,
				351,
				196,
				555,
				553,
				[411, 7],
				496,
				0,
			],
			[
				[0, 3],
				401,
				485,
				494,
				[411, 5],
				141,
				3,
				220,
				556,
				[411, 3],
				401,
				[0, 4],
				494,
				[411, 2],
				496,
				0,
				0,
				532,
				[411, 2],
				557,
				82,
				127,
				317,
				215,
				189,
				155,
				335,
				67,
				392,
				78,
				414,
				[411, 2],
				421,
				68,
				549,
				519,
				91,
				66,
				78,
				66,
				66,
				501,
				66,
				558,
				[411, 3],
				559,
				269,
				142,
				209,
				139,
				451,
				298,
				304,
				360,
				365,
				364,
				92,
				560,
				561,
				562,
				[411, 5],
				540,
				380,
				[196, 2],
				563,
				480,
				525,
				427,
				[411, 5],
				141,
			],
			[
				[0, 6],
				141,
				402,
				[411, 3],
				455,
				0,
				0,
				442,
				[411, 3],
				401,
				[0, 4],
				403,
				[411, 2],
				441,
				0,
				0,
				485,
				[411, 2],
				414,
				564,
				291,
				172,
				155,
				93,
				269,
				162,
				107,
				565,
				66,
				566,
				[411, 2],
				414,
				94,
				567,
				364,
				286,
				66,
				91,
				568,
				479,
				569,
				568,
				570,
				[411, 3],
				560,
				231,
				519,
				518,
				501,
				568,
				399,
				432,
				571,
				360,
				66,
				[106, 2],
				572,
				573,
				574,
				575,
				[411, 3],
				576,
				577,
				571,
				563,
				578,
				[571, 2],
				380,
				579,
				402,
				[411, 3],
				455,
			],
			[
				[0, 7],
				442,
				[411, 3],
				442,
				[0, 3],
				580,
				[411, 2],
				484,
				[0, 3],
				141,
				[411, 3],
				581,
				0,
				0,
				455,
				[411, 3],
				541,
				582,
				583,
				290,
				101,
				190,
				132,
				242,
				572,
				568,
				584,
				[411, 3],
				467,
				360,
				371,
				567,
				392,
				188,
				568,
				565,
				585,
				586,
				587,
				[411, 3],
				588,
				589,
				519,
				[590, 2],
				436,
				360,
				577,
				591,
				577,
				197,
				218,
				100,
				572,
				592,
				593,
				594,
				[411, 3],
				595,
				596,
				577,
				571,
				597,
				598,
				[577, 2],
				360,
				599,
				[411, 3],
				442,
			],
			[
				510,
				496,
				401,
				442,
				1,
				0,
				141,
				485,
				[411, 2],
				494,
				[0, 4],
				485,
				[411, 2],
				403,
				456,
				0,
				141,
				440,
				[411, 2],
				529,
				141,
				[0, 3],
				484,
				[411, 3],
				541,
				600,
				199,
				601,
				602,
				603,
				604,
				94,
				589,
				605,
				606,
				[411, 3],
				607,
				608,
				521,
				471,
				609,
				610,
				611,
				521,
				612,
				613,
				[411, 3],
				614,
				564,
				67,
				501,
				590,
				521,
				548,
				492,
				615,
				616,
				554,
				617,
				618,
				619,
				620,
				621,
				622,
				[411, 2],
				414,
				623,
				397,
				450,
				505,
				624,
				619,
				573,
				571,
				625,
				626,
				[411, 2],
				494,
				0,
			],
			[
				627,
				[411, 8],
				530,
				456,
				[0, 4],
				1,
				628,
				[411, 7],
				404,
				401,
				[0, 5],
				629,
				419,
				[411, 7],
				630,
				258,
				173,
				631,
				632,
				633,
				419,
				[411, 7],
				634,
				521,
				590,
				635,
				[411, 9],
				611,
				636,
				637,
				638,
				[411, 8],
				414,
				639,
				197,
				187,
				447,
				[411, 8],
				530,
				456,
				0,
			],
			[
				141,
				510,
				496,
				628,
				494,
				404,
				529,
				511,
				441,
				442,
				[0, 7],
				581,
				440,
				403,
				404,
				529,
				628,
				441,
				141,
				[0, 6],
				271,
				640,
				641,
				630,
				506,
				[414, 2],
				642,
				643,
				644,
				60,
				189,
				175,
				645,
				239,
				646,
				633,
				647,
				506,
				414,
				420,
				648,
				610,
				649,
				536,
				590,
				650,
				[411, 9],
				474,
				636,
				651,
				652,
				638,
				653,
				524,
				562,
				414,
				506,
				562,
				622,
				654,
				655,
				656,
				631,
				470,
				657,
				658,
				659,
				553,
				[414, 2],
				660,
				441,
				442,
				0,
				0,
			],
			[
				[0, 29],
				4,
				9,
				33,
				53,
				365,
				351,
				54,
				98,
				252,
				269,
				122,
				94,
				551,
				364,
				226,
				128,
				661,
				595,
				589,
				662,
				663,
				254,
				302,
				664,
				[549, 2],
				536,
				665,
				666,
				667,
				668,
				589,
				67,
				669,
				670,
				185,
				88,
				67,
				92,
				60,
				519,
				548,
				671,
				672,
				673,
				668,
				[667, 3],
				663,
				674,
				586,
				359,
				231,
				586,
				589,
				258,
				397,
				661,
				675,
				676,
				53,
				[0, 4],
			],
			[
				[0, 27],
				1,
				57,
				364,
				[676, 2],
				391,
				677,
				360,
				128,
				244,
				678,
				[186, 2],
				669,
				542,
				98,
				153,
				679,
				235,
				631,
				204,
				680,
				671,
				637,
				680,
				190,
				392,
				519,
				681,
				590,
				636,
				682,
				667,
				671,
				92,
				93,
				564,
				397,
				683,
				231,
				371,
				218,
				384,
				[371, 2],
				612,
				684,
				637,
				[667, 2],
				620,
				586,
				675,
				620,
				675,
				669,
				397,
				676,
				[685, 2],
				573,
				542,
				573,
				53,
				[0, 4],
			],
			[
				[0, 27],
				1,
				686,
				670,
				687,
				688,
				689,
				690,
				223,
				244,
				691,
				692,
				88,
				211,
				615,
				685,
				94,
				693,
				694,
				572,
				645,
				534,
				160,
				679,
				695,
				672,
				696,
				204,
				218,
				188,
				392,
				521,
				697,
				672,
				619,
				605,
				67,
				268,
				255,
				263,
				254,
				564,
				674,
				235,
				263,
				127,
				177,
				492,
				698,
				682,
				699,
				673,
				632,
				569,
				673,
				699,
				687,
				700,
				259,
				685,
				[573, 3],
				698,
				701,
				[0, 4],
			],
		],
	};


  // project-rome/@romejs/cli-diagnostics/banners/error.json
const ___R$project$rome$$romejs$cli$diagnostics$banners$error_json$default = {
		"palettes": [
			[0, 0, 0],
			[15, 0, 0],
			[30, 15, 15],
			[30, 15, 30],
			[15, 15, 15],
			[75, 60, 60],
			[45, 30, 30],
			[30, 30, 30],
			[90, 75, 75],
			[120, 90, 90],
			[105, 75, 75],
			[60, 45, 45],
			[90, 75, 60],
			[90, 60, 60],
			[105, 90, 90],
			[180, 135, 135],
			[150, 120, 120],
			[165, 135, 120],
			[120, 105, 90],
			[150, 120, 105],
			[105, 75, 90],
			[45, 45, 45],
			[30, 30, 15],
			[195, 165, 165],
			[195, 165, 150],
			[165, 120, 120],
			[180, 150, 150],
			[165, 135, 135],
			[15, 0, 15],
			[75, 60, 45],
			[165, 150, 135],
			[210, 165, 165],
			[210, 180, 180],
			[225, 180, 180],
			[135, 105, 105],
			[60, 30, 30],
			[60, 60, 45],
			[210, 180, 165],
			[225, 195, 180],
			[225, 195, 195],
			[75, 45, 45],
			[45, 15, 15],
			[135, 120, 105],
			[180, 150, 135],
			[195, 150, 150],
			[135, 105, 90],
			[240, 210, 195],
			[240, 195, 195],
			[30, 15, 0],
			[150, 135, 120],
			[180, 165, 150],
			[240, 210, 210],
			[240, 195, 180],
			[105, 90, 75],
			[135, 120, 120],
			[225, 180, 165],
			[210, 165, 150],
			[240, 210, 180],
			[60, 45, 30],
			[120, 105, 105],
			[240, 225, 210],
			[225, 210, 195],
			[195, 150, 135],
			[75, 75, 60],
			[180, 165, 165],
			[240, 225, 225],
			[225, 195, 165],
			[195, 165, 135],
			[210, 150, 135],
			[210, 180, 150],
			[180, 135, 105],
			[195, 180, 165],
			[165, 120, 90],
			[165, 105, 75],
			[180, 120, 105],
			[210, 165, 135],
			[195, 135, 120],
			[225, 165, 150],
			[195, 150, 120],
			[210, 195, 180],
			[150, 90, 75],
			[225, 180, 150],
			[180, 120, 90],
			[195, 135, 105],
			[150, 75, 45],
			[180, 135, 120],
			[45, 15, 30],
			[210, 150, 120],
			[165, 105, 90],
			[165, 120, 105],
			[135, 90, 75],
			[135, 90, 90],
			[180, 120, 75],
			[165, 90, 60],
			[150, 90, 45],
			[135, 60, 30],
			[135, 75, 60],
			[150, 105, 75],
			[180, 150, 120],
			[15, 15, 0],
			[165, 135, 105],
			[240, 195, 165],
			[180, 105, 75],
			[165, 90, 45],
			[195, 135, 90],
			[150, 90, 60],
			[135, 90, 60],
			[150, 105, 90],
			[150, 135, 105],
			[45, 45, 30],
			[210, 135, 120],
			[195, 120, 90],
			[180, 105, 60],
			[165, 75, 45],
			[105, 75, 60],
			[210, 135, 105],
			[225, 150, 105],
			[225, 135, 105],
			[210, 120, 90],
			[195, 105, 75],
			[195, 120, 75],
			[195, 90, 60],
			[180, 90, 45],
			[150, 75, 30],
			[135, 75, 45],
			[240, 150, 105],
			[240, 135, 105],
			[210, 105, 75],
			[180, 90, 60],
			[195, 105, 60],
			[150, 75, 60],
			[135, 90, 45],
			[255, 150, 105],
			[240, 150, 120],
			[240, 165, 120],
			[240, 165, 135],
			[225, 120, 90],
			[180, 75, 45],
			[180, 75, 30],
			[165, 75, 30],
			[225, 150, 135],
			[255, 165, 120],
			[240, 180, 150],
			[255, 195, 165],
			[240, 150, 135],
			[210, 105, 60],
			[195, 90, 45],
			[150, 60, 15],
			[150, 60, 30],
			[45, 30, 45],
			[225, 165, 135],
			[255, 150, 120],
			[255, 210, 180],
			[225, 120, 75],
			[165, 90, 75],
			[195, 120, 105],
			[255, 210, 195],
			[255, 195, 180],
			[255, 180, 165],
			[240, 120, 90],
			[180, 105, 105],
			[120, 90, 75],
			[240, 135, 90],
			[255, 135, 105],
			[255, 180, 150],
			[195, 120, 120],
			[135, 120, 90],
			[255, 165, 135],
			[240, 180, 165],
			[165, 60, 30],
			[150, 60, 45],
			[180, 105, 90],
			[240, 165, 150],
			[255, 165, 150],
			[165, 75, 60],
			[165, 105, 60],
			[120, 105, 75],
			[240, 135, 120],
			[240, 120, 105],
			[195, 90, 75],
			[135, 45, 30],
			[255, 135, 90],
			[210, 120, 75],
			[225, 150, 120],
			[225, 135, 90],
			[240, 120, 75],
			[135, 45, 15],
			[75, 45, 30],
			[150, 120, 90],
			[240, 135, 75],
			[180, 75, 60],
			[150, 105, 105],
			[210, 105, 90],
			[135, 75, 30],
			[120, 90, 60],
			[255, 150, 135],
			[225, 120, 105],
			[120, 45, 15],
			[120, 60, 15],
			[210, 135, 90],
			[165, 60, 45],
			[105, 45, 0],
			[135, 105, 75],
			[180, 90, 75],
			[105, 60, 15],
			[225, 105, 75],
			[210, 90, 75],
			[210, 90, 60],
			[195, 75, 45],
			[105, 30, 0],
			[120, 75, 45],
			[120, 60, 30],
			[120, 30, 15],
			[120, 30, 0],
			[135, 30, 0],
			[150, 45, 15],
			[165, 45, 15],
			[165, 60, 15],
			[105, 30, 15],
			[105, 45, 15],
			[75, 60, 30],
			[105, 15, 0],
			[105, 0, 0],
			[120, 0, 0],
			[120, 15, 0],
			[135, 15, 0],
			[150, 30, 0],
			[90, 0, 0],
			[75, 0, 0],
			[75, 15, 0],
			[90, 15, 0],
			[90, 30, 0],
			[120, 60, 45],
			[45, 30, 15],
			[150, 45, 0],
			[165, 30, 0],
			[165, 45, 0],
			[180, 60, 30],
			[135, 45, 0],
			[120, 45, 0],
			[225, 165, 165],
			[105, 75, 45],
			[90, 30, 15],
			[120, 45, 30],
			[60, 30, 15],
			[180, 45, 0],
			[45, 0, 0],
			[90, 30, 30],
			[150, 45, 30],
			[120, 45, 45],
			[105, 60, 45],
			[30, 0, 0],
			[180, 60, 45],
			[195, 15, 0],
			[225, 135, 75],
			[105, 30, 30],
			[105, 15, 15],
			[60, 0, 0],
			[135, 30, 30],
			[180, 0, 0],
			[210, 0, 0],
			[195, 105, 90],
			[120, 30, 30],
			[165, 0, 0],
			[120, 75, 60],
			[210, 150, 105],
			[240, 150, 90],
			[135, 60, 45],
			[135, 60, 15],
			[165, 15, 0],
			[195, 0, 0],
			[195, 75, 30],
			[195, 60, 30],
			[180, 15, 0],
			[255, 150, 90],
			[165, 30, 15],
			[165, 45, 30],
			[105, 45, 30],
			[195, 75, 60],
			[90, 45, 15],
			[150, 30, 15],
			[180, 45, 30],
			[225, 105, 60],
			[225, 105, 90],
			[150, 15, 0],
			[210, 90, 45],
			[210, 120, 105],
			[90, 60, 45],
			[225, 135, 120],
			[225, 120, 60],
			[90, 45, 30],
			[135, 30, 15],
			[195, 105, 45],
			[75, 30, 15],
			[45, 15, 0],
			[180, 60, 15],
			[60, 15, 15],
			[195, 90, 30],
			[180, 75, 15],
			[165, 60, 0],
			[150, 75, 15],
			[105, 60, 60],
			[150, 60, 0],
			[180, 90, 30],
			[165, 75, 15],
			[180, 105, 45],
			[165, 90, 30],
			[180, 120, 60],
			[165, 105, 45],
			[150, 90, 30],
			[135, 60, 0],
			[120, 90, 105],
			[165, 150, 150],
			[75, 30, 0],
			[75, 30, 30],
			[135, 105, 120],
			[60, 15, 0],
			[135, 120, 135],
			[165, 135, 150],
			[90, 60, 75],
			[60, 60, 60],
			[75, 60, 75],
			[150, 135, 135],
			[255, 0, 0],
			[240, 0, 0],
			[225, 45, 15],
			[135, 75, 15],
			[105, 90, 105],
			[60, 45, 60],
			[195, 60, 15],
			[60, 30, 0],
			[75, 15, 15],
			[225, 30, 0],
			[120, 60, 0],
			[45, 30, 0],
			[225, 0, 0],
			[225, 15, 0],
			[195, 165, 180],
			[90, 75, 90],
			[150, 0, 0],
			[195, 30, 0],
			[210, 15, 15],
			[180, 150, 165],
			[150, 120, 135],
			[75, 75, 75],
			[75, 45, 15],
			[195, 45, 0],
			[210, 30, 30],
			[225, 60, 30],
			[210, 75, 30],
			[240, 45, 15],
			[210, 30, 15],
			[225, 75, 30],
			[180, 30, 0],
			[210, 15, 0],
			[105, 90, 60],
			[240, 210, 165],
			[225, 105, 45],
			[75, 45, 60],
			[60, 60, 30],
			[165, 120, 75],
			[60, 45, 15],
			[210, 105, 45],
			[225, 90, 45],
			[210, 30, 0],
			[240, 60, 30],
			[240, 45, 30],
			[210, 45, 15],
			[195, 150, 105],
			[105, 45, 45],
			[240, 15, 0],
			[240, 75, 45],
			[150, 45, 45],
			[150, 105, 60],
			[255, 75, 60],
			[45, 45, 15],
			[90, 90, 75],
			[180, 60, 0],
		],
		"rows": [
			[[0, 52], 1, [0, 47]],
			[[0, 51], 2, [0, 4], 1, [0, 43]],
			[[0, 46], 3, 0, 0, 4, 1, 5, 6, 6, 1, 7, 2, 2, 4, 4, [0, 40]],
			[[0, 46], 5, 1, 0, 4, 8, 9, 10, 10, 8, 11, 12, 13, 11, 5, [0, 40]],
			[
				[0, 42],
				4,
				[0, 3],
				14,
				6,
				2,
				5,
				9,
				15,
				16,
				17,
				16,
				18,
				16,
				19,
				14,
				20,
				0,
				1,
				1,
				[0, 37],
			],
			[
				[0, 40],
				11,
				6,
				21,
				2,
				3,
				22,
				16,
				9,
				8,
				16,
				17,
				23,
				23,
				24,
				25,
				26,
				23,
				27,
				27,
				9,
				0,
				28,
				14,
				[0, 37],
			],
			[
				[0, 37],
				7,
				0,
				0,
				6,
				19,
				5,
				11,
				29,
				9,
				30,
				27,
				15,
				24,
				23,
				31,
				23,
				24,
				32,
				31,
				32,
				33,
				24,
				27,
				11,
				5,
				34,
				9,
				35,
				6,
				[0, 4],
				11,
				28,
				[0, 28],
			],
			[
				[0, 31],
				4,
				[0, 3],
				2,
				36,
				12,
				6,
				13,
				18,
				18,
				27,
				13,
				19,
				16,
				24,
				31,
				33,
				32,
				32,
				37,
				31,
				24,
				32,
				38,
				38,
				39,
				32,
				26,
				34,
				10,
				34,
				23,
				13,
				40,
				28,
				41,
				2,
				10,
				42,
				2,
				[0, 28],
			],
			[
				[0, 31],
				7,
				0,
				0,
				1,
				12,
				9,
				19,
				19,
				10,
				24,
				17,
				43,
				24,
				31,
				44,
				31,
				38,
				[33, 4],
				37,
				37,
				33,
				[39, 4],
				33,
				44,
				19,
				16,
				31,
				23,
				27,
				45,
				17,
				16,
				14,
				9,
				6,
				[0, 28],
			],
			[
				[0, 27],
				4,
				0,
				7,
				0,
				11,
				21,
				11,
				11,
				14,
				43,
				26,
				17,
				43,
				38,
				31,
				31,
				33,
				46,
				[38, 7],
				33,
				38,
				[39, 3],
				38,
				39,
				38,
				47,
				37,
				17,
				23,
				31,
				44,
				27,
				27,
				9,
				16,
				15,
				48,
				0,
				1,
				1,
				[0, 25],
			],
			[
				[0, 27],
				4,
				11,
				13,
				8,
				16,
				9,
				16,
				18,
				49,
				26,
				39,
				16,
				50,
				46,
				39,
				38,
				39,
				51,
				46,
				52,
				38,
				52,
				38,
				38,
				52,
				38,
				38,
				39,
				39,
				46,
				38,
				47,
				46,
				47,
				47,
				33,
				32,
				37,
				31,
				17,
				27,
				23,
				31,
				31,
				16,
				53,
				8,
				1,
				[0, 25],
			],
			[
				[0, 25],
				21,
				11,
				5,
				8,
				54,
				27,
				37,
				27,
				26,
				31,
				33,
				49,
				32,
				55,
				24,
				38,
				46,
				47,
				47,
				51,
				46,
				38,
				[55, 3],
				52,
				52,
				33,
				56,
				47,
				39,
				[47, 3],
				46,
				47,
				46,
				47,
				38,
				33,
				37,
				31,
				31,
				32,
				31,
				26,
				16,
				16,
				10,
				[0, 26],
			],
			[
				[0, 26],
				14,
				18,
				14,
				16,
				37,
				33,
				38,
				38,
				24,
				38,
				24,
				37,
				38,
				56,
				52,
				46,
				57,
				38,
				46,
				47,
				31,
				56,
				37,
				37,
				55,
				52,
				55,
				37,
				52,
				[33, 3],
				38,
				39,
				39,
				46,
				47,
				46,
				38,
				55,
				33,
				32,
				33,
				24,
				16,
				32,
				27,
				34,
				12,
				5,
				6,
				[0, 23],
			],
			[
				[0, 25],
				28,
				58,
				26,
				59,
				43,
				38,
				33,
				39,
				60,
				61,
				38,
				57,
				24,
				38,
				55,
				46,
				55,
				56,
				37,
				46,
				33,
				24,
				56,
				24,
				38,
				31,
				37,
				62,
				55,
				33,
				55,
				37,
				31,
				33,
				47,
				39,
				33,
				52,
				46,
				38,
				55,
				38,
				33,
				33,
				31,
				17,
				23,
				27,
				27,
				63,
				14,
				1,
				0,
				7,
				[0, 21],
			],
			[
				[0, 25],
				1,
				0,
				64,
				5,
				49,
				39,
				38,
				47,
				65,
				60,
				38,
				46,
				66,
				57,
				52,
				52,
				67,
				68,
				69,
				46,
				55,
				38,
				56,
				70,
				62,
				55,
				56,
				56,
				31,
				31,
				37,
				55,
				55,
				37,
				39,
				38,
				38,
				33,
				52,
				47,
				38,
				38,
				[33, 3],
				44,
				31,
				26,
				27,
				8,
				6,
				13,
				20,
				13,
				[0, 21],
			],
			[
				[0, 23],
				4,
				6,
				8,
				1,
				71,
				34,
				34,
				[46, 3],
				60,
				51,
				46,
				57,
				66,
				66,
				55,
				52,
				62,
				72,
				66,
				55,
				55,
				31,
				55,
				73,
				74,
				68,
				68,
				62,
				62,
				56,
				37,
				56,
				33,
				55,
				37,
				33,
				52,
				38,
				33,
				46,
				38,
				33,
				37,
				33,
				33,
				37,
				37,
				23,
				44,
				17,
				27,
				42,
				34,
				13,
				1,
				[0, 20],
			],
			[
				[0, 24],
				14,
				5,
				59,
				23,
				44,
				19,
				38,
				[46, 4],
				52,
				55,
				55,
				75,
				55,
				69,
				76,
				73,
				56,
				62,
				77,
				55,
				55,
				68,
				74,
				62,
				76,
				78,
				74,
				62,
				[56, 3],
				55,
				37,
				31,
				33,
				55,
				33,
				47,
				33,
				33,
				37,
				39,
				38,
				37,
				37,
				32,
				26,
				34,
				53,
				27,
				9,
				7,
				[0, 21],
			],
			[
				[0, 21],
				1,
				2,
				2,
				8,
				16,
				42,
				79,
				37,
				19,
				17,
				46,
				57,
				52,
				52,
				55,
				56,
				55,
				75,
				69,
				75,
				70,
				76,
				76,
				62,
				56,
				38,
				56,
				56,
				55,
				56,
				74,
				80,
				76,
				70,
				75,
				[62, 4],
				24,
				55,
				56,
				37,
				31,
				33,
				55,
				33,
				33,
				38,
				[37, 3],
				19,
				53,
				43,
				27,
				63,
				0,
				4,
				[0, 20],
			],
			[
				[0, 22],
				2,
				13,
				45,
				43,
				43,
				37,
				52,
				31,
				67,
				81,
				[52, 3],
				69,
				69,
				55,
				81,
				56,
				56,
				76,
				68,
				82,
				83,
				75,
				55,
				62,
				56,
				56,
				75,
				80,
				84,
				72,
				83,
				85,
				78,
				78,
				72,
				78,
				24,
				69,
				78,
				56,
				62,
				31,
				24,
				[37, 5],
				31,
				17,
				30,
				62,
				34,
				0,
				11,
				4,
				2,
				[0, 19],
			],
			[
				[0, 22],
				86,
				11,
				42,
				17,
				37,
				62,
				55,
				38,
				56,
				75,
				[55, 4],
				67,
				75,
				81,
				56,
				75,
				75,
				87,
				73,
				73,
				88,
				69,
				78,
				70,
				70,
				62,
				72,
				84,
				80,
				75,
				74,
				85,
				89,
				90,
				72,
				85,
				75,
				85,
				[62, 3],
				56,
				37,
				56,
				37,
				55,
				37,
				31,
				17,
				24,
				44,
				35,
				5,
				5,
				36,
				11,
				[0, 19],
			],
			[
				[0, 21],
				4,
				4,
				91,
				53,
				17,
				37,
				55,
				69,
				52,
				66,
				75,
				62,
				81,
				56,
				81,
				75,
				68,
				81,
				69,
				70,
				78,
				87,
				92,
				93,
				94,
				78,
				83,
				82,
				82,
				88,
				82,
				95,
				96,
				78,
				82,
				74,
				97,
				72,
				97,
				74,
				89,
				85,
				85,
				98,
				62,
				56,
				62,
				56,
				56,
				62,
				56,
				31,
				44,
				43,
				44,
				9,
				16,
				12,
				8,
				11,
				21,
				99,
				[0, 17],
			],
			[
				[0, 20],
				7,
				2,
				40,
				19,
				37,
				43,
				100,
				38,
				66,
				66,
				101,
				75,
				78,
				62,
				68,
				68,
				87,
				75,
				78,
				77,
				74,
				83,
				76,
				83,
				102,
				103,
				102,
				104,
				102,
				105,
				95,
				82,
				95,
				105,
				100,
				76,
				106,
				107,
				96,
				72,
				80,
				90,
				72,
				89,
				85,
				56,
				43,
				43,
				62,
				67,
				62,
				24,
				37,
				56,
				24,
				43,
				108,
				43,
				26,
				34,
				8,
				109,
				1,
				[0, 17],
			],
			[
				[0, 20],
				11,
				11,
				9,
				45,
				17,
				69,
				55,
				85,
				55,
				55,
				66,
				75,
				70,
				83,
				83,
				110,
				87,
				87,
				111,
				87,
				83,
				82,
				82,
				111,
				112,
				113,
				103,
				[102, 2],
				84,
				84,
				73,
				95,
				88,
				97,
				88,
				106,
				96,
				106,
				88,
				97,
				97,
				72,
				72,
				85,
				62,
				85,
				85,
				98,
				98,
				62,
				[24, 3],
				56,
				62,
				62,
				17,
				18,
				63,
				4,
				21,
				6,
				[0, 17],
			],
			[
				[0, 21],
				12,
				53,
				114,
				107,
				43,
				66,
				66,
				52,
				55,
				81,
				87,
				83,
				115,
				116,
				[117, 3],
				[115, 2],
				118,
				119,
				102,
				120,
				119,
				121,
				122,
				113,
				93,
				123,
				93,
				84,
				105,
				73,
				[124, 4],
				97,
				106,
				[105, 2],
				97,
				80,
				70,
				76,
				85,
				85,
				98,
				17,
				62,
				62,
				56,
				44,
				24,
				56,
				43,
				19,
				12,
				22,
				29,
				8,
				1,
				[0, 17],
			],
			[
				[0, 20],
				58,
				58,
				34,
				43,
				56,
				24,
				56,
				55,
				81,
				81,
				75,
				68,
				110,
				117,
				[125, 2],
				[126, 2],
				117,
				[115, 2],
				118,
				115,
				117,
				118,
				127,
				121,
				128,
				[122, 2],
				129,
				128,
				94,
				94,
				105,
				130,
				84,
				[124, 3],
				[105, 2],
				131,
				73,
				83,
				72,
				74,
				70,
				[62, 3],
				98,
				24,
				43,
				43,
				56,
				62,
				45,
				19,
				18,
				5,
				99,
				[0, 18],
			],
			[
				[0, 20],
				8,
				114,
				40,
				34,
				[55, 3],
				66,
				66,
				56,
				78,
				76,
				110,
				126,
				125,
				[132, 2],
				133,
				134,
				[135, 5],
				133,
				136,
				127,
				121,
				137,
				122,
				138,
				122,
				103,
				139,
				[123, 3],
				95,
				95,
				84,
				84,
				124,
				105,
				[82, 4],
				72,
				89,
				62,
				67,
				[62, 3],
				43,
				24,
				62,
				17,
				19,
				13,
				1,
				[0, 19],
			],
			[
				[0, 20],
				5,
				50,
				19,
				43,
				56,
				55,
				[66, 3],
				81,
				75,
				140,
				133,
				[125, 2],
				[132, 2],
				141,
				142,
				143,
				[101, 3],
				142,
				144,
				126,
				136,
				145,
				121,
				146,
				122,
				138,
				[139, 3],
				147,
				[148, 2],
				123,
				84,
				84,
				105,
				88,
				[82, 3],
				73,
				88,
				89,
				85,
				67,
				56,
				[62, 3],
				24,
				24,
				43,
				17,
				44,
				40,
				[0, 19],
			],
			[
				[0, 20],
				149,
				42,
				37,
				[107, 2],
				85,
				69,
				66,
				55,
				56,
				77,
				150,
				133,
				125,
				126,
				132,
				151,
				135,
				143,
				152,
				[52, 3],
				101,
				144,
				126,
				136,
				153,
				127,
				145,
				121,
				122,
				137,
				138,
				[139, 2],
				[123, 2],
				84,
				84,
				130,
				154,
				74,
				74,
				155,
				82,
				73,
				154,
				89,
				76,
				[85, 3],
				62,
				43,
				24,
				37,
				56,
				43,
				45,
				1,
				[0, 19],
			],
			[
				[0, 21],
				109,
				18,
				69,
				55,
				[66, 3],
				69,
				56,
				81,
				135,
				125,
				[126, 3],
				151,
				142,
				143,
				156,
				152,
				101,
				157,
				158,
				133,
				126,
				159,
				[153, 3],
				145,
				121,
				146,
				122,
				[137, 2],
				113,
				139,
				113,
				130,
				154,
				160,
				74,
				76,
				83,
				82,
				73,
				154,
				82,
				68,
				56,
				85,
				43,
				62,
				44,
				44,
				56,
				62,
				114,
				161,
				2,
				5,
				6,
				[0, 17],
			],
			[
				[0, 20],
				4,
				29,
				45,
				90,
				98,
				69,
				66,
				55,
				75,
				56,
				55,
				135,
				126,
				[162, 2],
				163,
				151,
				164,
				157,
				152,
				52,
				[157, 2],
				164,
				133,
				126,
				136,
				[153, 3],
				127,
				[121, 2],
				122,
				137,
				113,
				139,
				[148, 2],
				84,
				154,
				160,
				165,
				83,
				[155, 2],
				73,
				73,
				72,
				62,
				33,
				55,
				31,
				56,
				37,
				55,
				55,
				56,
				43,
				25,
				27,
				19,
				11,
				[0, 17],
			],
			[
				[0, 19],
				6,
				58,
				10,
				166,
				75,
				81,
				69,
				69,
				75,
				77,
				75,
				142,
				144,
				[162, 3],
				163,
				132,
				167,
				164,
				158,
				168,
				143,
				142,
				144,
				126,
				[136, 2],
				[153, 2],
				[127, 2],
				[121, 2],
				128,
				137,
				113,
				169,
				[148, 2],
				170,
				130,
				154,
				171,
				82,
				76,
				155,
				73,
				73,
				74,
				85,
				31,
				33,
				52,
				38,
				38,
				46,
				38,
				38,
				33,
				24,
				15,
				10,
				5,
				6,
				[0, 16],
			],
			[
				[0, 19],
				6,
				10,
				5,
				42,
				98,
				81,
				55,
				55,
				81,
				75,
				150,
				172,
				133,
				[162, 4],
				163,
				133,
				135,
				167,
				164,
				173,
				144,
				133,
				126,
				[136, 2],
				153,
				[127, 3],
				121,
				[128, 3],
				113,
				[148, 4],
				170,
				174,
				154,
				155,
				76,
				155,
				93,
				175,
				74,
				62,
				62,
				24,
				55,
				[46, 3],
				47,
				39,
				38,
				37,
				24,
				27,
				9,
				6,
				1,
				[0, 15],
			],
			[
				[0, 19],
				6,
				176,
				17,
				43,
				67,
				75,
				75,
				55,
				81,
				75,
				77,
				150,
				125,
				[162, 4],
				126,
				125,
				133,
				[135, 3],
				133,
				177,
				178,
				[136, 2],
				153,
				[127, 2],
				119,
				179,
				[128, 2],
				93,
				174,
				84,
				[148, 2],
				180,
				95,
				84,
				93,
				171,
				155,
				171,
				[105, 2],
				88,
				76,
				62,
				62,
				24,
				37,
				55,
				38,
				33,
				47,
				33,
				23,
				17,
				27,
				34,
				9,
				6,
				[0, 15],
			],
			[
				[0, 19],
				4,
				6,
				161,
				43,
				24,
				75,
				81,
				52,
				81,
				77,
				81,
				150,
				117,
				[162, 2],
				181,
				162,
				126,
				163,
				151,
				133,
				[144, 2],
				133,
				126,
				[136, 2],
				118,
				182,
				127,
				[119, 3],
				128,
				93,
				93,
				174,
				170,
				148,
				95,
				180,
				95,
				95,
				130,
				154,
				[171, 2],
				94,
				105,
				88,
				76,
				[85, 3],
				[62, 3],
				56,
				31,
				24,
				37,
				24,
				62,
				34,
				6,
				[0, 16],
			],
			[
				[0, 18],
				4,
				6,
				29,
				40,
				161,
				98,
				56,
				66,
				55,
				55,
				77,
				150,
				183,
				184,
				185,
				162,
				181,
				[163, 2],
				126,
				133,
				[135, 2],
				144,
				133,
				177,
				117,
				[136, 2],
				118,
				182,
				[119, 3],
				128,
				93,
				174,
				113,
				170,
				95,
				180,
				[186, 2],
				95,
				84,
				154,
				73,
				93,
				93,
				154,
				74,
				85,
				[62, 4],
				98,
				62,
				24,
				56,
				56,
				31,
				43,
				17,
				9,
				6,
				[0, 16],
			],
			[
				[0, 18],
				99,
				187,
				114,
				188,
				45,
				89,
				69,
				66,
				55,
				81,
				87,
				87,
				183,
				184,
				159,
				162,
				163,
				[126, 2],
				151,
				[135, 4],
				133,
				177,
				[136, 3],
				[118, 2],
				127,
				[119, 2],
				[128, 2],
				174,
				113,
				148,
				95,
				95,
				[186, 2],
				95,
				95,
				130,
				171,
				103,
				[105, 2],
				74,
				56,
				62,
				17,
				85,
				85,
				43,
				62,
				62,
				24,
				56,
				37,
				37,
				43,
				34,
				161,
				11,
				[0, 15],
			],
			[
				[0, 18],
				1,
				22,
				35,
				107,
				43,
				56,
				37,
				69,
				69,
				75,
				87,
				150,
				183,
				153,
				189,
				[162, 2],
				163,
				132,
				151,
				[167, 2],
				[135, 2],
				[133, 2],
				117,
				[136, 2],
				[118, 2],
				[127, 2],
				119,
				179,
				190,
				113,
				[170, 2],
				148,
				[95, 4],
				84,
				95,
				95,
				123,
				84,
				80,
				89,
				191,
				43,
				85,
				89,
				[85, 3],
				62,
				24,
				56,
				37,
				55,
				24,
				16,
				59,
				5,
				2,
				[0, 14],
			],
			[
				[0, 20],
				6,
				161,
				17,
				43,
				24,
				56,
				75,
				87,
				[150, 2],
				117,
				184,
				189,
				[162, 2],
				[163, 2],
				151,
				[135, 3],
				[133, 2],
				126,
				117,
				136,
				[118, 2],
				136,
				192,
				127,
				119,
				179,
				128,
				113,
				170,
				[148, 3],
				[95, 6],
				193,
				84,
				80,
				88,
				89,
				107,
				89,
				85,
				17,
				85,
				[62, 3],
				55,
				55,
				56,
				19,
				9,
				10,
				11,
				[0, 15],
			],
			[
				[0, 21],
				29,
				194,
				45,
				67,
				67,
				68,
				87,
				83,
				115,
				184,
				[162, 4],
				[163, 2],
				151,
				195,
				[167, 2],
				133,
				126,
				196,
				136,
				118,
				127,
				[136, 2],
				118,
				127,
				119,
				179,
				128,
				113,
				169,
				[148, 4],
				[95, 5],
				197,
				198,
				124,
				97,
				[107, 4],
				19,
				89,
				85,
				62,
				56,
				[55, 3],
				24,
				42,
				29,
				4,
				[0, 15],
			],
			[
				[0, 20],
				6,
				40,
				45,
				[98, 3],
				78,
				78,
				83,
				199,
				153,
				[162, 3],
				181,
				[163, 4],
				151,
				133,
				[126, 2],
				117,
				136,
				[127, 2],
				118,
				136,
				118,
				127,
				119,
				179,
				128,
				174,
				200,
				[148, 5],
				[95, 4],
				[201, 2],
				198,
				106,
				107,
				188,
				107,
				202,
				89,
				85,
				98,
				56,
				55,
				52,
				38,
				24,
				19,
				29,
				2,
				1,
				[0, 15],
			],
			[
				[0, 21],
				4,
				29,
				187,
				58,
				70,
				70,
				73,
				92,
				182,
				[162, 4],
				181,
				[162, 4],
				[126, 2],
				196,
				[136, 2],
				[127, 4],
				136,
				127,
				119,
				[179, 2],
				203,
				174,
				170,
				148,
				[95, 7],
				198,
				[201, 3],
				204,
				106,
				107,
				[89, 3],
				85,
				85,
				56,
				37,
				55,
				55,
				44,
				45,
				5,
				6,
				[0, 16],
			],
			[
				[0, 23],
				29,
				161,
				70,
				70,
				72,
				102,
				153,
				[162, 5],
				126,
				162,
				[159, 3],
				[136, 2],
				205,
				[127, 2],
				121,
				[179, 2],
				127,
				206,
				179,
				121,
				[128, 2],
				84,
				84,
				170,
				[95, 4],
				84,
				84,
				95,
				197,
				[201, 5],
				96,
				97,
				107,
				19,
				85,
				85,
				62,
				56,
				56,
				24,
				62,
				16,
				10,
				6,
				[0, 16],
			],
			[
				[0, 23],
				36,
				42,
				100,
				78,
				82,
				118,
				162,
				189,
				162,
				153,
				159,
				162,
				[126, 2],
				159,
				[136, 2],
				127,
				[207, 2],
				121,
				208,
				121,
				[128, 2],
				127,
				207,
				128,
				190,
				[174, 2],
				130,
				174,
				84,
				170,
				[84, 4],
				130,
				84,
				197,
				201,
				[209, 2],
				[201, 3],
				210,
				72,
				107,
				89,
				85,
				98,
				56,
				56,
				24,
				62,
				19,
				53,
				11,
				2,
				[0, 15],
			],
			[
				[0, 22],
				1,
				187,
				12,
				85,
				78,
				83,
				184,
				189,
				[153, 3],
				146,
				122,
				119,
				179,
				[128, 2],
				[113, 3],
				[137, 2],
				138,
				[137, 3],
				121,
				208,
				139,
				[148, 2],
				170,
				84,
				84,
				[124, 2],
				84,
				84,
				93,
				93,
				73,
				93,
				211,
				201,
				[209, 3],
				[201, 2],
				204,
				106,
				188,
				107,
				89,
				98,
				62,
				24,
				56,
				24,
				43,
				9,
				5,
				7,
				[0, 15],
			],
			[
				[0, 22],
				1,
				161,
				100,
				78,
				78,
				82,
				184,
				136,
				[153, 2],
				121,
				137,
				148,
				186,
				180,
				197,
				212,
				[213, 2],
				214,
				[215, 2],
				216,
				[137, 2],
				113,
				137,
				138,
				217,
				[186, 2],
				212,
				[218, 2],
				219,
				197,
				211,
				[198, 2],
				124,
				105,
				93,
				124,
				201,
				[209, 3],
				[201, 2],
				204,
				106,
				89,
				202,
				107,
				89,
				43,
				62,
				89,
				161,
				13,
				11,
				2,
				2,
				[0, 15],
			],
			[
				[0, 22],
				99,
				220,
				89,
				75,
				83,
				111,
				184,
				[153, 2],
				145,
				146,
				139,
				148,
				186,
				213,
				221,
				222,
				223,
				224,
				225,
				[226, 2],
				216,
				138,
				137,
				113,
				137,
				169,
				215,
				214,
				213,
				221,
				227,
				[228, 2],
				[229, 2],
				230,
				[231, 2],
				219,
				84,
				130,
				197,
				[209, 4],
				201,
				198,
				232,
				188,
				90,
				89,
				43,
				56,
				56,
				15,
				45,
				19,
				18,
				53,
				5,
				2,
				[0, 14],
			],
			[
				[0, 23],
				233,
				90,
				150,
				83,
				118,
				162,
				189,
				153,
				129,
				[122, 2],
				113,
				[169, 3],
				216,
				[234, 2],
				235,
				[226, 2],
				236,
				237,
				[137, 2],
				139,
				215,
				238,
				213,
				209,
				[213, 2],
				[209, 2],
				212,
				[197, 2],
				219,
				[209, 2],
				219,
				95,
				198,
				[201, 2],
				239,
				[197, 3],
				106,
				89,
				89,
				85,
				85,
				77,
				240,
				55,
				62,
				45,
				29,
				109,
				11,
				[0, 15],
			],
			[
				[0, 23],
				109,
				241,
				83,
				111,
				199,
				[162, 2],
				153,
				145,
				146,
				208,
				237,
				215,
				186,
				218,
				230,
				228,
				221,
				214,
				234,
				[226, 2],
				138,
				129,
				121,
				113,
				186,
				239,
				213,
				[209, 2],
				221,
				227,
				229,
				[242, 2],
				219,
				243,
				218,
				[209, 2],
				197,
				201,
				209,
				201,
				197,
				198,
				95,
				95,
				105,
				70,
				62,
				85,
				62,
				155,
				179,
				78,
				62,
				17,
				6,
				0,
				4,
				[0, 15],
			],
			[
				[0, 23],
				4,
				244,
				83,
				111,
				184,
				[162, 2],
				153,
				145,
				146,
				245,
				225,
				223,
				218,
				246,
				2,
				40,
				247,
				180,
				215,
				248,
				234,
				146,
				184,
				127,
				113,
				238,
				239,
				[197, 2],
				213,
				224,
				249,
				250,
				35,
				21,
				251,
				246,
				229,
				[209, 3],
				[201, 2],
				239,
				198,
				95,
				[193, 2],
				105,
				72,
				98,
				62,
				74,
				252,
				253,
				111,
				85,
				27,
				49,
				13,
				28,
				[0, 15],
			],
			[
				[0, 24],
				58,
				87,
				111,
				254,
				[189, 2],
				162,
				185,
				145,
				208,
				121,
				252,
				170,
				255,
				227,
				256,
				180,
				248,
				169,
				200,
				217,
				136,
				133,
				118,
				137,
				238,
				239,
				[197, 3],
				248,
				170,
				96,
				228,
				[257, 2],
				247,
				230,
				227,
				230,
				209,
				[201, 2],
				239,
				198,
				95,
				193,
				84,
				175,
				72,
				70,
				85,
				258,
				259,
				260,
				102,
				17,
				16,
				34,
				12,
				[0, 16],
			],
			[
				[0, 22],
				1,
				6,
				90,
				87,
				119,
				153,
				[189, 2],
				162,
				126,
				162,
				125,
				133,
				117,
				261,
				203,
				[200, 4],
				113,
				200,
				121,
				125,
				133,
				118,
				137,
				186,
				[239, 2],
				197,
				95,
				[170, 2],
				248,
				180,
				[262, 2],
				197,
				212,
				[209, 2],
				201,
				[239, 3],
				95,
				124,
				95,
				193,
				73,
				82,
				70,
				171,
				223,
				263,
				260,
				190,
				58,
				2,
				2,
				5,
				11,
				[0, 15],
			],
			[
				[0, 22],
				2,
				1,
				264,
				265,
				112,
				153,
				[189, 2],
				266,
				151,
				134,
				162,
				[136, 2],
				127,
				121,
				252,
				[237, 2],
				169,
				137,
				121,
				126,
				167,
				133,
				127,
				169,
				215,
				[239, 2],
				197,
				186,
				[148, 3],
				[170, 2],
				[267, 2],
				95,
				197,
				209,
				201,
				[239, 2],
				197,
				[95, 3],
				268,
				105,
				82,
				72,
				130,
				223,
				269,
				270,
				171,
				13,
				6,
				[0, 18],
			],
			[
				[0, 24],
				244,
				92,
				122,
				153,
				185,
				162,
				132,
				[125, 2],
				126,
				205,
				271,
				272,
				[237, 3],
				137,
				121,
				127,
				162,
				133,
				135,
				117,
				121,
				169,
				215,
				238,
				[239, 2],
				186,
				[170, 2],
				148,
				215,
				180,
				148,
				95,
				186,
				[239, 2],
				197,
				95,
				95,
				148,
				170,
				95,
				95,
				268,
				84,
				175,
				82,
				148,
				214,
				235,
				273,
				155,
				19,
				11,
				[0, 18],
			],
			[
				[0, 23],
				1,
				251,
				124,
				122,
				153,
				185,
				162,
				274,
				132,
				125,
				126,
				159,
				205,
				127,
				[207, 2],
				127,
				118,
				136,
				[126, 2],
				151,
				135,
				136,
				121,
				148,
				215,
				186,
				[239, 2],
				238,
				[148, 2],
				170,
				[148, 3],
				[186, 3],
				95,
				84,
				93,
				[174, 2],
				84,
				95,
				[268, 2],
				95,
				84,
				93,
				214,
				226,
				275,
				276,
				85,
				12,
				48,
				[0, 18],
			],
			[
				[0, 25],
				277,
				145,
				153,
				185,
				162,
				181,
				132,
				133,
				167,
				151,
				[133, 4],
				[144, 2],
				133,
				[163, 2],
				195,
				135,
				136,
				121,
				215,
				[186, 2],
				239,
				213,
				238,
				215,
				[148, 3],
				169,
				[148, 2],
				169,
				[148, 4],
				113,
				93,
				93,
				84,
				268,
				239,
				268,
				130,
				174,
				[226, 2],
				216,
				154,
				19,
				114,
				6,
				[0, 18],
			],
			[
				[0, 25],
				277,
				205,
				153,
				185,
				189,
				181,
				163,
				132,
				[167, 6],
				173,
				167,
				151,
				[126, 2],
				167,
				173,
				196,
				278,
				215,
				213,
				186,
				[239, 2],
				238,
				148,
				[169, 7],
				148,
				[215, 2],
				[148, 2],
				113,
				93,
				84,
				268,
				197,
				84,
				[203, 2],
				226,
				235,
				216,
				171,
				34,
				19,
				233,
				[0, 18],
			],
			[
				[0, 25],
				279,
				[153, 2],
				[185, 2],
				[181, 2],
				132,
				167,
				[173, 3],
				[167, 3],
				151,
				126,
				[162, 2],
				151,
				144,
				136,
				278,
				186,
				213,
				[239, 2],
				238,
				186,
				[200, 2],
				[137, 2],
				[169, 5],
				148,
				147,
				268,
				95,
				84,
				93,
				93,
				123,
				84,
				93,
				111,
				261,
				280,
				275,
				281,
				78,
				62,
				89,
				11,
				1,
				[0, 17],
			],
			[
				[0, 25],
				277,
				205,
				153,
				[185, 2],
				181,
				[163, 2],
				133,
				167,
				164,
				173,
				195,
				177,
				126,
				205,
				282,
				162,
				125,
				167,
				144,
				283,
				137,
				186,
				209,
				201,
				[239, 2],
				148,
				113,
				[137, 4],
				138,
				237,
				137,
				[113, 2],
				148,
				[268, 2],
				148,
				113,
				93,
				84,
				84,
				128,
				102,
				179,
				284,
				216,
				237,
				70,
				45,
				233,
				11,
				22,
				[0, 17],
			],
			[
				[0, 25],
				211,
				127,
				153,
				[185, 2],
				181,
				[163, 2],
				126,
				144,
				135,
				[178, 2],
				159,
				205,
				285,
				153,
				[125, 2],
				173,
				133,
				127,
				252,
				186,
				213,
				[209, 2],
				239,
				95,
				113,
				137,
				[128, 2],
				[137, 4],
				113,
				93,
				174,
				148,
				268,
				84,
				113,
				93,
				84,
				84,
				93,
				102,
				119,
				286,
				128,
				190,
				89,
				45,
				287,
				2,
				[0, 18],
			],
			[
				[0, 25],
				211,
				127,
				153,
				[185, 2],
				[181, 3],
				126,
				151,
				126,
				283,
				205,
				127,
				207,
				271,
				[126, 3],
				177,
				118,
				179,
				113,
				186,
				213,
				209,
				239,
				201,
				197,
				169,
				137,
				[128, 3],
				[137, 2],
				[113, 2],
				[93, 3],
				84,
				123,
				93,
				128,
				84,
				84,
				103,
				128,
				261,
				288,
				118,
				286,
				75,
				98,
				13,
				[0, 19],
			],
			[
				[0, 25],
				124,
				127,
				289,
				[185, 2],
				[159, 3],
				[126, 3],
				136,
				207,
				146,
				271,
				208,
				[153, 3],
				145,
				208,
				137,
				148,
				186,
				[213, 5],
				215,
				[137, 2],
				[128, 3],
				137,
				169,
				148,
				113,
				[93, 3],
				84,
				103,
				93,
				103,
				123,
				84,
				93,
				203,
				261,
				[140, 2],
				89,
				6,
				11,
				2,
				[0, 18],
			],
			[
				[0, 25],
				211,
				145,
				289,
				[185, 5],
				[159, 2],
				136,
				127,
				207,
				[208, 3],
				272,
				216,
				146,
				138,
				217,
				234,
				238,
				213,
				[209, 2],
				[213, 3],
				214,
				113,
				137,
				[128, 3],
				113,
				148,
				215,
				148,
				84,
				84,
				[103, 3],
				93,
				103,
				[84, 3],
				102,
				288,
				286,
				155,
				264,
				22,
				[0, 20],
			],
			[
				[0, 25],
				290,
				145,
				289,
				[185, 6],
				[205, 2],
				127,
				121,
				137,
				127,
				177,
				283,
				275,
				[226, 2],
				214,
				213,
				209,
				221,
				218,
				[221, 3],
				213,
				186,
				148,
				[137, 3],
				190,
				113,
				148,
				248,
				186,
				268,
				[123, 2],
				84,
				113,
				93,
				103,
				123,
				84,
				84,
				93,
				192,
				133,
				111,
				287,
				[0, 21],
			],
			[
				[0, 25],
				241,
				[145, 2],
				[153, 4],
				[205, 3],
				145,
				121,
				137,
				127,
				177,
				133,
				144,
				127,
				137,
				291,
				224,
				[221, 2],
				[230, 2],
				[221, 3],
				212,
				180,
				148,
				113,
				[137, 2],
				113,
				200,
				[148, 2],
				186,
				197,
				95,
				95,
				148,
				123,
				93,
				103,
				[123, 2],
				84,
				103,
				252,
				208,
				119,
				175,
				48,
				[0, 20],
			],
			[
				[0, 25],
				73,
				[145, 2],
				[153, 2],
				[282, 4],
				207,
				121,
				208,
				121,
				136,
				[126, 2],
				177,
				127,
				128,
				148,
				213,
				212,
				221,
				230,
				[221, 4],
				212,
				243,
				170,
				113,
				[169, 3],
				148,
				147,
				268,
				[239, 3],
				197,
				186,
				148,
				113,
				103,
				123,
				148,
				123,
				113,
				248,
				280,
				80,
				[277, 2],
				[0, 20],
			],
			[
				[0, 25],
				219,
				292,
				[145, 2],
				[282, 3],
				207,
				285,
				[208, 2],
				137,
				[121, 2],
				[127, 3],
				128,
				169,
				215,
				213,
				243,
				212,
				209,
				221,
				209,
				230,
				[221, 2],
				243,
				180,
				[148, 2],
				169,
				[147, 2],
				186,
				238,
				239,
				213,
				[209, 2],
				239,
				[268, 2],
				103,
				123,
				84,
				148,
				139,
				102,
				130,
				293,
				294,
				279,
				[0, 20],
			],
			[
				[0, 25],
				209,
				93,
				[145, 3],
				[285, 3],
				271,
				[138, 3],
				137,
				139,
				[137, 2],
				139,
				[147, 2],
				238,
				213,
				197,
				239,
				209,
				221,
				[230, 4],
				221,
				209,
				213,
				238,
				[215, 2],
				[238, 3],
				239,
				213,
				[209, 2],
				239,
				[268, 2],
				84,
				123,
				[148, 2],
				123,
				261,
				210,
				294,
				187,
				244,
				[0, 20],
			],
			[
				[0, 25],
				246,
				139,
				[145, 2],
				[285, 2],
				146,
				271,
				295,
				236,
				[147, 3],
				238,
				[123, 2],
				139,
				147,
				238,
				186,
				[209, 2],
				239,
				213,
				209,
				[230, 2],
				[229, 3],
				[230, 2],
				209,
				213,
				[238, 3],
				[213, 3],
				[209, 3],
				186,
				268,
				123,
				268,
				[148, 2],
				123,
				119,
				105,
				210,
				296,
				[0, 21],
			],
			[
				[0, 26],
				277,
				129,
				121,
				146,
				297,
				271,
				298,
				299,
				234,
				[238, 2],
				[239, 2],
				268,
				147,
				300,
				147,
				[238, 2],
				[214, 2],
				186,
				[213, 2],
				221,
				[230, 2],
				257,
				228,
				257,
				228,
				230,
				221,
				213,
				[238, 2],
				[213, 2],
				[209, 4],
				239,
				[268, 5],
				148,
				113,
				123,
				277,
				1,
				[0, 21],
			],
			[
				[0, 26],
				294,
				122,
				[146, 2],
				[138, 2],
				295,
				299,
				217,
				147,
				239,
				230,
				221,
				213,
				224,
				214,
				[225, 2],
				284,
				[226, 3],
				225,
				224,
				222,
				[227, 2],
				228,
				229,
				[257, 3],
				229,
				213,
				238,
				239,
				213,
				[209, 4],
				231,
				209,
				[239, 4],
				186,
				148,
				107,
				301,
				[0, 23],
			],
			[
				[0, 27],
				84,
				[146, 2],
				138,
				[298, 2],
				[138, 2],
				302,
				239,
				230,
				224,
				214,
				226,
				169,
				137,
				200,
				169,
				248,
				215,
				[291, 2],
				186,
				291,
				212,
				213,
				221,
				230,
				228,
				[246, 2],
				228,
				213,
				238,
				239,
				[209, 3],
				[231, 3],
				209,
				201,
				239,
				[201, 2],
				239,
				95,
				25,
				8,
				3,
				[0, 22],
			],
			[
				[0, 27],
				277,
				146,
				208,
				138,
				298,
				[138, 3],
				234,
				209,
				221,
				215,
				137,
				[121, 2],
				129,
				138,
				139,
				[169, 2],
				[215, 2],
				248,
				95,
				186,
				213,
				209,
				213,
				209,
				229,
				246,
				257,
				209,
				213,
				209,
				[231, 3],
				[209, 2],
				231,
				[209, 5],
				239,
				267,
				16,
				13,
				11,
				[0, 22],
			],
			[
				[0, 27],
				294,
				137,
				[138, 5],
				217,
				238,
				221,
				214,
				137,
				145,
				[127, 2],
				122,
				303,
				139,
				103,
				147,
				[186, 2],
				268,
				[239, 2],
				[213, 4],
				209,
				228,
				257,
				221,
				[209, 2],
				[231, 2],
				[209, 4],
				230,
				[231, 3],
				209,
				239,
				107,
				59,
				11,
				59,
				11,
				[0, 21],
			],
			[
				[0, 28],
				95,
				[138, 4],
				304,
				302,
				213,
				230,
				239,
				139,
				121,
				127,
				145,
				292,
				[305, 2],
				306,
				268,
				193,
				[268, 2],
				239,
				268,
				238,
				[213, 2],
				209,
				230,
				228,
				257,
				230,
				209,
				221,
				[231, 2],
				[209, 4],
				[230, 4],
				209,
				201,
				27,
				35,
				21,
				14,
				20,
				[0, 21],
			],
			[
				[0, 28],
				244,
				139,
				138,
				[298, 2],
				217,
				234,
				213,
				219,
				239,
				147,
				121,
				127,
				145,
				119,
				182,
				307,
				308,
				103,
				308,
				309,
				123,
				[300, 2],
				310,
				238,
				213,
				209,
				229,
				257,
				246,
				229,
				230,
				221,
				[209, 6],
				[230, 2],
				229,
				[231, 2],
				250,
				14,
				2,
				8,
				311,
				14,
				[0, 21],
			],
			[
				[0, 29],
				95,
				217,
				295,
				[217, 2],
				234,
				238,
				209,
				239,
				148,
				121,
				127,
				118,
				[184, 2],
				199,
				[112, 2],
				120,
				112,
				103,
				139,
				300,
				268,
				239,
				209,
				230,
				257,
				[246, 2],
				229,
				230,
				[209, 2],
				201,
				[239, 2],
				[209, 2],
				230,
				[229, 2],
				230,
				231,
				9,
				6,
				6,
				8,
				312,
				6,
				[0, 21],
			],
			[
				[0, 29],
				293,
				[217, 3],
				299,
				[302, 2],
				[239, 2],
				148,
				121,
				127,
				126,
				117,
				118,
				119,
				129,
				122,
				129,
				92,
				175,
				148,
				147,
				268,
				197,
				209,
				228,
				246,
				[251, 2],
				229,
				231,
				[209, 2],
				[239, 3],
				209,
				[230, 2],
				229,
				230,
				229,
				13,
				5,
				2,
				11,
				312,
				8,
				8,
				1,
				[0, 20],
			],
			[
				[0, 30],
				186,
				[217, 4],
				302,
				209,
				239,
				123,
				129,
				127,
				136,
				118,
				127,
				[129, 2],
				112,
				[139, 2],
				103,
				148,
				[239, 3],
				231,
				257,
				246,
				251,
				246,
				313,
				[209, 3],
				[239, 2],
				[209, 2],
				230,
				[229, 3],
				314,
				8,
				2,
				7,
				54,
				54,
				8,
				315,
				11,
				2,
				22,
				[0, 18],
			],
			[
				[0, 30],
				293,
				[234, 2],
				[299, 2],
				302,
				209,
				239,
				123,
				122,
				207,
				127,
				128,
				112,
				137,
				[122, 2],
				139,
				234,
				186,
				95,
				239,
				197,
				230,
				229,
				257,
				[251, 2],
				294,
				[231, 2],
				209,
				201,
				239,
				[209, 2],
				230,
				[229, 3],
				316,
				13,
				86,
				4,
				14,
				311,
				5,
				317,
				318,
				319,
				1,
				6,
				5,
				6,
				[0, 16],
			],
			[
				[0, 30],
				1,
				95,
				[234, 2],
				302,
				234,
				230,
				231,
				239,
				139,
				146,
				121,
				139,
				122,
				103,
				175,
				123,
				139,
				147,
				238,
				197,
				213,
				209,
				229,
				316,
				246,
				[251, 2],
				246,
				231,
				[209, 5],
				[230, 2],
				229,
				313,
				229,
				5,
				11,
				1,
				320,
				14,
				5,
				8,
				23,
				16,
				5,
				1,
				1,
				6,
				5,
				5,
				4,
				[0, 14],
			],
			[
				[0, 30],
				11,
				290,
				234,
				238,
				234,
				238,
				213,
				228,
				231,
				197,
				148,
				139,
				147,
				103,
				[175, 2],
				123,
				103,
				268,
				[209, 2],
				230,
				229,
				257,
				[246, 2],
				[251, 2],
				246,
				231,
				[209, 4],
				[230, 3],
				229,
				316,
				6,
				11,
				1,
				6,
				321,
				5,
				320,
				322,
				54,
				311,
				319,
				6,
				2,
				6,
				11,
				5,
				8,
				21,
				[0, 13],
			],
			[
				[0, 22],
				260,
				[323, 11],
				324,
				213,
				209,
				[229, 2],
				230,
				275,
				[323, 5],
				325,
				123,
				326,
				209,
				229,
				257,
				[246, 2],
				251,
				260,
				[323, 4],
				[231, 4],
				260,
				[323, 4],
				8,
				1,
				4,
				[11, 3],
				14,
				311,
				8,
				5,
				8,
				11,
				4,
				0,
				1,
				6,
				8,
				327,
				8,
				6,
				[0, 11],
			],
			[
				[0, 22],
				260,
				[323, 11],
				324,
				[209, 2],
				231,
				[229, 2],
				260,
				[323, 5],
				324,
				268,
				198,
				231,
				257,
				246,
				[251, 3],
				260,
				[323, 4],
				[230, 4],
				260,
				[323, 4],
				2,
				1,
				21,
				109,
				7,
				321,
				8,
				328,
				14,
				10,
				2,
				22,
				1,
				0,
				2,
				14,
				5,
				5,
				8,
				327,
				8,
				2,
				[0, 9],
			],
			[
				[0, 22],
				260,
				[323, 11],
				324,
				201,
				230,
				229,
				230,
				221,
				324,
				[323, 6],
				329,
				198,
				231,
				246,
				251,
				1,
				[251, 2],
				260,
				[323, 4],
				[230, 4],
				260,
				[323, 4],
				0,
				7,
				2,
				2,
				11,
				5,
				11,
				11,
				54,
				8,
				2,
				29,
				6,
				1,
				6,
				5,
				59,
				322,
				315,
				8,
				322,
				54,
				8,
				4,
				[0, 7],
			],
			[
				[0, 22],
				260,
				[323, 4],
				220,
				330,
				[244, 2],
				294,
				331,
				123,
				231,
				[209, 2],
				230,
				228,
				259,
				[323, 7],
				332,
				333,
				231,
				[251, 5],
				260,
				[323, 4],
				229,
				[230, 2],
				229,
				260,
				[323, 4],
				4,
				2,
				28,
				6,
				11,
				11,
				7,
				322,
				9,
				5,
				2,
				14,
				40,
				1,
				22,
				8,
				64,
				26,
				16,
				315,
				14,
				26,
				318,
				322,
				59,
				11,
				[0, 5],
			],
			[
				[0, 22],
				260,
				[323, 4],
				244,
				334,
				244,
				294,
				246,
				229,
				122,
				239,
				[221, 2],
				[227, 2],
				335,
				[323, 3],
				336,
				[323, 4],
				302,
				230,
				246,
				251,
				[246, 3],
				260,
				[323, 4],
				228,
				229,
				257,
				246,
				260,
				[323, 4],
				0,
				1,
				7,
				6,
				6,
				2,
				8,
				27,
				10,
				35,
				5,
				59,
				40,
				1,
				6,
				322,
				337,
				26,
				59,
				20,
				14,
				338,
				14,
				311,
				59,
				59,
				14,
				6,
				[0, 3],
			],
			[
				[0, 22],
				260,
				[323, 4],
				334,
				187,
				41,
				316,
				246,
				257,
				122,
				137,
				213,
				[221, 2],
				339,
				[323, 4],
				236,
				336,
				[323, 3],
				340,
				229,
				[257, 2],
				[229, 2],
				257,
				260,
				[323, 4],
				246,
				[251, 2],
				6,
				341,
				[323, 4],
				0,
				4,
				7,
				[2, 3],
				54,
				9,
				14,
				58,
				14,
				9,
				35,
				1,
				8,
				312,
				342,
				343,
				13,
				58,
				5,
				8,
				[14, 3],
				8,
				321,
				5,
				344,
				5,
				2,
			],
			[
				[0, 22],
				260,
				[323, 4],
				[244, 2],
				316,
				257,
				246,
				345,
				[292, 2],
				146,
				238,
				224,
				260,
				[323, 3],
				335,
				238,
				346,
				[323, 3],
				324,
				230,
				228,
				[230, 3],
				229,
				260,
				[323, 4],
				1,
				1,
				11,
				11,
				347,
				[323, 4],
				1,
				4,
				4,
				[2, 3],
				317,
				311,
				8,
				13,
				59,
				10,
				41,
				2,
				59,
				322,
				16,
				10,
				58,
				58,
				35,
				35,
				8,
				[311, 3],
				59,
				311,
				14,
				8,
				14,
			],
			[
				[0, 22],
				260,
				[323, 11],
				348,
				292,
				146,
				234,
				324,
				[323, 3],
				253,
				238,
				122,
				324,
				[323, 3],
				263,
				[221, 2],
				230,
				231,
				230,
				260,
				[323, 4],
				1,
				6,
				8,
				14,
				260,
				[323, 4],
				1,
				1,
				2,
				6,
				1,
				6,
				54,
				54,
				13,
				10,
				311,
				13,
				251,
				6,
				343,
				59,
				13,
				11,
				58,
				58,
				[233, 2],
				5,
				54,
				322,
				16,
				311,
				14,
				315,
				54,
				59,
			],
			[
				[0, 22],
				260,
				[323, 11],
				348,
				146,
				292,
				349,
				[323, 3],
				324,
				284,
				225,
				147,
				350,
				[323, 3],
				260,
				[221, 2],
				[209, 3],
				260,
				[323, 4],
				109,
				8,
				34,
				5,
				260,
				[323, 4],
				1,
				1,
				6,
				2,
				0,
				320,
				54,
				54,
				5,
				319,
				8,
				11,
				1,
				5,
				315,
				13,
				11,
				40,
				6,
				[233, 2],
				6,
				14,
				343,
				311,
				20,
				20,
				54,
				[322, 2],
				318,
			],
			[
				[0, 20],
				1,
				2,
				351,
				[323, 11],
				352,
				297,
				146,
				325,
				[323, 3],
				335,
				[214, 3],
				353,
				[323, 3],
				324,
				214,
				[213, 2],
				221,
				230,
				260,
				[323, 4],
				8,
				5,
				5,
				1,
				260,
				[323, 4],
				1,
				7,
				22,
				1,
				1,
				8,
				[315, 2],
				20,
				319,
				29,
				6,
				2,
				8,
				10,
				35,
				5,
				40,
				6,
				[233, 2],
				29,
				[8, 3],
				311,
				343,
				318,
				322,
				16,
				343,
			],
			[
				[0, 15],
				99,
				2,
				2,
				22,
				233,
				109,
				58,
				341,
				[323, 4],
				330,
				313,
				294,
				175,
				306,
				122,
				[282, 2],
				285,
				271,
				324,
				[323, 3],
				340,
				[226, 4],
				324,
				[323, 3],
				273,
				224,
				221,
				227,
				228,
				260,
				[323, 4],
				14,
				0,
				1,
				0,
				260,
				[323, 4],
				2,
				7,
				4,
				0,
				4,
				14,
				54,
				54,
				14,
				13,
				35,
				251,
				2,
				11,
				58,
				11,
				5,
				40,
				[233, 2],
				58,
				29,
				5,
				5,
				14,
				315,
				54,
				59,
				59,
				34,
				315,
			],
			[
				[0, 12],
				99,
				22,
				22,
				6,
				[109, 3],
				[58, 3],
				354,
				[323, 4],
				293,
				294,
				355,
				356,
				210,
				128,
				357,
				[282, 2],
				352,
				[323, 13],
				335,
				[213, 3],
				221,
				260,
				[323, 4],
				6,
				[0, 3],
				260,
				[323, 4],
				22,
				2,
				1,
				0,
				4,
				327,
				54,
				54,
				14,
				358,
				6,
				1,
				233,
				58,
				58,
				5,
				5,
				58,
				[233, 2],
				58,
				58,
				29,
				8,
				14,
				14,
				8,
				20,
				59,
				311,
				322,
			],
			[
				[0, 9],
				99,
				7,
				11,
				5,
				11,
				[109, 3],
				[58, 3],
				359,
				233,
				260,
				[323, 4],
				316,
				294,
				287,
				360,
				112,
				145,
				[282, 3],
				350,
				[323, 14],
				236,
				234,
				214,
				224,
				260,
				[323, 4],
				[0, 4],
				260,
				[323, 4],
				22,
				1,
				0,
				0,
				7,
				14,
				59,
				9,
				8,
				11,
				2,
				48,
				6,
				11,
				11,
				40,
				13,
				6,
				233,
				361,
				58,
				58,
				5,
				13,
				8,
				13,
				13,
				5,
				5,
				8,
				322,
			],
			[
				[0, 7],
				4,
				6,
				36,
				5,
				5,
				11,
				58,
				[109, 2],
				58,
				11,
				11,
				29,
				58,
				251,
				260,
				[323, 4],
				251,
				233,
				114,
				89,
				112,
				153,
				289,
				362,
				363,
				[323, 15],
				364,
				234,
				214,
				224,
				260,
				[323, 4],
				[0, 4],
				260,
				[323, 4],
				2,
				[0, 3],
				21,
				338,
				8,
				319,
				5,
				35,
				48,
				22,
				11,
				5,
				11,
				40,
				40,
				[233, 2],
				361,
				58,
				40,
				[5, 3],
				29,
				6,
				6,
				11,
				14,
				59,
			],
			[
				[0, 6],
				21,
				[5, 4],
				36,
				11,
				58,
				58,
				11,
				29,
				[58, 3],
				48,
				2,
				260,
				[323, 4],
				1,
				279,
				193,
				105,
				113,
				162,
				153,
				145,
				365,
				[323, 3],
				366,
				185,
				153,
				205,
				145,
				[146, 2],
				138,
				367,
				[323, 3],
				324,
				234,
				214,
				221,
				260,
				[323, 4],
				[0, 4],
				260,
				[323, 4],
				1,
				0,
				0,
				1,
				5,
				8,
				8,
				5,
				358,
				6,
				99,
				6,
				5,
				319,
				8,
				5,
				[233, 2],
				361,
				58,
				58,
				29,
				29,
				11,
				6,
				233,
				6,
				11,
				5,
				20,
				14,
			],
			[
				[0, 4],
				4,
				11,
				5,
				8,
				8,
				5,
				36,
				5,
				36,
				11,
				36,
				29,
				58,
				58,
				109,
				48,
				41,
				41,
				260,
				[323, 4],
				233,
				219,
				368,
				369,
				137,
				[162, 2],
				282,
				370,
				[323, 3],
				371,
				[153, 3],
				145,
				285,
				146,
				138,
				329,
				[323, 4],
				353,
				213,
				229,
				354,
				[323, 4],
				[0, 4],
				260,
				[323, 12],
				372,
				2,
				48,
				58,
				13,
				13,
				319,
				5,
				[233, 2],
				58,
				58,
				29,
				29,
				11,
				58,
				22,
				22,
				11,
				36,
				5,
				20,
				14,
			],
			[
				[0, 3],
				2,
				5,
				63,
				344,
				5,
				5,
				36,
				29,
				63,
				63,
				29,
				29,
				[58, 3],
				233,
				2,
				48,
				251,
				260,
				[323, 4],
				244,
				290,
				373,
				124,
				121,
				162,
				181,
				185,
				[323, 4],
				363,
				[282, 2],
				145,
				285,
				146,
				297,
				271,
				138,
				370,
				[323, 3],
				336,
				230,
				40,
				351,
				[323, 4],
				[0, 4],
				260,
				[323, 12],
				258,
				2,
				233,
				36,
				8,
				5,
				5,
				40,
				233,
				361,
				58,
				29,
				29,
				58,
				11,
				109,
				22,
				6,
				36,
				29,
				8,
				14,
				8,
			],
			[
				0,
				0,
				2,
				29,
				63,
				344,
				5,
				5,
				36,
				36,
				[12, 3],
				5,
				[58, 3],
				6,
				[233, 2],
				48,
				251,
				260,
				[323, 4],
				187,
				244,
				72,
				93,
				207,
				[162, 2],
				374,
				[323, 3],
				370,
				[282, 2],
				[145, 3],
				[362, 2],
				146,
				271,
				325,
				[323, 3],
				324,
				232,
				58,
				260,
				[323, 4],
				[0, 4],
				260,
				[323, 12],
				291,
				1,
				109,
				5,
				8,
				13,
				29,
				58,
				375,
				[58, 3],
				[22, 3],
				2,
				22,
				11,
				11,
				36,
				8,
				8,
				319,
			],
			[
				0,
				4,
				[5, 5],
				29,
				29,
				12,
				376,
				12,
				12,
				11,
				359,
				36,
				6,
				109,
				22,
				233,
				48,
				[251, 2],
				233,
				48,
				1,
				48,
				293,
				290,
				106,
				113,
				153,
				132,
				[181, 2],
				163,
				126,
				153,
				362,
				[282, 6],
				145,
				285,
				146,
				271,
				377,
				235,
				284,
				242,
				58,
				1,
				[0, 10],
				[1, 3],
				[0, 3],
				22,
				5,
				5,
				58,
				5,
				11,
				2,
				2,
				58,
				8,
				8,
				13,
				29,
				58,
				58,
				220,
				35,
				99,
				4,
				109,
				6,
				4,
				6,
				29,
				29,
				11,
				[5, 3],
			],
		],
	};


  // project-rome/@romejs/cli-diagnostics/DiagnosticsPrinter.ts




	function ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(
		path,
	) {
		if (!___R$project$rome$$romejs$fs$index_ts$existsSync(path)) {
			return;
		}

		const src = ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(path);
		const mtime = ___R$project$rome$$romejs$fs$index_ts$lstatSync(path).mtimeMs;
		return {content: src, mtime};
	}

	function ___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
		a,
		b,
	) {
		if (a === undefined || b === undefined) {
			return false;
		}

		if (a.line !== b.line || a.column !== b.column) {
			return false;
		}

		return true;
	}



	const ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS = {
		grep: "",
		inverseGrep: false,
		showAllDiagnostics: true,
		fieri: false,
		verboseDiagnostics: false,
		maxDiagnostics: 100,
	};










	class ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default
		extends Error {
		constructor(opts) {
			super(
				"Diagnostics printer. If you're seeing this then it wasn't caught and printed correctly.",
			);
			const {
				cwd,
				reporter,
				flags = ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS,
			} = opts;

			this.reporter = reporter;
			this.flags = flags;
			this.readFile =
				opts.readFile === undefined
					? ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal
					: opts.readFile;
			this.cwd =
				cwd === undefined
					? ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
							process.cwd(),
						)
					: cwd;
			this.processor =
				opts.processor === undefined
					? new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default()
					: opts.processor;

			this.displayedCount = 0;
			this.problemCount = 0;
			this.filteredCount = 0;
			this.truncatedCount = 0;

			this.hasTruncatedDiagnostics = false;
			this.missingFileSources = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();
			this.fileSources = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();
			this.fileMtimes = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();
			this.onFooterPrintCallbacks = [];
		}

		createFilePath(filename) {
			if (filename === undefined) {
				filename = "unknown";
			}

			const {normalizeFilename} = this.reporter.markupOptions;

			if (normalizeFilename === undefined) {
				return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
					filename,
				);
			} else {
				return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
					normalizeFilename(filename),
				);
			}
		}

		throwIfAny() {
			if (this.hasDiagnostics()) {
				throw this;
			}
		}

		hasDiagnostics() {
			return this.processor.hasDiagnostics();
		}

		getDisplayedProblemsCount() {
			return this.problemCount - this.filteredCount;
		}

		shouldTruncate() {
			if (
				!this.flags.showAllDiagnostics &&
				this.displayedCount > this.flags.maxDiagnostics
			) {
				return true;
			} else {
				return false;
			}
		}

		getDiagnostics() {
			return this.processor.getSortedDiagnostics();
		}

		shouldIgnore(diag) {
			const {grep, inverseGrep} = this.flags;

			// An empty grep pattern means show everything
			if (grep === undefined || grep === "") {
				return false;
			}

			// Match against the supplied grep pattern
			let ignored =
				___R$project$rome$$romejs$string$markup$format_ts$markupToPlainTextString(
					diag.description.message.value,
				).toLowerCase().includes(grep) === false;
			if (inverseGrep) {
				ignored = !ignored;
			}
			return ignored;
		}

		addFileSource(info, stats) {
			this.fileMtimes.set(info.path, stats.mtime);

			if (info.type === "reference") {
				this.fileSources.set(
					info.path,
					{
						sourceText: stats.content,
						lines: ___R$project$rome$$romejs$cli$diagnostics$utils_ts$toLines({
							path: info.path,
							input: stats.content,
							sourceType: info.sourceType,
							language: info.language,
						}),
					},
				);
			}
		}

		getDependenciesFromDiagnostics(diagnostics) {
			const deps = [];

			for (const {
				dependencies,
				description: {advice},
				location: {language, sourceType, mtime, filename},
			} of diagnostics) {
				if (filename !== undefined) {
					deps.push({
						type: "reference",
						path: this.createFilePath(filename),
						mtime,
						language,
						sourceType,
					});
				}

				if (dependencies !== undefined) {
					for (const {filename, mtime} of dependencies) {
						deps.push({
							type: "change",
							path: this.createFilePath(filename),
							mtime,
						});
					}
				}

				for (const item of advice) {
					if (item.type === "frame") {
						const {location} = item;
						if (
							location.filename !== undefined &&
							location.sourceText === undefined
						) {
							deps.push({
								type: "reference",
								path: this.createFilePath(location.filename),
								language: location.language,
								sourceType: location.sourceType,
								mtime: location.mtime,
							});
						}
					}
				}
			}

			const depsMap = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();

			// Remove non-absolute filenames and normalize sourceType and language for conflicts
			for (const dep of deps) {
				const path = dep.path;
				if (!path.isAbsolute()) {
					continue;
				}

				const existing = depsMap.get(path);

				// reference dependency can override change since it has more metadata that needs conflict resolution
				if (existing === undefined || existing.type === "change") {
					depsMap.set(dep.path, dep);
					continue;
				}

				if (dep.type === "reference") {
					if (existing.sourceType !== dep.sourceType) {
						existing.sourceType = "unknown";
					}

					if (existing.language !== dep.language) {
						existing.language = "unknown";
					}
				}
			}

			return Array.from(depsMap.values());
		}

		fetchFileSources(diagnostics) {
			for (const dep of this.getDependenciesFromDiagnostics(diagnostics)) {
				const {path} = dep;
				if (!path.isAbsolute()) {
					continue;
				}

				const abs = path.assertAbsolute();
				const stats = this.readFile(abs);
				if (stats === undefined) {
					this.missingFileSources.add(abs);
				} else {
					this.addFileSource(dep, stats);
				}
			}
		}

		print() {
			const filteredDiagnostics = this.filterDiagnostics();
			this.fetchFileSources(filteredDiagnostics);
			this.displayDiagnostics(filteredDiagnostics);
		}

		displayDiagnostics(diagnostics) {
			const restoreRedirect = this.reporter.redirectOutToErr(true);
			for (const diag of diagnostics) {
				this.displayDiagnostic(diag);
			}
			this.reporter.redirectOutToErr(restoreRedirect);
		}

		getOutdatedFiles(diag) {
			let outdatedFiles = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathSet();
			for (const {
				path,
				mtime: expectedMtime,
			} of this.getDependenciesFromDiagnostics([diag])) {
				const mtime = this.fileMtimes.get(path);
				if (
					mtime !== undefined &&
					expectedMtime !== undefined &&
					mtime > expectedMtime
				) {
					outdatedFiles.add(path);
				}
			}
			return outdatedFiles;
		}

		displayDiagnostic(diag) {
			const {reporter} = this;
			const {start, end, filename} = diag.location;
			let advice = [...diag.description.advice];

			// Remove stacktrace from beginning if it contains only one frame that matches the root diagnostic location
			const firstAdvice = advice[0];
			if (
				firstAdvice !== undefined &&
				firstAdvice.type === "stacktrace" &&
				firstAdvice.frames.length === 1
			) {
				const frame = firstAdvice.frames[0];
				if (
					frame.filename === filename &&
					___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
						frame,
						start,
					)
				) {
					advice.shift();
				}
			}

			// Determine if we should skip showing the frame at the top of the diagnostic output
			// We check if there are any frame advice entries that match us exactly, this is
			// useful for stuff like reporting call stacks
			let skipFrame = false;
			if (start !== undefined && end !== undefined) {
				adviceLoop: for (const item of advice) {
					if (
						item.type === "frame" &&
						item.location.filename === filename &&
						___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
							item.location.start,
							start,
						) &&
						___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
							item.location.end,
							end,
						)
					) {
						skipFrame = true;
						break;
					}

					if (item.type === "stacktrace") {
						for (const frame of item.frames) {
							if (
								frame.filename === filename &&
								___R$$priv$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$equalPosition(
									frame,
									start,
								)
							) {
								skipFrame = true;
								break adviceLoop;
							}
						}
					}
				}
			}

			const outdatedAdvice = [];
			const outdatedFiles = this.getOutdatedFiles(diag);
			const isOutdated = outdatedFiles.size > 0;
			if (isOutdated) {
				const outdatedFilesArr = Array.from(
					outdatedFiles,
					(path) => path.join(),
				);

				if (outdatedFilesArr.length === 1 && outdatedFilesArr[0] === filename) {
					outdatedAdvice.push({
						type: "log",
						category: "warn",
						text: "This file has been changed since the diagnostic was produced and may be out of date",
					});
				} else {
					outdatedAdvice.push({
						type: "log",
						category: "warn",
						text: "This diagnostic may be out of date as it relies on the following files that have been changed since the diagnostic was generated",
					});

					outdatedAdvice.push({
						type: "list",
						list: outdatedFilesArr.map((filename) =>
							___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${filename}" />`
						),
					});
				}
			}

			const derived = ___R$project$rome$$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(
				diag,
				{
					skipFrame,
					includeHeaderInAdvice: false,
					outdated: isOutdated,
				},
			);

			reporter.hr(derived.header);

			reporter.indent(() => {
				// Concat all the advice together
				const allAdvice = [...derived.advice, ...outdatedAdvice, ...advice];

				// Print advice
				for (const item of allAdvice) {
					const res = ___R$project$rome$$romejs$cli$diagnostics$printAdvice_ts$default(
						item,
						{
							printer: this,
							flags: this.flags,
							missingFileSources: this.missingFileSources,
							fileSources: this.fileSources,
							diagnostic: diag,
							reporter,
						},
					);
					if (res.printed) {
						reporter.br();
					}
					if (res.truncated) {
						this.hasTruncatedDiagnostics = true;
					}
				}

				// Print verbose information
				if (this.flags.verboseDiagnostics) {
					const {origins} = diag;

					if (origins !== undefined && origins.length > 0) {
						reporter.br();
						reporter.info("Why are you seeing this diagnostic?");
						reporter.br();
						reporter.list(
							origins.map((origin) => {
								let res = "<emphasis>" + origin.category + "</emphasis>";
								if (origin.message !== undefined) {
									res += ": " + origin.message;
								}
								return res;
							}),
							{ordered: true},
						);
					}
				}
			});
		}

		filterDiagnostics() {
			const diagnostics = this.getDiagnostics();
			const filteredDiagnostics = [];

			for (const diag of diagnostics) {
				this.problemCount++;

				if (this.shouldIgnore(diag)) {
					this.filteredCount++;
				} else if (this.shouldTruncate()) {
					this.truncatedCount++;
				} else {
					this.displayedCount++;
					filteredDiagnostics.push(diag);
				}
			}

			return filteredDiagnostics;
		}

		onFooterPrint(fn) {
			this.onFooterPrintCallbacks.push(fn);
		}

		footer() {
			const {reporter, problemCount} = this;

			const isError = problemCount > 0;

			if (isError) {
				const restoreRedirect = reporter.redirectOutToErr(true);
				reporter.hr();
				reporter.redirectOutToErr(restoreRedirect);
			}

			if (this.hasTruncatedDiagnostics) {
				reporter.warn(
					"Some diagnostics have been truncated. Use the --verbose-diagnostics flag to disable truncation.",
				);
			}

			if (isError) {
				if (this.flags.fieri) {
					this.showBanner(
						___R$project$rome$$romejs$cli$diagnostics$banners$error_json$default,
					);
				}
			} else {
				if (this.flags.fieri) {
					this.showBanner(
						___R$project$rome$$romejs$cli$diagnostics$banners$success_json$default,
					);
				}
			}

			for (const handler of this.onFooterPrintCallbacks) {
				const stop = handler(reporter, isError);
				if (stop) {
					return;
				}
			}

			if (isError) {
				this.footerError();
			} else {
				reporter.success("No known problems!");
			}
		}

		showBanner(banner) {
			for (const stream of this.reporter.getStreams(false)) {
				for (const row of banner.rows) {
					for (const field of row) {
						let palleteIndex;
						let times = 1;
						if (Array.isArray(field)) {
							[palleteIndex, times] = field;
						} else {
							palleteIndex = field;
						}

						const pallete = banner.palettes[palleteIndex];
						stream.write(
							___R$project$rome$$romejs$string$markup$ansi_ts$formatAnsi.bgRgb(
								" ",
								{
									r: pallete[0],
									g: pallete[1],
									b: pallete[2],
								},
							).repeat(times),
						);
					}
					stream.write("\n");
				}
			}
		}

		footerError() {
			const {reporter, filteredCount} = this;

			const displayableProblems = this.getDisplayedProblemsCount();
			let str =
				"Found <number emphasis>" +
				displayableProblems +
				'</number> <grammarNumber plural="problems" singular="problem">' +
				displayableProblems +
				"</grammarNumber>";

			if (filteredCount > 0) {
				str += "<dim> (" + filteredCount + " filtered)</dim>";
			}

			reporter.error(str);

			if (this.truncatedCount > 0) {
				const {maxDiagnostics} = this.flags;
				reporter.warn(
					"Only <number>" +
					maxDiagnostics +
					"</number> errors shown, add the <emphasis>--show-all-diagnostics</emphasis> flag to view the remaining <number>" +
					(displayableProblems - maxDiagnostics) +
					"</number> errors",
				);
			}
		}
	}


  // project-rome/@romejs/cli-diagnostics/index.ts
function ___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnostics(
		{
			diagnostics,
			suppressions,
			printerOptions,
			excludeFooter,
		},
	) {
		const printer = new ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default(
			printerOptions,
		);
		printer.processor.addDiagnostics(diagnostics);
		printer.processor.addSuppressions(suppressions);
		printer.print();
		if (!excludeFooter) {
			printer.footer();
		}
		return printer;
	}

	function ___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnosticsToString(
		opts,
	) {
		const reporter = new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default();
		const stream = reporter.attachCaptureStream(opts.format);
		___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnostics(
			Object.assign(
				{},
				opts,
				{printerOptions: Object.assign({reporter}, opts.printerOptions)},
			),
		);
		return stream.read();
	}


  // project-rome/@romejs/diagnostics/errors.ts
const ___R$project$rome$$romejs$diagnostics$errors_ts = {
		get DiagnosticsError() {
			return ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError;
		},
		createSingleDiagnosticError: ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError,
		getDiagnosticsFromError: ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError,
	};
	class ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError
		extends Error {
		constructor(message, diagnostics, suppressions = []) {
			if (diagnostics.length === 0) {
				throw new Error("No diagnostics");
			}

			message += "\n";
			message += ___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnosticsToString({
				diagnostics,
				suppressions,
			});

			super(message);
			this.diagnostics = diagnostics;
			this.suppressions = suppressions;
			this.name = "DiagnosticsError";
		}
	}

	function ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
		diag,
		suppressions,
	) {
		return new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
			diag.description.message.value,
			[diag],
			suppressions,
		);
	}

	function ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(
		err,
	) {
		if (
			err instanceof
			___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError
		) {
			const processor = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default({

			});
			processor.addSuppressions(err.suppressions);
			processor.addDiagnostics(err.diagnostics);
			return processor.getDiagnostics();
		}

		return undefined;
	}


  // project-rome/@romejs/diagnostics/types.ts
const ___R$project$rome$$romejs$diagnostics$types_ts = {};

























































  // project-rome/@romejs/diagnostics/helpers.ts
const ___R$project$rome$$romejs$diagnostics$helpers_ts = {
		buildSuggestionAdvice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice,
		truncateSourceText: ___R$project$rome$$romejs$diagnostics$helpers_ts$truncateSourceText,
		buildDuplicateLocationAdvice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildDuplicateLocationAdvice,
		diagnosticLocationToMarkupFilelink: ___R$project$rome$$romejs$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink,
	};


	function ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
		value,
		items,
		{minRating = 0.5, ignoreCase, formatItem} = {},
	) {
		const advice = [];

		const ratings = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
			value,
			items,
			{
				minRating,
				formatItem,
				ignoreCase,
			},
		);

		const strings = ratings.map((item) => {
			const {target} = item;
			if (formatItem === undefined) {
				return target;
			} else {
				return formatItem(target);
			}
		});

		const topRatingFormatted = strings.shift();
		if (topRatingFormatted === undefined) {
			return advice;
		}

		// Raw rating that hasn't been formatted
		const topRatingRaw = ratings[0].target;

		if (topRatingRaw === value) {
			// TODO produce a better example
		}

		// If there's only 2 suggestions then just say "Did you mean A or B?" rather than printing the list
		if (strings.length === 1) {
			advice.push({
				type: "log",
				category: "info",
				text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Did you mean <emphasis>${topRatingFormatted}</emphasis> or <emphasis>${strings[0]}</emphasis>?`,
			});
		} else {
			advice.push({
				type: "log",
				category: "info",
				text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Did you mean <emphasis>${topRatingFormatted}</emphasis>?`,
			});

			advice.push({
				type: "diff",
				diff: ___R$project$rome$$romejs$string$diff$index_ts$default(
					value,
					topRatingRaw,
				),
			});

			if (strings.length > 0) {
				advice.push({
					type: "log",
					category: "info",
					text: "Or one of these?",
				});

				advice.push({
					type: "list",
					list: strings.map((str) =>
						___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(str)
					),
					truncate: true,
				});
			}
		}

		// TODO check if ANY of the suggestions match
		if (
			topRatingRaw !== value &&
			topRatingRaw.toLowerCase() === value.toLowerCase()
		) {
			advice.push({
				type: "log",
				category: "warn",
				text: "This operation is case sensitive",
			});
		}

		return advice;
	}

	function ___R$project$rome$$romejs$diagnostics$helpers_ts$truncateSourceText(
		code,
		start,
		end,
	) {
		const lines = code.split(
			___R$project$rome$$romejs$js$parser$utils$whitespace_ts$NEWLINE,
		);

		// Pad the starting and ending lines by 10
		const fromLine = Math.max(
			___R$project$rome$$romejs$ob1$index_ts$ob1Get1(start.line) - 10,
			0,
		);
		const toLine = Math.max(
			___R$project$rome$$romejs$ob1$index_ts$ob1Get1(end.line) + 10,
			lines.length,
		);

		const capturedLines = lines.slice(fromLine, toLine);
		return "\n".repeat(fromLine) + capturedLines.join("\n");
	}

	function ___R$project$rome$$romejs$diagnostics$helpers_ts$buildDuplicateLocationAdvice(
		locations,
	) {
		const locationAdvice = locations.map((location) => {
			if (location === undefined) {
				return {
					type: "log",
					category: "warn",
					text: "Unable to find location",
				};
			} else {
				return {
					type: "frame",
					location,
				};
			}
		});

		return [
			{
				type: "log",
				category: "info",
				text: "Defined already here",
			},
			...locationAdvice,
		];
	}

	function ___R$project$rome$$romejs$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
		loc,
	) {
		const {start, filename} = loc;

		if (filename === undefined) {
			return "unknown";
		}

		if (start === undefined) {
			return ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${filename}" />`;
		}

		return ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${filename}" line="${start.line}" column="${start.column}" />`;
	}


  // project-rome/@romejs/diagnostics/descriptions.ts
const ___R$project$rome$$romejs$diagnostics$descriptions_ts = {
		createBlessedDiagnosticMessage: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage,
		get descriptions() {
			return ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions;
		},
	};

	function ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
		value,
	) {
		return {
			type: "PARTIAL_BLESSED_DIAGNOSTIC_MESSAGE",
			value,
		};
	}

	function ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$join(
		conjunction,
		items,
	) {
		if (items.length === 0) {
			return "";
		} else if (items.length === 1) {
			return items[0];
		} else {
			const popped = items.pop();
			return [...items, conjunction + " " + popped].join(", ");
		}
	}

	function ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$andJoin(
		items,
	) {
		return ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$join(
			"and",
			items,
		);
	}
	___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$andJoin;

	function ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$orJoin(
		items,
	) {
		return ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$join(
			"or",
			items,
		);
	}

	function ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$addEmphasis(
		items,
	) {
		return items.map((item) => "<emphasis>" + item + "</emphasis>");
	}

	// rome-ignore lint/js/noExplicitAny;















	// This is a lot of gross meta programming
	function ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$createMessages(
		messages,
	) {
		// rome-ignore lint/js/noExplicitAny
		const out = ({});

		for (const categoryName in messages) {
			// rome-ignore lint/js/noExplicitAny
			const category = {};
			out[categoryName] = category;

			const inputCategory = messages[categoryName];
			for (const key in inputCategory) {
				const value = inputCategory[key];

				if (typeof value === "string") {
					category[key] = {
						advice: [],
						message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
							value,
						),
					};
				} else if (typeof value === "function") {
					// rome-ignore lint/js/noExplicitAny
					const callback = (value);

					category[key] = function(...params) {
						const ___R$ = callback.apply(null, [...params]);
						const ret = Object.assign({}, ___R$);
						delete ret.message;
						const {message} = ___R$;
						return Object.assign(
							{advice: []},
							ret,
							{
								message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
									message,
								),
							},
						);
					};
				} else {
					const ___R$1 = (value);
					const obj = Object.assign({}, ___R$1);
					delete obj.message;
					const {message} = ___R$1;
					category[key] = Object.assign(
						{advice: []},
						obj,
						{
							message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
								message,
							),
						},
					);
				}
			}
		}

		return out;
	}

	function ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$buildJSXOpeningAdvice(
		name,
		openingLoc,
	) {
		return [
			{
				type: "log",
				category: "info",
				text: name === ""
					? "Originated from this opening tag"
					: "Originated from opening tag of <emphasis>" + name + "</emphasis>",
			},
			{
				type: "frame",
				location: openingLoc,
			},
		];
	}

	const ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions = ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$createMessages({
		FLAGS: {
			UNSUPPORTED_SHORTHANDS: "Shorthand flags are not supported",
			INCORRECT_CASED_FLAG: (flag) => ({
				message: "Incorrect cased flag name",
				advice: [
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Use <emphasis>${___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(
							flag,
						)}</emphasis> instead`,
					},
				],
			}),
			INCORRECT_ARG_COUNT: (excessive, message) => ({
				message: excessive ? "Too many arguments" : "Missing arguments",
				advice: [
					{
						type: "log",
						category: "info",
						text: message,
					},
				],
			}),
			DISALLOWED_REVIEW_FLAG: (key) => ({
				message: "Flag <emphasis>" +
				key +
				"</emphasis> is not allowed with <emphasis>review</emphasis>",
			}),
			DISALLOWED_REQUEST_FLAG: (key) => ({
				message: "This command does not support the <emphasis>" +
				key +
				"</emphasis> flag",
			}),
			UNKNOWN_ACTION: (action) => ({
				message: "Unknown action " + action,
			}),
			NO_FILES_FOUND: (noun) => ({
				message: noun === undefined
					? "No files found"
					: "No files to " + noun + " found",
			}),
		},
		// @romejs/parser-core
		PARSER_CORE: {
			EXPECTED_SPACE: "Expected no space between",
			EXPECTED_EOF: "Expected end of file",
			UNEXPECTED_EOF: "Unexpected end of file",
			UNEXPECTED: (type) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unexpected ${type}`,
			}),
			UNEXPECTED_CHARACTER: (char) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unexpected character <emphasis>${char}</emphasis>`,
			}),
			EXPECTED_TOKEN: (got, expected) => {
				return {
					message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Expected token ${expected} but got ${got}`,
				};
			},
		},
		// @romejs/codec-js-regexp
		REGEX_PARSER: {
			INVALID_CAPTURE_GROUP_MODIFIER: "Invalid capture group modifier",
			UNCLOSED_GROUP: "Unclosed group",
			UNOPENED_GROUP: "Unopened group",
			INVALID_QUANTIFIER_TARGET: "Invalid target for quantifier",
			UNKNOWN_REGEX_PART: "Unknown regex part",
			REVERSED_CHAR_SET_RANGE: "Range values reversed. Start char code is greater than end char code",
			UNCLOSED_CHAR_SET: "Unclosed character set",
			DUPLICATE_FLAG: "Duplicate regular expression flag",
			INVALID_FLAG: "Invalid regular expression flag",
			REVERSED_QUANTIFIER_RANGE: "Quantifier minimum is greater than maximum",
			NO_TARGET_QUANTIFIER: "Nothing to repeat",
			INVALID_NAMED_CAPTURE: "Invalid named capture referenced",
			UNCLOSED_NAMED_CAPTURE: "Unclosed named capture",
		},
		// @romejs/codec-json
		JSON: {
			SINGLE_QUOTE_USAGE: "You can only use double quoted strings",
			TRAILING_COMMA_VALUE: "Trailing comma is only allowed after a value",
			UNCLOSED_STRING: "Unclosed string",
			UNCLOSED_BLOCK_COMMENT: "Unclosed block comment",
			MISTAKEN_ARRAY_IDENTITY: "Trying to use an array element as an object property. Did you mean to make an object?",
			REDUNDANT_COMMA: "Redundant comma",
			EMPTY_INPUT_IN_JSON: "Empty input",
			PROPERTY_KEY_UNQUOTED_IN_JSON: "Property keys must be quoted in JSON",
			IMPLICIT_OBJECT_IN_JSON: "Objects must be wrapped in curly braces in JSON",
			COMMENTS_IN_JSON: "Comments aren't allowed in JSON",
			TRAILING_COMMA_IN_JSON: "Trailing commas aren't allowed in JSON",
			REGEX_IN_JSON: "Regular expressions aren't allowed in JSON",
			UNKNOWN_WORD_IN_JSON: (word) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`${word} isn't a valid JSON word`,
			}),
			STRING_NEWLINES_IN_JSON: 'Newlines aren\'t allowed in JSON, you insert a newline by escaping it like this "\\n"',
			UNDEFINED_IN_JSON: "undefined isn't allowed in JSON, you could use null instead",
			BIGINT_IN_JSON: "Bigints aren't allowed in JSON",
			NUMERIC_SEPARATORS_IN_JSON: "Numeric separators are not allowed in JSON",
		},
		// @romejs/codec-semver
		SEMVER: {
			MISSING_MINOR_VERSION: "A minor number is required for a version",
			MISSING_PATCH_VERSION: "A patch number is required for a version",
			EXCESSIVE_VERSION_PARTS: "Too many parts for version",
			INVALID_QUANTIFIER_PART: "Invalid version qualifier part",
			WILDCARD_IN_VERSION: "Wildcard aren't allowed in a hard version",
			INVALID_VERSION_NUMBER: "This isn't a valid version part, expected a number",
			INVALID_RANGE: "A semver range can only be defined with versions",
			BARE_PIPE_WITHOUT_LOOSE: "Bare pipes are only allowed in loose mode",
			UNEXPECTED_WORD: (word) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unexpected word <emphasis>${word}</emphasis>`,
			}),
			UNKNOWN_START: "Unknown start of atom",
			EXPECTED_VERSION: "Unexpected value for version",
		},
		V8: {
			SYNTAX_ERROR: (message) => ({message, category: "v8/syntaxError"}),
		},
		// @romejs/core/master/commands/lint.ts
		LINT_COMMAND: {
			INVALID_DECISION_ACTION: (action) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`<emphasis>${action}</emphasis> is not a valid decision action`,
			}),
			INVALID_DECISION_PART_COUNT: (i) => ({
				message: "Segment " +
				i +
				" contains an invalid number of decision parts",
			}),
		},
		// @romejs/js-compiler
		LINT: {
			NO_DID_UPDATE_SET_STATE: {
				category: "lint/noDidUpdateSetState",
				message: "Avoid this.setState in componentDidUpdate",
			},
			JSX_A11Y_HEADING_HAS_CONTENT: {
				category: "lint/js/xA11yHeadingHasContent",
				message: "Headings must have content and the content must be accessible by a screen reader.",
			},
			JSX_A11Y_NO_DISTRACTING_ELEMENTS: (element) => ({
				category: "lint/js/xA11yNoDistractingElements",
				message: "Do not use " +
				element +
				" elements as they can create visual accessibility issues and are deprecated.",
			}),
			JSX_A11Y_ALT_TEXT: {
				category: "lint/js/xA11yAltText",
				message: "<emphasis>img</emphasis>, <emphasis>area</emphasis>, <emphasis>input type='image'</emphasis>, <emphasis>object</emphasis> must have alt text",
			},
			NO_DANGER: {
				category: "lint/noDanger",
				message: "dangerouslySetInnerHTML should be avoided",
			},
			IMPORT_DEFAULT_BASENAME: (prev, basename) => ({
				category: "lint/importDefaultBasename",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`When importing the default, use the basename <emphasis>${basename}</emphasis>`,
				advice: [
					{
						type: "log",
						category: "info",
						text: "If you really meant this then use this instead",
					},
					{
						type: "code",
						code: ___R$project$rome$$romejs$string$markup$escape_ts$markup`import {default as ${prev}}`,
					},
				],
			}),
			NO_COMMA_OPERATOR: {
				category: "lint/noCommaOperator",
				message: "Avoid usage of the comma operator. It can lead to easy mistakes and ambiguous code.",
				advice: [
					{
						type: "log",
						category: "info",
						text: "If you want multiple expressions then break it up.",
					},
				],
			},
			NEGATION_ELSE: {
				category: "lint/negationElse",
				message: "Invert the blocks when you have a negation test",
			},
			STYLE_PROP_OBJECT: {
				category: "lint/stylePropObject",
				message: "<emphasis>style</emphasis> property value must be an object.",
			},
			NO_DANGER_WITH_CHILDREN: {
				category: "lint/noDangerWithChildren",
				message: "Only set one of <emphasis>children</emphasis> or <emphasis>props.dangerouslySetInnerHTML</emphasis>.",
			},
			NO_FIND_DOM_NODE: {
				category: "lint/noFindDOMNode",
				message: "Do not use findDOMNode",
			},
			PENDING_FIXES: (relativeFilename, original, formatted) => ({
				category: "lint/pendingFixes",
				message: "Pending formatting and recommended autofixes",
				advice: [
					{
						type: "diff",
						diff: ___R$project$rome$$romejs$string$diff$index_ts$default(
							original,
							formatted,
						),
					},
					({
						type: "action",
						command: "lint",
						shortcut: "f",
						instruction: "To apply fixes and formatting run",
						noun: "Apply fixes and format",
						args: [relativeFilename],
						commandFlags: {
							save: true,
						},
					}),
					({
						type: "action",
						hidden: true,
						command: "lint",
						shortcut: "o",
						instruction: "To format this file without any fixes run",
						noun: "Only format",
						args: [relativeFilename],
						commandFlags: {
							format: true,
						},
					}),
				],
			}),
			DUPLICATE_IMPORT_SOURCE: (seenLocation) => ({
				category: "lint/duplicateImportSource",
				message: "This module has already been imported",
				advice: [
					{
						type: "log",
						category: "info",
						text: "Previously imported here",
					},
					{
						type: "frame",
						location: seenLocation,
					},
				],
			}),
			NO_CHILDREN_PROP: {
				category: "lint/noChildrenProp",
				message: "children should not be passed as a prop",
			},
			PREFER_BLOCK_STATEMENT: {
				category: "lint/preferBlockStatements",
				message: "Block statements are preferred in this position",
			},
			PREFER_TEMPLATE: {
				category: "lint/preferTemplate",
				message: "Template literals are preferred over string concatenation",
			},
			PREFER_WHILE: {
				category: "lint/preferWhile",
				message: "A while loop should be used over a for loop",
			},
			REACT_IN_JSX_SCOPE: {
				category: "lint/reactInJsxScope",
				message: "<emphasis>React</emphasis> must be in scope when using JSX",
			},
			REACT_JSX_A11Y_HTML_HAS_LANG: {
				category: "lint/js/xA11yHTMLHasLang",
				message: "<emphasis>html</emphasis> elements must have a <emphasis>lang prop</emphasis>.",
			},
			REACT_JSX_A11Y_IMG_REDUNDANT_ALT: {
				category: "lint/js/xA11yImgRedundantAlt",
				message: '<emphasis>img</emphasis> element alt descriptions must not contain "image", "picture", or "photo"',
			},
			REACT_JSX_VOID_DOM_ELEMENTS_NO_CHILDREN: (element, properties) => ({
				category: "lint/voidDomElementsNoChildren",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`<emphasis>${element}</emphasis> is a void element tag and must not have <emphasis>${___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$orJoin(
					properties,
				)}</emphasis>.`,
			}),
			REACT_JSX_NO_COMMENT_TEXT: {
				category: "lint/js/xNoCommentText",
				message: "Comments inside children should be placed in braces",
			},
			REACT_JSX_NO_TARGET_BLANK: {
				category: "lint/js/xA11yNoTargetBlank",
				message: 'Using <emphasis>target="_blank"</emphasis> without <emphasis>rel="noreferrer"</emphasis> is a security risk.',
			},
			REACT_JSX_A11Y_IFRAME_HAS_TITLE: {
				category: "lint/js/xA11yIframeHasTitle",
				message: "<emphasis>iframe</emphasis> elements should have a <emphasis>title prop</emphasis>.",
			},
			REACT_JSX_NO_ACCESS_KEY: {
				category: "lint/js/xA11yNoAccessKey",
				message: "The <emphasis>accessKey</emphasis> prop is not allowed. Inconsistencies between keyboard shortcuts and keyboard comments used by screenreader and keyboard only users create a11y complications.",
			},
			REACT_JSX_NO_AUTOFOCUS: {
				category: "lint/js/xA11yNoAutofocus",
				message: "The <emphasis>autoFocus</emphasis> prop should not be used, as it can reduce usability and accessibility for users.",
			},
			REACT_JSX_NO_SCOPE: {
				category: "lint/js/xA11yScope",
				message: "The <emphasis>scope</emphasis> prop can only be used on <emphasis>th</emphasis> elements.",
			},
			REACT_JSX_KEY: (origin) => ({
				category: "lint/js/xKey",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Missing the "key" prop for element in ${origin}`,
			}),
			UNSAFE_NEGATION: {
				category: "lint/unsafeNegation",
				message: "Unsafe usage of negation operator in left side of binary expression",
			},
			UNUSED_VARIABLES: (kind, name) => ({
				category: "lint/unusedVariables",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unused ${kind} <emphasis>${name}</emphasis>`,
			}),
			UNDECLARED_VARIABLES: (name) => ({
				category: "lint/undeclaredVariables",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Undeclared variable <emphasis>${name}</emphasis>`,
			}),
			VARIABLE_CAMEL_CASE: (name, camelCaseName) => ({
				category: "lint/camelCase",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Variable <emphasis>${name}</emphasis> should be camel cased as <emphasis>${camelCaseName}</emphasis>`,
			}),
			IDENTIFIER_CAMEL_CASE: (name, camelCaseName) => ({
				category: "lint/camelCase",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Identifier <emphasis>${name}</emphasis> should be camel cased as <emphasis>${camelCaseName}</emphasis>`,
			}),
			CASE_SINGLE_STATEMENT: {
				category: "lint/caseSingleStatement",
				message: "A switch case should only have a single statement. If you want more then wrap it in a block.",
			},
			CONFUSING_LANGUAGE: (description, word, suggestion, advice) => ({
				category: "lint/confusingLanguage",
				message: description,
				advice: [
					...advice,
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Consider using <emphasis>${suggestion}</emphasis> instead`,
					},
				],
			}),
			DOUBLE_EQUALS: {
				category: "lint/doubleEquals",
				message: "Use === instead of ==",
				advice: [
					{
						type: "log",
						category: "info",
						text: "== is only allowed when comparing against null",
					},
				],
			},
			EMPTY_MATCHES: {
				category: "lint/emptyMatches",
				message: "The expression can return empty matches, and may match infinitely in some use cases",
			},
			NEGATE_DOUBLE_EQUALS: {
				category: "lint/doubleEquals",
				message: "Use !== instead of !=",
				advice: [
					{
						type: "log",
						category: "info",
						text: "!= is only allowed when comparing against null",
					},
				],
			},
			NO_CATCH_ASSIGN: {
				category: "lint/noCatchAssign",
				message: "Don't reassign catch parameters",
			},
			SPARSE_ARRAY: {
				category: "lint/sparseArray",
				message: "Your array contains an empty slot",
			},
			SINGLE_VAR_DECLARATOR: {
				category: "lint/singleVarDeclarator",
				message: "Declare each variable separately",
			},
			PREFER_FUNCTION_DECLARATIONS: {
				category: "lint/preferFunctionDeclarations",
				message: "Use a function declaration instead of a const function",
			},
			NO_VAR: {
				category: "lint/noVar",
				message: "Variable declarations using `var` are disallowed, use `let` or `const` instead.",
			},
			NO_SHORTHAND_ARRAY_TYPE: {
				category: "lint/noShorthandArrayType",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					"Use Array<T> instead of shorthand T[]",
				),
			},
			NO_UNSAFE_FINALLY: (type) => ({
				category: "lint/noUnsafeFinally",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unsafe usage of ${type}.`,
			}),
			NO_TEMPLATE_CURLY_IN_STRING: {
				category: "lint/noTemplateCurlyInString",
				message: "Unexpected template string expression.",
			},
			NO_SHADOW_RESTRICTED_NAMES: (name) => ({
				category: "lint/noShadowRestrictedNames",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Shadowing of global property <emphasis>${name}</emphasis>`,
				advice: [
					{
						type: "log",
						category: "info",
						text: "Consider renaming this variable. It's easy to confuse the origin of variables when they're named after a known global.",
					},
				],
			}),
			NO_MULTIPLE_SPACES_IN_REGEX_LITERAL: (count) => ({
				category: "lint/noMultipleSpacesInRegularExpressionLiterals",
				message: "Unclear multiple spaces in regular expression",
				advice: [
					{
						type: "log",
						category: "info",
						text: "It's hard to visually count the amount of spaces, it's clearer if you use a quantifier instead. eg / {" +
						String(count) +
						"}/",
					},
				],
			}),
			NO_LABEL_VAR: {
				category: "lint/noLabelVar",
				message: "Labels should not be variable names",
			},
			NO_IMPORT_ASSIGN: (name) => ({
				category: "lint/noImportAssign",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`<emphasis>${name}</emphasis> is read-only`,
			}),
			NO_EXTRA_BOOLEAN_CAST: {
				category: "lint/noExtraBooleanCast",
				message: "Redundant double negation.",
			},
			NO_FUNCTION_ASSIGN: {
				category: "lint/noFunctionAssign",
				message: "Reassignment of function declaration",
			},
			NO_EXPLICIT_ANY: {
				category: "lint/noExplicitAny",
				message: "Unexpected any. Specify a different type.",
			},
			NO_EMPTY_CHAR_SET: {
				category: "lint/noEmptyCharacterClass",
				message: "Empty character classes in regular expressions are not allowed",
			},
			NO_DUPLICATE_KEYS: (key) => ({
				category: "lint/noDuplicateKeys",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Duplicate key <emphasis>${key}</emphasis>`,
			}),
			NO_POSIX_IN_REGULAR_EXPRESSION: {
				category: "lint/noPosixInRegularExpression",
				message: "POSIX Character Classes and Collating Sequences are not supported in ECMAscript Regular Expressions",
			},
			NO_DUPLICATE_CASE: (value) => ({
				category: "lint/noDuplicateCase",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Duplicate case <emphasis>${value}</emphasis> not allowed.`,
			}),
			NO_DUPE_ARGS: (name) => ({
				category: "lint/noDupeArgs",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Duplicate argument <emphasis>${name}</emphasis> in function definition`,
			}),
			NO_DELETE: {
				category: "lint/noDelete",
				message: "Unexpected 'delete' operator.",
			},
			NO_DELETE_VARS: {
				category: "lint/noDeleteVars",
				message: "Variables should not be deleted.",
			},
			NO_DEBUGGER: {
				category: "lint/noDebugger",
				message: "Unexpected 'debugger' statement",
			},
			NO_COND_ASSIGN: {
				category: "lint/noCondAssign",
				message: "Cannot assign variable in loop condition",
			},
			NO_COMPARE_NEG_ZERO: (op) => ({
				category: "lint/noCompareNegZero",
				message: "Do not use the '" + op + "' operator to compare against -0",
				fixable: op === "===",
			}),
			NO_ASYNC_PROMISE_EXECUTOR: {
				category: "lint/noAsyncPromiseExecutor",
				message: "Promise executor functions should not be async.",
			},
			GETTER_RETURN: (got) => ({
				category: "lint/getterReturn",
				message: "Expected a 'return' at end of a getter method but got " + got,
			}),
			NO_SETTER_RETURN: {
				category: "lint/noSetterReturn",
				message: "Setter cannot return a value",
			},
			EMPTY_BLOCKS: {
				category: "lint/emptyBlocks",
				message: "Empty block",
			},
			NO_ARGUMENTS: {
				category: "lint/noArguments",
				message: "Use the rest parameters instead of 'arguments'",
			},
			DUPLICATE_REGEX_GROUP_NAME: (name) => ({
				category: "lint/noDuplicateGroupNamesInRegularExpressions",
				message: "Duplicate group name <emphasis>" +
				name +
				"</emphasis> in regular expression",
			}),
			NO_REFERENCE_TO_NON_EXISTING_GROUP: (name) => ({
				category: "lint/noReferenceToNonExistingGroup",
				message: 'Reference to non-existent group <emphasis>"' +
				name +
				'"</emphasis>',
			}),
			DEFAULT_EXPORT_SAME_BASENAME: (
				{
					defaultName,
					defaultType,
					actualFilename,
					correctFilename,
				},
			) => {
				let adviceMessage = "";

				if (defaultName === "*default*") {
					adviceMessage += "The";
				} else {
					adviceMessage +=
						"Filename should be <emphasis>" +
						correctFilename +
						"</emphasis> or the";
				}

				adviceMessage +=
					" " +
					defaultType +
					" name should be <emphasis>" +
					actualFilename +
					"</emphasis>";

				return {
					category: "lint/defaultExportSameBasename",
					message: "Filename and the name of a default " +
					defaultType +
					" should match",
					advice: [
						{
							type: "log",
							category: "info",
							text: adviceMessage,
						},
					],
				};
			},
			RESTRICTED_GLOBALS: (globalName) => ({
				category: "lint/restrictedGlobals",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`The use of the existing global variable <emphasis>${globalName}</emphasis> is not allowed. Use local variable instead.`,
			}),
			SORT_EXPORT_SPECIFIERS: {
				category: "lint/sortImportExportSpecifiers",
				message: "Specifiers of the export declaration should be sorted alphabetically.",
			},
			SORT_IMPORT_SPECIFIERS: {
				category: "lint/sortImportExportSpecifiers",
				message: "Specifiers of the import declaration should be sorted alphabetically.",
			},
		},
		PROJECT_MANAGER: {
			NO_VCS: (rootConfigLocation) => ({
				category: "projectManager/vscMissing",
				message: "Can't find any version control for this project",
				advice: rootConfigLocation === undefined
					? [
							{
								type: "log",
								category: "info",
								text: "Version control root was set to the project root as it was not configured. To configure a different folder run",
							},
							{
								type: "command",
								command: "rome config set-directory vcs.root DIRECTORY_HERE",
							},
						]
					: [
							{
								type: "log",
								category: "info",
								text: "Version control root was set here",
							},
							{
								type: "frame",
								location: rootConfigLocation,
							},
						],
			}),
			DUPLICATE_PACKAGE: (packageName, existing) => ({
				category: "projectManager/nameCollision",
				message: "Duplicate package name <emphasis>" +
				packageName +
				"</emphasis>",
				advice: [
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Defined already by <filelink target="${existing}" />`,
					},
				],
			}),
			NOT_FOUND: {
				category: "projectManager/missing",
				message: "Couldn't find a project",
				advice: [
					{
						type: "log",
						category: "info",
						text: "Run <command>rome init</command> in this folder to initialize a project",
					},
				],
			},
			INCORRECT_CONFIG_FILENAME: (validFilenames) => ({
				category: "projectManager/incorrectConfigFilename",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Invalid rome config filename, <emphasis>${validFilenames.join(
					" or ",
				)}</emphasis> are the only valid filename`,
			}),
		},
		FORMAT: {
			DISABLED: {
				category: "format/disabled",
				message: "Format is disabled for this project",
				// TODO advice and better error message
			},
		},
		// @romejs/js-compiler
		COMPILER: {
			CLASSES_UNSUPPORTED: {
				category: "compile/classes",
				message: "The classes transform doesn't know how to transform this",
			},
			JSX_NOT_XML: {
				category: "compile/jsx",
				message: "JSX is not XML",
			},
		},
		// @romejs/string-escape
		STRING_ESCAPE: {
			NOT_ENOUGH_CODE_POINTS: "Not enough code point digits",
			INVALID_STRING_CHARACTER: "Invalid string character (U+0000 to U+001F)",
			INVALID_HEX_DIGIT_FOR_ESCAPE: "Invalid hex digit for unicode escape",
		},
		ANALYZE_DEPENDENCIES: {
			CJS_EXPORT_IN_ES: {
				category: "analyzeDependencies/cjsExportInES",
				message: "You cannot use CommonJS exports in an ES module",
			},
		},
		// @romejs/string-markup
		STRING_MARKUP: {
			UNCLOSED_STRING: "Unclosed string",
			EXPECTED_CLOSING_TAG_NAME: "Expected closing tag name",
			UNKNOWN_START: "Unknown child start",
			EXPECTED_ATTRIBUTE_NAME: "Expected attribute name",
			INCORRECT_CLOSING_TAG_NAME: (expected, got) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Expected to close ${expected} but found ${got}`,
			}),
			UNCLOSED_TAG: (tagName, openLocation) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unclosed ${tagName} tag`,
				advice: [
					{type: "log", category: "info", text: "Tag started here"},
					{
						type: "frame",
						location: openLocation,
					},
				],
			}),
			INVALID_ATTRIBUTE_NAME_FOR_TAG: (tagName, attributeName, validAttributes) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`<emphasis>${attributeName}</emphasis> is not a valid attribute name for <emphasis>${tagName}</emphasis>`,
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
					attributeName,
					validAttributes,
				),
			}),
			UNKNOWN_TAG_NAME: (tagName) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unknown tag name <emphasis>${tagName}</emphasis>`,
			}),
			RESTRICTED_CHILD: (tagName, allowedParents, gotParentName = "none") => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`The tag <emphasis>${tagName}</emphasis> should only appear as a child of ${___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$orJoin(
					___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$addEmphasis(
						allowedParents,
					),
				)} not <emphasis>${gotParentName}</emphasis>`,
			}),
			RESTRICTED_PARENT: (tagName, allowedChildren, gotChildName) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`The tag <emphasis>${tagName}</emphasis> should only contain the tags ${___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$orJoin(
					___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$addEmphasis(
						allowedChildren,
					),
				)} not <emphasis>${gotChildName}</emphasis>`,
			}),
			RESTRICTED_PARENT_TEXT: (tagName) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`The tag <emphasis>${tagName}</emphasis> should not contain any text`,
			}),
		},
		// @romejs/path-match
		PATH_MATCH: {
			INVALID_PATTERN_SEGMENT_PART: "Invalid pattern segment part",
			INVALID_PATH_SEGMENT: "Invalid path segment",
		},
		TESTS: {
			CANCELLED: {
				category: "tests/cancelled",
				message: "Test was cancelled",
			},
			UNDECLARED: {
				message: "No tests declared in this file",
				category: "tests/noneDeclared",
			},
			LOGS: (advice) => ({
				message: "Test file produced console logs",
				category: "tests/logs",
				advice: [
					...advice,
					{
						type: "log",
						category: "info",
						text: "Only visible when this test file contains failures",
					},
				],
			}),
		},
		SUPPRESSIONS: {
			UNUSED: (suppression) => {
				let description = "";
				if (suppression.startLine === suppression.endLine) {
					description = "line " + suppression.startLine;
				} else {
					description +=
						"lines " + suppression.startLine + " to " + suppression.endLine;
				}

				return {
					message: "Unused suppression. Did not hide any errors.",
					category: "suppressions/unused",
					advice: [
						{
							type: "log",
							category: "info",
							text: "This suppression should hide <emphasis>" +
							description +
							"</emphasis>",
						},
					],
				};
			},
			MISSING_SPACE: {
				category: "suppressions/missingSpace",
				message: "Missing space between prefix and suppression categories",
			},
			MISSING_TARGET: {
				category: "suppressions/missingTarget",
				message: "We could not find a target for this suppression",
			},
			DUPLICATE: (category) => ({
				category: "suppressions/duplicate",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Duplicate suppression category <emphasis>${category}</emphasis>`,
			}),
		},
		SNAPSHOTS: {
			MISSING_NEWLINE_AFTER_CODE_BLOCK: "Newline required after code block",
			MISSING_NEWLINE_BEFORE_CODE_BLOCK: "Newline required before code block end",
			UNCLOSED_CODE_BLOCK: "Unclosed code block",
			EXPECTED_CODE_BLOCK_AFTER_HEADING: "Expected a code block after this heading",
			REDUNDANT: {
				category: "tests/snapshots/redundant",
				message: "Snapshot should not exist",
			},
			MISSING: {
				category: "tests/snapshots/missing",
				message: "Snapshot does not exist",
			},
			INCORRECT: (expected, got) => ({
				category: "tests/snapshots/incorrect",
				message: "Snapshots do not match",
				advice: [
					{
						type: "diff",
						diff: ___R$project$rome$$romejs$string$diff$index_ts$default(
							expected,
							got,
						),
					},
				],
			}),
			INLINE_COLLISION: {
				category: "tests/snapshots/inlineCollision",
				message: "Trying to update this inline snapshot multiple times",
				advice: [
					{
						type: "log",
						category: "info",
						text: "<emphasis>t.inlineSnapshot</emphasis> can only be called once. Did you call it in a loop?",
					},
				],
			},
			INLINE_MISSING_RECEIVED: {
				category: "tests/snapshots/inlineMissingReceived",
				message: "This inline snapshot call does not have a received argument",
			},
			INLINE_FROZEN: {
				category: "tests/snapshots/frozen",
				message: "Inline snapshot cannot be updated as snapshots are frozen",
			},
			FROZEN: {
				category: "tests/snapshots/frozen",
				message: "Snapshot cannot be updated as snapshots are frozen",
			},
			INLINE_BAD_MATCH: {
				category: "tests/snapshots/incorrect",
				message: "Inline snapshots do not match",
			},
		},
		BUNDLER: {
			TOP_LEVEL_AWAIT_IN_LEGACY: {
				category: "bundler/topLevelAwait",
				message: "This module contains a top level await which isn't supported in wrapper mode",
			},
			DETECTED_CYCLE: (localName, target, culprit, path) => {
				function formatPart(part, index) {
					const tagged = '<filelink target="' + part + '" />';
					if (part === culprit) {
						return '<highlight i="0" legend>' + tagged + "</highlight>";
					} else if (part === target) {
						return '<highlight i="1" legend>' + tagged + "</highlight>";
					} else if (index === 0) {
						return tagged + " <inverse>ENTRY</inverse>";
					} else {
						return tagged;
					}
				}

				return {
					category: "bundler/moduleCycle",
					message: "The variable <emphasis>" +
					localName +
					"</emphasis> won't be initialized yet",
					advice: [
						{
							type: "log",
							category: "info",
							text: "This is because the module it belongs to wont be executed yet. This is due to a circular dependency creating a module cycle.",
						},
						{
							type: "log",
							category: "info",
							text: "The likely cause is the file " +
							formatPart(culprit) +
							" that was required by " +
							formatPart(target) +
							" which created a circular dependency:",
						},
						{
							type: "list",
							reverse: true,
							ordered: true,
							list: path.map(formatPart),
						},
					],
				};
			},
		},
		RESOLVER: {
			NOT_FOUND: (responseType, source, location) => {
				let messagePrefix = "";
				let category = "resolver/notFound";

				switch (responseType) {
					case "UNSUPPORTED": {
						messagePrefix = "Unsupported";
						category = "resolver/unsupported";
						break;
					}
					case "MISSING": {
						messagePrefix = "Cannot find";
						break;
					}
					case "FETCH_ERROR": {
						messagePrefix = "Failed to fetch";
						category = "resolver/fetchFailed";
						break;
					}
				}

				return {
					message: messagePrefix +
					___R$project$rome$$romejs$string$markup$escape_ts$markup` <emphasis>${source}</emphasis> from <filelink emphasis target="${location.filename}" />`,
					category,
				};
			},
			IMPORT_TYPE_MISMATCH: (
				exportName,
				source,
				importedAsKing,
				actualKind,
				exportLoc,
			) => ({
				category: "resolver/importTypeMismatch",
				message: "The export <emphasis>" +
				exportName +
				'</emphasis> in <filelink emphasis target="' +
				source +
				'" /> was incorrectly imported as a <emphasis>' +
				importedAsKing +
				"</emphasis> when it's actually a <emphasis>" +
				actualKind +
				"</emphasis>",
				advice: exportLoc && [
					{
						type: "log",
						category: "info",
						text: 'Export was defined here in <filelink emphasis target="' +
						exportLoc.filename +
						'" />',
					},
					{
						type: "frame",
						location: exportLoc,
					},
				],
			}),
			UNKNOWN_EXPORT: (name, source, exportedNames, formatExportedName) => ({
				message: "Couldn't find export <emphasis>" +
				name +
				'</emphasis> in <filelink emphasis target="' +
				source +
				'" />',
				category: "resolver/unknownExport",
				advice: exportedNames.length === 0
					? [
							{
								type: "log",
								category: "info",
								text: "This file doesn't have any exports",
							},
						]
					: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
							name,
							exportedNames,
							{
								formatItem: (name) => {
									const {location, source} = formatExportedName(name);

									if (location !== undefined) {
										if (location.start === undefined) {
											name = ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${location.filename}">${name}</filelink>`;
										} else {
											name = ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${location.filename}" line="${location.start.line}" column="${location.start.column}">${name}</filelink>`;
										}
									}

									if (source !== undefined) {
										name += ___R$project$rome$$romejs$string$markup$escape_ts$markup` <dim>(from <filelink target="${source}" />)</dim>`;
									}

									return name;
								},
							},
						),
			}),
			UNKNOWN_EXPORT_POSSIBLE_UNEXPORTED_LOCAL: (name, source, location) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Couldn't find export <emphasis>${name}</emphasis> in <filelink emphasis target="${source}" />`,
				category: "resolver/unknownExport",
				advice: [
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`However we found a matching local variable in <filelink emphasis target="${location.filename}" />. Did you forget to export it?`,
					},
					{
						type: "frame",
						location,
					},
				],
			}),
		},
		SPDX: {
			UNKNOWN_LICENSE: (id, knownLicenses) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unknown SPDX license <emphasis>${id}</emphasis>`,
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
					id,
					knownLicenses,
				),
			}),
			VALID_LICENSE_WITH_MISSING_DASH: (possibleCorrectLicense) => ({
				message: "Missing dash between SPDX license name and version",
				advice: [
					{
						type: "log",
						category: "info",
						text: "Did you mean <emphasis>" +
						possibleCorrectLicense +
						"</emphasis>?",
					},
				],
			}),
			WITH_RIGHT_LICENSE_ONLY: "Only a license id can be on the right side of a WITH",
			OPERATOR_NOT_BETWEEN_EXPRESSION: "Can only use AND/OR in between an expression",
			PLUS_NOT_AFTER_LICENSE: "A plus can only come after a license id",
			UNOPENED_PAREN: "Nothing open to close",
		},
		// @romejs/js-parser
		JS_PARSER: {
			UNTERMINATED_BLOCK_COMMENT: "Unterminated comment",
			UNTERMINATED_JSX_STRING: "Unterminated string constant",
			INVALID_UNICODE_ESCAPE: "Invalid Unicode escape",
			EXPECTED_UNICODE_ESCAPE: "Expecting Unicode escape sequence \\uXXXX",
			BAD_HEX_ESCAPE: "Bad character escape sequence",
			OCTAL_IN_STRICT_MODE: "Octal literal in strict mode",
			UNTERMINATED_TEMPLATE: "Unterminated template",
			UNTERMINATED_STRING: "Unterminated string constant",
			OUT_OF_BOUND_CODE_POINT: "Code point out of bounds",
			IDENTIFIER_AFTER_NUMBER: "Identifier directly after number",
			OCTAL_BIGINT: "A bigint can't be an octal",
			DECIMAL_BIGINT: "A bigint can't have a decimal",
			INVALID_NUMBER: "Invalid number",
			LEGACY_OCTAL_IN_STRICT_MODE: "Legacy octal literals are not allowed in strict mode",
			INVALID_INT_TOKEN: "Invalid or unexpected int token",
			UNICODE_ESCAPE_IN_REGEX_FLAGS: "Regular expression flags can't contain unicode escapes",
			UNTERMINATED_REGEX: "Unterminated regular expression",
			DANGLING_BACKSLASH_IN_REGEX: "Dangling backslash in a regular expression",
			EXPECTED_RELATIONAL_OPERATOR: "Expected relational operator",
			UNEXPECTED_SPACE: "Unexpected space",
			EXPECTED_SEMI_OR_LINE_TERMINATOR: "Expected a semicolon or a line terminator",
			GET_SET_CLASS_CONSTRUCTOR: "Constructor can't have get/set modifier",
			ASYNC_CLASS_CONSTRUCTOR: "Constructor cannot be async",
			GENERATOR_CLASS_CONSTRUCTOR: "Constructor cannot be a generator",
			DUPLICATE_CLASS_CONSTRUCTOR: "Duplicate constructor in the same class",
			UNKNOWN_CLASS_PROPERTY_START: "Unknown class property start",
			CLASS_STATIC_PROTOTYPE_PROPERTY: "Classes may not have static property named prototype",
			CLASS_PRIVATE_FIELD_NAMED_CONSTRUCTOR: "Classes may not have a private field named '#constructor'",
			CLASS_PROPERTY_NAME_CONSTRUCTOR: "Classes may not have a non-static field named 'constructor'",
			PROTO_PROP_REDEFINITION: "Redefinition of __proto__ property",
			MISSING_CONDITIONAL_SEPARATOR: "Missing conditional expression consequent separator",
			WRAP_EXPONENTIATION: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
			DELETE_LOCAL_VARIABLE_IN_STRICT: "Deleting local variable in strict mode",
			DELETE_PRIVATE_FIELD: "Deleting a private field is not allowed",
			TAGGED_TEMPLATE_IN_OPTIONAL_CHAIN: "Tagged Template Literals are not allowed in optionalChain",
			YIELD_NAME_IN_GENERATOR: "Can not use 'yield' as identifier inside a generator",
			AWAIT_NAME_IN_ASYNC: "Can not use 'await' as identifier inside an async function",
			EMPTY_PARENTHESIZED_EXPRESSION: "Parenthesized expression didnt contain anything",
			AWAIT_IN_ASYNC_PARAMS: "await is not allowed in async function parameters",
			YIELD_IN_GENERATOR_PARAMS: "yield is not allowed in generator parameters",
			FLOW_TYPE_CAST_IN_TS: "Flow type cast expressions aren't allowed in TypeScript",
			PARENTHESIZED_FUNCTION_PARAMS: "Function parameters can't be parenthesized",
			NEW_WITH_TYPESCRIPT_TYPE_ARGUMENTS_NO_PARENS: "In TypeScript, a new expression with type arguments must have parens",
			INVALID_TEMPLATE_ESCAPE: "Invalid escape sequence in template",
			EXPECTED_IDENTIFIER: "Expected an identifier",
			IMPORT_EXACT_ARGUMENTS: "import() requires exactly one argument",
			IMPORT_TRAILING_COMMA: "Trailing comma is disallowed inside import(...) arguments",
			IMPORT_SPREAD: "Spread is not allowed in import()",
			IMPORT_NEW_CALLEE: "Cannot use new with import(...)",
			SUPER_OUTSIDE_METHOD: "super is only allowed in object methods and classes",
			INVALID_SUPER_SUFFIX: "Invalid super suffix operator",
			AWAIT_OUTSIDE_ASYNC: "Can't use await outside of an async function",
			AWAIT_STAR: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
			NEW_TARGET_OUTSIDE_CLASS: "new.target can only be used in functions or class properties",
			MULTIPLE_DESTRUCTURING_RESTS: "Cannot have multiple rest elements when destructuring",
			TRAILING_COMMA_AFTER_REST: "A trailing comma is not permitted after the rest element",
			GETTER_WITH_PARAMS: "getter should have no parameters",
			SETTER_WITH_REST: "setter function argument must not be a rest parameter",
			SETTER_NOT_ONE_PARAM: "setter should have exactly one param",
			ASYNC_GETTER_SETTER: "An object setter/getter can't be async",
			GENERATOR_GETTER_SETTER: "An object setter/getter can't be a generator",
			ARGUMENTS_IN_CLASS_FIELD: "'arguments' is not allowed in class field initializer",
			NON_SIMPLE_PARAM_IN_EXPLICIT_STRICT_FUNCTION: "Non-simple parameter in strict mode",
			STRICT_DIRECTIVE_IN_NON_SIMPLE_PARAMS: "Illegal 'use strict' directive in function with non-simple parameter list",
			OBJECT_PROPERTY_WITH_TYPE_PARAMETERS: "Object property cannot have type parameters",
			ILLEGAL_VARIANCE: "Variance is not allowed here",
			OBJECT_METHOD_IN_PATTERN: "Object methods aren't allowed in object patterns",
			IMPORT_META_OUTSIDE_MODULE: "import.meta may only appear in a module",
			EXPECTED_ARROW_AFTER_ASYNC_TYPE_PARAMS: "Expected arrow because we are a possible async arrow and type annotated parameters were present",
			INVALID_OBJECT_PATTERN_PROP: "Invalid property node for object pattern",
			ASYNC_OBJECT_METHOD_LINE_BREAK: "There shouldn't be any newlines between async and the rest of the function",
			SPACE_BETWEEN_PRIVATE_HASH: "Unexpected space between # and identifier",
			CONFUSING_CALL_ARGUMENT: "Function parameter type annotation? Possibly forgot curlies around an object. Possibly forgot async keyword.",
			EXPECTED_ARROW_AFTER_TYPE_PARAMS: "Expected an arrow function after this type parameter declaration",
			REQUIRED_CLASS_NAME: "Class name is required",
			JSX_ELEM_TYPE_ARGUMENTS_OUTSIDE_TS: "JSX element type arguments are only allowed in TS",
			UNWRAPPED_ADJACENT_JHX: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?",
			CONFUSED_OR: "Unexpected ||, did you mean just |?",
			INVALID_ASSIGNMENT_TARGET: "Not a valid assignment target",
			IMPORT_KIND_SPECIFIER_ON_IMPORT_DECLARATION_WITH_KIND: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
			DESTRUCTURING_IN_IMPORT: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
			IMPORT_TYPE_STAR: "import * is not allowed",
			IMPORT_MISSING_SOURCE: "import missing a source",
			EXPORT_TYPE_NAMESPACE: "Can't have a type export namespacer specifier",
			EXPORT_MISSING_FROM: "Expected `from` for an export node",
			EXPORT_FROM_NOT_STRING: "Export from only allows strings",
			BINDING_MEMBER_EXPRESSION: "Binding member expression",
			INVALID_OBJECT_PATTERN_PROPERTY: "Not a valid assignment object pattern property",
			OBJECT_PATTERN_CANNOT_CONTAIN_METHODS: "Object pattern cannot contains methods",
			INVALID_ASSIGNMENT_PATTERN_OPERATOR: "Only '=' operator can be used for specifying default value.",
			INVALID_OBJECT_REST_ARGUMENT: "Invalid rest operator's argument",
			INVALID_EXPORT_DEFAULT: "Only expressions, functions or classes are allowed as the `default` export.",
			INVALID_EXPORT_DECLARATION: "Invalid export declaration",
			DESTRUCTURING_REST_ELEMENT_NOT_LAST: "The rest element has to be the last element when destructuring",
			REST_INVALID_ARGUMENT: "Invalid rest operator's argument",
			EXPORT_ASYNC_NO_FUNCTION_KEYWORD: "Started with `export async` so we expected to receive an async function but no function keyword was found",
			TYPE_CAST_WITHOUT_ANNOTATION: "Type cast expression has no type annotation. Did you mean for this to be a function parameter?",
			TYPE_CAST_CANNOT_BE_OPTIONAL: "Type cast expressions cannot be optional. Did you mean for this to be a function parameter?",
			TYPE_CAST_EXPECTED_PARENS: "The type cast expression is expected to be wrapped with parentheses",
			INVALID_ASYNC_ARROW_WITH_TYPE_PARAMS: "Invalid async arrow with type parameters",
			TYPE_NUMERIC_LITERAL_PLUS: "Numeric literal type annotations cannot stand with a +, omit it instead",
			TYPE_NUMERIC_LITERAL_EXPECTED: 'Unexpected token, expected "number"',
			JSX_INVALID_ATTRIBUTE_VALUE: "JSX attribute value should be either an expression or a quoted JSX text",
			JSX_UNCLOSED_SELF_CLOSING_TAG: "Unclosed JSX element open",
			JSX_UNCLOSED_CLOSING_TAG: "Unclosed JSX element close",
			JSX_EMPTY_ATTRIBUTE_VALUE: "JSX attribute cannot be an empty expression",
			JSX_UNKNOWN_IDENTIFIER_TOKEN: "Unknown JSX identifier token",
			TS_IMPORT_ARG_NOT_STRING: "Argument in a type import must be a string literal",
			TS_CONSTANT_NOT_LITERAL: "Only literal values are allowed as a constant type",
			TS_INVALID_SIGNATURE_BINDING_NODE: "Invalid node in signature binding list",
			TS_REQUIRED_FOLLOWS_OPTIONAL: "A required element cannot follow an optional element.",
			TS_TEMPLATE_LITERAL_WITH_SUBSTITUION: "Template literal types cannot have any substitution",
			TS_UNKNOWN_NON_ARRAY_START: "Unknown TS non array type start",
			TS_INVALID_READONLY_MODIFIER: "'readonly' type modifier is only permitted on array and tuple literal types.",
			TS_EXTERNAL_MODULE_REFERENCE_ARG_NOT_STRING: "TypeScript require() must have a single string argument",
			TS_UNKNOWN_DECLARE_START: "Unknown TypeScript declare start",
			TS_UNEXPECTED_CAST_IN_PARAMETER_POSITION: "Unexpected type cast in parameter position",
			TS_DISABLED_BUT_ACCESSIBILITY_OR_READONLY: "Accessibility and readonly syntax found but TS is not enabled",
			TS_PARAMETER_PROPERTY_BINDING_PATTERN: "A parameter property may not be declared using a binding pattern.",
			TYPE_ANNOTATION_AFTER_ASSIGNMENT: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
			TYPE_BINDING_PARAMETER_OPTIONAL: "A binding pattern parameter cannot be optional in an implementation signature.",
			ILLEGAL_FUNCTION_IN_STRICT: "In strict mode code, functions can only be declared at top level or inside a block",
			ILLEGAL_FUNCTION_IN_NON_STRICT: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
			ILLEGAL_GENERATOR_DEFINITION: "Generators can only be declared at the top level or inside a block",
			ILLEGAL_ASYNC_DEFINITION: "Async functions can only be declared at the top level or inside a block",
			LEXICAL_DECLARATION_IN_SINGLE_STATEMENT_CONTEXT: "Lexical declaration cannot appear in a single-statement context",
			IMPORT_EXPORT_MUST_TOP_LEVEL: "'import' and 'export' may only appear at the top level",
			REGULAR_FOR_AWAIT: "Can't have an await on a regular for loop",
			RETURN_OUTSIDE_FUNCTION: "'return' outside of function",
			MULTIPLE_DEFAULT_CASE: "Multiple default clauses",
			SWITCH_STATEMENT_OUTSIDE_CASE: "Statement outside of a case or default block",
			NEWLINE_AFTER_THROW: "Illegal newline after throw",
			TRY_MISSING_FINALLY_OR_CATCH: "Missing catch or finally clause",
			INVALID_LABEL_DECLARATION: "Invalid labeled declaration",
			WITH_IN_STRICT: "'with' in strict mode",
			OCTAL_IN_STRICT: "Octal literal in strict mode",
			FOR_IN_OF_WITH_INITIALIZER: "Loop variable declaration may not have an initializer",
			CONST_WITHOUT_INITIALIZER: "A constant must have an initializer",
			COMPLEX_BINDING_WITHOUT_INITIALIZER: "Complex binding patterns require an initialization value",
			ACCESSOR_WITH_TYPE_PARAMS: "An accessor cannot have type parameters",
			UNEXPECTED_SPREAD: "Unexpected spread",
			DUPLICATE_LABEL: (label, loc) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Label <emphasis>${label}</emphasis> is already declared`,
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildDuplicateLocationAdvice([
					loc,
				]),
			}),
			UNKNOWN_LABEL: (label) => ({
				message: label === undefined
					? "No loop label found"
					: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unknown label <emphasis>${label}</emphasis>`,
			}),
			IMPORT_EXPORT_IN_SCRIPT: (manifestPath) => ({
				message: "<emphasis>import</emphasis> and <emphasis>export</emphasis> can only appear in a module",
				advice: [
					// TODO this advice is pointless if you have syntax extensions enabled
					{
						type: "log",
						category: "info",
						text: "Change the extension to <emphasis>.mjs</emphasis> to turn this file into a module",
					},
					{
						type: "log",
						category: "info",
						text: 'Add <emphasis>"type": "module"</emphasis> to your <filelink emphasis target="' +
						manifestPath +
						'" />',
					},
				],
			}),
			SUPER_CALL_OUTSIDE_CONSTRUCTOR: {
				message: "super() is only valid inside a class constructor of a subclass",
				advice: [
					{
						type: "log",
						category: "info",
						text: "Maybe a typo in the method name ('constructor') or not extending another class?",
					},
				],
			},
			JSX_DISABLED: {
				message: "JSX syntax isn't enabled",
				advice: [
					{
						type: "log",
						category: "info",
						text: "Are you using <emphasis>TypeScript</emphasis>? Change the file extension to <emphasis>.tsx</emphasis>",
					},
					{
						type: "log",
						category: "info",
						text: "Are you using <emphasis>Flow</emphasis>? Add a <emphasis>@flow</emphasis> comment annotation to the top of the file",
					},
					{
						type: "log",
						category: "info",
						text: "Not using either? Change the file extension to <emphasis>.jsx</emphasis>",
					},
					// TODO you can also add `@jsx whatever` at the top of a file
				],
			},
			JSX_IN_TS_EXTENSION: {
				message: "JSX isn't allowed in regular TypeScript files",
				advice: [
					{
						type: "log",
						category: "info",
						text: "Change the file extension to <emphasis>.tsx</emphasis> to enable JSX support",
					},
				],
			},
			INVALID_PARENTEHSIZED_LVAL: (patternType) => ({
				message: "Invalid parenthesized binding",
				advice: patternType === "object"
					? [
							{
								type: "log",
								category: "info",
								text: "Did you use `({a}) = 0` instead of `({a} = 0)`?",
							},
						]
					: patternType === "array"
						? [
								{
									type: "log",
									category: "info",
									text: "Did you use `([a]) = 0` instead of `([a] = 0)`?",
								},
							]
						: [],
			}),
			EXPECTED_COMMA_SEPARATOR: (context) => ({
				message: "Expected a comma to separate items in " + context,
			}),
			INVALID_LEFT_HAND_SIDE: (context) => ({
				message: "Invalid left-hand side in " + context,
			}),
			TS_EMPTY_LIST: (descriptor) => ({
				message: descriptor + " list cannot be empty",
			}),
			JSX_EXPECTED_CLOSING_TAG: (name, openingLoc) => ({
				message: "Expected a corresponding JSX closing tag for <emphasis>" +
				name +
				"</emphasis>",
				advice: ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$buildJSXOpeningAdvice(
					name,
					openingLoc,
				),
			}),
			JSX_EXPECTED_CLOSING_FRAGMENT_TAG: (name, openingLoc) => ({
				message: "Expected JSX closing fragment tag",
				advice: ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$buildJSXOpeningAdvice(
					name,
					openingLoc,
				),
			}),
			JSX_UNKNOWN_CHILD_START: (name, openingLoc) => ({
				message: "Unknown JSX children start",
				advice: ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$buildJSXOpeningAdvice(
					name,
					openingLoc,
				),
			}),
			JSX_UNCLOSED_ELEMENT: (name, openingLoc) => ({
				message: "Unclosed JSX element",
				advice: ___R$$priv$project$rome$$romejs$diagnostics$descriptions_ts$buildJSXOpeningAdvice(
					name,
					openingLoc,
				),
			}),
			TS_REQUIRED: (label) => ({
				message: "A " + label + " is only valid inside of a TypeScript file",
				advice: [
					{
						type: "log",
						category: "info",
						text: "To enable <emphasis>TypeScript</emphasis> support, the file extension should end in <emphasis>.ts</emphasis> or <emphasis>.tsx</emphasis>",
					},
				],
			}),
			DUPLICATE_EXPORT: (name, existing) => ({
				message: name === "default"
					? "Only one default export allowed per module."
					: "`" +
						name +
						"` has already been exported. Exported identifiers must be unique.",
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildDuplicateLocationAdvice([
					existing,
				]),
			}),
			NEW_IN_OPTIONAL_CHAIN: (responsiblePointer) => ({
				message: "constructors in/after an Optional Chain are not allowed",
				advice: responsiblePointer && [
					{
						type: "log",
						category: "info",
						text: "Optional chain member responsible",
					},
					{
						type: "frame",
						location: responsiblePointer,
					},
				],
			}),
			UNKNOWN_EXPRESSION_ATOM_START: (context) => ({
				message: "Unknown start to an " + context,
			}),
			INVALID_META_PROPERTY: (metaName, propertyName) => ({
				message: "The only valid meta property for " +
				metaName +
				" is " +
				metaName +
				"." +
				propertyName,
			}),
			ARGUMENT_CLASH_IN_STRICT: (name, loc) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Argument <emphasis>${name}</emphasis> name clash in strict mode`,
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildDuplicateLocationAdvice([
					loc,
				]),
			}),
			RESERVED_WORD: (word) => ({
				message: word + " is a reserved word",
			}),
			UNEXPECTED_KEYWORD: (keyword) => ({
				message: "Unexpected keyword " + keyword,
			}),
			UNEXPECTED_TOKEN: (expected, possibleShiftMistake) => ({
				message: expected === undefined
					? "Unexpected token"
					: "Unexpected token, expected " + expected,
				advice: possibleShiftMistake
					? [
							{
								type: "log",
								category: "info",
								text: "Did you accidently hold shift?",
							},
						]
					: [],
			}),
			EXPECTED_CLOSING: (name, char, location) => ({
				message: "Unclosed " + name,
				advice: [
					{
						type: "log",
						category: "info",
						text: "We expected to find the closing character <emphasis>" +
						char +
						"</emphasis> here",
					},
					{
						type: "frame",
						location,
					},
				],
			}),
			EXPECTED_KEYWORD: (keyword) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Expected keyword ${keyword}`,
			}),
			ESCAPE_SEQUENCE_IN_WORD: (word) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`${word} can't contain a unicode escape`,
			}),
			EXPECTED_ENABLE_SYNTAX: (syntaxName) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Expected ${syntaxName} syntax to be enabled`,
			}),
			UNEXPECTED_HASH: (exclamationFollowed) => ({
				message: "Unexpected character #",
				advice: exclamationFollowed
					? [
							{
								type: "log",
								category: "info",
								text: "Did you want to write a hashbang? A hashbang can only be the first thing in a file.",
							},
						]
					: [],
			}),
			UNEXPECTED_UNICODE_CHARACTER: (
				char,
				unicodeName,
				equivalentChar,
				equivalentName,
			) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unexpected Unicode character '<emphasis>${char}</emphasis>' (<emphasis>${unicodeName}</emphasis>)`,
				advice: [
					{
						type: "log",
						category: "info",
						text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Did you mean '<emphasis>${equivalentChar}</emphasis>' (<emphasis>${equivalentName}</emphasis>)? Both characters look the same, but are not.`,
					},
				],
			}),
			EXPECTED_NUMBER_IN_RADIX: (radix) => ({
				message: "Expected number in radix " + String(radix),
			}),
			INVALID_IDENTIFIER_NAME: (name) => ({
				message: "Invalid identifier " + name,
			}),
			ESCAPE_SEQUENCE_IN_KEYWORD: (keyword) => ({
				message: "Escape sequence in keyword " + keyword,
			}),
		},
		// @romejs/js-analysis
		TYPE_CHECK: {
			NOT_CALLABLE: {
				category: "typeCheck/uncallable",
				message: "This type isn't callable",
			},
			INCOMPATIBILITY: (upper, originLoc) => ({
				category: "typeCheck/incompatible",
				message: "Type incompatibility found",
				advice: [
					{
						type: "log",
						category: "error",
						text: "This type is incompatible with expected type of",
					},
					originLoc === undefined
						? {
								type: "log",
								category: "info",
								text: upper,
							}
						: {
								type: "frame",
								location: Object.assign({}, originLoc, {marker: upper}),
							},
				],
			}),
			UNKNOWN_IMPORT: (importedName, source, possibleNames) => ({
				category: "typeCheck/unknownImport",
				message: "Unknown import '" + importedName + "' in '" + source + "'",
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
					importedName,
					possibleNames,
				),
			}),
			UNKNOWN_PROP: (key, possibleNames) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Property ${key} not found in`,
				category: "typeCheck/unknownProperty",
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
					key,
					possibleNames,
				),
			}),
			UNDECLARED_VARIABLE: (name, possibleNames) => ({
				category: "typeCheck/undeclaredVariable",
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Undeclared variable ${name}`,
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
					name,
					possibleNames,
				),
			}),
			NOT_EXHAUSTIVE: (only, target) => ({
				category: "typeCheck/notExhaustive",
				//message += `but allows ${this.extraenous.map(type => this.utils.humanize(type)).join(' | ')}`;
				message: "Expected only a " + only + " but got " + target,
			}),
			MISSING_CONDITION: (missing) => ({
				category: "typeCheck/missingCondition",
				message: "Missing the conditions " + missing.join(", "),
			}),
		},
		// @romejs/consume
		CONSUME: {
			SET_PROPERTY_NON_OBJECT: "Attempted to set a property on a non-object",
			EXPECTED_JSON_VALUE: "Expected a JSON value",
			EXPECTED_OBJECT: "Expected object",
			EXPECTED_ARRAY: "Expected array",
			EXPECTED_DATE: "Expected a date",
			EXPECTED_BOOLEAN: "Expected a boolean",
			EXPECTED_STRING: "Expected a string",
			EXPECTED_BIGINT: "Expected a bigint",
			EXPECTED_NUMBER: "Expected a number",
			EXPECTED_URL: "Expected a URL",
			EXPECTED_VALID_NUMBER: "Expected valid number",
			EXPECTED_ABSOLUTE_PATH: "Expected an absolute file path",
			EXPECTED_RELATIVE_PATH: "Expected a relative file path",
			EXPECTED_EXPLICIT_RELATIVE_PATH: "Expected an explicit relative file path. This is one that starts with <emphasis>./</emphasis> or <emphasis>../</emphasis>",
			INVALID: "Invalid value",
			EXPECTED_NUMBER_BETWEEN: (min, max) => ({
				message: "Expected number between " + min + " and " + max,
			}),
			EXPECTED_NUMBER_HIGHER: (num) => ({
				message: "Expected number higher than " + num,
			}),
			EXPECTED_NUMBER_LOWER: (num) => ({
				message: "Expected number lower than " + num,
			}),
			INVALID_STRING_SET_VALUE: (value, validValues) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Invalid value <emphasis>${value}</emphasis>`,
				advice: [
					{
						type: "log",
						category: "info",
						text: "Possible values are",
					},
					{
						type: "list",
						list: validValues.map((str) =>
							___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
								str,
							)
						),
					},
				],
			}),
			UNUSED_PROPERTY: (key, type, knownProperties) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Unknown <emphasis>${key}</emphasis> ${type}`,
				advice: ___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
					key,
					knownProperties,
					{
						ignoreCase: true,
					},
				),
			}),
		},
		// @romejs/codec-js-manifest
		MANIFEST: {
			TOO_MANY_HASH_PARTS: "Too many hashes",
			MISSING_HOSTED_GIT_USER: "Missing user",
			MISSING_HOSTED_GIT_REPO: "Missing repo",
			TOO_MANY_HOSTED_GIT_PARTS: "Expected only 2 parts",
			EMPTY_NPM_PATTERN: "Missing rest of npm dependency pattern",
			TOO_MANY_NPM_PARTS: "Too many @ signs",
			STRING_BIN_WITHOUT_NAME: "A string bin is only allowed if the manifest has a name property",
			MISSING_REPO_URL: "Missing repo URL",
			MIXED_EXPORTS_PATHS: "Cannot mix a root conditional export with relative paths",
			NAME_EXCEEDS: "cannot exceed 214 characters",
			INVALID_NAME_START: "cannot start with a dot or underscore",
			ORG_WITH_NO_PACKAGE_NAME: "contains an org but no package name",
			ORG_TOO_MANY_PARTS: "contains too many name separators",
			REDUNDANT_ORG_NAME_START: "Redundant <emphasis>@</emphasis> in org name",
			INVALID_NAME_CHAR: (char) => ({
				message: ___R$project$rome$$romejs$string$markup$escape_ts$markup`The character <emphasis>${char}</emphasis> isn't allowed`,
			}),
			INCORRECT_CASING: (typoKey, correctKey) => ({
				message: typoKey + " has incorrect casing, should be " + correctKey,
			}),
			INCORRECT_CAMEL_CASING: (typoKey, correctKey) => ({
				message: typoKey +
				" isn't correctly camel cased when it should be " +
				correctKey,
			}),
			TYPO: (typoKey, correctKey) => ({
				message: typoKey + " is a typo of " + correctKey,
			}),
		},
		// @romejs/project
		PROJECT_CONFIG: {
			BOOLEAN_CATEGORY: (enabled) => ({
				message: "Expected an object here but got a boolean",
				advice: [
					{
						type: "log",
						category: "info",
						text: 'You likely wanted `{"enabled": ' +
						String(enabled) +
						"}` instead",
					},
				],
			}),
			RECURSIVE_CONFIG: "Recursive config",
		},
	});


  // project-rome/@romejs/diagnostics/DiagnosticsNormalizer.ts
class ___R$project$rome$$romejs$diagnostics$DiagnosticsNormalizer_ts$default {
		constructor(markupOptions, sourceMaps) {
			this.sourceMaps = sourceMaps;
			this.markupOptions = markupOptions || {};
			this.hasMarkupOptions = markupOptions !== undefined;
		}

		normalizeFilename(filename) {
			const {markupOptions} = this;
			if (markupOptions === undefined || filename === undefined) {
				return filename;
			}
			const {normalizeFilename} = markupOptions;
			if (normalizeFilename === undefined) {
				return filename;
			}

			return normalizeFilename(filename);
		}

		normalizePositionValue(value) {
			if (this.markupOptions !== undefined && this.markupOptions.stripPositions) {
				return undefined;
			} else {
				return value;
			}
		}

		normalizeLocation(location) {
			const {sourceMaps} = this;
			if (sourceMaps === undefined) {
				return location;
			}

			let {marker, filename, start, end} = location;

			if (filename !== undefined) {
				if (start !== undefined) {
					const resolved = sourceMaps.approxOriginalPositionFor(
						filename,
						start.line,
						start.column,
					);
					if (resolved !== undefined) {
						filename = resolved.source;
						start = Object.assign(
							{},
							start,
							{line: resolved.line, column: resolved.column},
						);
					}
				}

				if (end !== undefined) {
					const resolved = sourceMaps.approxOriginalPositionFor(
						filename,
						end.line,
						end.column,
					);
					if (resolved !== undefined) {
						// TODO confirm this is the same as `start` if it resolved
						filename = resolved.source;
						end = Object.assign(
							{},
							end,
							{line: resolved.line, column: resolved.column},
						);
					}
				}
			}

			return Object.assign(
				{},
				location,
				{
					filename: this.normalizeFilename(filename),
					marker: this.maybeNormalizeMarkup(marker),
					start: this.normalizePositionValue(start),
					end: this.normalizePositionValue(end),
				},
			);
		}

		normalizeMarkup(markup) {
			return ___R$project$rome$$romejs$string$markup$format_ts$normalizeMarkup(
				markup,
				this.markupOptions,
			);
		}

		maybeNormalizeMarkup(markup) {
			return markup === undefined ? undefined : this.normalizeMarkup(markup);
		}

		normalizeDiagnosticAdviceItem(item) {
			const {sourceMaps} = this;

			switch (item.type) {
				case "frame":
					return Object.assign(
						{},
						item,
						{location: this.normalizeLocation(item.location)},
					);

				case "list":
					return Object.assign(
						{},
						item,
						{list: item.list.map((markup) => this.normalizeMarkup(markup))},
					);

				case "log":
					return Object.assign(
						{},
						item,
						{text: this.normalizeMarkup(item.text)},
					);

				case "action":
					if (this.markupOptions.stripPositions) {
						return Object.assign(
							{},
							item,
							{
								// Command flags could have position information
								commandFlags: {},
							},
						);
					} else {
						return item;
					}

				case "stacktrace":
					return Object.assign(
						{},
						item,
						{
							frames: item.frames.map((frame) => {
								const {filename, line, column} = frame;

								if (
									filename === undefined ||
									line === undefined ||
									column === undefined ||
									(sourceMaps !== undefined && !sourceMaps.has(filename))
								) {
									return Object.assign(
										{},
										frame,
										{
											start: this.normalizePositionValue(line),
											column: this.normalizePositionValue(column),
											filename: this.normalizeFilename(filename),
										},
									);
								}

								if (sourceMaps !== undefined) {
									const resolved = sourceMaps.approxOriginalPositionFor(
										filename,
										line,
										column,
									);
									if (resolved !== undefined) {
										return Object.assign(
											{},
											frame,
											{
												filename: this.normalizeFilename(resolved.source),
												line: this.normalizePositionValue(resolved.line),
												column: this.normalizePositionValue(resolved.column),
											},
										);
									}
								}

								return frame;
							}),
						},
					);
			}

			return item;
		}

		normalizeDiagnostic(diag) {
			const {sourceMaps} = this;

			// Fast path for a common case
			if (
				!this.hasMarkupOptions &&
				(sourceMaps === undefined || !sourceMaps.hasAny())
			) {
				return diag;
			}

			const {description} = diag;

			const advice = description.advice.map((item) => {
				return this.normalizeDiagnosticAdviceItem(item);
			});

			diag = Object.assign(
				{},
				diag,
				{
					label: this.maybeNormalizeMarkup(diag.label),
					location: this.normalizeLocation(diag.location),
					description: Object.assign(
						{},
						description,
						{
							message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
								this.normalizeMarkup(description.message.value),
							),
							advice,
						},
					),
				},
			);

			return diag;
		}
	}


  // project-rome/@romejs/diagnostics/derive.ts
const ___R$project$rome$$romejs$diagnostics$derive_ts = {
		mergeDiagnostics: ___R$project$rome$$romejs$diagnostics$derive_ts$mergeDiagnostics,
		derivePositionlessKeyFromDiagnostic: ___R$project$rome$$romejs$diagnostics$derive_ts$derivePositionlessKeyFromDiagnostic,
		deriveRootAdviceFromDiagnostic: ___R$project$rome$$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic,
		deriveDiagnosticFromErrorStructure: ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure,
		deriveDiagnosticFromError: ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError,
		getErrorStackAdvice: ___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice,
		addOriginsToDiagnostics: ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics,
		addOriginsToDiagnostic: ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostic,
	};
	function ___R$$priv$project$rome$$romejs$diagnostics$derive_ts$normalizeArray(
		val,
	) {
		if (Array.isArray(val)) {
			return val;
		} else {
			return [];
		}
	}

	function ___R$project$rome$$romejs$diagnostics$derive_ts$mergeDiagnostics(
		rootDiag,
		...diags
	) {
		let mergedAdvice = [
			...___R$$priv$project$rome$$romejs$diagnostics$derive_ts$normalizeArray(
				rootDiag.description.advice,
			),
		];

		for (const diag of diags) {
			mergedAdvice = [
				...mergedAdvice,
				...___R$project$rome$$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(
					diag,
				).advice,
				...___R$$priv$project$rome$$romejs$diagnostics$derive_ts$normalizeArray(
					diag.description.advice,
				),
			];
		}

		return Object.assign(
			{},
			rootDiag,
			{
				description: Object.assign(
					{},
					rootDiag.description,
					{advice: mergedAdvice},
				),
			},
		);
	}

	function ___R$project$rome$$romejs$diagnostics$derive_ts$derivePositionlessKeyFromDiagnostic(
		diag,
	) {
		const normalizer = new ___R$project$rome$$romejs$diagnostics$DiagnosticsNormalizer_ts$default({
			stripPositions: true,
		});

		return JSON.stringify(normalizer.normalizeDiagnostic(diag));
	}

	function ___R$project$rome$$romejs$diagnostics$derive_ts$deriveRootAdviceFromDiagnostic(
		diag,
		opts = {
			skipFrame: false,
			includeHeaderInAdvice: true,
			outdated: false,
		},
	) {
		const advice = [];
		const {description, fixable, location} = diag;

		let header = ___R$project$rome$$romejs$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
			location,
		);

		if (diag.label !== undefined) {
			header += " <emphasis>" + diag.label + "</emphasis>";

			if (description.category !== undefined) {
				header += " <dim>" + description.category + "</dim>";
			}
		} else {
			if (description.category !== undefined) {
				header += " <emphasis>" + description.category + "</emphasis>";
			}
		}

		if (fixable === true) {
			header += " <inverse>FIXABLE</inverse>";
		}

		if (opts.outdated === true) {
			header += " <inverse>OUTDATED</inverse>";
		}

		if (opts.includeHeaderInAdvice === true) {
			advice.push({
				type: "log",
				category: "none",
				text: header,
			});
		}

		advice.push({
			type: "log",
			category: "error",
			text: description.message.value,
		});

		if (opts.skipFrame === false) {
			if (location.start !== undefined && location.end !== undefined) {
				advice.push({
					type: "frame",
					location: diag.location,
				});
			} else if (location.marker !== undefined) {
				// If we have no start/end, but we do have a marker then output is a log error
				advice.push({
					type: "log",
					category: "error",
					text: location.marker,
				});
			}
		}

		return {header, advice};
	}



	function ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
		struct,
		opts,
	) {
		const {filename} = opts;

		let targetFilename = filename;
		let targetCode = undefined;
		let targetLoc = undefined;

		let {frames, message = "Unknown error"} = struct;

		const {cleanFrames} = opts;
		if (cleanFrames !== undefined) {
			frames = cleanFrames(frames);
		}

		// Point the target to the closest frame with a filename
		for (const frame of frames) {
			if (frame.filename === undefined) {
				continue;
			}

			targetFilename = frame.filename;
			targetLoc = ___R$project$rome$$romejs$v8$errors_ts$getSourceLocationFromErrorFrame(
				frame,
			);
			break;
		}

		const advice = ___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(
			Object.assign({}, struct, {frames}),
		);

		return {
			description: Object.assign(
				{
					message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
						___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
							message,
						),
					),
				},
				opts.description,
				{
					advice: [
						...advice,
						...((opts.description == null ? undefined : opts.description.advice) || []),
					],
				},
			),
			location: {
				filename: targetFilename,
				start: targetLoc === undefined ? undefined : targetLoc.start,
				end: targetLoc === undefined ? undefined : targetLoc.end,
				sourceText: targetCode,
			},
			label: opts.label,
		};
	}

	function ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
		error,
		opts,
	) {
		return ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
			___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(error),
			opts,
		);
	}

	function ___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(
		error,
		title,
	) {
		const advice = [];
		const {frames, stack} = error;

		if (frames.length === 0 && stack !== undefined) {
			// Just in case we didn't get the frames for some reason
			if (title !== undefined) {
				advice.push({
					type: "log",
					category: "info",
					text: title,
				});
			}

			// Remove the `message` from the `stack`
			let cleanStack = stack;
			let removeMessage = error.name + ": " + error.message;
			if (cleanStack.startsWith(removeMessage)) {
				cleanStack = cleanStack.slice(removeMessage.length);
			}
			cleanStack = cleanStack.trim();

			advice.push({
				type: "log",
				category: "warn",
				text: "Raw stack trace is being displayed as we did not receive any frames",
			});

			advice.push({
				type: "list",
				list: cleanStack.split("\n").map((line) =>
					___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
						line.trim(),
					)
				),
			});
		} else {
			const adviceFrames = frames.map((frame) => {
				const {
					typeName,
					functionName,
					methodName,
					filename,
					lineNumber,
					columnNumber,
					isEval,
					isNative,
					isConstructor,
					isAsync,
				} = frame;

				const prefixes = [];
				if (isAsync) {
					prefixes.push("await");
				}
				if (isEval) {
					prefixes.push("eval");
				}
				if (isConstructor) {
					prefixes.push("new");
				}
				const prefix = prefixes.length === 0 ? undefined : prefixes.join(" ");

				let object = typeName;
				let property = "<anonymous>";
				if (functionName !== undefined) {
					property = functionName;
				}
				if (methodName !== undefined) {
					property = methodName;
				}

				let suffix;
				if (isNative) {
					suffix = "native";
				}

				return {
					suffix,
					prefix,
					object,
					property,
					filename,
					line: lineNumber,
					column: columnNumber,
				};
			});

			advice.push({
				type: "stacktrace",
				title,
				frames: adviceFrames,
			});
		}

		return advice;
	}

	function ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics(
		origins,
		diagnostics,
	) {
		return diagnostics.map((diag) => {
			return ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostic(
				origins,
				diag,
			);
		});
	}

	function ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostic(
		origins,
		diag,
	) {
		const newOrigins =
			diag.origins === undefined ? origins : [...origins, ...diag.origins];
		return Object.assign({}, diag, {origins: newOrigins});
	}


  // project-rome/@romejs/diagnostics/wrap.ts
const ___R$project$rome$$romejs$diagnostics$wrap_ts = {
		catchDiagnostics: ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics,
		catchDiagnosticsSync: ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnosticsSync,
	};


	async function ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(
		promise,
		origin,
	) {
		try {
			const value = await promise();

			return {value, diagnostics: undefined};
		} catch (err) {
			const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(
				err,
			);

			if (diagnostics) {
				return {
					value: undefined,
					diagnostics: origin === undefined
						? diagnostics
						: ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics(
								[origin],
								diagnostics,
							),
				};
			} else {
				throw err;
			}
		}
	}

	function ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnosticsSync(
		callback,
		origin,
	) {
		try {
			const value = callback();

			return {value, diagnostics: undefined};
		} catch (err) {
			const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(
				err,
			);

			if (diagnostics) {
				return {
					value: undefined,
					diagnostics: origin === undefined
						? diagnostics
						: ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics(
								[origin],
								diagnostics,
							),
				};
			} else {
				throw err;
			}
		}
	}


  // project-rome/@romejs/diagnostics/DiagnosticsProcessor.ts








	const ___R$$priv$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$DEFAULT_UNIQUE = [
		["category", "filename", "message", "start.line", "start.column"],
	];



	class ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default {
		constructor(options = {}) {
			this.filters = [];
			this.options = options;
			this.includedKeys = new Set();
			this.unique =
				options.unique === undefined
					? ___R$$priv$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$DEFAULT_UNIQUE
					: options.unique;
			this.throwAfter = undefined;
			this.locked = false;
			this.origins = options.origins === undefined ? [] : [...options.origins];
			this.allowedUnusedSuppressionPrefixes = new Set();
			this.usedSuppressions = new Set();
			this.suppressions = new Set();
			this.sourceMaps = new ___R$project$rome$$romejs$codec$source$map$SourceMapConsumerCollection_ts$default();
			this.normalizer = new ___R$project$rome$$romejs$diagnostics$DiagnosticsNormalizer_ts$default(
				options.markupOptions,
				this.sourceMaps,
			);

			this.diagnostics = [];
			this.cachedDiagnostics = undefined;
		}

		static createImmediateThrower(origins) {
			const diagnostics = new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default({
				origins,
				onDiagnostics() {
					diagnostics.maybeThrowDiagnosticsError();
				},
			});
			return diagnostics;
		}

		lock() {
			this.locked = true;
		}

		unshiftOrigin(origin) {
			this.origins.unshift(origin);
		}

		setThrowAfter(num) {
			this.throwAfter = num;
		}

		maybeThrowDiagnosticsError() {
			if (this.hasDiagnostics()) {
				throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
					"Thrown by DiagnosticsProcessor",
					this.getDiagnostics(),
				);
			}
		}

		hasDiagnostics() {
			return this.getDiagnostics().length > 0;
		}

		assertEmpty() {
			if (this.hasDiagnostics()) {
				throw new Error("Expected no diagnostics for this operation");
			}
		}

		addAllowedUnusedSuppressionPrefix(prefix) {
			this.assertEmpty();
			this.allowedUnusedSuppressionPrefixes.add(prefix);
		}

		addSuppressions(suppressions) {
			this.cachedDiagnostics = undefined;
			for (const suppression of suppressions) {
				this.suppressions.add(suppression);
			}
		}

		addFilters(filters) {
			this.cachedDiagnostics = undefined;
			this.filters = this.filters.concat(filters);
		}

		addFilter(filter) {
			this.cachedDiagnostics = undefined;
			this.filters.push(filter);
		}

		doesMatchFilter(diag) {
			for (const suppression of this.suppressions) {
				if (
					___R$project$rome$$romejs$js$compiler$suppressions_ts$matchesSuppression(
						diag.location,
						suppression,
					)
				) {
					this.usedSuppressions.add(suppression);
					return true;
				}
			}

			for (const filter of this.filters) {
				if (
					filter.message !== undefined &&
					filter.message !== diag.description.message.value
				) {
					continue;
				}

				if (
					filter.filename !== undefined &&
					filter.filename !== diag.location.filename
				) {
					continue;
				}

				if (
					filter.category !== undefined &&
					filter.category !== diag.description.category
				) {
					continue;
				}

				if (filter.start !== undefined && diag.location.start !== undefined) {
					if (
						filter.start.line !== diag.location.start.line ||
						filter.start.column !== diag.location.start.column
					) {
						continue;
					}
				}

				if (
					filter.line !== undefined &&
					diag.location.start !== undefined &&
					diag.location.start.line !== filter.line
				) {
					continue;
				}

				if (filter.test !== undefined && filter.test(diag)) {
					continue;
				}

				return true;
			}

			return false;
		}

		buildDedupeKeys(diag) {
			if (diag.unique) {
				return [];
			}

			// We don't do anything with `end` in this method, it's fairly meaningless for deduping errors
			let {start} = diag.location;

			const keys = [];

			for (const rule of this.unique) {
				const parts = [];

				if (rule.includes("category")) {
					parts.push("category:" + diag.description.category);
				}

				if (rule.includes("filename")) {
					parts.push("filename:" + String(diag.location.filename));
				}

				if (rule.includes("message")) {
					parts.push("message:" + diag.description.message);
				}

				if (start !== undefined) {
					if (rule.includes("start.line")) {
						parts.push("start.line:" + start.line);
					}

					if (rule.includes("start.column")) {
						parts.push("start.column:" + start.column);
					}
				}

				const key = parts.join(",");
				keys.push(key);
			}

			return keys;
		}

		addDiagnosticAssert(diag, origin) {
			return this.addDiagnostics([diag], origin, true)[0];
		}

		addDiagnostic(diag, origin) {
			return this.addDiagnostics([diag], origin)[0];
		}

		addDiagnostics(diags, origin, force) {
			if (diags.length === 0) {
				return diags;
			}

			this.cachedDiagnostics = undefined;

			if (this.locked) {
				throw new Error(
					"DiagnosticsProcessor is locked and cannot accept anymore diagnostics",
				);
			}

			const {max} = this.options;
			const added = [];

			// Add origins to diagnostics
			const origins = [...this.origins];
			if (origin !== undefined) {
				origins.push(origin);
			}
			diags = ___R$project$rome$$romejs$diagnostics$derive_ts$addOriginsToDiagnostics(
				origins,
				diags,
			);

			// Filter diagnostics
			diagLoop: for (let diag of diags) {
				if (!force && max !== undefined && this.diagnostics.length > max) {
					break;
				}

				// Check before normalization
				if (!force && this.doesMatchFilter(diag)) {
					continue;
				}

				diag = this.normalizer.normalizeDiagnostic(diag);

				// Check after normalization
				if (!force && this.doesMatchFilter(diag)) {
					continue;
				}

				const keys = this.buildDedupeKeys(diag);

				if (!force) {
					for (const key of keys) {
						if (this.includedKeys.has(key)) {
							continue diagLoop;
						}
					}
				}

				this.diagnostics.push(diag);
				added.push(diag);

				for (const key of keys) {
					this.includedKeys.add(key);
				}
			}

			const {onDiagnostics} = this.options;
			if (onDiagnostics !== undefined && added.length > 0) {
				onDiagnostics(added);
			}

			const {throwAfter} = this;
			if (throwAfter !== undefined && this.diagnostics.length >= throwAfter) {
				this.maybeThrowDiagnosticsError();
			}

			return added;
		}

		getDiagnosticsByFilename() {
			const byFilename = new Map();

			for (const diag of this.getDiagnostics()) {
				const {filename} = diag.location;

				let filenameDiagnostics = byFilename.get(filename);
				if (filenameDiagnostics === undefined) {
					filenameDiagnostics = [];
					byFilename.set(filename, filenameDiagnostics);
				}
				filenameDiagnostics.push(diag);
			}

			return byFilename;
		}

		getDiagnostics() {
			const {cachedDiagnostics} = this;
			if (cachedDiagnostics !== undefined) {
				return cachedDiagnostics;
			}

			const diagnostics = [...this.diagnostics];

			// Add errors for remaining suppressions
			for (const suppression of this.suppressions) {
				if (this.usedSuppressions.has(suppression)) {
					continue;
				}

				const [categoryPrefix] = suppression.category.split("/");
				if (this.allowedUnusedSuppressionPrefixes.has(categoryPrefix)) {
					continue;
				}

				diagnostics.push({
					location: suppression.commentLocation,
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SUPPRESSIONS.UNUSED(
						suppression,
					),
				});
			}

			this.cachedDiagnostics = diagnostics;

			return diagnostics;
		}

		getSortedDiagnostics() {
			const diagnosticsByFilename = this.getDiagnosticsByFilename();

			// Get all filenames and sort them
			const filenames = Array.from(diagnosticsByFilename.keys()).sort((a, b) => {
				if (a === undefined || b === undefined) {
					return 0;
				} else {
					return ___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare(
						a,
						b,
					);
				}
			});

			let sortedDiagnostics = [];

			for (const filename of filenames) {
				const fileDiagnostics = diagnosticsByFilename.get(filename);
				if (fileDiagnostics === undefined) {
					throw new Error("We use keys() so should be present");
				}

				// Sort all file diagnostics by location start index
				const sortedFileDiagnostics = fileDiagnostics.sort((a, b) => {
					const aStart = a.location.start;
					const bStart = b.location.start;
					if (aStart === undefined || bStart === undefined) {
						return 0;
					} else {
						return (
							___R$project$rome$$romejs$ob1$index_ts$ob1Get0(aStart.index) -
							___R$project$rome$$romejs$ob1$index_ts$ob1Get0(bStart.index)
						);
					}
				});

				sortedDiagnostics = [...sortedDiagnostics, ...sortedFileDiagnostics];
			}

			return sortedDiagnostics;
		}
	}


  // project-rome/@romejs/diagnostics/constants.ts
const ___R$project$rome$$romejs$diagnostics$constants_ts = {
		get INTERNAL_ERROR_LOG_ADVICE() {
			return ___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE;
		},
	};
	const ___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE = {
		type: "log",
		category: "warn",
		text: "This diagnostic was derived from an internal Rome error. The problem likely isn't with your code. Please report this if necessary",
	};


  // project-rome/@romejs/diagnostics/categories.ts
const ___R$project$rome$$romejs$diagnostics$categories_ts = {};







  // project-rome/@romejs/diagnostics/index.ts



  // project-rome/ackage.json
const ___R$project$rome$ackage_json$default = {
		"name": "rome-root",
		"license": "MIT",
		"version": "0.0.25",
		"engines": {"node": ">=12.0.0"},
		"//": "Look! No deps!",
		"dependencies": {},
		"///": "Only used for static type checking",
		"devDependencies": {
			"@types/node": "^13.13.5",
			"@types/react": "^16.9.34",
			"@types/react-dom": "^16.9.7",
			"@types/vscode": "^1.45.0",
			"typescript": "^3.8.3",
		},
		"romeLSPBin": "./scripts/vendor-rome",
		"scripts": {
			"dev-rome": "node ./scripts/dev-rome",
			"test": "node ./scripts/dev-rome test",
			"lint": "node ./scripts/dev-rome lint",
			"fix": "node ./scripts/dev-rome --fix",
		},
		"rome": {
			"root": true,
			"bundler": {"mode": "modern"},
			"lint": {
				"ignore": [
					"build",
					"coverage",
					"node_modules",
					"core/static",
					"resources",
					"test-fixtures",
					"vendor",
					"type-libs",
					"lib/modules.js",
					"prelude.ts",
					"website",
					"@romejs-web",
					"out",
					"vscode/node_modules",
				],
			},
		},
	};


  // project-rome/@romejs/core/common/constants.ts
const ___R$project$rome$$romejs$core$common$constants_ts = {
		get CHILD_ARGS() {
			return ___R$project$rome$$romejs$core$common$constants_ts$CHILD_ARGS;
		},
		get BIN() {
			return ___R$project$rome$$romejs$core$common$constants_ts$BIN;
		},
		get MAP() {
			return ___R$project$rome$$romejs$core$common$constants_ts$MAP;
		},
		get MAX_MASTER_BYTES_BEFORE_WORKERS() {
			return ___R$project$rome$$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS;
		},
		get MAX_WORKER_BYTES_BEFORE_ADD() {
			return ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD;
		},
		get MAX_WORKER_COUNT() {
			return ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_COUNT;
		},
		get VERSION() {
			return ___R$project$rome$$romejs$core$common$constants_ts$VERSION;
		},
		get SOCKET_PATH() {
			return ___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH;
		},
		get CLI_SOCKET_PATH() {
			return ___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH;
		},
		get MOCKS_FOLDER_NAME() {
			return ___R$project$rome$$romejs$core$common$constants_ts$MOCKS_FOLDER_NAME;
		},
	};
	const ___R$$priv$project$rome$$romejs$core$common$constants_ts$os = require(
		"os",
	);
	const ___R$project$rome$$romejs$core$common$constants_ts$CHILD_ARGS = [
		"--max-old-space-size=8192",
	];

	const ___R$project$rome$$romejs$core$common$constants_ts$BIN = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
		process.mainModule.filename,
	);
	const ___R$project$rome$$romejs$core$common$constants_ts$MAP = ___R$project$rome$$romejs$core$common$constants_ts$BIN.addExtension(
		".map",
	);

	const ___R$$priv$project$rome$$romejs$core$common$constants_ts$MEGABYTE = 10_000;

	const ___R$project$rome$$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS =
		0.5 * ___R$$priv$project$rome$$romejs$core$common$constants_ts$MEGABYTE;

	const ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD =
		1 * ___R$$priv$project$rome$$romejs$core$common$constants_ts$MEGABYTE;

	const ___R$$priv$project$rome$$romejs$core$common$constants_ts$CPU_COUNT = ___R$$priv$project$rome$$romejs$core$common$constants_ts$os.cpus().length;
	const ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_COUNT = Math.min(
		___R$$priv$project$rome$$romejs$core$common$constants_ts$CPU_COUNT,
		4,
	);

	const ___R$project$rome$$romejs$core$common$constants_ts$VERSION = String(
		___R$project$rome$ackage_json$default.version,
	);

	const ___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH = ___R$project$rome$$romejs$path$index_ts$TEMP_PATH.append(
		"rome-" +
		___R$project$rome$$romejs$core$common$constants_ts$VERSION +
		".sock",
	);

	const ___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH = ___R$project$rome$$romejs$path$index_ts$TEMP_PATH.append(
		"rome-wait-" +
		___R$project$rome$$romejs$core$common$constants_ts$VERSION +
		".sock",
	);

	const ___R$project$rome$$romejs$core$common$constants_ts$MOCKS_FOLDER_NAME = "__rmocks__";


  // project-rome/@romejs/core/common/types/client.ts
const ___R$project$rome$$romejs$core$common$types$client_ts = {
		get DEFAULT_CLIENT_FLAGS() {
			return ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS;
		},
		get DEFAULT_CLIENT_REQUEST_FLAGS() {
			return ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS;
		},
	};
	const ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS = {
		clientName: "unknown",
		cwd: ___R$project$rome$$romejs$path$index_ts$CWD_PATH,
		silent: false,
		verbose: false,
	};

	const ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS = Object.assign(
		{},
		___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$DEFAULT_PRINTER_FLAGS,
		{
			showAllDiagnostics: false,
			collectMarkers: false,
			timing: false,
			benchmark: false,
			benchmarkIterations: 10,
			watch: false,
			review: false,
			resolverPlatform: undefined,
			resolverScale: undefined,
			resolverMocks: false,
		},
	);








  // project-rome/@romejs/core/common/commands.ts


	const ___R$project$rome$$romejs$core$common$commands_ts$commandCategories = {
		PROCESS_MANAGEMENT: "Process Management",
		CODE_QUALITY: "Code Quality",
		SOURCE_CODE: "Source Code",
		PROJECT_MANAGEMENT: "Project Management",
		SOURCE_CONTROL: "Source Control",
		INTERNAL: "Internal",
	};


  // project-rome/@romejs/core/client/commands/init.ts
const ___R$project$rome$$romejs$core$client$commands$init_ts$default = ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: "create a project config",
		usage: "",
		examples: [],
		defineFlags(consumer) {
			return {};
		},
		async callback(req) {
			const {reporter} = req.client;

			const configPath = req.client.flags.cwd.append("rome.rjson");
			if (await ___R$project$rome$$romejs$fs$index_ts$exists(configPath)) {
				reporter.error(
					'<filelink target="' +
					configPath.join() +
					'" emphasis>rome.rjson</filelink> file already exists',
				);
				reporter.info(
					"Use <command>rome config</command> to update an existing config",
				);
				return false;
			}

			const config = {
				version: "^" +
				___R$project$rome$$romejs$core$common$constants_ts$VERSION,
			};
			await writeConfig();

			async function writeConfig() {
				await ___R$project$rome$$romejs$fs$index_ts$writeFile(
					configPath,
					___R$project$rome$$romejs$codec$json$index_ts$stringifyRJSON(config),
				);
			}

			// Run lint, capture diagnostics

			reporter.success(
				'Created config <filelink emphasis target="' +
				configPath.join() +
				'" />',
			);

			return true;
		},
	});


  // project-rome/@romejs/core/client/commands/start.ts
const ___R$project$rome$$romejs$core$client$commands$start_ts$default = ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: "start daemon (if none running)",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const existingServer = await req.client.tryConnectToExistingDaemon();
			if (existingServer) {
				req.client.reporter.success("Already running server.");
				return true;
			}

			const bridge = await req.client.startDaemon();
			return bridge !== undefined;
		},
	});


  // project-rome/@romejs/core/client/commands/develop.ts
const ___R$project$rome$$romejs$core$client$commands$develop_ts$default = ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: "TODO",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const existingServer = await req.client.tryConnectToExistingDaemon();
			const hasExistingServer = existingServer !== undefined;

			if (!hasExistingServer) {
				await req.client.forceStartDaemon();
			}

			await req.client.query(
				Object.assign({}, req.query, {terminateWhenIdle: true}),
				"master",
			);

			return true;
		},
	});


  // project-rome/@romejs/core/client/commands/stop.ts
const ___R$project$rome$$romejs$core$client$commands$stop_ts$default = ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: "stop a running daemon if one exists",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			// We might want to use `terminateWhenIdle` here combined with a timeout instead of forcing it to die straight away
			const {reporter} = req.client;
			const bridge = await req.client.tryConnectToExistingDaemon();
			if (bridge) {
				const stop = await req.client.query(
					{
						commandName: "stop",
					},
					"master",
				);
				if (stop.type === "ERROR" && stop.fatal) {
					reporter.success("Stopped server.");
				} else {
					reporter.error("Failed to stop server.");
					return false;
				}
			} else {
				reporter.warn("No running server to stop.");
			}
			return true;
		},
	});


  // project-rome/@romejs/core/common/utils/executeMain.ts
const ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$internalModule = require(
		"module",
	);
	const ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$vm = require(
		"vm",
	);


	async function ___R$project$rome$$romejs$core$common$utils$executeMain_ts$default(
		opts,
	) {
		const {path, code, sourceMap, globals} = opts;

		const filename = path.join();

		// Create global context
		const sandbox = Object.assign(
			{
				process: {
					argv: [process.argv[0], filename],
					__proto__: process,
				},
				Buffer,
				clearImmediate,
				clearInterval,
				clearTimeout,
				setImmediate,
				setInterval,
				setTimeout,
				require: ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$internalModule.createRequire
					? ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$internalModule.createRequire(
							filename,
						)
					: ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$internalModule.createRequireFromPath(
							filename,
						),
				console,
				__dirname: path.getParent().join(),
				__filename: filename,
			},
			globals,
		);
		sandbox.global = sandbox;
		const context = ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$vm.createContext(
			sandbox,
		);

		// Here we do some gymnastics to catch a syntax error to correctly identify it as being our fault
		let script;
		try {
			script = new ___R$$priv$project$rome$$romejs$core$common$utils$executeMain_ts$vm.Script(
				code,
				{
					filename,
					displayErrors: true,
				},
			);
		} catch (err) {
			if (err instanceof SyntaxError && err.stack !== undefined) {
				const lineMatch = err.stack.match(/^(.*?):(\d+)/);
				if (lineMatch == null) {
					throw err;
				}

				const line = Number(lineMatch[2]);

				const pos = {
					index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0Neg1,
					column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
					line: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1(line),
				};

				const syntaxError = {
					description: Object.assign(
						{},
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.V8.SYNTAX_ERROR(
							err.message,
						),
						{
							advice: [
								___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE,
							],
						},
					),
					location: {
						start: pos,
						end: pos,
						filename,
						sourceText: ___R$project$rome$$romejs$diagnostics$helpers_ts$truncateSourceText(
							code,
							pos,
							pos,
						),
					},
				};
				return {syntaxError};
			}

			throw err;
		}

		// Execute the script if there was no syntax error
		if (sourceMap !== undefined) {
			___R$project$rome$$romejs$v8$sourceMapManager_ts$default.add(
				filename,
				sourceMap,
			);
		}
		await script.runInContext(context);
		return {syntaxError: undefined};
	}


  // project-rome/@romejs/core/client/commands/run.ts
const ___R$project$rome$$romejs$core$client$commands$run_ts$default = ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: "TODO",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const bridge = await req.client.findOrStartMaster();
			if (bridge === undefined) {
				return false;
			}

			process.on(
				"unhandledRejection",
				(error) => {
					error;
					//console.log('unhandledRejection', error.stack);
				},
			);

			const res = await req.client.query(
				{
					commandName: "run",
					args: req.query.args,
				},
				"master",
			);

			if (res.type !== "SUCCESS") {
				return false;
			}

			const data = ___R$project$rome$$romejs$consume$index_ts$consumeUnknown(
				res.data,
				"parse/json",
			);

			if (data.exists()) {
				const type = data.get("type").asString();

				switch (type) {
					case "executeCode": {
						process.execArgv = [...process.execArgv, process.argv[1], "run"];
						process.argv = [
							process.argv[0],
							String(data.filename),
							...process.argv.slice(4),
						];
						const {syntaxError} = await ___R$project$rome$$romejs$core$common$utils$executeMain_ts$default({
							path: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
								data.get("filename").asString(),
							),
							code: data.get("code").asString(),
							sourceMap: ___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default.fromJSON(
								data.get("map").asAny(),
							),
						});
						if (syntaxError !== undefined) {
							throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
								syntaxError,
							);
						}
						await new Promise(() => {});
						break;
					}
				}
			}

			return true;
		},
	});


  // project-rome/@romejs/core/client/commands/restart.ts
const ___R$project$rome$$romejs$core$client$commands$restart_ts$default = ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: "restart daemon",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const stopped = await req.client.query({
				commandName: "stop",
			});

			if (stopped.type === "SUCCESS" && stopped.data === true) {
				const started = await req.client.query({
					commandName: "start",
				});
				return started.type === "SUCCESS" && started.data === true;
			} else {
				return false;
			}
		},
	});


  // project-rome/@romejs/core/client/commands/status.ts
const ___R$project$rome$$romejs$core$client$commands$status_ts$default = ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand({
		description: "get the current daemon status",
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {reporter} = req.client;
			const bridge = await req.client.tryConnectToExistingDaemon();
			if (bridge) {
				const status = await req.client.query(
					{
						commandName: "status",
					},
					"master",
				);
				if (status.type === "SUCCESS") {
					reporter.inspect(status.data);
					return true;
				} else {
					return false;
				}
			} else {
				reporter.error("Server not running.");
				return false;
			}
		},
	});


  // project-rome/@romejs/core/client/commands/lsp.ts
const ___R$project$rome$$romejs$core$client$commands$lsp_ts$default = ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand({
		description: "connect to an lsp",
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		usage: "",
		examples: [],
		// vscode-languageclient adds these on
		ignoreFlags: ["stdio", "clientProcessId"],
		defineFlags() {
			return {};
		},
		async callback(req) {
			req.client.setFlags({
				clientName: "lsp",
				silent: true,
			});

			const stdin = req.client.reporter.getStdin();
			req.client.reporter.teardown();

			const bridge = await req.client.findOrStartMaster();
			if (bridge === undefined) {
				return false;
			}

			bridge.lspFromServerBuffer.subscribe((chunk) => {
				req.client.derivedReporterStreams.stdout.write(chunk);
			});

			stdin.on(
				"data",
				(chunk) => {
					bridge.lspFromClientBuffer.call(chunk.toString());
				},
			);

			await req.client.query(
				{
					commandName: "lsp",
				},
				"master",
			);

			return true;
		},
	});


  // project-rome/@romejs/core/client/commands.ts


	function ___R$project$rome$$romejs$core$client$commands_ts$createLocalCommand(
		cmd,
	) {
		return cmd;
	}

	const ___R$project$rome$$romejs$core$client$commands_ts$localCommands = new Map();
	___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
		"init",
		___R$project$rome$$romejs$core$client$commands$init_ts$default,
	);
	___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
		"start",
		___R$project$rome$$romejs$core$client$commands$start_ts$default,
	);
	___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
		"develop",
		___R$project$rome$$romejs$core$client$commands$develop_ts$default,
	);
	___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
		"stop",
		___R$project$rome$$romejs$core$client$commands$stop_ts$default,
	);
	___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
		"run",
		___R$project$rome$$romejs$core$client$commands$run_ts$default,
	);
	___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
		"restart",
		___R$project$rome$$romejs$core$client$commands$restart_ts$default,
	);
	___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
		"status",
		___R$project$rome$$romejs$core$client$commands$status_ts$default,
	);
	___R$project$rome$$romejs$core$client$commands_ts$localCommands.set(
		"lsp",
		___R$project$rome$$romejs$core$client$commands$lsp_ts$default,
	);


  // project-rome/@romejs/core/master/MasterRequest.ts
const ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$crypto = require(
		"crypto",
	);


	let ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$requestIdCounter = 0;







	const ___R$project$rome$$romejs$core$master$MasterRequest_ts$EMPTY_SUCCESS_RESPONSE = {
		type: "SUCCESS",
		hasData: false,
		data: undefined,
		markers: [],
	};







	class ___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid
		extends ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError {
		constructor(message, diagnostics, showHelp) {
			super(message, diagnostics);
			this.showHelp = showHelp;
		}
	}

	function ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$hash(
		val,
	) {
		return val === undefined || Object.keys(val).length === 0
			? "none"
			: ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$crypto.createHash(
					"sha256",
				).update(JSON.stringify(val)).digest("hex");
	}

	class ___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestCancelled
		extends Error {
		constructor() {
			super(
				"MasterRequest has been cancelled. This error is meant to be seen by Master",
			);
		}
	}

	class ___R$project$rome$$romejs$core$master$MasterRequest_ts$default {
		constructor(opts) {
			this.query = opts.query;
			this.master = opts.master;
			this.bridge = opts.client.bridge;
			this.reporter = opts.client.reporter;
			this.cancelled = false;
			this.toredown = false;
			this.markerEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "MasterRequest.marker",
				onError: this.master.onFatalErrorBound,
			});
			this.endEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "MasterRequest.teardown",
				onError: this.master.onFatalErrorBound,
				serial: true,
			});
			this.client = opts.client;
			this.id = ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$requestIdCounter++;
			this.markers = [];
			this.start = Date.now();
			this.normalizedCommandFlags = {
				flags: {},
				defaultFlags: {},
			};
			this.client.requestsInFlight.add(this);
		}

		async init() {
			if (this.query.requestFlags.collectMarkers) {
				this.markerEvent.subscribe((marker) => {
					this.markers.push(marker);
				});
			}

			await this.master.handleRequestStart(this);
		}

		checkCancelled() {
			if (this.cancelled) {
				throw new ___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestCancelled();
			}
		}

		cancel() {
			this.cancelled = true;
			this.teardown({
				type: "CANCELLED",
			});
		}

		teardown(res) {
			if (this.toredown) {
				return;
			}

			this.toredown = true;
			this.client.requestsInFlight.delete(this);

			// Output timing information
			if (this.query.requestFlags.timing) {
				const end = Date.now();
				this.reporter.info(
					"Request took <duration emphasis>" +
					String(end - this.start) +
					"</duration>",
				);
			}

			if (res !== undefined) {
				// If the query asked for no data then strip all diagnostics and data values
				if (this.query.noData) {
					if (res.type === "SUCCESS") {
						res = Object.assign(
							{},
							___R$project$rome$$romejs$core$master$MasterRequest_ts$EMPTY_SUCCESS_RESPONSE,
							{hasData: res.data !== undefined},
						);
					} else if (res.type === "DIAGNOSTICS") {
						res = {
							type: "DIAGNOSTICS",
							hasDiagnostics: res.hasDiagnostics,
							diagnostics: [],
						};
					} else if (res.type === "INVALID_REQUEST") {
						res = {
							type: "INVALID_REQUEST",
							diagnostics: [],
							showHelp: res.showHelp,
						};
					}
				}

				// Add on markers
				if (res.type === "SUCCESS") {
					res = Object.assign({}, res, {markers: this.markers});
				}
			}

			this.reporter.teardown();
			this.endEvent.send(res);
			this.master.handleRequestEnd(this);
			return res;
		}

		setNormalizedCommandFlags(normalized) {
			this.normalizedCommandFlags = normalized;
		}

		async assertClientCwdProject() {
			const location = this.getDiagnosticPointerForClientCwd();
			return this.master.projectManager.assertProject(
				this.client.flags.cwd,
				location,
			);
		}

		async getVCSClient() {
			return this.master.projectManager.getVCSClient(
				await this.assertClientCwdProject(),
			);
		}

		async maybeGetVCSClient() {
			return this.master.projectManager.maybeGetVCSClient(
				await this.assertClientCwdProject(),
			);
		}

		createDiagnosticsProcessor(opts = {}) {
			return new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
				Object.assign({markupOptions: this.reporter.markupOptions}, opts),
			);
		}

		createDiagnosticsPrinter(processor = this.createDiagnosticsProcessor()) {
			processor.unshiftOrigin({
				category: "master",
				message: this.query.commandName + " command was dispatched",
			});

			return new ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default({
				processor,
				reporter: this.reporter,
				cwd: this.client.flags.cwd,
				flags: this.getDiagnosticsPrinterFlags(),
				readFile: this.master.readDiagnosticsPrinterFile.bind(this.master),
			});
		}

		getDiagnosticsPrinterFlags() {
			const {requestFlags} = this.query;
			return {
				grep: requestFlags.grep,
				inverseGrep: requestFlags.inverseGrep,
				showAllDiagnostics: requestFlags.showAllDiagnostics,
				verboseDiagnostics: requestFlags.verboseDiagnostics,
				maxDiagnostics: requestFlags.maxDiagnostics,
				fieri: requestFlags.fieri,
			};
		}

		expectArgumentLength(min, max = min) {
			const {args} = this.query;
			let message;

			let excessive = false;

			if (min === max) {
				if (args.length !== min) {
					if (min === 0) {
						message = "Expected no arguments";
					} else {
						message =
							"Expected exactly <number emphasis>" + min + "</number> arguments";
					}
				}
			} else {
				if (args.length < min) {
					message =
						"Expected at least <number emphasis>" + min + "</number> arguments";
				}

				if (args.length > max) {
					excessive = true;
					message =
						"Expected no more than <number emphasis>" +
						min +
						"</number> arguments";
				}
			}

			if (message !== undefined) {
				this.throwDiagnosticFlagError({
					target: {
						type: "arg-range",
						from: min,
						to: max,
					},
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.FLAGS.INCORRECT_ARG_COUNT(
						excessive,
						message,
					),
				});
			}
		}

		throwDiagnosticFlagError(
			{
				description,
				target = {type: "none"},
				showHelp = true,
			},
		) {
			const location = this.getDiagnosticPointerFromFlags(target);

			let {category} = description;
			if (category === undefined) {
				category =
					target.type === "arg" || target.type === "arg-range"
						? "args/invalid"
						: "flags/invalid";
			}

			const diag = {
				description: Object.assign({advice: []}, description, {category}),
				location,
			};

			throw new ___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid(
				description.message.value,
				[diag],
				showHelp,
			);
		}

		getDiagnosticPointerForClientCwd() {
			const cwd = this.client.flags.cwd.join();
			return {
				sourceText: cwd,
				start: {
					index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
					line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
					column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
				},
				end: {
					index: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(cwd.length),
					line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
					column: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(cwd.length),
				},
				filename: "cwd",
			};
		}

		getDiagnosticPointerFromFlags(target) {
			const {query} = this;

			const rawFlags = Object.assign(
				{},
				this.client.flags,
				this.query.requestFlags,
				this.normalizedCommandFlags.flags,
			);
			const flags = Object.assign({}, rawFlags, {cwd: rawFlags.cwd.join()});

			const rawDefaultFlags = Object.assign(
				{},
				___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS,
				___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS,
				this.normalizedCommandFlags.defaultFlags,
				{clientName: this.client.flags.clientName},
			);
			const defaultFlags = Object.assign(
				{},
				rawDefaultFlags,
				{cwd: rawDefaultFlags.cwd.join()},
			);

			return ___R$project$rome$$romejs$cli$flags$serializeCLIFlags_ts$serializeCLIFlags(
				{
					programName: "rome",
					commandName: query.commandName,
					flags,
					args: query.args,
					defaultFlags,
					incorrectCaseFlags: new Set(),
					shorthandFlags: new Set(),
				},
				target,
			);
		}

		getResolverOptionsFromFlags() {
			const {requestFlags} = this.query;
			return {
				origin: this.client.flags.cwd,
				platform: requestFlags.resolverPlatform,
				scale: requestFlags.resolverScale,
				mocks: requestFlags.resolverMocks,
			};
		}

		getBundlerConfigFromFlags(resolverOpts) {
			return {
				inlineSourceMap: false,
				cwd: this.client.flags.cwd,
				resolver: Object.assign(
					{},
					this.getResolverOptionsFromFlags(),
					resolverOpts,
				),
			};
		}

		async resolveFilesFromArgs(overrideArgs, tryAlternateArg) {
			this.checkCancelled();

			const projects = new Set();
			const rawArgs =
				overrideArgs === undefined ? this.query.args : overrideArgs;
			const resolvedArgs = [];
			const {cwd} = this.client.flags;

			// If args was explicitly provided then don't assume empty args is the project root
			if (rawArgs.length === 0 && overrideArgs === undefined) {
				const location = this.getDiagnosticPointerForClientCwd();
				const project = await this.assertClientCwdProject();
				resolvedArgs.push({
					path: project.folder,
					location,
					project,
				});
				projects.add(project);
			} else {
				for (let i = 0; i < rawArgs.length; i++) {
					const arg = rawArgs[i];

					const location = this.getDiagnosticPointerFromFlags({
						type: "arg",
						key: i,
					});

					let source = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
						arg,
					);
					let resolved;

					if (tryAlternateArg !== undefined) {
						const alternateSource = tryAlternateArg(source);
						if (alternateSource !== undefined) {
							const resolvedAlternate = await this.master.resolver.resolveEntry({
								origin: cwd,
								source: alternateSource,
								requestedType: "folder",
							});
							if (resolvedAlternate.type === "FOUND") {
								resolved = resolvedAlternate;
							}
						}
					}

					if (resolved === undefined) {
						resolved = await this.master.resolver.resolveEntryAssert(
							{
								origin: cwd,
								source,
								requestedType: "folder",
							},
							{
								location,
							},
						);
					}

					const project = this.master.projectManager.assertProjectExisting(
						resolved.path,
					);
					projects.add(project);

					resolvedArgs.push({
						project,
						path: resolved.path,
						location,
					});
				}
			}

			return {
				resolvedArgs,
				projects,
			};
		}

		async watchFilesFromArgs(opts, callback) {
			this.checkCancelled();

			// Everything needs to be relative to this
			const {resolvedArgs} = await this.resolveFilesFromArgs(
				opts.args,
				opts.tryAlternateArg,
			);

			const initial = await this.getFilesFromArgs(opts);
			await callback(initial, true);

			let pendingEvictPaths = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();
			let pendingEvictProjects = new Set();
			let timeout;
			let changesWhileRunningCallback = false;
			let runningCallback = false;

			async function flush() {
				if (pendingEvictPaths.size === 0) {
					return;
				}

				timeout = undefined;

				const result = {
					paths: pendingEvictPaths,
					projects: pendingEvictProjects,
				};
				pendingEvictPaths = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();
				pendingEvictProjects = new Set();

				runningCallback = true;
				await callback(result, false);
				runningCallback = false;

				if (changesWhileRunningCallback) {
					changesWhileRunningCallback = false;
					flush();
				}
			}

			const onChange = (path) => {
				let matches = false;
				for (const arg of resolvedArgs) {
					if (arg.path.equal(path) || path.isRelativeTo(arg.path)) {
						matches = true;
						break;
					}
				}
				if (!matches) {
					return;
				}

				const project = this.master.projectManager.findProjectExisting(path);
				if (project !== undefined) {
					pendingEvictProjects.add(project);
				}

				pendingEvictPaths.add(path);

				// Buffer up evicted paths
				if (runningCallback) {
					changesWhileRunningCallback = true;
				} else if (timeout === undefined) {
					timeout = setTimeout(flush, 100);
				}
			};

			// Subscribe to evictions and file changes. This can cause double emits but we dedupe them with AbsoluteFilePathSet. An updated buffer dispatches a fileChangeEvent but NOT an evictEvent. An evictEvent is dispatched for all files in a project when the project config is changed but does NOT dispatch evictEvent.
			const evictSubscription = this.master.fileAllocator.evictEvent.subscribe(
				onChange,
			);
			const fileChangeEvent = this.master.fileChangeEvent.subscribe(onChange);

			this.endEvent.subscribe(() => {
				evictSubscription.unsubscribe();
				fileChangeEvent.unsubscribe();
			});

			return ___R$project$rome$$romejs$events$utils_ts$mergeEventSubscriptions([
				evictSubscription,
				fileChangeEvent,
			]);
		}

		async getFilesFromArgs(opts = {}) {
			this.checkCancelled();

			const {master} = this;
			const {configCategory, ignoreProjectIgnore} = opts;
			const {projects, resolvedArgs} = await this.resolveFilesFromArgs(
				opts.args,
				opts.tryAlternateArg,
			);

			const extendedGlobOpts = Object.assign({}, opts);

			if (configCategory !== undefined) {
				extendedGlobOpts.getProjectIgnore = (project) =>
					ignoreProjectIgnore ? [] : project.config[configCategory].ignore
				;
			}

			// Resolved arguments that resulted in no files
			const noArgMatches = new Set();

			// Match files
			const paths = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();
			for (const arg of resolvedArgs) {
				const matches = master.memoryFs.glob(arg.path, extendedGlobOpts);

				if (matches.size === 0) {
					if (!opts.ignoreArgumentMisses) {
						noArgMatches.add(arg);
					}
				} else {
					for (const path of matches) {
						paths.add(path);
					}
				}
			}

			if (noArgMatches.size > 0) {
				const diagnostics = [];

				for (const {path, project, location} of noArgMatches) {
					let category = "args/fileNotFound";

					let advice = [...(opts.advice || [])];

					// Hint if all files were ignored
					if (configCategory !== undefined && !ignoreProjectIgnore) {
						const {paths: withoutIgnore} = await this.getFilesFromArgs(
							Object.assign({}, opts, {ignoreProjectIgnore: true}),
						);

						// Remove paths that we already successfully found
						for (const path of paths) {
							withoutIgnore.delete(path);
						}

						if (withoutIgnore.size > 0) {
							advice.push({
								type: "log",
								category: "info",
								text: "The following files were ignored",
							});

							advice.push({
								type: "list",
								list: Array.from(
									withoutIgnore,
									(path) => '<filelink target="' + path.join() + '" />',
								),
								truncate: true,
							});

							const ignoreSource = master.projectManager.findProjectConfigConsumer(
								project,
								(consumer) =>
									consumer.has(configCategory) &&
									consumer.get(configCategory).get("ignore")
								,
							);

							if (ignoreSource.value !== undefined) {
								const ignorePointer = ignoreSource.value.getDiagnosticLocation(
									"value",
								);

								advice.push({
									type: "log",
									category: "info",
									text: "Ignore patterns were defined here",
								});

								advice.push({
									type: "frame",
									location: ignorePointer,
								});
							}
						}
					}

					diagnostics.push({
						location: Object.assign(
							{},
							location,
							{marker: '<filelink target="' + path.join() + '" />'},
						),
						description: Object.assign(
							{},
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.FLAGS.NO_FILES_FOUND(
								opts.noun,
							),
							{category, advice},
						),
					});
				}

				throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
					"MasterRequest.getFilesFromArgs: Some arguments did not resolve to any files",
					diagnostics,
				);
			}

			return {paths, projects};
		}

		normalizeCompileResult(res) {
			const {projectManager} = this.master;

			// Turn all the cacheDependencies entries from 'absolute paths to UIDs
			return Object.assign(
				{},
				res,
				{
					cacheDependencies: res.cacheDependencies.map((filename) => {
						return projectManager.getFileReference(
							___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
								filename,
							),
						).uid;
					}),
				},
			);
		}

		startMarker(opts) {
			this.master.logger.info("Started marker %s", opts.label);
			return Object.assign({}, opts, {start: Date.now()});
		}

		endMarker(startMarker) {
			const endMarker = Object.assign({}, startMarker, {end: Date.now()});
			this.master.logger.info("Finished marker %s", startMarker.label);
			this.markerEvent.send(endMarker);
			return endMarker;
		}

		async wrapRequestDiagnostic(method, path, factory) {
			const {master} = this;
			const owner = await master.fileAllocator.getOrAssignOwner(path);
			const ref = master.projectManager.getTransportFileReference(path);

			const marker = this.startMarker({
				label: method + ": " + ref.uid,
				facet: method,
				rowId: "worker " + owner.id,
			});

			try {
				const res = await factory(owner.bridge, ref);
				this.endMarker(marker);
				return res;
			} catch (err) {
				let diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(
					err,
				);

				if (diagnostics === undefined) {
					const diag = ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
						err,
						{
							description: {
								category: "internalError/request",
							},
						},
					);

					throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
						Object.assign(
							{},
							diag,
							{
								description: Object.assign(
									{},
									diag.description,
									{
										advice: [
											...diag.description.advice,
											{
												type: "log",
												category: "info",
												text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Error occurred while requesting <emphasis>${method}</emphasis> for <filelink emphasis target="${ref.uid}" />`,
											},
										],
									},
								),
							},
						),
					);
				} else {
					// We don't want to tamper with these
					throw err;
				}
			}
		}

		async requestWorkerUpdateBuffer(path, content) {
			this.checkCancelled();

			await this.wrapRequestDiagnostic(
				"updateBuffer",
				path,
				(bridge, file) => bridge.updateBuffer.call({file, content}),
			);
			this.master.fileChangeEvent.send(path);
		}

		async requestWorkerParse(path, opts) {
			this.checkCancelled();

			return this.wrapRequestDiagnostic(
				"parse",
				path,
				(bridge, file) => bridge.parseJS.call({file, options: opts}),
			);
		}

		async requestWorkerUpdateInlineSnapshots(path, updates, parseOptions) {
			this.checkCancelled();

			return this.wrapRequestDiagnostic(
				"updateInlineSnapshots",
				path,
				(bridge, file) =>
					bridge.updateInlineSnapshots.call({file, updates, parseOptions})
				,
			);
		}

		async requestWorkerLint(path, optionsWithoutModSigs) {
			this.checkCancelled();

			const {cache} = this.master;
			const cacheEntry = await cache.get(path);

			const cacheKey = ___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$hash(
				optionsWithoutModSigs,
			);
			const cached = cacheEntry.lint[cacheKey];
			if (cached !== undefined) {
				return cached;
			}

			const prefetchedModuleSignatures = await this.maybePrefetchModuleSignatures(
				path,
			);

			const options = Object.assign(
				{},
				optionsWithoutModSigs,
				{prefetchedModuleSignatures},
			);

			const res = await this.wrapRequestDiagnostic(
				"lint",
				path,
				(bridge, file) => bridge.lint.call({file, options, parseOptions: {}}),
			);

			await cache.update(
				path,
				(cacheEntry) => ({
					lint: Object.assign({}, cacheEntry.lint, {[cacheKey]: res}),
				}),
			);

			return res;
		}

		async requestWorkerFormat(path, parseOptions) {
			this.checkCancelled();

			return await this.wrapRequestDiagnostic(
				"format",
				path,
				(bridge, file) => bridge.format.call({file, parseOptions}),
			);
		}

		async requestWorkerCompile(path, stage, options, parseOptions) {
			this.checkCancelled();

			const {cache} = this.master;

			// Create a cache key comprised of the stage and hash of the options
			const cacheKey =
				stage +
				":" +
				___R$$priv$project$rome$$romejs$core$master$MasterRequest_ts$hash(
					options,
				);

			// Check cache for this stage and options
			const cacheEntry = await cache.get(path);
			const cached = cacheEntry.compile[cacheKey];
			if (cached !== undefined) {
				// TODO check cacheDependencies
				return cached;
			}

			const compileRes = await this.wrapRequestDiagnostic(
				"compile",
				path,
				(bridge, file) => {
					// We allow options to be passed in as undefined so we can compute an easy cache key
					if (options === undefined) {
						options = {};
					}

					return bridge.compileJS.call({file, stage, options, parseOptions});
				},
			);

			const res = this.normalizeCompileResult(
				Object.assign({}, compileRes, {cached: false}),
			);

			// There's a race condition here between the file being opened and then rewritten
			await cache.update(
				path,
				(cacheEntry) => ({
					compile: Object.assign(
						{},
						cacheEntry.compile,
						{[cacheKey]: Object.assign({}, res, {cached: true})},
					),
				}),
			);

			return res;
		}

		async requestWorkerAnalyzeDependencies(path, parseOptions) {
			this.checkCancelled();

			const {cache} = this.master;

			const cacheEntry = await cache.get(path);
			if (cacheEntry.analyzeDependencies !== undefined) {
				return cacheEntry.analyzeDependencies;
			}

			const res = await this.wrapRequestDiagnostic(
				"analyzeDependencies",
				path,
				(bridge, file) => bridge.analyzeDependencies.call({file, parseOptions}),
			);
			await cache.update(
				path,
				{
					analyzeDependencies: Object.assign({}, res, {cached: true}),
				},
			);

			return Object.assign({}, res, {cached: false});
		}

		async requestWorkerModuleSignature(path, parseOptions) {
			this.checkCancelled();

			const {cache} = this.master;

			const cacheEntry = await cache.get(path);
			if (cacheEntry.moduleSignature !== undefined) {
				return cacheEntry.moduleSignature;
			}

			const res = await this.wrapRequestDiagnostic(
				"moduleSignature",
				path,
				(bridge, file) => bridge.moduleSignatureJS.call({file, parseOptions}),
			);
			await cache.update(
				path,
				{
					moduleSignature: res,
				},
			);
			return res;
		}

		async maybePrefetchModuleSignatures(path) {
			this.checkCancelled();

			const {projectManager} = this.master;

			const prefetchedModuleSignatures = {};
			const project = await projectManager.assertProject(path);
			if (project.config.typeCheck.enabled === false) {
				return prefetchedModuleSignatures;
			}

			// get the owner of this file

			/*const rootOwner = await fileAllocator.getOrAssignOwner(filename);
    const rootOwnerId = workerManager.getIdFromBridge(rootOwner);

    // absolute filenames to redupe export graphs
    const absoluteFilenameToGraphKey: Map<string, string> = new Map();

    // TODO exclude graphs that aren't a part of the root graph
    for (const dep of await dependencyGraph.getTransitiveDependencies(
      filename,
    )) {
      const key = `${dep.origin}:${dep.relative}`;
      const absolute = dep.absoluteMocked;

      // TODO check if we have this graph by another key and point to it if necessary
      const existingEntryKey = absoluteFilenameToGraphKey.get(absolute);
      if (existingEntryKey !== undefined) {
        invariant(existingEntryKey !== key, 'duplicate transitive dependency key %s', key);
        prefetchedModuleSignatures[key] = {
          type: 'POINTER',
          key: existingEntryKey,
        };
        continue;
      }

      // set the key so we point to the value instead of reproducing the whole graph
      absoluteFilenameToGraphKey.set(absolute, key);

      // fetch the owner so we can leave out graphs owned by the worker
      const owner = await fileAllocator.getOrAssignOwner(absolute);
      if (owner === rootOwner) {
        const project = await projectManager.assertProject(absolute);
        prefetchedModuleSignatures[key] = {
          type: 'OWNED',
          filename: absolute,
          projectId: project.id,
        };
        continue;
      }

      // get mtime so we can use it for a cache
      const mtime = this.master.memoryFs.getMtime(absolute);

      // check if this worker has it cached
      // TODO figure out some way to evict this on file deletion
      const cacheKey = `moduleSignature:${absolute}`;
      const cachedMtime = workerManager.getValueFromWorkerCache(
        rootOwnerId,
        cacheKey,
      );
      if (cachedMtime === mtime) {
        prefetchedModuleSignatures[key] = {
          type: 'USE_CACHED',
          filename: absolute,
        };
        continue;
      } else {
        workerManager.setWorkerCacheValue(rootOwnerId, cacheKey, mtime);
      }

      // calculate the graph
      const graph = await this.moduleSignature(absolute);
      prefetchedModuleSignatures[key] = {
        type: 'RESOLVED',
        graph,
      };
    }*/
			return prefetchedModuleSignatures;
		}
	}


  // project-rome/@romejs/core/client/review.ts


	async function ___R$$priv$project$rome$$romejs$core$client$review_ts$check(
		req,
		state,
	) {
		const {reporter} = req.client;

		reporter.clearScreen();

		if (state.initial) {
			reporter.info("Fetching initial diagnostics");
			state.initial = false;
		} else {
			reporter.info("Updating diagnostics");
		}

		const res = await req.fork(
			Object.assign(
				{},
				req.query,
				{
					// We want data no matter what
					noData: false,
				},
			),
		).initCommand();

		if (res.type === "SUCCESS") {
			throw new Error("Expected diagnostics or an error");
		}

		// In case it returned an error
		if (res.type !== "DIAGNOSTICS") {
			return res;
		}

		const diagnostics = res.diagnostics;
		let diag;

		for (const _diag of diagnostics) {
			const key = ___R$project$rome$$romejs$diagnostics$derive_ts$derivePositionlessKeyFromDiagnostic(
				_diag,
			);
			if (!state.seen.has(key)) {
				state.seen.add(key);
				diag = _diag;
				break;
			}
		}

		if (diag === undefined) {
			return res;
		}

		return await ___R$$priv$project$rome$$romejs$core$client$review_ts$ask(
			diag,
			req,
			state,
			false,
		);
	}

	async function ___R$$priv$project$rome$$romejs$core$client$review_ts$ask(
		diag,
		req,
		state,
		showMoreOptions,
	) {
		const {client} = req;
		const {reporter} = client;
		reporter.clearScreen();

		// Extract actions and remove them from the diagnostic
		let {advice = []} = diag.description;
		let hasExtraOptions = false;
		const actions = [];
		for (const item of advice) {
			if (item.type === "action") {
				// Only show extra items and hide all non-extra items when `more === true`
				if (item.extra === true) {
					hasExtraOptions = true;
					if (!showMoreOptions) {
						continue;
					}
				} else if (showMoreOptions) {
					continue;
				}

				actions.push(item);
			}
		}
		advice = advice.filter((item) => item.type !== "action");
		diag = Object.assign(
			{},
			diag,
			{description: Object.assign({}, diag.description, {advice})},
		);

		const optionToAction = new Map();
		const chosenShortcuts = new Set(["n", "escape"]);

		const actionOptions = {};

		let counter = 0;
		for (const action of actions) {
			const key = String(counter++);
			let shortcut =
				action.shortcut !== undefined && !chosenShortcuts.has(action.shortcut)
					? action.shortcut
					: undefined;
			optionToAction.set(key, action);
			actionOptions[key] = {
				label: action.noun,
				shortcut,
			};
		}

		const options = Object.assign(
			{
				ignore: {
					label: "Do nothing",
					shortcut: "n",
				},
			},
			actionOptions,
			{
				exit: {
					label: "Exit",
					shortcut: "escape",
				},
			},
		);

		if (hasExtraOptions) {
			if (showMoreOptions) {
				options.more = {
					label: "Less options...",
					shortcut: "l",
				};
			} else {
				options.more = {
					label: "More options...",
					shortcut: "m",
				};
			}
		}

		const printer = new ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default({
			reporter,
		});
		diag = printer.processor.addDiagnosticAssert(diag);
		printer.print();

		const answer = await reporter.radio(
			"How do you want to resolve this?",
			{
				options,
			},
		);

		// Check if this diagnostic is now out of date
		printer.fetchFileSources([diag]);
		const outdatedFiles = printer.getOutdatedFiles(diag);
		if (outdatedFiles.size > 0) {
			const files = Array.from(
				outdatedFiles,
				(path) => '<filelink emphasis target="' + path.join() + '" />',
			);

			reporter.br();

			if (files.length === 1) {
				reporter.warn(
					"The file " + files[0] + " changed while waiting for your response.",
				);
			} else {
				reporter.warn(
					"The following diagnostic dependencies changed while waiting for your response.",
				);
				reporter.list(files);
			}

			await reporter.confirm("Press any key to try again");

			return await ___R$$priv$project$rome$$romejs$core$client$review_ts$check(
				req,
				state,
			);
		}

		if (answer === "less") {
			return await ___R$$priv$project$rome$$romejs$core$client$review_ts$ask(
				diag,
				req,
				state,
				false,
			);
		}

		if (answer === "more") {
			return await ___R$$priv$project$rome$$romejs$core$client$review_ts$ask(
				diag,
				req,
				state,
				true,
			);
		}

		if (answer === "ignore") {
			return await ___R$$priv$project$rome$$romejs$core$client$review_ts$check(
				req,
				state,
			);
		}

		if (answer === "exit") {
			return ___R$project$rome$$romejs$core$master$MasterRequest_ts$EMPTY_SUCCESS_RESPONSE;
		}

		const action = optionToAction.get(answer);
		if (action === undefined) {
			throw new Error("Should have found an action for this option");
		}

		const requestFlags = Object.assign({}, action.requestFlags);

		// Execute action
		const actionRes = await client.query(
			{
				commandName: action.command,
				args: action.args,
				commandFlags: action.commandFlags,
				requestFlags,
			},
			"master",
		);
		if (actionRes.type !== "DIAGNOSTICS" && actionRes.type !== "SUCCESS") {
			return actionRes;
		}

		state.resolvedCount++;
		return await ___R$$priv$project$rome$$romejs$core$client$review_ts$check(
			req,
			state,
		);
	}

	async function ___R$project$rome$$romejs$core$client$review_ts$default(req) {
		const {reporter} = req.client;
		const state = {
			initial: true,
			seen: new Set(),
			resolvedCount: 0,
		};
		const res = await ___R$$priv$project$rome$$romejs$core$client$review_ts$check(
			req,
			state,
		);

		reporter.clearScreen();

		if (state.seen.size === 0) {
			reporter.success("Nothing to review!");
		} else {
			if (res.type === "DIAGNOSTICS") {
				___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnostics({
					diagnostics: res.diagnostics,
					suppressions: [],
					excludeFooter: true,
					printerOptions: {
						reporter,
					},
				});
				reporter.hr();
				reporter.error(
					"<number emphasis>" +
					res.diagnostics.length +
					'</number> unresolved <grammarNumber plural="issues" singular="issue">' +
					res.diagnostics.length +
					"</grammarNumber> remaining",
				);
			}

			reporter.success(
				"<number emphasis>" +
				state.resolvedCount +
				'</number> <grammarNumber plural="issues" singular="issue">' +
				state.resolvedCount +
				"</grammarNumber> resolved",
			);
		}

		return res;
	}


  // project-rome/@romejs/core/client/ClientRequest.ts


	class ___R$project$rome$$romejs$core$client$ClientRequest_ts$default {
		constructor(client, type = "local", query) {
			this.client = client;
			this.type = type;
			this.query = query;
		}

		fork(query) {
			return new ___R$project$rome$$romejs$core$client$ClientRequest_ts$default(
				this.client,
				this.type,
				query,
			);
		}

		async init() {
			try {
				const {requestFlags} = this.query;
				if (requestFlags !== undefined && requestFlags.review) {
					return await this.initReview();
				} else {
					return await this.initCommand();
				}
			} catch (err) {
				return {
					type: "ERROR",
					fatal: false,
					handled: false,
					name: err.name,
					message: err.message,
					stack: err.stack,
				};
			}
		}

		async initReview() {
			return ___R$project$rome$$romejs$core$client$review_ts$default(this);
		}

		async initCommand() {
			const localCommand = ___R$project$rome$$romejs$core$client$commands_ts$localCommands.get(
				this.query.commandName,
			);

			if (this.type === "master" || localCommand === undefined) {
				return this.initFromMaster();
			} else {
				return this.initFromLocal(localCommand);
			}
		}

		async initFromLocal(
			// rome-ignore lint/js/noExplicitAny
			localCommand,
		) {
			const {query} = this;

			let flags;
			if (localCommand.defineFlags !== undefined) {
				flags = localCommand.defineFlags(
					___R$project$rome$$romejs$consume$index_ts$consumeUnknown(
						query.commandFlags,
						"flags/invalid",
					),
				);
			}

			const res = await localCommand.callback(this, flags);
			if (res === true) {
				return {
					type: "SUCCESS",
					data: undefined,
					hasData: false,
					markers: [],
				};
			} else if (res === false) {
				return {
					type: "ERROR",
					fatal: false,
					// Local command would have printed something
					handled: true,
					name: "Error",
					message: "Command was not successful",
					stack: undefined,
				};
			} else {
				return res;
			}
		}

		async initFromMaster() {
			const {client} = this;

			try {
				const bridge = await client.findOrStartMaster();
				return await bridge.query.call(this.query);
			} catch (err) {
				if (
					err instanceof
					___R$project$rome$$romejs$events$BridgeError_ts$default
				) {
					return {
						type: "ERROR",
						fatal: true,
						handled: false,
						name: "Error",
						message: "Server died while processing command. Results may be incomplete.",
						stack: undefined,
					};
				} else {
					throw err;
				}
			}
		}
	}


  // project-rome/@romejs/core/master/WorkerQueue.ts






	class ___R$project$rome$$romejs$core$master$WorkerQueue_ts$default {
		constructor(master, maxPer = 2) {
			this.master = master;
			this.callbacks = [];
			this.runningWorkers = [];
			this.workers = new Map();
			this.open = true;
			this.maxPer = maxPer;
		}

		async pushQueue(path, metadata) {
			if (!this.open) {
				throw new Error("WorkerQueue has already closed");
			}

			if (this.callbacks.length === 0) {
				throw new Error("No callbacks attached to queue");
			}

			const workerContainer = await this.master.fileAllocator.getOrAssignOwner(
				path,
			);

			// Populate the worker queue for this item
			let worker = this.workers.get(workerContainer);
			if (worker === undefined) {
				worker = {
					running: false,
					queue: [],
				};
				this.workers.set(workerContainer, worker);
			}
			worker.queue.push([path, metadata]);

			// Start this worker if it isn't already
			if (worker.running === false) {
				const promise = this.processWorker(worker);
				// Add a `catch` so that we aren't considered an unhandled promise if it rejects before a handler is attached
				promise.catch(() => {});
				this.runningWorkers.push(promise);
			}
		}

		addCallback(callback) {
			this.callbacks.push(callback);
		}

		async processWorker(worker) {
			worker.running = true;

			const {queue} = worker;

			const next = async () => {
				const item = queue.shift();
				if (item === undefined) {
					// Exhausted queue
					return;
				}

				const [filename, metadata] = item;
				for (const callback of this.callbacks) {
					await callback(filename, metadata);
				}
				await next();
			};

			while (queue.length > 0) {
				// "threads"
				const threads = [];
				for (let i = 0; i < this.maxPer; i++) {
					threads.push(next());
				}
				await Promise.all(threads);
			}

			worker.running = false;
		}

		async spin() {
			while (
				// Keep consuming all the promises until we're exhausted
				this.runningWorkers.length >
				0
			) {
				const {runningWorkers} = this;
				this.runningWorkers = [];
				await Promise.all(runningWorkers);
			}

			// Ensure we never receive anymore queue items

			this.open = false;
		}
	}


  // project-rome/@romejs/core/master/dependencies/DependencyOrderer.ts




	class ___R$project$rome$$romejs$core$master$dependencies$DependencyOrderer_ts$default {
		constructor(graph) {
			this.graph = graph;
			this.orderedNodes = new Set();
			this.visitedNodes = new Set();
			this.possibleCyclePaths = new Map();
			this.diagnostics = [];
			this.firstTopAwaitLocations = [];
		}

		handleAlreadyVisitedFile(node, path, ancestry) {
			const filename = path.join();

			// We flag a possible cycle when a dependency has yet to have it's own transitive dependencies resolve but it ends up going back to itself
			const isPossibleCycle =
				this.orderedNodes.has(node) === false && ancestry.includes(filename);
			if (isPossibleCycle) {
				const ourCyclePath = ancestry.concat([filename]);
				const existingCycle = this.possibleCyclePaths.get(node);

				// We want to get the shortest cycle path since it's likely the most easily resolved
				const isShortestCycle =
					existingCycle === undefined ||
					existingCycle.length > ourCyclePath.length;
				if (isShortestCycle) {
					this.possibleCyclePaths.set(node, ourCyclePath);
				}
			}
		}

		addFile(path, ancestry) {
			const node = this.graph.getNode(path);

			if (this.visitedNodes.has(node)) {
				this.handleAlreadyVisitedFile(node, path, ancestry);
				return;
			}

			this.visitedNodes.add(node);

			const {firstTopAwaitLocation} = node.analyze;
			if (firstTopAwaitLocation !== undefined) {
				this.firstTopAwaitLocations.push({
					mtime: node.getMtime(),
					loc: firstTopAwaitLocation,
				});
			}

			const subAncestry = ancestry.concat([path.join()]);
			for (const depPath of node.getAbsoluteDependencies()) {
				const dep = node.getDependencyInfoFromAbsolute(depPath).analyze;
				if (dep.kind === "value") {
					this.addFile(depPath, subAncestry);
				}
			}

			this.orderedNodes.add(node);
		}

		// We detect cycles by determining if there were any references to imports at the top level that
		// are for a module that will be initialized before
		detectCycles() {
			const flatOrder = Array.from(this.orderedNodes);

			for (let i = 0; i < flatOrder.length; i++) {
				const node = flatOrder[i];

				for (const imp of node.analyze.importFirstUsage) {
					const resolved = node.getNodeFromRelativeDependency(imp.source).resolveImport(
						imp.imported,
						imp.loc,
					);
					if (resolved.type !== "FOUND") {
						continue;
					}

					// Hoisted exports will always be accessible
					if (resolved.record.valueType === "function") {
						continue;
					}

					const dep = resolved.node;

					const isBefore = flatOrder.indexOf(dep) > i;
					if (isBefore) {
						this.flagCycle(node, dep, imp);
					}
				}
			}
		}

		flagCycle(node, dep, imp) {
			const path = this.possibleCyclePaths.get(dep);
			if (!path) {
				// idk??
				return;
			}

			const target = path[path.length - 1];
			const culprit = String(
				path.find((value, index) => path[index - 1] === target),
			);

			this.diagnostics.push({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.BUNDLER.DETECTED_CYCLE(
					imp.local,
					target,
					culprit,
					path,
				),
				location: {
					filename: node.path.join(),
					mtime: node.getMtime(),
					start: imp.loc === undefined ? undefined : imp.loc.start,
					end: imp.loc === undefined ? undefined : imp.loc.end,
				},
			});
		}

		order(path) {
			this.addFile(path, []);
			this.detectCycles();
			return {
				firstTopAwaitLocations: this.firstTopAwaitLocations,
				diagnostics: this.diagnostics,
				files: Array.from(this.orderedNodes, (node) => node.path),
			};
		}
	}


  // project-rome/@romejs/core/master/dependencies/DependencyNode.ts






	function ___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$equalKind(
		producer,
		consumerKind,
	) {
		// Allow importing functions and classes as `type` and `typeof`
		if (
			producer.type === "local" &&
			(producer.valueType === "class" || producer.valueType === "function") &&
			(consumerKind === "type" || consumerKind === "typeof")
		) {
			return true;
		}

		// You can only import a type or a class as a type
		if (producer.kind === "type") {
			return consumerKind === "type";
		}

		// You can only import a value as a value or typeof
		if (producer.kind === "value") {
			return consumerKind === "typeof" || consumerKind === "value";
		}

		return false;
	}





	class ___R$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$default {
		constructor(graph, ref, res) {
			this.graph = graph;

			this.project = graph.master.projectManager.assertProjectExisting(ref.real);
			this.uid = ref.uid;
			this.path = ref.real;
			this.ref = ref;
			this.type = res.moduleType;

			this.usedAsync = false;
			this.all = false;
			this.relativeToAbsolutePath = new Map();
			this.absoluteToAnalyzeDependency = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();

			this.analyze = res;

			const {handler} = ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandler(
				ref.real,
				this.project.config,
			);
			this.handler = handler;
		}

		getMtime() {
			return this.graph.master.memoryFs.getMtime(this.path);
		}

		setUsedAsync(usedAsync) {
			this.usedAsync = usedAsync;
		}

		setAll(all) {
			this.all = all;
		}

		hasEscapedExports() {
			for (const exp of this.analyze.exports) {
				if (exp.type === "local" && exp.name === "*") {
					return true;
				}
			}
			return false;
		}

		getDependents() {
			const dependents = [];
			for (const node of this.graph.nodes.values()) {
				if (node.absoluteToAnalyzeDependency.has(this.path)) {
					dependents.push(node);
				}
			}
			return dependents;
		}

		addDependency(relative, absolute, dep) {
			this.relativeToAbsolutePath.set(relative, absolute);
			this.absoluteToAnalyzeDependency.set(
				absolute,
				{
					analyze: dep,
					path: absolute,
				},
			);
		}

		getDependencyInfoFromAbsolute(path) {
			const dep = this.absoluteToAnalyzeDependency.get(path);
			if (dep === undefined) {
				throw new Error("Expected dependency");
			}
			return dep;
		}

		getNodeFromRelativeDependency(relative) {
			const absolute = this.relativeToAbsolutePath.get(relative);
			if (absolute === undefined) {
				throw new Error("Expected dependency " + relative + " in " + this.path);
			}
			return this.graph.getNode(absolute);
		}

		getAbsoluteDependencies() {
			return Array.from(this.relativeToAbsolutePath.values());
		}

		getTransitiveDependencies() {
			let queue = [this];

			const nodes = new Set();

			while (queue.length > 0) {
				const node = queue.shift();
				if (node === undefined) {
					throw new Error("Already validated queue.length");
				}

				nodes.add(node);

				for (const absolute of node.getAbsoluteDependencies()) {
					const node = this.graph.getNode(absolute);

					if (!nodes.has(node)) {
						queue.push(node);
					}
				}
			}

			return Array.from(nodes);
		}

		getDependencyOrder() {
			const orderer = new ___R$project$rome$$romejs$core$master$dependencies$DependencyOrderer_ts$default(
				this.graph,
			);
			return orderer.order(this.path);
		}

		// Get a list of all DependencyNodes where exports could be resolved. eg. `export *`
		getExportedModules(chain = new Set()) {
			if (chain.has(this)) {
				return new Set();
			} else {
				chain.add(this);
			}

			for (const exp of this.analyze.exports) {
				if (
					exp.type === "externalAll" &&
					this.relativeToAbsolutePath.has(exp.source)
				) {
					this.getNodeFromRelativeDependency(exp.source).getExportedModules(
						chain,
					);
				}
			}

			return chain;
		}

		getExportedNames(kind, seen = new Set()) {
			if (seen.has(this)) {
				return new Set();
			} else {
				seen.add(this);
			}

			let names = new Set();

			for (const exp of this.analyze.exports) {
				if (
					!___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$equalKind(
						exp,
						kind,
					)
				) {
					continue;
				}

				switch (exp.type) {
					case "local": {
						names.add(exp.name);
						break;
					}

					case "external": {
						const resolved = this.getNodeFromRelativeDependency(exp.source).resolveImport(
							exp.imported,
							exp.loc,
						);
						if (
							resolved.type === "FOUND" &&
							___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$equalKind(
								resolved.record,
								kind,
							)
						) {
							names.add(exp.exported);
						}
						break;
					}

					case "externalNamespace": {
						names.add(exp.exported);
						break;
					}

					case "externalAll": {
						names = new Set([
							...names,
							...this.getNodeFromRelativeDependency(exp.source).getExportedNames(
								kind,
								seen,
							),
						]);
						break;
					}
				}
			}

			return names;
		}

		buildDiagnosticForUnknownExport(kind, resolved) {
			const location = Object.assign({}, resolved.loc, {mtime: this.getMtime()});

			const expectedName = resolved.name;
			const fromSource = resolved.node.uid;

			// Check if there was a matching local in any of the exported modules
			for (const mod of resolved.node.getExportedModules()) {
				// We use an object as a hash map so need to check for pollution
				if (
					Object.prototype.hasOwnProperty.call(
						mod.analyze.topLevelLocalBindings,
						expectedName,
					)
				) {
					const localLoc = mod.analyze.topLevelLocalBindings[expectedName];
					if (localLoc !== undefined) {
						return {
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.RESOLVER.UNKNOWN_EXPORT_POSSIBLE_UNEXPORTED_LOCAL(
								expectedName,
								fromSource,
								localLoc,
							),
							location,
						};
					}
				}
			}

			return {
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.RESOLVER.UNKNOWN_EXPORT(
					expectedName,
					fromSource,
					Array.from(resolved.node.getExportedNames(kind)),
					(name) => {
						const exportInfo = resolved.node.resolveImport(name, undefined);

						if (exportInfo.type === "NOT_FOUND") {
							throw new Error(
								"mod.resolveImport returned NOT_FOUND for an export " +
								name +
								" in " +
								exportInfo.node.path +
								" despite being returned by getExportedNames",
							);
						}

						return {
							location: exportInfo.record.loc,
							source: exportInfo.node === resolved.node
								? undefined
								: exportInfo.node.path.join(),
						};
					},
				),
				location,
			};
		}

		buildDiagnosticForTypeMismatch(resolved, node, nameInfo) {
			const {name, kind, loc} = nameInfo;
			const {record} = resolved;

			return {
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.RESOLVER.IMPORT_TYPE_MISMATCH(
					name,
					node.uid,
					kind,
					record.kind,
					record.loc,
				),
				location: Object.assign({}, loc, {mtime: this.getMtime()}),
			};
		}

		resolveImports() {
			const cached = this.resolveImportsCache;
			if (cached !== undefined) {
				return cached;
			}

			const {graph} = this;

			// Build up a map of any forwarded imports
			const resolvedImports = {};

			// Diagnostics for unknown imports
			const diagnostics = [];

			// Go through all of our dependencies and check if they have any external exports to forward
			const allowTypeImportsAsValue = this.analyze.syntax.includes("ts");
			for (const absolute of this.relativeToAbsolutePath.values()) {
				const mod = graph.getNode(absolute);

				// We can't follow CJS names
				if (mod.type === "cjs") {
					continue;
				}

				const usedNames = this.getDependencyInfoFromAbsolute(absolute).analyze.names;

				// Try to resolve these exports
				for (const nameInfo of usedNames) {
					const {name, kind, loc} = nameInfo;
					if (kind === "type" || kind === "typeof") {
						// Disable resolving typed imports for now as there's ridiculous code that hides some behind $FlowFixMe
						continue;
					}

					const resolved = mod.resolveImport(name, loc);

					// Unknown import
					if (resolved.type === "NOT_FOUND") {
						diagnostics.push(
							this.buildDiagnosticForUnknownExport(kind, resolved),
						);
						continue;
					}

					// Flag imports of the wrong type
					if (
						!allowTypeImportsAsValue &&
						!___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$equalKind(
							resolved.record,
							kind,
						)
					) {
						diagnostics.push(
							this.buildDiagnosticForTypeMismatch(resolved, mod, nameInfo),
						);
						continue;
					}

					// If the resolved target isn't the same as the file then forward it
					if (resolved.node.uid !== mod.uid) {
						resolvedImports[mod.uid + ":" + name] = {
							id: resolved.node.uid,
							name: resolved.record.name,
						};
					}
				}
			}

			const result = {
				resolved: resolvedImports,
				diagnostics,
			};
			this.resolveImportsCache = result;
			return result;
		}

		resolveImport(name, loc, ignoreDefault = false, ancestry = []) {
			if (ancestry.includes(this)) {
				return {
					type: "NOT_FOUND",
					loc,
					node: this,
					name,
				};
			}

			const subAncestry = [...ancestry, this];

			// We always want to resolve exports from the bottom up
			const exports = this.analyze.exports.reverse();

			for (const record of exports) {
				// When resolving exportAll we never want to include the default export of those modules
				if (
					record.type === "local" &&
					record.name === "default" &&
					ignoreDefault
				) {
					continue;
				}

				if (
					record.type === "local" &&
					(record.name === name || record.name === "*")
				) {
					return {
						type: "FOUND",
						node: this,
						record,
					};
				}

				if (record.type === "external" && record.exported === name) {
					return this.getNodeFromRelativeDependency(record.source).resolveImport(
						record.imported,
						record.loc,
						false,
						subAncestry,
					);
				}

				if (record.type === "externalAll") {
					const resolved = this.getNodeFromRelativeDependency(record.source).resolveImport(
						name,
						record.loc,
						true,
						subAncestry,
					);

					if (resolved.type === "FOUND") {
						return resolved;
					}
				}
			}

			return {
				type: "NOT_FOUND",
				loc,
				node: this,
				name,
			};
		}
	}


  // project-rome/@romejs/core/common/utils/Locker.ts


	class ___R$$priv$project$rome$$romejs$core$common$utils$Locker_ts$Lock {
		constructor(locker, key) {
			this.locker = locker;
			this.resolves = [];
			this.key = key;
		}

		addResolve(resolve) {
			this.resolves.push(resolve);
		}

		release() {
			const {resolves} = this;

			if (resolves.length === 0) {
				this.locker.locks.delete(this.key);
			} else {
				const resolve = resolves.shift();
				if (resolve === undefined) {
					throw new Error("Already validated resolved.length aboved");
				}
				resolve(this);
			}
		}
	}

	class ___R$project$rome$$romejs$core$common$utils$Locker_ts$default {
		constructor() {
			this.locks = new Map();
		}

		hasLock(id) {
			return this.locks.has(id);
		}

		getNewLock(key) {
			if (this.locks.has(key)) {
				throw new Error("Expected no lock to exist");
			}

			const lock = new ___R$$priv$project$rome$$romejs$core$common$utils$Locker_ts$Lock(
				this,
				key,
			);
			this.locks.set(key, lock);
			return lock;
		}

		async getLock(key) {
			const existingLock = this.locks.get(key);

			if (existingLock === undefined) {
				return this.getNewLock(key);
			} else {
				return new Promise((resolve) => {
					existingLock.addResolve(resolve);
				});
			}
		}

		async waitLock(key) {
			if (this.hasLock(key)) {
				const lock = await this.getLock(key);
				lock.release();
			}
		}
	}


  // project-rome/@romejs/core/master/dependencies/DependencyGraph.ts


	const ___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$BUILTINS = [
		"electron",
		"buffer",
		"child_process",
		"crypto",
		"dgram",
		"dns",
		"fs",
		"http",
		"https",
		"net",
		"os",
		"readline",
		"stream",
		"string_decoder",
		"tls",
		"tty",
		"zlib",
		"constants",
		"events",
		"url",
		"assert",
		"util",
		"path",
		"punycode",
		"querystring",
		"cluster",
		"console",
		"module",
		"process",
		"vm",
		"domain",
		"v8",
		"repl",
		"timers",
		"inspector",
	];





	class ___R$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$default {
		constructor(request, resolverOpts) {
			this.request = request;
			this.master = request.master;
			this.nodes = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.resolverOpts = resolverOpts;

			this.locker = new ___R$project$rome$$romejs$core$common$utils$Locker_ts$default();
			this.closeEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "DependencyGraph.closeEvent",
			});
		}

		close() {
			this.closeEvent.send();
		}

		isExternal(source) {
			return ___R$$priv$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$BUILTINS.includes(
				source,
			);
		}

		getBundleBuddyStats(entries) {
			const stats = [];

			for (const node of this.nodes.values()) {
				const source = node.uid;

				for (const absoluteTarget of node.relativeToAbsolutePath.values()) {
					const target = this.getNode(absoluteTarget).uid;
					stats.push({
						target,
						source,
					});
				}
			}

			for (const absoluteEntry of entries) {
				const source = this.getNode(absoluteEntry).uid;
				stats.push({
					source,
					target: undefined,
				});
			}

			return stats;
		}

		deleteNode(path) {
			this.nodes.delete(path);
		}

		addNode(path, res) {
			const module = new ___R$project$rome$$romejs$core$master$dependencies$DependencyNode_ts$default(
				this,
				this.master.projectManager.getFileReference(path),
				res,
			);
			this.nodes.set(path, module);
			return module;
		}

		maybeGetNode(path) {
			return this.nodes.get(path);
		}

		getNode(path) {
			const mod = this.maybeGetNode(path);
			if (mod === undefined) {
				throw new Error("No module found for " + path.join());
			}
			return mod;
		}

		async seed(
			{
				paths,
				diagnosticsProcessor,
				analyzeProgress,
				validate = false,
			},
		) {
			const workerQueue = new ___R$project$rome$$romejs$core$master$WorkerQueue_ts$default(
				this.master,
			);

			workerQueue.addCallback(async (path, item) => {
				await this.resolve(
					path,
					{
						workerQueue,
						all: item.all,
						async: item.async,
						ancestry: item.ancestry,
					},
					diagnosticsProcessor,
					analyzeProgress,
				);
			});

			// Add initial queue items
			const roots = await Promise.all(
				paths.map((path) =>
					this.resolve(
						path,
						{
							workerQueue,
							all: true,
							async: false,
							ancestry: [],
						},
						diagnosticsProcessor,
						analyzeProgress,
					)
				),
			);

			await workerQueue.spin();

			if (diagnosticsProcessor.hasDiagnostics()) {
				return;
			}

			if (validate) {
				for (const root of roots) {
					this.validateTransitive(root, diagnosticsProcessor);
				}
			}
		}

		validate(node, diagnosticsProcessor) {
			const resolvedImports = node.resolveImports();
			return (
				diagnosticsProcessor.addDiagnostics(resolvedImports.diagnostics).length >
				0
			);
		}

		validateTransitive(node, diagnosticsProcessor) {
			const order = node.getDependencyOrder();
			diagnosticsProcessor.addDiagnostics(order.diagnostics);

			for (const path of order.files) {
				this.validate(this.getNode(path), diagnosticsProcessor);
			}
		}

		async resolve(path, opts, diagnosticsProcessor, analyzeProgress) {
			const filename = path.join();
			const {async, all, ancestry} = opts;
			const {master} = this;

			// We have a lock here in case we hit `this.resolve` while we're waiting for the `analyzeDependencies` result
			const lock = await this.locker.getLock(filename);

			if (this.nodes.has(path)) {
				const node = this.getNode(path);

				if (all) {
					node.setAll(true);
				}

				if (async) {
					node.setUsedAsync(true);
				}

				lock.release();

				return node;
			}

			const progressText = ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${filename}" />`;

			if (analyzeProgress !== undefined) {
				analyzeProgress.pushText(progressText);
			}

			const res = await this.request.requestWorkerAnalyzeDependencies(path, {});

			const node = this.addNode(path, res);
			node.setAll(all);
			node.setUsedAsync(async);
			lock.release();

			const {dependencies, diagnostics} = res;

			if (diagnostics.length > 0) {
				diagnosticsProcessor.addDiagnostics(diagnostics);
			}

			// If we're a remote path then the origin should be the URL and not our local path
			const remote = this.master.projectManager.getRemoteFromLocalPath(path);
			const origin = remote === undefined ? path : remote.getParent();

			// Resolve full locations
			await Promise.all(
				dependencies.map(async (dep) => {
					const {source, optional} = dep;
					if (this.isExternal(source)) {
						return;
					}

					const {diagnostics} = await ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(
						async () => {
							const resolved = await master.resolver.resolveAssert(
								Object.assign(
									{},
									this.resolverOpts,
									{
										origin,
										source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
											source,
										),
									},
								),
								dep.loc === undefined
									? undefined
									: {
											location: Object.assign(
												{sourceText: undefined},
												dep.loc,
												{language: "js", mtime: undefined},
											),
										},
							);

							node.addDependency(source, resolved.path, dep);
						},
						{
							category: "DependencyGraph",
							message: "Caught by resolve",
						},
					);

					if (diagnostics !== undefined && !optional) {
						diagnosticsProcessor.addDiagnostics(diagnostics);
					}
				}),
			);

			// Queue our dependencies...
			const subAncestry = [...ancestry, filename];
			for (const path of node.getAbsoluteDependencies()) {
				const dep = node.getDependencyInfoFromAbsolute(path).analyze;
				await opts.workerQueue.pushQueue(
					path,
					{
						all: dep.all,
						async: dep.async,
						type: dep.type,
						loc: dep.loc,
						ancestry: subAncestry,
					},
				);
			}

			if (analyzeProgress !== undefined) {
				analyzeProgress.popText(progressText);
				analyzeProgress.tick();
			}

			return node;
		}
	}


  // project-rome/@romejs/core/master/bundler/BundleRequest.ts
const ___R$$priv$project$rome$$romejs$core$master$bundler$BundleRequest_ts$crypto = require(
		"crypto",
	);


	class ___R$project$rome$$romejs$core$master$bundler$BundleRequest_ts$default {
		constructor(
			{
				bundler,
				reporter,
				mode,
				resolvedEntry,
				options,
			},
		) {
			this.options = options;
			this.reporter = reporter;
			this.bundler = bundler;
			this.cached = true;
			this.mode = mode;

			this.resolvedEntry = resolvedEntry;
			this.resolvedEntryUid = bundler.master.projectManager.getUid(
				resolvedEntry,
			);

			this.diagnostics = bundler.request.createDiagnosticsProcessor({
				origins: [
					{
						category: "bundler",
						message: 'Requested bundle for <filelink target="' +
						this.resolvedEntryUid +
						'" />',
					},
				],
			});
			this.diagnostics.addAllowedUnusedSuppressionPrefix("lint");

			this.compiles = new Map();
			this.assets = new Map();

			this.sourceMap = new ___R$project$rome$$romejs$codec$source$map$SourceMapGenerator_ts$default({
				file: resolvedEntry.getBasename(),
			});
		}

		async stepAnalyze() {
			const {graph} = this.bundler;
			const {reporter} = this;

			const analyzeProgress = reporter.progress({
				name: "bundler:analyze:" + this.resolvedEntryUid,
				title: "Analyzing",
			});
			this.diagnostics.setThrowAfter(100);
			try {
				await graph.seed({
					paths: [this.resolvedEntry],
					diagnosticsProcessor: this.diagnostics,
					analyzeProgress,
					validate: true,
				});
			} finally {
				analyzeProgress.end();
			}

			return this.bundler.graph.getNode(this.resolvedEntry).getDependencyOrder();
		}

		async stepCompile(paths) {
			const {master} = this.bundler;
			const {reporter} = this;
			this.diagnostics.setThrowAfter(undefined);

			const compilingSpinner = reporter.progress({
				name: "bundler:compile:" + this.resolvedEntryUid,
				title: "Compiling",
			});
			compilingSpinner.setTotal(paths.length);

			const queue = new ___R$project$rome$$romejs$core$master$WorkerQueue_ts$default(
				master,
			);

			queue.addCallback(async (path) => {
				const progressText = '<filelink target="' + path.join() + '" />';
				compilingSpinner.pushText(progressText);
				await this.compileJS(path);
				compilingSpinner.tick();
				compilingSpinner.popText(progressText);
			});

			for (const path of paths) {
				await queue.pushQueue(path);
			}

			await queue.spin();
			compilingSpinner.end();
		}

		async compileJS(path) {
			const {graph} = this.bundler;

			const source = path.join();
			const mod = graph.getNode(path);

			// Build a map of relative module sources to module id
			const relativeSourcesToModuleId = {};
			for (const [relative, absolute] of mod.relativeToAbsolutePath) {
				const moduleId = graph.getNode(absolute).uid;
				relativeSourcesToModuleId[relative] = moduleId;
			}

			// Diagnostics would have already been added during the initial DependencyGraph.seed
			// We're doing the work of resolving everything again, maybe we should cache it?
			const resolvedImports = mod.resolveImports().resolved;

			let assetPath;
			if (mod.handler == null ? undefined : mod.handler.isAsset) {
				const buffer = await ___R$project$rome$$romejs$fs$index_ts$readFile(
					mod.path,
				);

				// Asset path in the form of: BASENAME-SHA1HASH.EXTENSIONS
				const hash = ___R$$priv$project$rome$$romejs$core$master$bundler$BundleRequest_ts$crypto.createHash(
					"sha1",
				).update(buffer).digest("hex");
				const basename = mod.path.getExtensionlessBasename();
				const exts = mod.path.getExtensions();

				assetPath = basename + "-" + hash + exts;
				this.assets.set(assetPath, buffer);
			}

			const opts = {
				mode: this.mode,
				moduleAll: mod.all,
				moduleId: mod.uid,
				relativeSourcesToModuleId,
				resolvedImports,
				assetPath,
			};

			const lock = await this.bundler.compileLocker.getLock(source);

			const res = await this.bundler.request.requestWorkerCompile(
				path,
				"compileForBundle",
				{
					bundle: opts,
				},
				{},
			);

			lock.release();

			if (!res.cached) {
				this.cached = false;
			}

			this.diagnostics.addSuppressions(res.suppressions);
			this.diagnostics.addDiagnostics(res.diagnostics);

			this.compiles.set(source, res);
			return res;
		}

		stepCombine(order, forceSourceMaps) {
			const {files} = order;
			const {inlineSourceMap} = this.bundler.config;
			const {graph} = this.bundler;
			const {resolvedEntry, mode, sourceMap} = this;

			// We allow deferring the generation of source maps. We don't do this by default as it's slower than generating them upfront
			// which is what most callers need. But for things like tests, we want to lazily compute the source map only when diagnostics
			// are present.
			let deferredSourceMaps =
				!forceSourceMaps && this.options.deferredSourceMaps === true;
			if (deferredSourceMaps) {
				sourceMap.addMaterializer(() => {
					this.stepCombine(order, true);
				});
			}

			let content = "";
			let lineOffset = 0;

			function push(str) {
				str += "\n";
				content += str;
				if (!deferredSourceMaps) {
					for (let cha of str) {
						if (cha === "\n") {
							lineOffset++;
						}
					}
				}
			}

			function addMappings(filename, sourceContent, mappings) {
				if (deferredSourceMaps) {
					return;
				}

				sourceMap.setSourceContent(filename, sourceContent);
				for (const mapping of mappings) {
					sourceMap.addMapping(
						Object.assign(
							{},
							mapping,
							{
								generated: Object.assign(
									{},
									mapping.generated,
									{
										line: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
											lineOffset,
											mapping.generated.line,
										),
									},
								),
							},
						),
					);
				}
			}

			const {interpreter} = this.options;
			if (interpreter !== undefined) {
				push("#!" + interpreter + "\n");
			}

			// add on bootstrap
			if (order.firstTopAwaitLocations.length > 0) {
				if (mode === "legacy") {
					for (const {loc, mtime} of order.firstTopAwaitLocations) {
						this.diagnostics.addDiagnostic({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.BUNDLER.TOP_LEVEL_AWAIT_IN_LEGACY,
							location: Object.assign({}, loc, {mtime}),
						});
					}
				}

				push("(async function(global) {");
			} else {
				push("(function(global) {");
			}

			if (mode === "modern") {
				push("  'use strict';");
			}

			// TODO prelude

			/*
    const path = createAbsoluteFilePath(loc);
    const res = await this.bundler.request.requestWorkerCompile(
      path,
      'compile',
    );
    push('(function() {');
    addMappings(
      this.bundler.master.projectManager.getUid(path),
      res.src,
      res.mappings,
    );
    push(res.code);
    push('})();');
    */
			const declaredCJS = new Set();
			function declareCJS(module) {
				if (
					mode !== "modern" ||
					module.type !== "cjs" ||
					declaredCJS.has(module)
				) {
					return;
				}

				declaredCJS.add(module);

				push(
					"  var " +
					___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
						module.uid,
					) +
					" = {};",
				);
			}

			// Add on files
			for (const source of files) {
				const module = graph.getNode(source);

				for (const path of module.getAbsoluteDependencies()) {
					declareCJS(graph.getNode(path));
				}

				const compileResult = this.compiles.get(source.join());
				if (compileResult === undefined) {
					continue;
					throw new Error("Expected compile result");
				}

				// Only do this in modern mode, the module id will already be in the wrapper otherwise
				if (mode === "modern") {
					push("  // " + module.uid);
				}

				declareCJS(module);

				addMappings(
					module.uid,
					compileResult.sourceText,
					compileResult.mappings,
				);
				push(compileResult.compiledCode);
				push("");
			}

			// push on initial entry require
			const entryModule = graph.getNode(resolvedEntry);
			if (mode === "modern") {
				push(
					"  return " +
					___R$project$rome$$romejs$js$compiler$transforms$compileForBundle$_utils_ts$getPrefixedNamespace(
						entryModule.uid,
					) +
					";",
				);
			} else {
				push('  return Rome.requireNamespace("' + entryModule.uid + '");');
			}

			// push footer
			push(
				"})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);",
			);

			//
			if (inlineSourceMap === true) {
				const sourceMapComment = sourceMap.toComment();
				content += sourceMapComment;
			} else {
				content += "//# sourceMappingURL=" + this.sourceMap.file + ".map";
			}

			return {
				diagnostics: this.diagnostics.getDiagnostics(),
				content,
				sourceMap: this.sourceMap,
				cached: this.cached,
				assets: this.assets,
			};
		}

		shouldAbort() {
			return this.diagnostics.hasDiagnostics();
		}

		abort() {
			return {
				sourceMap: this.sourceMap,
				content: "",
				diagnostics: this.diagnostics.getDiagnostics(),
				cached: false,
				assets: this.assets,
			};
		}

		async bundle() {
			const order = await this.stepAnalyze();
			if (this.shouldAbort()) {
				return this.abort();
			}

			// Compile
			await this.stepCompile(order.files);
			if (this.shouldAbort()) {
				return this.abort();
			}

			// Combine
			return await this.stepCombine(order, false);
		}
	}


  // project-rome/@romejs/codec-spdx-license/data.ts
const ___R$project$rome$$romejs$codec$spdx$license$data_ts$default = {
		licenseListVersion: "3.8-4-gd79c632",
		licenses: [
			{
				reference: "./0BSD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/0BSD.json",
				referenceNumber: "231",
				name: "BSD Zero Clause License",
				licenseId: "0BSD",
				seeAlso: ["http://landley.net/toybox/license.html"],
				isOsiApproved: true,
			},
			{
				reference: "./AAL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AAL.json",
				referenceNumber: "57",
				name: "Attribution Assurance License",
				licenseId: "AAL",
				seeAlso: ["https://opensource.org/licenses/attribution"],
				isOsiApproved: true,
			},
			{
				reference: "./ADSL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ADSL.json",
				referenceNumber: "210",
				name: "Amazon Digital Services License",
				licenseId: "ADSL",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/AmazonDigitalServicesLicense",
				],
				isOsiApproved: false,
			},
			{
				reference: "./AFL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-1.1.json",
				referenceNumber: "28",
				name: "Academic Free License v1.1",
				licenseId: "AFL-1.1",
				seeAlso: [
					"http://opensource.linux-mirror.org/licenses/afl-1.1.txt",
					"http://wayback.archive.org/web/20021004124254/http://www.opensource.org/licenses/academic.php",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AFL-1.2.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-1.2.json",
				referenceNumber: "215",
				name: "Academic Free License v1.2",
				licenseId: "AFL-1.2",
				seeAlso: [
					"http://opensource.linux-mirror.org/licenses/afl-1.2.txt",
					"http://wayback.archive.org/web/20021204204652/http://www.opensource.org/licenses/academic.php",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AFL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-2.0.json",
				referenceNumber: "330",
				name: "Academic Free License v2.0",
				licenseId: "AFL-2.0",
				seeAlso: [
					"http://wayback.archive.org/web/20060924134533/http://www.opensource.org/licenses/afl-2.0.txt",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AFL-2.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-2.1.json",
				referenceNumber: "241",
				name: "Academic Free License v2.1",
				licenseId: "AFL-2.1",
				seeAlso: ["http://opensource.linux-mirror.org/licenses/afl-2.1.txt"],
				isOsiApproved: true,
			},
			{
				reference: "./AFL-3.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AFL-3.0.json",
				referenceNumber: "350",
				name: "Academic Free License v3.0",
				licenseId: "AFL-3.0",
				seeAlso: [
					"http://www.rosenlaw.com/AFL3.0.htm",
					"https://opensource.org/licenses/afl-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AGPL-1.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AGPL-1.0.json",
				referenceNumber: "169",
				name: "Affero General Public License v1.0",
				licenseId: "AGPL-1.0",
				seeAlso: ["http://www.affero.org/oagpl.html"],
				isOsiApproved: false,
			},
			{
				reference: "./AGPL-1.0-only.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AGPL-1.0-only.json",
				referenceNumber: "68",
				name: "Affero General Public License v1.0 only",
				licenseId: "AGPL-1.0-only",
				seeAlso: ["http://www.affero.org/oagpl.html"],
				isOsiApproved: false,
			},
			{
				reference: "./AGPL-1.0-or-later.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AGPL-1.0-or-later.json",
				referenceNumber: "162",
				name: "Affero General Public License v1.0 or later",
				licenseId: "AGPL-1.0-or-later",
				seeAlso: ["http://www.affero.org/oagpl.html"],
				isOsiApproved: false,
			},
			{
				reference: "./AGPL-3.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AGPL-3.0.json",
				referenceNumber: "143",
				name: "GNU Affero General Public License v3.0",
				licenseId: "AGPL-3.0",
				seeAlso: [
					"https://www.gnu.org/licenses/agpl.txt",
					"https://opensource.org/licenses/AGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AGPL-3.0-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AGPL-3.0-only.json",
				referenceNumber: "287",
				name: "GNU Affero General Public License v3.0 only",
				licenseId: "AGPL-3.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/agpl.txt",
					"https://opensource.org/licenses/AGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AGPL-3.0-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/AGPL-3.0-or-later.json",
				referenceNumber: "154",
				name: "GNU Affero General Public License v3.0 or later",
				licenseId: "AGPL-3.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/agpl.txt",
					"https://opensource.org/licenses/AGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./AMDPLPA.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AMDPLPA.json",
				referenceNumber: "128",
				name: "AMD's plpa_map.c License",
				licenseId: "AMDPLPA",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/AMD_plpa_map_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./AML.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AML.json",
				referenceNumber: "151",
				name: "Apple MIT License",
				licenseId: "AML",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Apple_MIT_License"],
				isOsiApproved: false,
			},
			{
				reference: "./AMPAS.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/AMPAS.json",
				referenceNumber: "131",
				name: "Academy of Motion Picture Arts and Sciences BSD",
				licenseId: "AMPAS",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/BSD#AMPASBSD"],
				isOsiApproved: false,
			},
			{
				reference: "./ANTLR-PD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ANTLR-PD.json",
				referenceNumber: "44",
				name: "ANTLR Software Rights Notice",
				licenseId: "ANTLR-PD",
				seeAlso: ["http://www.antlr2.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./APAFML.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APAFML.json",
				referenceNumber: "240",
				name: "Adobe Postscript AFM License",
				licenseId: "APAFML",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/AdobePostscriptAFM"],
				isOsiApproved: false,
			},
			{
				reference: "./APL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APL-1.0.json",
				referenceNumber: "268",
				name: "Adaptive Public License 1.0",
				licenseId: "APL-1.0",
				seeAlso: ["https://opensource.org/licenses/APL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./APSL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APSL-1.0.json",
				referenceNumber: "375",
				name: "Apple Public Source License 1.0",
				licenseId: "APSL-1.0",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Apple_Public_Source_License_1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./APSL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APSL-1.1.json",
				referenceNumber: "327",
				name: "Apple Public Source License 1.1",
				licenseId: "APSL-1.1",
				seeAlso: [
					"http://www.opensource.apple.com/source/IOSerialFamily/IOSerialFamily-7/APPLE_LICENSE",
				],
				isOsiApproved: true,
			},
			{
				reference: "./APSL-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/APSL-1.2.json",
				referenceNumber: "194",
				name: "Apple Public Source License 1.2",
				licenseId: "APSL-1.2",
				seeAlso: [
					"http://www.samurajdata.se/opensource/mirror/licenses/apsl.php",
				],
				isOsiApproved: true,
			},
			{
				reference: "./APSL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/APSL-2.0.json",
				referenceNumber: "136",
				name: "Apple Public Source License 2.0",
				licenseId: "APSL-2.0",
				seeAlso: ["http://www.opensource.apple.com/license/apsl/"],
				isOsiApproved: true,
			},
			{
				reference: "./Abstyles.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Abstyles.json",
				referenceNumber: "72",
				name: "Abstyles License",
				licenseId: "Abstyles",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Abstyles"],
				isOsiApproved: false,
			},
			{
				reference: "./Adobe-2006.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Adobe-2006.json",
				referenceNumber: "299",
				name: "Adobe Systems Incorporated Source Code License Agreement",
				licenseId: "Adobe-2006",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/AdobeLicense"],
				isOsiApproved: false,
			},
			{
				reference: "./Adobe-Glyph.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Adobe-Glyph.json",
				referenceNumber: "332",
				name: "Adobe Glyph List License",
				licenseId: "Adobe-Glyph",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MIT#AdobeGlyph"],
				isOsiApproved: false,
			},
			{
				reference: "./Afmparse.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Afmparse.json",
				referenceNumber: "321",
				name: "Afmparse License",
				licenseId: "Afmparse",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Afmparse"],
				isOsiApproved: false,
			},
			{
				reference: "./Aladdin.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Aladdin.json",
				referenceNumber: "304",
				name: "Aladdin Free Public License",
				licenseId: "Aladdin",
				seeAlso: ["http://pages.cs.wisc.edu/~ghost/doc/AFPL/6.01/Public.htm"],
				isOsiApproved: false,
			},
			{
				reference: "./Apache-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Apache-1.0.json",
				referenceNumber: "32",
				name: "Apache License 1.0",
				licenseId: "Apache-1.0",
				seeAlso: ["http://www.apache.org/licenses/LICENSE-1.0"],
				isOsiApproved: false,
			},
			{
				reference: "./Apache-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Apache-1.1.json",
				referenceNumber: "264",
				name: "Apache License 1.1",
				licenseId: "Apache-1.1",
				seeAlso: [
					"http://apache.org/licenses/LICENSE-1.1",
					"https://opensource.org/licenses/Apache-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Apache-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Apache-2.0.json",
				referenceNumber: "355",
				name: "Apache License 2.0",
				licenseId: "Apache-2.0",
				seeAlso: [
					"http://www.apache.org/licenses/LICENSE-2.0",
					"https://opensource.org/licenses/Apache-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Artistic-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Artistic-1.0.json",
				referenceNumber: "263",
				name: "Artistic License 1.0",
				licenseId: "Artistic-1.0",
				seeAlso: ["https://opensource.org/licenses/Artistic-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Artistic-1.0-Perl.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Artistic-1.0-Perl.json",
				referenceNumber: "295",
				name: "Artistic License 1.0 (Perl)",
				licenseId: "Artistic-1.0-Perl",
				seeAlso: ["http://dev.perl.org/licenses/artistic.html"],
				isOsiApproved: true,
			},
			{
				reference: "./Artistic-1.0-cl8.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Artistic-1.0-cl8.json",
				referenceNumber: "221",
				name: "Artistic License 1.0 w/clause 8",
				licenseId: "Artistic-1.0-cl8",
				seeAlso: ["https://opensource.org/licenses/Artistic-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Artistic-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Artistic-2.0.json",
				referenceNumber: "75",
				name: "Artistic License 2.0",
				licenseId: "Artistic-2.0",
				seeAlso: [
					"http://www.perlfoundation.org/artistic_license_2_0",
					"https://opensource.org/licenses/artistic-license-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-1-Clause.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-1-Clause.json",
				referenceNumber: "377",
				name: "BSD 1-Clause License",
				licenseId: "BSD-1-Clause",
				seeAlso: [
					"https://svnweb.freebsd.org/base/head/include/ifaddrs.h?revision=326823",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-2-Clause.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-2-Clause.json",
				referenceNumber: "296",
				name: 'BSD 2-Clause "Simplified" License',
				licenseId: "BSD-2-Clause",
				seeAlso: ["https://opensource.org/licenses/BSD-2-Clause"],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-2-Clause-FreeBSD.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSD-2-Clause-FreeBSD.json",
				referenceNumber: "271",
				name: "BSD 2-Clause FreeBSD License",
				licenseId: "BSD-2-Clause-FreeBSD",
				seeAlso: ["http://www.freebsd.org/copyright/freebsd-license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-2-Clause-NetBSD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-2-Clause-NetBSD.json",
				referenceNumber: "179",
				name: "BSD 2-Clause NetBSD License",
				licenseId: "BSD-2-Clause-NetBSD",
				seeAlso: ["http://www.netbsd.org/about/redistribution.html#default"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-2-Clause-Patent.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-2-Clause-Patent.json",
				referenceNumber: "351",
				name: "BSD-2-Clause Plus Patent License",
				licenseId: "BSD-2-Clause-Patent",
				seeAlso: ["https://opensource.org/licenses/BSDplusPatent"],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-3-Clause.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause.json",
				referenceNumber: "195",
				name: 'BSD 3-Clause "New" or "Revised" License',
				licenseId: "BSD-3-Clause",
				seeAlso: ["https://opensource.org/licenses/BSD-3-Clause"],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-3-Clause-Attribution.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-Attribution.json",
				referenceNumber: "39",
				name: "BSD with attribution",
				licenseId: "BSD-3-Clause-Attribution",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/BSD_with_Attribution",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-Clear.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-Clear.json",
				referenceNumber: "84",
				name: "BSD 3-Clause Clear License",
				licenseId: "BSD-3-Clause-Clear",
				seeAlso: ["http://labs.metacarta.com/license-explanation.html#license"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-LBNL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-LBNL.json",
				referenceNumber: "142",
				name: "Lawrence Berkeley National Labs BSD variant license",
				licenseId: "BSD-3-Clause-LBNL",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/LBNLBSD"],
				isOsiApproved: true,
			},
			{
				reference: "./BSD-3-Clause-No-Nuclear-License.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License.json",
				referenceNumber: "59",
				name: "BSD 3-Clause No Nuclear License",
				licenseId: "BSD-3-Clause-No-Nuclear-License",
				seeAlso: [
					"http://download.oracle.com/otn-pub/java/licenses/bsd.txt?AuthParam=1467140197_43d516ce1776bd08a58235a7785be1cc",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-No-Nuclear-License-2014.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-License-2014.json",
				referenceNumber: "331",
				name: "BSD 3-Clause No Nuclear License 2014",
				licenseId: "BSD-3-Clause-No-Nuclear-License-2014",
				seeAlso: [
					"https://java.net/projects/javaeetutorial/pages/BerkeleyLicense",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-No-Nuclear-Warranty.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-No-Nuclear-Warranty.json",
				referenceNumber: "113",
				name: "BSD 3-Clause No Nuclear Warranty",
				licenseId: "BSD-3-Clause-No-Nuclear-Warranty",
				seeAlso: [
					"https://jogamp.org/git/?p=gluegen.git;a=blob_plain;f=LICENSE.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-3-Clause-Open-MPI.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-3-Clause-Open-MPI.json",
				referenceNumber: "207",
				name: "BSD 3-Clause Open MPI variant",
				licenseId: "BSD-3-Clause-Open-MPI",
				seeAlso: [
					"https://www.open-mpi.org/community/license.php",
					"http://www.netlib.org/lapack/LICENSE.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-4-Clause.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSD-4-Clause.json",
				referenceNumber: "66",
				name: 'BSD 4-Clause "Original" or "Old" License',
				licenseId: "BSD-4-Clause",
				seeAlso: ["http://directory.fsf.org/wiki/License:BSD_4Clause"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-4-Clause-UC.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-4-Clause-UC.json",
				referenceNumber: "361",
				name: "BSD-4-Clause (University of California-Specific)",
				licenseId: "BSD-4-Clause-UC",
				seeAlso: ["http://www.freebsd.org/copyright/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-Protection.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-Protection.json",
				referenceNumber: "388",
				name: "BSD Protection License",
				licenseId: "BSD-Protection",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/BSD_Protection_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSD-Source-Code.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BSD-Source-Code.json",
				referenceNumber: "163",
				name: "BSD Source Code Attribution",
				licenseId: "BSD-Source-Code",
				seeAlso: [
					"https://github.com/robbiehanson/CocoaHTTPServer/blob/master/LICENSE.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BSL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BSL-1.0.json",
				referenceNumber: "284",
				name: "Boost Software License 1.0",
				licenseId: "BSL-1.0",
				seeAlso: [
					"http://www.boost.org/LICENSE_1_0.txt",
					"https://opensource.org/licenses/BSL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Bahyph.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Bahyph.json",
				referenceNumber: "146",
				name: "Bahyph License",
				licenseId: "Bahyph",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Bahyph"],
				isOsiApproved: false,
			},
			{
				reference: "./Barr.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Barr.json",
				referenceNumber: "123",
				name: "Barr License",
				licenseId: "Barr",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Barr"],
				isOsiApproved: false,
			},
			{
				reference: "./Beerware.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Beerware.json",
				referenceNumber: "243",
				name: "Beerware License",
				licenseId: "Beerware",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Beerware",
					"https://people.freebsd.org/~phk/",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BitTorrent-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BitTorrent-1.0.json",
				referenceNumber: "200",
				name: "BitTorrent Open Source License v1.0",
				licenseId: "BitTorrent-1.0",
				seeAlso: [
					"http://sources.gentoo.org/cgi-bin/viewvc.cgi/gentoo-x86/licenses/BitTorrent?r1=1.1&r2=1.1.1.1&diff_format=s",
				],
				isOsiApproved: false,
			},
			{
				reference: "./BitTorrent-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/BitTorrent-1.1.json",
				referenceNumber: "181",
				name: "BitTorrent Open Source License v1.1",
				licenseId: "BitTorrent-1.1",
				seeAlso: ["http://directory.fsf.org/wiki/License:BitTorrentOSL1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./BlueOak-1.0.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/BlueOak-1.0.0.json",
				referenceNumber: "204",
				name: "Blue Oak Model License 1.0.0",
				licenseId: "BlueOak-1.0.0",
				seeAlso: ["https://blueoakcouncil.org/license/1.0.0"],
				isOsiApproved: false,
			},
			{
				reference: "./Borceux.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Borceux.json",
				referenceNumber: "294",
				name: "Borceux license",
				licenseId: "Borceux",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Borceux"],
				isOsiApproved: false,
			},
			{
				reference: "./CATOSL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CATOSL-1.1.json",
				referenceNumber: "226",
				name: "Computer Associates Trusted Open Source License 1.1",
				licenseId: "CATOSL-1.1",
				seeAlso: ["https://opensource.org/licenses/CATOSL-1.1"],
				isOsiApproved: true,
			},
			{
				reference: "./CC-BY-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-1.0.json",
				referenceNumber: "23",
				name: "Creative Commons Attribution 1.0 Generic",
				licenseId: "CC-BY-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-2.0.json",
				referenceNumber: "58",
				name: "Creative Commons Attribution 2.0 Generic",
				licenseId: "CC-BY-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-2.5.json",
				referenceNumber: "180",
				name: "Creative Commons Attribution 2.5 Generic",
				licenseId: "CC-BY-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-3.0.json",
				referenceNumber: "333",
				name: "Creative Commons Attribution 3.0 Unported",
				licenseId: "CC-BY-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-4.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CC-BY-4.0.json",
				referenceNumber: "211",
				name: "Creative Commons Attribution 4.0 International",
				licenseId: "CC-BY-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-1.0.json",
				referenceNumber: "223",
				name: "Creative Commons Attribution Non Commercial 1.0 Generic",
				licenseId: "CC-BY-NC-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-2.0.json",
				referenceNumber: "315",
				name: "Creative Commons Attribution Non Commercial 2.0 Generic",
				licenseId: "CC-BY-NC-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-2.5.json",
				referenceNumber: "386",
				name: "Creative Commons Attribution Non Commercial 2.5 Generic",
				licenseId: "CC-BY-NC-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-3.0.json",
				referenceNumber: "325",
				name: "Creative Commons Attribution Non Commercial 3.0 Unported",
				licenseId: "CC-BY-NC-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-4.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-4.0.json",
				referenceNumber: "262",
				name: "Creative Commons Attribution Non Commercial 4.0 International",
				licenseId: "CC-BY-NC-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-1.0.json",
				referenceNumber: "98",
				name: "Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic",
				licenseId: "CC-BY-NC-ND-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd-nc/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-2.0.json",
				referenceNumber: "133",
				name: "Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic",
				licenseId: "CC-BY-NC-ND-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-2.5.json",
				referenceNumber: "30",
				name: "Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic",
				licenseId: "CC-BY-NC-ND-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-nd/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-3.0.json",
				referenceNumber: "41",
				name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported",
				licenseId: "CC-BY-NC-ND-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-nd/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-ND-4.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-ND-4.0.json",
				referenceNumber: "166",
				name: "Creative Commons Attribution Non Commercial No Derivatives 4.0 International",
				licenseId: "CC-BY-NC-ND-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-1.0.json",
				referenceNumber: "116",
				name: "Creative Commons Attribution Non Commercial Share Alike 1.0 Generic",
				licenseId: "CC-BY-NC-SA-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-2.0.json",
				referenceNumber: "398",
				name: "Creative Commons Attribution Non Commercial Share Alike 2.0 Generic",
				licenseId: "CC-BY-NC-SA-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-2.5.json",
				referenceNumber: "208",
				name: "Creative Commons Attribution Non Commercial Share Alike 2.5 Generic",
				licenseId: "CC-BY-NC-SA-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-3.0.json",
				referenceNumber: "349",
				name: "Creative Commons Attribution Non Commercial Share Alike 3.0 Unported",
				licenseId: "CC-BY-NC-SA-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-NC-SA-4.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-NC-SA-4.0.json",
				referenceNumber: "320",
				name: "Creative Commons Attribution Non Commercial Share Alike 4.0 International",
				licenseId: "CC-BY-NC-SA-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-1.0.json",
				referenceNumber: "90",
				name: "Creative Commons Attribution No Derivatives 1.0 Generic",
				licenseId: "CC-BY-ND-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-2.0.json",
				referenceNumber: "46",
				name: "Creative Commons Attribution No Derivatives 2.0 Generic",
				licenseId: "CC-BY-ND-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-2.5.json",
				referenceNumber: "27",
				name: "Creative Commons Attribution No Derivatives 2.5 Generic",
				licenseId: "CC-BY-ND-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-3.0.json",
				referenceNumber: "274",
				name: "Creative Commons Attribution No Derivatives 3.0 Unported",
				licenseId: "CC-BY-ND-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-ND-4.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-ND-4.0.json",
				referenceNumber: "307",
				name: "Creative Commons Attribution No Derivatives 4.0 International",
				licenseId: "CC-BY-ND-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-nd/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-1.0.json",
				referenceNumber: "391",
				name: "Creative Commons Attribution Share Alike 1.0 Generic",
				licenseId: "CC-BY-SA-1.0",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-2.0.json",
				referenceNumber: "356",
				name: "Creative Commons Attribution Share Alike 2.0 Generic",
				licenseId: "CC-BY-SA-2.0",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/2.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-2.5.json",
				referenceNumber: "196",
				name: "Creative Commons Attribution Share Alike 2.5 Generic",
				licenseId: "CC-BY-SA-2.5",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/2.5/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-3.0.json",
				referenceNumber: "225",
				name: "Creative Commons Attribution Share Alike 3.0 Unported",
				licenseId: "CC-BY-SA-3.0",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/3.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-BY-SA-4.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CC-BY-SA-4.0.json",
				referenceNumber: "286",
				name: "Creative Commons Attribution Share Alike 4.0 International",
				licenseId: "CC-BY-SA-4.0",
				seeAlso: ["https://creativecommons.org/licenses/by-sa/4.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CC-PDDC.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CC-PDDC.json",
				referenceNumber: "88",
				name: "Creative Commons Public Domain Dedication and Certification",
				licenseId: "CC-PDDC",
				seeAlso: ["https://creativecommons.org/licenses/publicdomain/"],
				isOsiApproved: false,
			},
			{
				reference: "./CC0-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CC0-1.0.json",
				referenceNumber: "63",
				name: "Creative Commons Zero v1.0 Universal",
				licenseId: "CC0-1.0",
				seeAlso: ["https://creativecommons.org/publicdomain/zero/1.0/legalcode"],
				isOsiApproved: false,
			},
			{
				reference: "./CDDL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CDDL-1.0.json",
				referenceNumber: "324",
				name: "Common Development and Distribution License 1.0",
				licenseId: "CDDL-1.0",
				seeAlso: ["https://opensource.org/licenses/cddl1"],
				isOsiApproved: true,
			},
			{
				reference: "./CDDL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CDDL-1.1.json",
				referenceNumber: "273",
				name: "Common Development and Distribution License 1.1",
				licenseId: "CDDL-1.1",
				seeAlso: [
					"http://glassfish.java.net/public/CDDL+GPL_1_1.html",
					"https://javaee.github.io/glassfish/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./CDLA-Permissive-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CDLA-Permissive-1.0.json",
				referenceNumber: "104",
				name: "Community Data License Agreement Permissive 1.0",
				licenseId: "CDLA-Permissive-1.0",
				seeAlso: ["https://cdla.io/permissive-1-0"],
				isOsiApproved: false,
			},
			{
				reference: "./CDLA-Sharing-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CDLA-Sharing-1.0.json",
				referenceNumber: "172",
				name: "Community Data License Agreement Sharing 1.0",
				licenseId: "CDLA-Sharing-1.0",
				seeAlso: ["https://cdla.io/sharing-1-0"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CECILL-1.0.json",
				referenceNumber: "10",
				name: "CeCILL Free Software License Agreement v1.0",
				licenseId: "CECILL-1.0",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL_V1-fr.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CECILL-1.1.json",
				referenceNumber: "130",
				name: "CeCILL Free Software License Agreement v1.1",
				licenseId: "CECILL-1.1",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL_V1.1-US.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CECILL-2.0.json",
				referenceNumber: "5",
				name: "CeCILL Free Software License Agreement v2.0",
				licenseId: "CECILL-2.0",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL_V2-en.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-2.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CECILL-2.1.json",
				referenceNumber: "140",
				name: "CeCILL Free Software License Agreement v2.1",
				licenseId: "CECILL-2.1",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.html"],
				isOsiApproved: true,
			},
			{
				reference: "./CECILL-B.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CECILL-B.json",
				referenceNumber: "89",
				name: "CeCILL-B Free Software License Agreement",
				licenseId: "CECILL-B",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CECILL-C.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CECILL-C.json",
				referenceNumber: "232",
				name: "CeCILL-C Free Software License Agreement",
				licenseId: "CECILL-C",
				seeAlso: ["http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CERN-OHL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CERN-OHL-1.1.json",
				referenceNumber: "118",
				name: "CERN Open Hardware Licence v1.1",
				licenseId: "CERN-OHL-1.1",
				seeAlso: ["https://www.ohwr.org/project/licenses/wikis/cern-ohl-v1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./CERN-OHL-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CERN-OHL-1.2.json",
				referenceNumber: "161",
				name: "CERN Open Hardware Licence v1.2",
				licenseId: "CERN-OHL-1.2",
				seeAlso: ["https://www.ohwr.org/project/licenses/wikis/cern-ohl-v1.2"],
				isOsiApproved: false,
			},
			{
				reference: "./CNRI-Jython.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CNRI-Jython.json",
				referenceNumber: "74",
				name: "CNRI Jython License",
				licenseId: "CNRI-Jython",
				seeAlso: ["http://www.jython.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./CNRI-Python.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CNRI-Python.json",
				referenceNumber: "92",
				name: "CNRI Python License",
				licenseId: "CNRI-Python",
				seeAlso: ["https://opensource.org/licenses/CNRI-Python"],
				isOsiApproved: true,
			},
			{
				reference: "./CNRI-Python-GPL-Compatible.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CNRI-Python-GPL-Compatible.json",
				referenceNumber: "337",
				name: "CNRI Python Open Source GPL Compatible License Agreement",
				licenseId: "CNRI-Python-GPL-Compatible",
				seeAlso: ["http://www.python.org/download/releases/1.6.1/download_win/"],
				isOsiApproved: false,
			},
			{
				reference: "./CPAL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CPAL-1.0.json",
				referenceNumber: "275",
				name: "Common Public Attribution License 1.0",
				licenseId: "CPAL-1.0",
				seeAlso: ["https://opensource.org/licenses/CPAL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./CPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/CPL-1.0.json",
				referenceNumber: "228",
				name: "Common Public License 1.0",
				licenseId: "CPL-1.0",
				seeAlso: ["https://opensource.org/licenses/CPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./CPOL-1.02.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CPOL-1.02.json",
				referenceNumber: "222",
				name: "Code Project Open License 1.02",
				licenseId: "CPOL-1.02",
				seeAlso: ["http://www.codeproject.com/info/cpol10.aspx"],
				isOsiApproved: false,
			},
			{
				reference: "./CUA-OPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CUA-OPL-1.0.json",
				referenceNumber: "159",
				name: "CUA Office Public License v1.0",
				licenseId: "CUA-OPL-1.0",
				seeAlso: ["https://opensource.org/licenses/CUA-OPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Caldera.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Caldera.json",
				referenceNumber: "242",
				name: "Caldera License",
				licenseId: "Caldera",
				seeAlso: ["http://www.lemis.com/grog/UNIX/ancient-source-all.pdf"],
				isOsiApproved: false,
			},
			{
				reference: "./ClArtistic.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ClArtistic.json",
				referenceNumber: "237",
				name: "Clarified Artistic License",
				licenseId: "ClArtistic",
				seeAlso: [
					"http://gianluca.dellavedova.org/2011/01/03/clarified-artistic-license/",
					"http://www.ncftp.com/ncftp/doc/LICENSE.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Condor-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Condor-1.1.json",
				referenceNumber: "145",
				name: "Condor Public License v1.1",
				licenseId: "Condor-1.1",
				seeAlso: [
					"http://research.cs.wisc.edu/condor/license.html#condor",
					"http://web.archive.org/web/20111123062036/http://research.cs.wisc.edu/condor/license.html#condor",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Crossword.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Crossword.json",
				referenceNumber: "97",
				name: "Crossword License",
				licenseId: "Crossword",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Crossword"],
				isOsiApproved: false,
			},
			{
				reference: "./CrystalStacker.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/CrystalStacker.json",
				referenceNumber: "38",
				name: "CrystalStacker License",
				licenseId: "CrystalStacker",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing:CrystalStacker?rd=Licensing/CrystalStacker",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Cube.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Cube.json",
				referenceNumber: "379",
				name: "Cube License",
				licenseId: "Cube",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Cube"],
				isOsiApproved: false,
			},
			{
				reference: "./D-FSL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/D-FSL-1.0.json",
				referenceNumber: "347",
				name: "Deutsche Freie Software Lizenz",
				licenseId: "D-FSL-1.0",
				seeAlso: [
					"http://www.dipp.nrw.de/d-fsl/lizenzen/",
					"http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/de/D-FSL-1_0_de.txt",
					"http://www.dipp.nrw.de/d-fsl/index_html/lizenzen/en/D-FSL-1_0_en.txt",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/deutsche-freie-software-lizenz",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/german-free-software-license",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_de.txt/at_download/file",
					"https://www.hbz-nrw.de/produkte/open-access/lizenzen/dfsl/D-FSL-1_0_en.txt/at_download/file",
				],
				isOsiApproved: false,
			},
			{
				reference: "./DOC.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/DOC.json",
				referenceNumber: "265",
				name: "DOC License",
				licenseId: "DOC",
				seeAlso: ["http://www.cs.wustl.edu/~schmidt/ACE-copying.html"],
				isOsiApproved: false,
			},
			{
				reference: "./DSDP.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/DSDP.json",
				referenceNumber: "257",
				name: "DSDP License",
				licenseId: "DSDP",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/DSDP"],
				isOsiApproved: false,
			},
			{
				reference: "./Dotseqn.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Dotseqn.json",
				referenceNumber: "33",
				name: "Dotseqn License",
				licenseId: "Dotseqn",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Dotseqn"],
				isOsiApproved: false,
			},
			{
				reference: "./ECL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ECL-1.0.json",
				referenceNumber: "405",
				name: "Educational Community License v1.0",
				licenseId: "ECL-1.0",
				seeAlso: ["https://opensource.org/licenses/ECL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./ECL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ECL-2.0.json",
				referenceNumber: "1",
				name: "Educational Community License v2.0",
				licenseId: "ECL-2.0",
				seeAlso: ["https://opensource.org/licenses/ECL-2.0"],
				isOsiApproved: true,
			},
			{
				reference: "./EFL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/EFL-1.0.json",
				referenceNumber: "73",
				name: "Eiffel Forum License v1.0",
				licenseId: "EFL-1.0",
				seeAlso: [
					"http://www.eiffel-nice.org/license/forum.txt",
					"https://opensource.org/licenses/EFL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EFL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EFL-2.0.json",
				referenceNumber: "7",
				name: "Eiffel Forum License v2.0",
				licenseId: "EFL-2.0",
				seeAlso: [
					"http://www.eiffel-nice.org/license/eiffel-forum-license-2.html",
					"https://opensource.org/licenses/EFL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EPL-1.0.json",
				referenceNumber: "267",
				name: "Eclipse Public License 1.0",
				licenseId: "EPL-1.0",
				seeAlso: [
					"http://www.eclipse.org/legal/epl-v10.html",
					"https://opensource.org/licenses/EPL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EPL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EPL-2.0.json",
				referenceNumber: "403",
				name: "Eclipse Public License 2.0",
				licenseId: "EPL-2.0",
				seeAlso: [
					"https://www.eclipse.org/legal/epl-2.0",
					"https://www.opensource.org/licenses/EPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EUDatagrid.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EUDatagrid.json",
				referenceNumber: "254",
				name: "EU DataGrid Software License",
				licenseId: "EUDatagrid",
				seeAlso: [
					"http://eu-datagrid.web.cern.ch/eu-datagrid/license.html",
					"https://opensource.org/licenses/EUDatagrid",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EUPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/EUPL-1.0.json",
				referenceNumber: "94",
				name: "European Union Public License 1.0",
				licenseId: "EUPL-1.0",
				seeAlso: [
					"http://ec.europa.eu/idabc/en/document/7330.html",
					"http://ec.europa.eu/idabc/servlets/Doc027f.pdf?id=31096",
				],
				isOsiApproved: false,
			},
			{
				reference: "./EUPL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EUPL-1.1.json",
				referenceNumber: "396",
				name: "European Union Public License 1.1",
				licenseId: "EUPL-1.1",
				seeAlso: [
					"https://joinup.ec.europa.eu/software/page/eupl/licence-eupl",
					"https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl1.1.-licence-en_0.pdf",
					"https://opensource.org/licenses/EUPL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./EUPL-1.2.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/EUPL-1.2.json",
				referenceNumber: "261",
				name: "European Union Public License 1.2",
				licenseId: "EUPL-1.2",
				seeAlso: [
					"https://joinup.ec.europa.eu/page/eupl-text-11-12",
					"https://joinup.ec.europa.eu/sites/default/files/custom-page/attachment/eupl_v1.2_en.pdf",
					"https://joinup.ec.europa.eu/sites/default/files/inline-files/EUPL%20v1_2%20EN(1).txt",
					"http://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32017D0863",
					"https://opensource.org/licenses/EUPL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Entessa.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Entessa.json",
				referenceNumber: "374",
				name: "Entessa Public License v1.0",
				licenseId: "Entessa",
				seeAlso: ["https://opensource.org/licenses/Entessa"],
				isOsiApproved: true,
			},
			{
				reference: "./ErlPL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ErlPL-1.1.json",
				referenceNumber: "395",
				name: "Erlang Public License v1.1",
				licenseId: "ErlPL-1.1",
				seeAlso: ["http://www.erlang.org/EPLICENSE"],
				isOsiApproved: false,
			},
			{
				reference: "./Eurosym.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Eurosym.json",
				referenceNumber: "165",
				name: "Eurosym License",
				licenseId: "Eurosym",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Eurosym"],
				isOsiApproved: false,
			},
			{
				reference: "./FSFAP.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/FSFAP.json",
				referenceNumber: "382",
				name: "FSF All Permissive License",
				licenseId: "FSFAP",
				seeAlso: [
					"https://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./FSFUL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/FSFUL.json",
				referenceNumber: "2",
				name: "FSF Unlimited License",
				licenseId: "FSFUL",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./FSFULLR.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/FSFULLR.json",
				referenceNumber: "297",
				name: "FSF Unlimited License (with License Retention)",
				licenseId: "FSFULLR",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/FSF_Unlimited_License#License_Retention_Variant",
				],
				isOsiApproved: false,
			},
			{
				reference: "./FTL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/FTL.json",
				referenceNumber: "363",
				name: "Freetype Project License",
				licenseId: "FTL",
				seeAlso: [
					"http://freetype.fis.uniroma2.it/FTL.TXT",
					"http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/docs/FTL.TXT",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Fair.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Fair.json",
				referenceNumber: "253",
				name: "Fair License",
				licenseId: "Fair",
				seeAlso: [
					"http://fairlicense.org/",
					"https://opensource.org/licenses/Fair",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Frameworx-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Frameworx-1.0.json",
				referenceNumber: "362",
				name: "Frameworx Open License 1.0",
				licenseId: "Frameworx-1.0",
				seeAlso: ["https://opensource.org/licenses/Frameworx-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./FreeImage.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/FreeImage.json",
				referenceNumber: "359",
				name: "FreeImage Public License v1.0",
				licenseId: "FreeImage",
				seeAlso: ["http://freeimage.sourceforge.net/freeimage-license.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.1.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.1.json",
				referenceNumber: "248",
				name: "GNU Free Documentation License v1.1",
				licenseId: "GFDL-1.1",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.1-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.1-only.json",
				referenceNumber: "100",
				name: "GNU Free Documentation License v1.1 only",
				licenseId: "GFDL-1.1-only",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.1-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.1-or-later.json",
				referenceNumber: "119",
				name: "GNU Free Documentation License v1.1 or later",
				licenseId: "GFDL-1.1-or-later",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.1.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.2.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.2.json",
				referenceNumber: "190",
				name: "GNU Free Documentation License v1.2",
				licenseId: "GFDL-1.2",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.2-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.2-only.json",
				referenceNumber: "86",
				name: "GNU Free Documentation License v1.2 only",
				licenseId: "GFDL-1.2-only",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.2-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.2-or-later.json",
				referenceNumber: "127",
				name: "GNU Free Documentation License v1.2 or later",
				licenseId: "GFDL-1.2-or-later",
				seeAlso: ["https://www.gnu.org/licenses/old-licenses/fdl-1.2.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.3.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.3.json",
				referenceNumber: "354",
				name: "GNU Free Documentation License v1.3",
				licenseId: "GFDL-1.3",
				seeAlso: ["https://www.gnu.org/licenses/fdl-1.3.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.3-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.3-only.json",
				referenceNumber: "193",
				name: "GNU Free Documentation License v1.3 only",
				licenseId: "GFDL-1.3-only",
				seeAlso: ["https://www.gnu.org/licenses/fdl-1.3.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GFDL-1.3-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GFDL-1.3-or-later.json",
				referenceNumber: "51",
				name: "GNU Free Documentation License v1.3 or later",
				licenseId: "GFDL-1.3-or-later",
				seeAlso: ["https://www.gnu.org/licenses/fdl-1.3.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./GL2PS.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/GL2PS.json",
				referenceNumber: "303",
				name: "GL2PS License",
				licenseId: "GL2PS",
				seeAlso: ["http://www.geuz.org/gl2ps/COPYING.GL2PS"],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-1.0.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-1.0.json",
				referenceNumber: "319",
				name: "GNU General Public License v1.0 only",
				licenseId: "GPL-1.0",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-1.0+.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-1.0+.json",
				referenceNumber: "198",
				name: "GNU General Public License v1.0 or later",
				licenseId: "GPL-1.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-1.0-only.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/GPL-1.0-only.json",
				referenceNumber: "15",
				name: "GNU General Public License v1.0 only",
				licenseId: "GPL-1.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-1.0-or-later.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/GPL-1.0-or-later.json",
				referenceNumber: "129",
				name: "GNU General Public License v1.0 or later",
				licenseId: "GPL-1.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-1.0-standalone.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0.json",
				referenceNumber: "345",
				name: "GNU General Public License v2.0 only",
				licenseId: "GPL-2.0",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html",
					"https://opensource.org/licenses/GPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-2.0+.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0+.json",
				referenceNumber: "389",
				name: "GNU General Public License v2.0 or later",
				licenseId: "GPL-2.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html",
					"https://opensource.org/licenses/GPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-2.0-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-only.json",
				referenceNumber: "227",
				name: "GNU General Public License v2.0 only",
				licenseId: "GPL-2.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html",
					"https://opensource.org/licenses/GPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-2.0-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-or-later.json",
				referenceNumber: "249",
				name: "GNU General Public License v2.0 or later",
				licenseId: "GPL-2.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/gpl-2.0-standalone.html",
					"https://opensource.org/licenses/GPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-2.0-with-GCC-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-GCC-exception.json",
				referenceNumber: "329",
				name: "GNU General Public License v2.0 w/GCC Runtime Library exception",
				licenseId: "GPL-2.0-with-GCC-exception",
				seeAlso: [
					"https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/libgcc1.c;h=762f5143fc6eed57b6797c82710f3538aa52b40b;hb=cb143a3ce4fb417c68f5fa2691a1b1b1053dfba9#l10",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0-with-autoconf-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-autoconf-exception.json",
				referenceNumber: "36",
				name: "GNU General Public License v2.0 w/Autoconf exception",
				licenseId: "GPL-2.0-with-autoconf-exception",
				seeAlso: ["http://ac-archive.sourceforge.net/doc/copyright.html"],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0-with-bison-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-bison-exception.json",
				referenceNumber: "360",
				name: "GNU General Public License v2.0 w/Bison exception",
				licenseId: "GPL-2.0-with-bison-exception",
				seeAlso: [
					"http://git.savannah.gnu.org/cgit/bison.git/tree/data/yacc.c?id=193d7c7054ba7197b0789e14965b739162319b5e#n141",
				],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0-with-classpath-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-classpath-exception.json",
				referenceNumber: "219",
				name: "GNU General Public License v2.0 w/Classpath exception",
				licenseId: "GPL-2.0-with-classpath-exception",
				seeAlso: ["https://www.gnu.org/software/classpath/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-2.0-with-font-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-2.0-with-font-exception.json",
				referenceNumber: "24",
				name: "GNU General Public License v2.0 w/Font exception",
				licenseId: "GPL-2.0-with-font-exception",
				seeAlso: ["https://www.gnu.org/licenses/gpl-faq.html#FontException"],
				isOsiApproved: false,
			},
			{
				reference: "./GPL-3.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0.json",
				referenceNumber: "401",
				name: "GNU General Public License v3.0 only",
				licenseId: "GPL-3.0",
				seeAlso: [
					"https://www.gnu.org/licenses/gpl-3.0-standalone.html",
					"https://opensource.org/licenses/GPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0+.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0+.json",
				referenceNumber: "147",
				name: "GNU General Public License v3.0 or later",
				licenseId: "GPL-3.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/gpl-3.0-standalone.html",
					"https://opensource.org/licenses/GPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0-only.json",
				referenceNumber: "122",
				name: "GNU General Public License v3.0 only",
				licenseId: "GPL-3.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/gpl-3.0-standalone.html",
					"https://opensource.org/licenses/GPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0-or-later.json",
				referenceNumber: "387",
				name: "GNU General Public License v3.0 or later",
				licenseId: "GPL-3.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/gpl-3.0-standalone.html",
					"https://opensource.org/licenses/GPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0-with-GCC-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0-with-GCC-exception.json",
				referenceNumber: "6",
				name: "GNU General Public License v3.0 w/GCC Runtime Library exception",
				licenseId: "GPL-3.0-with-GCC-exception",
				seeAlso: ["https://www.gnu.org/licenses/gcc-exception-3.1.html"],
				isOsiApproved: true,
			},
			{
				reference: "./GPL-3.0-with-autoconf-exception.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/GPL-3.0-with-autoconf-exception.json",
				referenceNumber: "8",
				name: "GNU General Public License v3.0 w/Autoconf exception",
				licenseId: "GPL-3.0-with-autoconf-exception",
				seeAlso: ["https://www.gnu.org/licenses/autoconf-exception-3.0.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Giftware.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Giftware.json",
				referenceNumber: "367",
				name: "Giftware License",
				licenseId: "Giftware",
				seeAlso: [
					"http://liballeg.org/license.html#allegro-4-the-giftware-license",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Glide.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Glide.json",
				referenceNumber: "117",
				name: "3dfx Glide License",
				licenseId: "Glide",
				seeAlso: ["http://www.users.on.net/~triforce/glidexp/COPYING.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./Glulxe.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Glulxe.json",
				referenceNumber: "199",
				name: "Glulxe License",
				licenseId: "Glulxe",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Glulxe"],
				isOsiApproved: false,
			},
			{
				reference: "./HPND.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/HPND.json",
				referenceNumber: "148",
				name: "Historical Permission Notice and Disclaimer",
				licenseId: "HPND",
				seeAlso: ["https://opensource.org/licenses/HPND"],
				isOsiApproved: true,
			},
			{
				reference: "./HPND-sell-variant.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/HPND-sell-variant.json",
				referenceNumber: "158",
				name: "Historical Permission Notice and Disclaimer - sell variant",
				licenseId: "HPND-sell-variant",
				seeAlso: [
					"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/auth_gss/gss_generic_token.c?h=v4.19",
				],
				isOsiApproved: false,
			},
			{
				reference: "./HaskellReport.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/HaskellReport.json",
				referenceNumber: "205",
				name: "Haskell Language Report License",
				licenseId: "HaskellReport",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Haskell_Language_Report_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./IBM-pibs.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/IBM-pibs.json",
				referenceNumber: "233",
				name: "IBM PowerPC Initialization and Boot Software",
				licenseId: "IBM-pibs",
				seeAlso: [
					"http://git.denx.de/?p=u-boot.git;a=blob;f=arch/powerpc/cpu/ppc4xx/miiphy.c;h=297155fdafa064b955e53e9832de93bfb0cfb85b;hb=9fab4bf4cc077c21e43941866f3f2c196f28670d",
				],
				isOsiApproved: false,
			},
			{
				reference: "./ICU.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ICU.json",
				referenceNumber: "174",
				name: "ICU License",
				licenseId: "ICU",
				seeAlso: [
					"http://source.icu-project.org/repos/icu/icu/trunk/license.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./IJG.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/IJG.json",
				referenceNumber: "236",
				name: "Independent JPEG Group License",
				licenseId: "IJG",
				seeAlso: ["http://dev.w3.org/cvsweb/Amaya/libjpeg/Attic/README?rev=1.2"],
				isOsiApproved: false,
			},
			{
				reference: "./IPA.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/IPA.json",
				referenceNumber: "310",
				name: "IPA Font License",
				licenseId: "IPA",
				seeAlso: ["https://opensource.org/licenses/IPA"],
				isOsiApproved: true,
			},
			{
				reference: "./IPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/IPL-1.0.json",
				referenceNumber: "309",
				name: "IBM Public License v1.0",
				licenseId: "IPL-1.0",
				seeAlso: ["https://opensource.org/licenses/IPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./ISC.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ISC.json",
				referenceNumber: "353",
				name: "ISC License",
				licenseId: "ISC",
				seeAlso: [
					"https://www.isc.org/downloads/software-support-policy/isc-license/",
					"https://opensource.org/licenses/ISC",
				],
				isOsiApproved: true,
			},
			{
				reference: "./ImageMagick.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ImageMagick.json",
				referenceNumber: "326",
				name: "ImageMagick License",
				licenseId: "ImageMagick",
				seeAlso: ["http://www.imagemagick.org/script/license.php"],
				isOsiApproved: false,
			},
			{
				reference: "./Imlib2.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Imlib2.json",
				referenceNumber: "135",
				name: "Imlib2 License",
				licenseId: "Imlib2",
				seeAlso: [
					"http://trac.enlightenment.org/e/browser/trunk/imlib2/COPYING",
					"https://git.enlightenment.org/legacy/imlib2.git/tree/COPYING",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Info-ZIP.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Info-ZIP.json",
				referenceNumber: "283",
				name: "Info-ZIP License",
				licenseId: "Info-ZIP",
				seeAlso: ["http://www.info-zip.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Intel.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Intel.json",
				referenceNumber: "29",
				name: "Intel Open Source License",
				licenseId: "Intel",
				seeAlso: ["https://opensource.org/licenses/Intel"],
				isOsiApproved: true,
			},
			{
				reference: "./Intel-ACPI.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Intel-ACPI.json",
				referenceNumber: "235",
				name: "Intel ACPI Software License Agreement",
				licenseId: "Intel-ACPI",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Intel_ACPI_Software_License_Agreement",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Interbase-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Interbase-1.0.json",
				referenceNumber: "323",
				name: "Interbase Public License v1.0",
				licenseId: "Interbase-1.0",
				seeAlso: [
					"https://web.archive.org/web/20060319014854/http://info.borland.com/devsupport/interbase/opensource/IPL.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./JPNIC.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/JPNIC.json",
				referenceNumber: "316",
				name: "Japan Network Information Center License",
				licenseId: "JPNIC",
				seeAlso: [
					"https://gitlab.isc.org/isc-projects/bind9/blob/master/COPYRIGHT#L366",
				],
				isOsiApproved: false,
			},
			{
				reference: "./JSON.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/JSON.json",
				referenceNumber: "197",
				name: "JSON License",
				licenseId: "JSON",
				seeAlso: ["http://www.json.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./JasPer-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/JasPer-2.0.json",
				referenceNumber: "77",
				name: "JasPer License",
				licenseId: "JasPer-2.0",
				seeAlso: ["http://www.ece.uvic.ca/~mdadams/jasper/LICENSE"],
				isOsiApproved: false,
			},
			{
				reference: "./LAL-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LAL-1.2.json",
				referenceNumber: "153",
				name: "Licence Art Libre 1.2",
				licenseId: "LAL-1.2",
				seeAlso: ["http://artlibre.org/licence/lal/licence-art-libre-12/"],
				isOsiApproved: false,
			},
			{
				reference: "./LAL-1.3.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LAL-1.3.json",
				referenceNumber: "357",
				name: "Licence Art Libre 1.3",
				licenseId: "LAL-1.3",
				seeAlso: ["https://artlibre.org/"],
				isOsiApproved: false,
			},
			{
				reference: "./LGPL-2.0.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.0.json",
				referenceNumber: "276",
				name: "GNU Library General Public License v2 only",
				licenseId: "LGPL-2.0",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.0+.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.0+.json",
				referenceNumber: "139",
				name: "GNU Library General Public License v2 or later",
				licenseId: "LGPL-2.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.0-only.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.0-only.json",
				referenceNumber: "328",
				name: "GNU Library General Public License v2 only",
				licenseId: "LGPL-2.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.0-or-later.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.0-or-later.json",
				referenceNumber: "35",
				name: "GNU Library General Public License v2 or later",
				licenseId: "LGPL-2.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.0-standalone.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.1.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.1.json",
				referenceNumber: "182",
				name: "GNU Lesser General Public License v2.1 only",
				licenseId: "LGPL-2.1",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html",
					"https://opensource.org/licenses/LGPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.1+.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.1+.json",
				referenceNumber: "202",
				name: "GNU Library General Public License v2.1 or later",
				licenseId: "LGPL-2.1+",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html",
					"https://opensource.org/licenses/LGPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.1-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.1-only.json",
				referenceNumber: "138",
				name: "GNU Lesser General Public License v2.1 only",
				licenseId: "LGPL-2.1-only",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html",
					"https://opensource.org/licenses/LGPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-2.1-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-2.1-or-later.json",
				referenceNumber: "269",
				name: "GNU Lesser General Public License v2.1 or later",
				licenseId: "LGPL-2.1-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html",
					"https://opensource.org/licenses/LGPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-3.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-3.0.json",
				referenceNumber: "209",
				name: "GNU Lesser General Public License v3.0 only",
				licenseId: "LGPL-3.0",
				seeAlso: [
					"https://www.gnu.org/licenses/lgpl-3.0-standalone.html",
					"https://opensource.org/licenses/LGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-3.0+.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-3.0+.json",
				referenceNumber: "220",
				name: "GNU Lesser General Public License v3.0 or later",
				licenseId: "LGPL-3.0+",
				seeAlso: [
					"https://www.gnu.org/licenses/lgpl-3.0-standalone.html",
					"https://opensource.org/licenses/LGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-3.0-only.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-3.0-only.json",
				referenceNumber: "47",
				name: "GNU Lesser General Public License v3.0 only",
				licenseId: "LGPL-3.0-only",
				seeAlso: [
					"https://www.gnu.org/licenses/lgpl-3.0-standalone.html",
					"https://opensource.org/licenses/LGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPL-3.0-or-later.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LGPL-3.0-or-later.json",
				referenceNumber: "317",
				name: "GNU Lesser General Public License v3.0 or later",
				licenseId: "LGPL-3.0-or-later",
				seeAlso: [
					"https://www.gnu.org/licenses/lgpl-3.0-standalone.html",
					"https://opensource.org/licenses/LGPL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LGPLLR.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LGPLLR.json",
				referenceNumber: "404",
				name: "Lesser General Public License For Linguistic Resources",
				licenseId: "LGPLLR",
				seeAlso: ["http://www-igm.univ-mlv.fr/~unitex/lgpllr.html"],
				isOsiApproved: false,
			},
			{
				reference: "./LPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LPL-1.0.json",
				referenceNumber: "371",
				name: "Lucent Public License Version 1.0",
				licenseId: "LPL-1.0",
				seeAlso: ["https://opensource.org/licenses/LPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./LPL-1.02.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LPL-1.02.json",
				referenceNumber: "120",
				name: "Lucent Public License v1.02",
				licenseId: "LPL-1.02",
				seeAlso: [
					"http://plan9.bell-labs.com/plan9/license.html",
					"https://opensource.org/licenses/LPL-1.02",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LPPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.0.json",
				referenceNumber: "82",
				name: "LaTeX Project Public License v1.0",
				licenseId: "LPPL-1.0",
				seeAlso: ["http://www.latex-project.org/lppl/lppl-1-0.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./LPPL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.1.json",
				referenceNumber: "168",
				name: "LaTeX Project Public License v1.1",
				licenseId: "LPPL-1.1",
				seeAlso: ["http://www.latex-project.org/lppl/lppl-1-1.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./LPPL-1.2.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.2.json",
				referenceNumber: "160",
				name: "LaTeX Project Public License v1.2",
				licenseId: "LPPL-1.2",
				seeAlso: ["http://www.latex-project.org/lppl/lppl-1-2.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./LPPL-1.3a.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.3a.json",
				referenceNumber: "270",
				name: "LaTeX Project Public License v1.3a",
				licenseId: "LPPL-1.3a",
				seeAlso: ["http://www.latex-project.org/lppl/lppl-1-3a.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./LPPL-1.3c.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LPPL-1.3c.json",
				referenceNumber: "126",
				name: "LaTeX Project Public License v1.3c",
				licenseId: "LPPL-1.3c",
				seeAlso: [
					"http://www.latex-project.org/lppl/lppl-1-3c.txt",
					"https://opensource.org/licenses/LPPL-1.3c",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Latex2e.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Latex2e.json",
				referenceNumber: "37",
				name: "Latex2e License",
				licenseId: "Latex2e",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Latex2e"],
				isOsiApproved: false,
			},
			{
				reference: "./Leptonica.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Leptonica.json",
				referenceNumber: "300",
				name: "Leptonica License",
				licenseId: "Leptonica",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Leptonica"],
				isOsiApproved: false,
			},
			{
				reference: "./LiLiQ-P-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LiLiQ-P-1.1.json",
				referenceNumber: "79",
				name: "Licence Libre du Qu\xe9bec \u2013 Permissive version 1.1",
				licenseId: "LiLiQ-P-1.1",
				seeAlso: [
					"https://forge.gouv.qc.ca/licence/fr/liliq-v1-1/",
					"http://opensource.org/licenses/LiLiQ-P-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LiLiQ-R-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LiLiQ-R-1.1.json",
				referenceNumber: "290",
				name: "Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 version 1.1",
				licenseId: "LiLiQ-R-1.1",
				seeAlso: [
					"https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-liliq-r-v1-1/",
					"http://opensource.org/licenses/LiLiQ-R-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./LiLiQ-Rplus-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/LiLiQ-Rplus-1.1.json",
				referenceNumber: "335",
				name: "Licence Libre du Qu\xe9bec \u2013 R\xe9ciprocit\xe9 forte version 1.1",
				licenseId: "LiLiQ-Rplus-1.1",
				seeAlso: [
					"https://www.forge.gouv.qc.ca/participez/licence-logicielle/licence-libre-du-quebec-liliq-en-francais/licence-libre-du-quebec-reciprocite-forte-liliq-r-v1-1/",
					"http://opensource.org/licenses/LiLiQ-Rplus-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Libpng.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Libpng.json",
				referenceNumber: "376",
				name: "libpng License",
				licenseId: "Libpng",
				seeAlso: ["http://www.libpng.org/pub/png/src/libpng-LICENSE.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./Linux-OpenIB.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Linux-OpenIB.json",
				referenceNumber: "217",
				name: "Linux Kernel Variant of OpenIB.org license",
				licenseId: "Linux-OpenIB",
				seeAlso: [
					"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/infiniband/core/sa.h",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MIT.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MIT.json",
				referenceNumber: "256",
				name: "MIT License",
				licenseId: "MIT",
				seeAlso: ["https://opensource.org/licenses/MIT"],
				isOsiApproved: true,
			},
			{
				reference: "./MIT-0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-0.json",
				referenceNumber: "76",
				name: "MIT No Attribution",
				licenseId: "MIT-0",
				seeAlso: [
					"https://github.com/aws/mit-0",
					"https://romanrm.net/mit-zero",
					"https://github.com/awsdocs/aws-cloud9-user-guide/blob/master/LICENSE-SAMPLECODE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MIT-CMU.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-CMU.json",
				referenceNumber: "344",
				name: "CMU License",
				licenseId: "MIT-CMU",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing:MIT?rd=Licensing/MIT#CMU_Style",
					"https://github.com/python-pillow/Pillow/blob/fffb426092c8db24a5f4b6df243a8a3c01fb63cd/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MIT-advertising.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-advertising.json",
				referenceNumber: "192",
				name: "Enlightenment License (e16)",
				licenseId: "MIT-advertising",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/MIT_With_Advertising",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MIT-enna.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-enna.json",
				referenceNumber: "52",
				name: "enna License",
				licenseId: "MIT-enna",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MIT#enna"],
				isOsiApproved: false,
			},
			{
				reference: "./MIT-feh.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MIT-feh.json",
				referenceNumber: "365",
				name: "feh License",
				licenseId: "MIT-feh",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MIT#feh"],
				isOsiApproved: false,
			},
			{
				reference: "./MITNFA.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MITNFA.json",
				referenceNumber: "336",
				name: "MIT +no-false-attribs license",
				licenseId: "MITNFA",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MITNFA"],
				isOsiApproved: false,
			},
			{
				reference: "./MPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MPL-1.0.json",
				referenceNumber: "239",
				name: "Mozilla Public License 1.0",
				licenseId: "MPL-1.0",
				seeAlso: [
					"http://www.mozilla.org/MPL/MPL-1.0.html",
					"https://opensource.org/licenses/MPL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MPL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MPL-1.1.json",
				referenceNumber: "394",
				name: "Mozilla Public License 1.1",
				licenseId: "MPL-1.1",
				seeAlso: [
					"http://www.mozilla.org/MPL/MPL-1.1.html",
					"https://opensource.org/licenses/MPL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MPL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MPL-2.0.json",
				referenceNumber: "121",
				name: "Mozilla Public License 2.0",
				licenseId: "MPL-2.0",
				seeAlso: [
					"http://www.mozilla.org/MPL/2.0/",
					"https://opensource.org/licenses/MPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MPL-2.0-no-copyleft-exception.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MPL-2.0-no-copyleft-exception.json",
				referenceNumber: "183",
				name: "Mozilla Public License 2.0 (no copyleft exception)",
				licenseId: "MPL-2.0-no-copyleft-exception",
				seeAlso: [
					"http://www.mozilla.org/MPL/2.0/",
					"https://opensource.org/licenses/MPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MS-PL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MS-PL.json",
				referenceNumber: "366",
				name: "Microsoft Public License",
				licenseId: "MS-PL",
				seeAlso: [
					"http://www.microsoft.com/opensource/licenses.mspx",
					"https://opensource.org/licenses/MS-PL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MS-RL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/MS-RL.json",
				referenceNumber: "4",
				name: "Microsoft Reciprocal License",
				licenseId: "MS-RL",
				seeAlso: [
					"http://www.microsoft.com/opensource/licenses.mspx",
					"https://opensource.org/licenses/MS-RL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./MTLL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MTLL.json",
				referenceNumber: "102",
				name: "Matrix Template Library License",
				licenseId: "MTLL",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Matrix_Template_Library_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./MakeIndex.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MakeIndex.json",
				referenceNumber: "343",
				name: "MakeIndex License",
				licenseId: "MakeIndex",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MakeIndex"],
				isOsiApproved: false,
			},
			{
				reference: "./MirOS.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MirOS.json",
				referenceNumber: "369",
				name: "The MirOS Licence",
				licenseId: "MirOS",
				seeAlso: ["https://opensource.org/licenses/MirOS"],
				isOsiApproved: true,
			},
			{
				reference: "./Motosoto.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Motosoto.json",
				referenceNumber: "12",
				name: "Motosoto License",
				licenseId: "Motosoto",
				seeAlso: ["https://opensource.org/licenses/Motosoto"],
				isOsiApproved: true,
			},
			{
				reference: "./MulanPSL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/MulanPSL-1.0.json",
				referenceNumber: "201",
				name: "Mulan Permissive Software License, Version 1",
				licenseId: "MulanPSL-1.0",
				seeAlso: [
					"https://license.coscl.org.cn/MulanPSL/",
					"https://github.com/yuwenlong/longphp/blob/25dfb70cc2a466dc4bb55ba30901cbce08d164b5/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Multics.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Multics.json",
				referenceNumber: "164",
				name: "Multics License",
				licenseId: "Multics",
				seeAlso: ["https://opensource.org/licenses/Multics"],
				isOsiApproved: true,
			},
			{
				reference: "./Mup.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Mup.json",
				referenceNumber: "305",
				name: "Mup License",
				licenseId: "Mup",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Mup"],
				isOsiApproved: false,
			},
			{
				reference: "./NASA-1.3.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NASA-1.3.json",
				referenceNumber: "110",
				name: "NASA Open Source Agreement 1.3",
				licenseId: "NASA-1.3",
				seeAlso: [
					"http://ti.arc.nasa.gov/opensource/nosa/",
					"https://opensource.org/licenses/NASA-1.3",
				],
				isOsiApproved: true,
			},
			{
				reference: "./NBPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NBPL-1.0.json",
				referenceNumber: "17",
				name: "Net Boolean Public License v1",
				licenseId: "NBPL-1.0",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=37b4b3f6cc4bf34e1d3dec61e69914b9819d8894",
				],
				isOsiApproved: false,
			},
			{
				reference: "./NCSA.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/NCSA.json",
				referenceNumber: "187",
				name: "University of Illinois/NCSA Open Source License",
				licenseId: "NCSA",
				seeAlso: [
					"http://otm.illinois.edu/uiuc_openSource",
					"https://opensource.org/licenses/NCSA",
				],
				isOsiApproved: true,
			},
			{
				reference: "./NGPL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NGPL.json",
				referenceNumber: "308",
				name: "Nethack General Public License",
				licenseId: "NGPL",
				seeAlso: ["https://opensource.org/licenses/NGPL"],
				isOsiApproved: true,
			},
			{
				reference: "./NLOD-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NLOD-1.0.json",
				referenceNumber: "134",
				name: "Norwegian Licence for Open Government Data",
				licenseId: "NLOD-1.0",
				seeAlso: ["http://data.norge.no/nlod/en/1.0"],
				isOsiApproved: false,
			},
			{
				reference: "./NLPL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NLPL.json",
				referenceNumber: "306",
				name: "No Limit Public License",
				licenseId: "NLPL",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/NLPL"],
				isOsiApproved: false,
			},
			{
				reference: "./NOSL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/NOSL.json",
				referenceNumber: "380",
				name: "Netizen Open Source License",
				licenseId: "NOSL",
				seeAlso: ["http://bits.netizen.com.au/licenses/NOSL/nosl.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./NPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/NPL-1.0.json",
				referenceNumber: "245",
				name: "Netscape Public License v1.0",
				licenseId: "NPL-1.0",
				seeAlso: ["http://www.mozilla.org/MPL/NPL/1.0/"],
				isOsiApproved: false,
			},
			{
				reference: "./NPL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/NPL-1.1.json",
				referenceNumber: "409",
				name: "Netscape Public License v1.1",
				licenseId: "NPL-1.1",
				seeAlso: ["http://www.mozilla.org/MPL/NPL/1.1/"],
				isOsiApproved: false,
			},
			{
				reference: "./NPOSL-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NPOSL-3.0.json",
				referenceNumber: "150",
				name: "Non-Profit Open Software License 3.0",
				licenseId: "NPOSL-3.0",
				seeAlso: ["https://opensource.org/licenses/NOSL3.0"],
				isOsiApproved: true,
			},
			{
				reference: "./NRL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NRL.json",
				referenceNumber: "101",
				name: "NRL License",
				licenseId: "NRL",
				seeAlso: ["http://web.mit.edu/network/isakmp/nrllicense.html"],
				isOsiApproved: false,
			},
			{
				reference: "./NTP.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NTP.json",
				referenceNumber: "258",
				name: "NTP License",
				licenseId: "NTP",
				seeAlso: ["https://opensource.org/licenses/NTP"],
				isOsiApproved: true,
			},
			{
				reference: "./NTP-0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NTP-0.json",
				referenceNumber: "185",
				name: "NTP No Attribution",
				licenseId: "NTP-0",
				seeAlso: [
					"https://github.com/tytso/e2fsprogs/blob/master/lib/et/et_name.c",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Naumen.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Naumen.json",
				referenceNumber: "282",
				name: "Naumen Public License",
				licenseId: "Naumen",
				seeAlso: ["https://opensource.org/licenses/Naumen"],
				isOsiApproved: true,
			},
			{
				reference: "./Net-SNMP.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Net-SNMP.json",
				referenceNumber: "278",
				name: "Net-SNMP License",
				licenseId: "Net-SNMP",
				seeAlso: ["http://net-snmp.sourceforge.net/about/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./NetCDF.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/NetCDF.json",
				referenceNumber: "212",
				name: "NetCDF license",
				licenseId: "NetCDF",
				seeAlso: ["http://www.unidata.ucar.edu/software/netcdf/copyright.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Newsletr.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Newsletr.json",
				referenceNumber: "358",
				name: "Newsletr License",
				licenseId: "Newsletr",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Newsletr"],
				isOsiApproved: false,
			},
			{
				reference: "./Nokia.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Nokia.json",
				referenceNumber: "125",
				name: "Nokia Open Source License",
				licenseId: "Nokia",
				seeAlso: ["https://opensource.org/licenses/nokia"],
				isOsiApproved: true,
			},
			{
				reference: "./Noweb.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Noweb.json",
				referenceNumber: "70",
				name: "Noweb License",
				licenseId: "Noweb",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Noweb"],
				isOsiApproved: false,
			},
			{
				reference: "./Nunit.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Nunit.json",
				referenceNumber: "87",
				name: "Nunit License",
				licenseId: "Nunit",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Nunit"],
				isOsiApproved: false,
			},
			{
				reference: "./OCCT-PL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OCCT-PL.json",
				referenceNumber: "65",
				name: "Open CASCADE Technology Public License",
				licenseId: "OCCT-PL",
				seeAlso: ["http://www.opencascade.com/content/occt-public-license"],
				isOsiApproved: false,
			},
			{
				reference: "./OCLC-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OCLC-2.0.json",
				referenceNumber: "341",
				name: "OCLC Research Public License 2.0",
				licenseId: "OCLC-2.0",
				seeAlso: [
					"http://www.oclc.org/research/activities/software/license/v2final.htm",
					"https://opensource.org/licenses/OCLC-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./ODC-By-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ODC-By-1.0.json",
				referenceNumber: "381",
				name: "Open Data Commons Attribution License v1.0",
				licenseId: "ODC-By-1.0",
				seeAlso: ["https://opendatacommons.org/licenses/by/1.0/"],
				isOsiApproved: false,
			},
			{
				reference: "./ODbL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ODbL-1.0.json",
				referenceNumber: "340",
				name: "ODC Open Database License v1.0",
				licenseId: "ODbL-1.0",
				seeAlso: ["http://www.opendatacommons.org/licenses/odbl/1.0/"],
				isOsiApproved: false,
			},
			{
				reference: "./OFL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OFL-1.0.json",
				referenceNumber: "80",
				name: "SIL Open Font License 1.0",
				licenseId: "OFL-1.0",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OFL-1.0-RFN.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OFL-1.0-RFN.json",
				referenceNumber: "298",
				name: "SIL Open Font License 1.0 with Reserved Font Name",
				licenseId: "OFL-1.0-RFN",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OFL-1.0-no-RFN.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OFL-1.0-no-RFN.json",
				referenceNumber: "71",
				name: "SIL Open Font License 1.0 with no Reserved Font Name",
				licenseId: "OFL-1.0-no-RFN",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL10_web",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OFL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OFL-1.1.json",
				referenceNumber: "311",
				name: "SIL Open Font License 1.1",
				licenseId: "OFL-1.1",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web",
					"https://opensource.org/licenses/OFL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OFL-1.1-RFN.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OFL-1.1-RFN.json",
				referenceNumber: "43",
				name: "SIL Open Font License 1.1 with Reserved Font Name",
				licenseId: "OFL-1.1-RFN",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web",
					"https://opensource.org/licenses/OFL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OFL-1.1-no-RFN.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OFL-1.1-no-RFN.json",
				referenceNumber: "238",
				name: "SIL Open Font License 1.1 with no Reserved Font Name",
				licenseId: "OFL-1.1-no-RFN",
				seeAlso: [
					"http://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web",
					"https://opensource.org/licenses/OFL-1.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OGL-Canada-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGL-Canada-2.0.json",
				referenceNumber: "346",
				name: "Open Government Licence - Canada",
				licenseId: "OGL-Canada-2.0",
				seeAlso: ["https://open.canada.ca/en/open-government-licence-canada"],
				isOsiApproved: false,
			},
			{
				reference: "./OGL-UK-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGL-UK-1.0.json",
				referenceNumber: "348",
				name: "Open Government Licence v1.0",
				licenseId: "OGL-UK-1.0",
				seeAlso: [
					"http://www.nationalarchives.gov.uk/doc/open-government-licence/version/1/",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OGL-UK-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGL-UK-2.0.json",
				referenceNumber: "13",
				name: "Open Government Licence v2.0",
				licenseId: "OGL-UK-2.0",
				seeAlso: [
					"http://www.nationalarchives.gov.uk/doc/open-government-licence/version/2/",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OGL-UK-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGL-UK-3.0.json",
				referenceNumber: "21",
				name: "Open Government Licence v3.0",
				licenseId: "OGL-UK-3.0",
				seeAlso: [
					"http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OGTSL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OGTSL.json",
				referenceNumber: "26",
				name: "Open Group Test Suite License",
				licenseId: "OGTSL",
				seeAlso: [
					"http://www.opengroup.org/testing/downloads/The_Open_Group_TSL.txt",
					"https://opensource.org/licenses/OGTSL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OLDAP-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-1.1.json",
				referenceNumber: "55",
				name: "Open LDAP Public License v1.1",
				licenseId: "OLDAP-1.1",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=806557a5ad59804ef3a44d5abfbe91d706b0791f",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-1.2.json",
				referenceNumber: "48",
				name: "Open LDAP Public License v1.2",
				licenseId: "OLDAP-1.2",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=42b0383c50c299977b5893ee695cf4e486fb0dc7",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-1.3.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-1.3.json",
				referenceNumber: "42",
				name: "Open LDAP Public License v1.3",
				licenseId: "OLDAP-1.3",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=e5f8117f0ce088d0bd7a8e18ddf37eaa40eb09b1",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-1.4.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-1.4.json",
				referenceNumber: "50",
				name: "Open LDAP Public License v1.4",
				licenseId: "OLDAP-1.4",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=c9f95c2f3f2ffb5e0ae55fe7388af75547660941",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.0.json",
				referenceNumber: "25",
				name: "Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)",
				licenseId: "OLDAP-2.0",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cbf50f4e1185a21abd4c0a54d3f4341fe28f36ea",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.0.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.0.1.json",
				referenceNumber: "280",
				name: "Open LDAP Public License v2.0.1",
				licenseId: "OLDAP-2.0.1",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b6d68acd14e51ca3aab4428bf26522aa74873f0e",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.1.json",
				referenceNumber: "400",
				name: "Open LDAP Public License v2.1",
				licenseId: "OLDAP-2.1",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=b0d176738e96a0d3b9f85cb51e140a86f21be715",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.2.json",
				referenceNumber: "318",
				name: "Open LDAP Public License v2.2",
				licenseId: "OLDAP-2.2",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=470b0c18ec67621c85881b2733057fecf4a1acc3",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.2.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.2.1.json",
				referenceNumber: "384",
				name: "Open LDAP Public License v2.2.1",
				licenseId: "OLDAP-2.2.1",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=4bc786f34b50aa301be6f5600f58a980070f481e",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.2.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.2.2.json",
				referenceNumber: "170",
				name: "Open LDAP Public License 2.2.2",
				licenseId: "OLDAP-2.2.2",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=df2cc1e21eb7c160695f5b7cffd6296c151ba188",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.3.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.3.json",
				referenceNumber: "230",
				name: "Open LDAP Public License v2.3",
				licenseId: "OLDAP-2.3",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=d32cf54a32d581ab475d23c810b0a7fbaf8d63c3",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.4.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.4.json",
				referenceNumber: "115",
				name: "Open LDAP Public License v2.4",
				licenseId: "OLDAP-2.4",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=cd1284c4a91a8a380d904eee68d1583f989ed386",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.5.json",
				referenceNumber: "108",
				name: "Open LDAP Public License v2.5",
				licenseId: "OLDAP-2.5",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=6852b9d90022e8593c98205413380536b1b5a7cf",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.6.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.6.json",
				referenceNumber: "109",
				name: "Open LDAP Public License v2.6",
				licenseId: "OLDAP-2.6",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=1cae062821881f41b73012ba816434897abf4205",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.7.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.7.json",
				referenceNumber: "229",
				name: "Open LDAP Public License v2.7",
				licenseId: "OLDAP-2.7",
				seeAlso: [
					"http://www.openldap.org/devel/gitweb.cgi?p=openldap.git;a=blob;f=LICENSE;hb=47c2415c1df81556eeb39be6cad458ef87c534a2",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OLDAP-2.8.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OLDAP-2.8.json",
				referenceNumber: "252",
				name: "Open LDAP Public License v2.8",
				licenseId: "OLDAP-2.8",
				seeAlso: ["http://www.openldap.org/software/release/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./OML.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OML.json",
				referenceNumber: "171",
				name: "Open Market License",
				licenseId: "OML",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Open_Market_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OPL-1.0.json",
				referenceNumber: "338",
				name: "Open Public License v1.0",
				licenseId: "OPL-1.0",
				seeAlso: [
					"http://old.koalateam.com/jackaroo/OPL_1_0.TXT",
					"https://fedoraproject.org/wiki/Licensing/Open_Public_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./OSET-PL-2.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/OSET-PL-2.1.json",
				referenceNumber: "203",
				name: "OSET Public License version 2.1",
				licenseId: "OSET-PL-2.1",
				seeAlso: [
					"http://www.osetfoundation.org/public-license",
					"https://opensource.org/licenses/OPL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OSL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-1.0.json",
				referenceNumber: "95",
				name: "Open Software License 1.0",
				licenseId: "OSL-1.0",
				seeAlso: ["https://opensource.org/licenses/OSL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./OSL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-1.1.json",
				referenceNumber: "178",
				name: "Open Software License 1.1",
				licenseId: "OSL-1.1",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/OSL1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./OSL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-2.0.json",
				referenceNumber: "364",
				name: "Open Software License 2.0",
				licenseId: "OSL-2.0",
				seeAlso: [
					"http://web.archive.org/web/20041020171434/http://www.rosenlaw.com/osl2.0.html",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OSL-2.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-2.1.json",
				referenceNumber: "157",
				name: "Open Software License 2.1",
				licenseId: "OSL-2.1",
				seeAlso: [
					"http://web.archive.org/web/20050212003940/http://www.rosenlaw.com/osl21.htm",
					"https://opensource.org/licenses/OSL-2.1",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OSL-3.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OSL-3.0.json",
				referenceNumber: "149",
				name: "Open Software License 3.0",
				licenseId: "OSL-3.0",
				seeAlso: [
					"https://web.archive.org/web/20120101081418/http://rosenlaw.com:80/OSL3.0.htm",
					"https://opensource.org/licenses/OSL-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./OpenSSL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/OpenSSL.json",
				referenceNumber: "83",
				name: "OpenSSL License",
				licenseId: "OpenSSL",
				seeAlso: ["http://www.openssl.org/source/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./PDDL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/PDDL-1.0.json",
				referenceNumber: "132",
				name: "ODC Public Domain Dedication & License 1.0",
				licenseId: "PDDL-1.0",
				seeAlso: ["http://opendatacommons.org/licenses/pddl/1.0/"],
				isOsiApproved: false,
			},
			{
				reference: "./PHP-3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/PHP-3.0.json",
				referenceNumber: "191",
				name: "PHP License v3.0",
				licenseId: "PHP-3.0",
				seeAlso: [
					"http://www.php.net/license/3_0.txt",
					"https://opensource.org/licenses/PHP-3.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./PHP-3.01.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/PHP-3.01.json",
				referenceNumber: "3",
				name: "PHP License v3.01",
				licenseId: "PHP-3.01",
				seeAlso: ["http://www.php.net/license/3_01.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./PSF-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/PSF-2.0.json",
				referenceNumber: "91",
				name: "Python Software Foundation License 2.0",
				licenseId: "PSF-2.0",
				seeAlso: ["https://opensource.org/licenses/Python-2.0"],
				isOsiApproved: false,
			},
			{
				reference: "./Parity-6.0.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Parity-6.0.0.json",
				referenceNumber: "406",
				name: "The Parity Public License 6.0.0",
				licenseId: "Parity-6.0.0",
				seeAlso: ["https://paritylicense.com/versions/6.0.0.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Plexus.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Plexus.json",
				referenceNumber: "156",
				name: "Plexus Classworlds License",
				licenseId: "Plexus",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Plexus_Classworlds_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./PostgreSQL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/PostgreSQL.json",
				referenceNumber: "11",
				name: "PostgreSQL License",
				licenseId: "PostgreSQL",
				seeAlso: [
					"http://www.postgresql.org/about/licence",
					"https://opensource.org/licenses/PostgreSQL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Python-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Python-2.0.json",
				referenceNumber: "393",
				name: "Python License 2.0",
				licenseId: "Python-2.0",
				seeAlso: ["https://opensource.org/licenses/Python-2.0"],
				isOsiApproved: true,
			},
			{
				reference: "./QPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/QPL-1.0.json",
				referenceNumber: "289",
				name: "Q Public License 1.0",
				licenseId: "QPL-1.0",
				seeAlso: [
					"http://doc.qt.nokia.com/3.3/license.html",
					"https://opensource.org/licenses/QPL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Qhull.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Qhull.json",
				referenceNumber: "124",
				name: "Qhull License",
				licenseId: "Qhull",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Qhull"],
				isOsiApproved: false,
			},
			{
				reference: "./RHeCos-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RHeCos-1.1.json",
				referenceNumber: "61",
				name: "Red Hat eCos Public License v1.1",
				licenseId: "RHeCos-1.1",
				seeAlso: ["http://ecos.sourceware.org/old-license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./RPL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RPL-1.1.json",
				referenceNumber: "216",
				name: "Reciprocal Public License 1.1",
				licenseId: "RPL-1.1",
				seeAlso: ["https://opensource.org/licenses/RPL-1.1"],
				isOsiApproved: true,
			},
			{
				reference: "./RPL-1.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RPL-1.5.json",
				referenceNumber: "105",
				name: "Reciprocal Public License 1.5",
				licenseId: "RPL-1.5",
				seeAlso: ["https://opensource.org/licenses/RPL-1.5"],
				isOsiApproved: true,
			},
			{
				reference: "./RPSL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/RPSL-1.0.json",
				referenceNumber: "53",
				name: "RealNetworks Public Source License v1.0",
				licenseId: "RPSL-1.0",
				seeAlso: [
					"https://helixcommunity.org/content/rpsl",
					"https://opensource.org/licenses/RPSL-1.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./RSA-MD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RSA-MD.json",
				referenceNumber: "279",
				name: "RSA Message-Digest License ",
				licenseId: "RSA-MD",
				seeAlso: ["http://www.faqs.org/rfcs/rfc1321.html"],
				isOsiApproved: false,
			},
			{
				reference: "./RSCPL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/RSCPL.json",
				referenceNumber: "339",
				name: "Ricoh Source Code Public License",
				licenseId: "RSCPL",
				seeAlso: [
					"http://wayback.archive.org/web/20060715140826/http://www.risource.org/RPL/RPL-1.0A.shtml",
					"https://opensource.org/licenses/RSCPL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./Rdisc.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Rdisc.json",
				referenceNumber: "322",
				name: "Rdisc License",
				licenseId: "Rdisc",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Rdisc_License"],
				isOsiApproved: false,
			},
			{
				reference: "./Ruby.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Ruby.json",
				referenceNumber: "14",
				name: "Ruby License",
				licenseId: "Ruby",
				seeAlso: ["http://www.ruby-lang.org/en/LICENSE.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./SAX-PD.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SAX-PD.json",
				referenceNumber: "152",
				name: "Sax Public Domain Notice",
				licenseId: "SAX-PD",
				seeAlso: ["http://www.saxproject.org/copying.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SCEA.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SCEA.json",
				referenceNumber: "137",
				name: "SCEA Shared Source License",
				licenseId: "SCEA",
				seeAlso: ["http://research.scea.com/scea_shared_source_license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SGI-B-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SGI-B-1.0.json",
				referenceNumber: "189",
				name: "SGI Free Software License B v1.0",
				licenseId: "SGI-B-1.0",
				seeAlso: ["http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.1.0.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SGI-B-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SGI-B-1.1.json",
				referenceNumber: "288",
				name: "SGI Free Software License B v1.1",
				licenseId: "SGI-B-1.1",
				seeAlso: ["http://oss.sgi.com/projects/FreeB/"],
				isOsiApproved: false,
			},
			{
				reference: "./SGI-B-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/SGI-B-2.0.json",
				referenceNumber: "31",
				name: "SGI Free Software License B v2.0",
				licenseId: "SGI-B-2.0",
				seeAlso: ["http://oss.sgi.com/projects/FreeB/SGIFreeSWLicB.2.0.pdf"],
				isOsiApproved: false,
			},
			{
				reference: "./SHL-0.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SHL-0.5.json",
				referenceNumber: "49",
				name: "Solderpad Hardware License v0.5",
				licenseId: "SHL-0.5",
				seeAlso: ["https://solderpad.org/licenses/SHL-0.5/"],
				isOsiApproved: false,
			},
			{
				reference: "./SHL-0.51.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SHL-0.51.json",
				referenceNumber: "281",
				name: "Solderpad Hardware License, Version 0.51",
				licenseId: "SHL-0.51",
				seeAlso: ["https://solderpad.org/licenses/SHL-0.51/"],
				isOsiApproved: false,
			},
			{
				reference: "./SISSL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/SISSL.json",
				referenceNumber: "78",
				name: "Sun Industry Standards Source License v1.1",
				licenseId: "SISSL",
				seeAlso: [
					"http://www.openoffice.org/licenses/sissl_license.html",
					"https://opensource.org/licenses/SISSL",
				],
				isOsiApproved: true,
			},
			{
				reference: "./SISSL-1.2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SISSL-1.2.json",
				referenceNumber: "62",
				name: "Sun Industry Standards Source License v1.2",
				licenseId: "SISSL-1.2",
				seeAlso: [
					"http://gridscheduler.sourceforge.net/Gridengine_SISSL_license.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SMLNJ.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/SMLNJ.json",
				referenceNumber: "218",
				name: "Standard ML of New Jersey License",
				licenseId: "SMLNJ",
				seeAlso: ["https://www.smlnj.org/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SMPPL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SMPPL.json",
				referenceNumber: "106",
				name: "Secure Messaging Protocol Public License",
				licenseId: "SMPPL",
				seeAlso: [
					"https://github.com/dcblake/SMP/blob/master/Documentation/License.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SNIA.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SNIA.json",
				referenceNumber: "302",
				name: "SNIA Public License 1.1",
				licenseId: "SNIA",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/SNIA_Public_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/SPL-1.0.json",
				referenceNumber: "247",
				name: "Sun Public License v1.0",
				licenseId: "SPL-1.0",
				seeAlso: ["https://opensource.org/licenses/SPL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./SSH-OpenSSH.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SSH-OpenSSH.json",
				referenceNumber: "22",
				name: "SSH OpenSSH license",
				licenseId: "SSH-OpenSSH",
				seeAlso: [
					"https://github.com/openssh/openssh-portable/blob/1b11ea7c58cd5c59838b5fa574cd456d6047b2d4/LICENCE#L10",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SSH-short.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SSH-short.json",
				referenceNumber: "67",
				name: "SSH short notice",
				licenseId: "SSH-short",
				seeAlso: [
					"https://github.com/openssh/openssh-portable/blob/1b11ea7c58cd5c59838b5fa574cd456d6047b2d4/pathnames.h",
					"http://web.mit.edu/kolya/.f/root/athena.mit.edu/sipb.mit.edu/project/openssh/OldFiles/src/openssh-2.9.9p2/ssh-add.1",
					"https://joinup.ec.europa.eu/svn/lesoll/trunk/italc/lib/src/dsa_key.cpp",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SSPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SSPL-1.0.json",
				referenceNumber: "334",
				name: "Server Side Public License, v 1",
				licenseId: "SSPL-1.0",
				seeAlso: [
					"https://www.mongodb.com/licensing/server-side-public-license",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SWL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SWL.json",
				referenceNumber: "93",
				name: "Scheme Widget Library (SWL) Software License Agreement",
				licenseId: "SWL",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/SWL"],
				isOsiApproved: false,
			},
			{
				reference: "./Saxpath.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Saxpath.json",
				referenceNumber: "34",
				name: "Saxpath License",
				licenseId: "Saxpath",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Saxpath_License"],
				isOsiApproved: false,
			},
			{
				reference: "./Sendmail.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Sendmail.json",
				referenceNumber: "293",
				name: "Sendmail License",
				licenseId: "Sendmail",
				seeAlso: [
					"http://www.sendmail.com/pdfs/open_source/sendmail_license.pdf",
					"https://web.archive.org/web/20160322142305/https://www.sendmail.com/pdfs/open_source/sendmail_license.pdf",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Sendmail-8.23.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Sendmail-8.23.json",
				referenceNumber: "176",
				name: "Sendmail License 8.23",
				licenseId: "Sendmail-8.23",
				seeAlso: [
					"https://www.proofpoint.com/sites/default/files/sendmail-license.pdf",
					"https://web.archive.org/web/20181003101040/https://www.proofpoint.com/sites/default/files/sendmail-license.pdf",
				],
				isOsiApproved: false,
			},
			{
				reference: "./SimPL-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SimPL-2.0.json",
				referenceNumber: "250",
				name: "Simple Public License 2.0",
				licenseId: "SimPL-2.0",
				seeAlso: ["https://opensource.org/licenses/SimPL-2.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Sleepycat.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Sleepycat.json",
				referenceNumber: "56",
				name: "Sleepycat License",
				licenseId: "Sleepycat",
				seeAlso: ["https://opensource.org/licenses/Sleepycat"],
				isOsiApproved: true,
			},
			{
				reference: "./Spencer-86.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Spencer-86.json",
				referenceNumber: "184",
				name: "Spencer License 86",
				licenseId: "Spencer-86",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Spencer-94.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Spencer-94.json",
				referenceNumber: "213",
				name: "Spencer License 94",
				licenseId: "Spencer-94",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/Henry_Spencer_Reg-Ex_Library_License",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Spencer-99.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Spencer-99.json",
				referenceNumber: "64",
				name: "Spencer License 99",
				licenseId: "Spencer-99",
				seeAlso: [
					"http://www.opensource.apple.com/source/tcl/tcl-5/tcl/generic/regfronts.c",
				],
				isOsiApproved: false,
			},
			{
				reference: "./StandardML-NJ.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/StandardML-NJ.json",
				referenceNumber: "285",
				name: "Standard ML of New Jersey License",
				licenseId: "StandardML-NJ",
				seeAlso: ["http://www.smlnj.org//license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./SugarCRM-1.1.3.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/SugarCRM-1.1.3.json",
				referenceNumber: "342",
				name: "SugarCRM Public License v1.1.3",
				licenseId: "SugarCRM-1.1.3",
				seeAlso: ["http://www.sugarcrm.com/crm/SPL"],
				isOsiApproved: false,
			},
			{
				reference: "./TAPR-OHL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TAPR-OHL-1.0.json",
				referenceNumber: "9",
				name: "TAPR Open Hardware License v1.0",
				licenseId: "TAPR-OHL-1.0",
				seeAlso: ["https://www.tapr.org/OHL"],
				isOsiApproved: false,
			},
			{
				reference: "./TCL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TCL.json",
				referenceNumber: "54",
				name: "TCL/TK License",
				licenseId: "TCL",
				seeAlso: [
					"http://www.tcl.tk/software/tcltk/license.html",
					"https://fedoraproject.org/wiki/Licensing/TCL",
				],
				isOsiApproved: false,
			},
			{
				reference: "./TCP-wrappers.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TCP-wrappers.json",
				referenceNumber: "234",
				name: "TCP Wrappers License",
				licenseId: "TCP-wrappers",
				seeAlso: ["http://rc.quest.com/topics/openssh/license.php#tcpwrappers"],
				isOsiApproved: false,
			},
			{
				reference: "./TMate.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TMate.json",
				referenceNumber: "402",
				name: "TMate Open Source License",
				licenseId: "TMate",
				seeAlso: ["http://svnkit.com/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./TORQUE-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TORQUE-1.1.json",
				referenceNumber: "188",
				name: "TORQUE v2.5+ Software License v1.1",
				licenseId: "TORQUE-1.1",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/TORQUEv1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./TOSL.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TOSL.json",
				referenceNumber: "251",
				name: "Trusster Open Source License",
				licenseId: "TOSL",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/TOSL"],
				isOsiApproved: false,
			},
			{
				reference: "./TU-Berlin-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TU-Berlin-1.0.json",
				referenceNumber: "372",
				name: "Technische Universitaet Berlin License 1.0",
				licenseId: "TU-Berlin-1.0",
				seeAlso: [
					"https://github.com/swh/ladspa/blob/7bf6f3799fdba70fda297c2d8fd9f526803d9680/gsm/COPYRIGHT",
				],
				isOsiApproved: false,
			},
			{
				reference: "./TU-Berlin-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/TU-Berlin-2.0.json",
				referenceNumber: "392",
				name: "Technische Universitaet Berlin License 2.0",
				licenseId: "TU-Berlin-2.0",
				seeAlso: [
					"https://github.com/CorsixTH/deps/blob/fd339a9f526d1d9c9f01ccf39e438a015da50035/licences/libgsm.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./UCL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/UCL-1.0.json",
				referenceNumber: "291",
				name: "Upstream Compatibility License v1.0",
				licenseId: "UCL-1.0",
				seeAlso: ["https://opensource.org/licenses/UCL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./UPL-1.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/UPL-1.0.json",
				referenceNumber: "144",
				name: "Universal Permissive License v1.0",
				licenseId: "UPL-1.0",
				seeAlso: ["https://opensource.org/licenses/UPL"],
				isOsiApproved: true,
			},
			{
				reference: "./Unicode-DFS-2015.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Unicode-DFS-2015.json",
				referenceNumber: "260",
				name: "Unicode License Agreement - Data Files and Software (2015)",
				licenseId: "Unicode-DFS-2015",
				seeAlso: [
					"https://web.archive.org/web/20151224134844/http://unicode.org/copyright.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Unicode-DFS-2016.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Unicode-DFS-2016.json",
				referenceNumber: "370",
				name: "Unicode License Agreement - Data Files and Software (2016)",
				licenseId: "Unicode-DFS-2016",
				seeAlso: ["http://www.unicode.org/copyright.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Unicode-TOU.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Unicode-TOU.json",
				referenceNumber: "16",
				name: "Unicode Terms of Use",
				licenseId: "Unicode-TOU",
				seeAlso: ["http://www.unicode.org/copyright.html"],
				isOsiApproved: false,
			},
			{
				reference: "./Unlicense.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Unlicense.json",
				referenceNumber: "173",
				name: "The Unlicense",
				licenseId: "Unlicense",
				seeAlso: ["https://unlicense.org/"],
				isOsiApproved: false,
			},
			{
				reference: "./VOSTROM.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/VOSTROM.json",
				referenceNumber: "352",
				name: "VOSTROM Public License for Open Source",
				licenseId: "VOSTROM",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/VOSTROM"],
				isOsiApproved: false,
			},
			{
				reference: "./VSL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/VSL-1.0.json",
				referenceNumber: "390",
				name: "Vovida Software License v1.0",
				licenseId: "VSL-1.0",
				seeAlso: ["https://opensource.org/licenses/VSL-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Vim.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Vim.json",
				referenceNumber: "206",
				name: "Vim License",
				licenseId: "Vim",
				seeAlso: ["http://vimdoc.sourceforge.net/htmldoc/uganda.html"],
				isOsiApproved: false,
			},
			{
				reference: "./W3C.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/W3C.json",
				referenceNumber: "107",
				name: "W3C Software Notice and License (2002-12-31)",
				licenseId: "W3C",
				seeAlso: [
					"http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231.html",
					"https://opensource.org/licenses/W3C",
				],
				isOsiApproved: true,
			},
			{
				reference: "./W3C-19980720.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/W3C-19980720.json",
				referenceNumber: "266",
				name: "W3C Software Notice and License (1998-07-20)",
				licenseId: "W3C-19980720",
				seeAlso: [
					"http://www.w3.org/Consortium/Legal/copyright-software-19980720.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./W3C-20150513.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/W3C-20150513.json",
				referenceNumber: "111",
				name: "W3C Software Notice and Document License (2015-05-13)",
				licenseId: "W3C-20150513",
				seeAlso: [
					"https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document",
				],
				isOsiApproved: false,
			},
			{
				reference: "./WTFPL.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/WTFPL.json",
				referenceNumber: "20",
				name: "Do What The F*ck You Want To Public License",
				licenseId: "WTFPL",
				seeAlso: ["http://sam.zoy.org/wtfpl/COPYING"],
				isOsiApproved: false,
			},
			{
				reference: "./Watcom-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Watcom-1.0.json",
				referenceNumber: "141",
				name: "Sybase Open Watcom Public License 1.0",
				licenseId: "Watcom-1.0",
				seeAlso: ["https://opensource.org/licenses/Watcom-1.0"],
				isOsiApproved: true,
			},
			{
				reference: "./Wsuipa.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Wsuipa.json",
				referenceNumber: "255",
				name: "Wsuipa License",
				licenseId: "Wsuipa",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Wsuipa"],
				isOsiApproved: false,
			},
			{
				reference: "./X11.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/X11.json",
				referenceNumber: "99",
				name: "X11 License",
				licenseId: "X11",
				seeAlso: ["http://www.xfree86.org/3.3.6/COPYRIGHT2.html#3"],
				isOsiApproved: false,
			},
			{
				reference: "./XFree86-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/XFree86-1.1.json",
				referenceNumber: "155",
				name: "XFree86 License 1.1",
				licenseId: "XFree86-1.1",
				seeAlso: ["http://www.xfree86.org/current/LICENSE4.html"],
				isOsiApproved: false,
			},
			{
				reference: "./XSkat.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/XSkat.json",
				referenceNumber: "81",
				name: "XSkat License",
				licenseId: "XSkat",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/XSkat_License"],
				isOsiApproved: false,
			},
			{
				reference: "./Xerox.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Xerox.json",
				referenceNumber: "224",
				name: "Xerox License",
				licenseId: "Xerox",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Xerox"],
				isOsiApproved: false,
			},
			{
				reference: "./Xnet.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Xnet.json",
				referenceNumber: "313",
				name: "X.Net License",
				licenseId: "Xnet",
				seeAlso: ["https://opensource.org/licenses/Xnet"],
				isOsiApproved: true,
			},
			{
				reference: "./YPL-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/YPL-1.0.json",
				referenceNumber: "292",
				name: "Yahoo! Public License v1.0",
				licenseId: "YPL-1.0",
				seeAlso: ["http://www.zimbra.com/license/yahoo_public_license_1.0.html"],
				isOsiApproved: false,
			},
			{
				reference: "./YPL-1.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/YPL-1.1.json",
				referenceNumber: "40",
				name: "Yahoo! Public License v1.1",
				licenseId: "YPL-1.1",
				seeAlso: ["http://www.zimbra.com/license/yahoo_public_license_1.1.html"],
				isOsiApproved: false,
			},
			{
				reference: "./ZPL-1.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/ZPL-1.1.json",
				referenceNumber: "85",
				name: "Zope Public License 1.1",
				licenseId: "ZPL-1.1",
				seeAlso: ["http://old.zope.org/Resources/License/ZPL-1.1"],
				isOsiApproved: false,
			},
			{
				reference: "./ZPL-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ZPL-2.0.json",
				referenceNumber: "112",
				name: "Zope Public License 2.0",
				licenseId: "ZPL-2.0",
				seeAlso: [
					"http://old.zope.org/Resources/License/ZPL-2.0",
					"https://opensource.org/licenses/ZPL-2.0",
				],
				isOsiApproved: true,
			},
			{
				reference: "./ZPL-2.1.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/ZPL-2.1.json",
				referenceNumber: "368",
				name: "Zope Public License 2.1",
				licenseId: "ZPL-2.1",
				seeAlso: ["http://old.zope.org/Resources/ZPL/"],
				isOsiApproved: false,
			},
			{
				reference: "./Zed.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Zed.json",
				referenceNumber: "114",
				name: "Zed License",
				licenseId: "Zed",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Zed"],
				isOsiApproved: false,
			},
			{
				reference: "./Zend-2.0.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Zend-2.0.json",
				referenceNumber: "373",
				name: "Zend License v2.0",
				licenseId: "Zend-2.0",
				seeAlso: [
					"https://web.archive.org/web/20130517195954/http://www.zend.com/license/2_00.txt",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Zimbra-1.3.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Zimbra-1.3.json",
				referenceNumber: "175",
				name: "Zimbra Public License v1.3",
				licenseId: "Zimbra-1.3",
				seeAlso: [
					"http://web.archive.org/web/20100302225219/http://www.zimbra.com/license/zimbra-public-license-1-3.html",
				],
				isOsiApproved: false,
			},
			{
				reference: "./Zimbra-1.4.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/Zimbra-1.4.json",
				referenceNumber: "385",
				name: "Zimbra Public License v1.4",
				licenseId: "Zimbra-1.4",
				seeAlso: ["http://www.zimbra.com/legal/zimbra-public-license-1-4"],
				isOsiApproved: false,
			},
			{
				reference: "./Zlib.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/Zlib.json",
				referenceNumber: "45",
				name: "zlib License",
				licenseId: "Zlib",
				seeAlso: [
					"http://www.zlib.net/zlib_license.html",
					"https://opensource.org/licenses/Zlib",
				],
				isOsiApproved: true,
			},
			{
				reference: "./blessing.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/blessing.json",
				referenceNumber: "301",
				name: "SQLite Blessing",
				licenseId: "blessing",
				seeAlso: [
					"https://www.sqlite.org/src/artifact/e33a4df7e32d742a?ln=4-9",
					"https://sqlite.org/src/artifact/df5091916dbb40e6",
				],
				isOsiApproved: false,
			},
			{
				reference: "./bzip2-1.0.5.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/bzip2-1.0.5.json",
				referenceNumber: "186",
				name: "bzip2 and libbzip2 License v1.0.5",
				licenseId: "bzip2-1.0.5",
				seeAlso: ["http://bzip.org/1.0.5/bzip2-manual-1.0.5.html"],
				isOsiApproved: false,
			},
			{
				reference: "./bzip2-1.0.6.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/bzip2-1.0.6.json",
				referenceNumber: "69",
				name: "bzip2 and libbzip2 License v1.0.6",
				licenseId: "bzip2-1.0.6",
				seeAlso: ["https://github.com/asimonov-im/bzip2/blob/master/LICENSE"],
				isOsiApproved: false,
			},
			{
				reference: "./copyleft-next-0.3.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/copyleft-next-0.3.0.json",
				referenceNumber: "312",
				name: "copyleft-next 0.3.0",
				licenseId: "copyleft-next-0.3.0",
				seeAlso: [
					"https://github.com/copyleft-next/copyleft-next/blob/master/Releases/copyleft-next-0.3.0",
				],
				isOsiApproved: false,
			},
			{
				reference: "./copyleft-next-0.3.1.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/copyleft-next-0.3.1.json",
				referenceNumber: "378",
				name: "copyleft-next 0.3.1",
				licenseId: "copyleft-next-0.3.1",
				seeAlso: [
					"https://github.com/copyleft-next/copyleft-next/blob/master/Releases/copyleft-next-0.3.1",
				],
				isOsiApproved: false,
			},
			{
				reference: "./curl.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/curl.json",
				referenceNumber: "314",
				name: "curl License",
				licenseId: "curl",
				seeAlso: ["https://github.com/bagder/curl/blob/master/COPYING"],
				isOsiApproved: false,
			},
			{
				reference: "./diffmark.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/diffmark.json",
				referenceNumber: "397",
				name: "diffmark license",
				licenseId: "diffmark",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/diffmark"],
				isOsiApproved: false,
			},
			{
				reference: "./dvipdfm.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/dvipdfm.json",
				referenceNumber: "19",
				name: "dvipdfm License",
				licenseId: "dvipdfm",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/dvipdfm"],
				isOsiApproved: false,
			},
			{
				reference: "./eCos-2.0.html",
				isDeprecatedLicenseId: true,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/eCos-2.0.json",
				referenceNumber: "272",
				name: "eCos license version 2.0",
				licenseId: "eCos-2.0",
				seeAlso: ["https://www.gnu.org/licenses/ecos-license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./eGenix.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/eGenix.json",
				referenceNumber: "214",
				name: "eGenix.com Public License 1.1.0",
				licenseId: "eGenix",
				seeAlso: [
					"http://www.egenix.com/products/eGenix.com-Public-License-1.1.0.pdf",
					"https://fedoraproject.org/wiki/Licensing/eGenix.com_Public_License_1.1.0",
				],
				isOsiApproved: false,
			},
			{
				reference: "./etalab-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/etalab-2.0.json",
				referenceNumber: "259",
				name: "Etalab Open License 2.0",
				licenseId: "etalab-2.0",
				seeAlso: [
					"https://github.com/DISIC/politique-de-contribution-open-source/blob/master/LICENSE.pdf",
					"https://raw.githubusercontent.com/DISIC/politique-de-contribution-open-source/master/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./gSOAP-1.3b.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/gSOAP-1.3b.json",
				referenceNumber: "167",
				name: "gSOAP Public License v1.3b",
				licenseId: "gSOAP-1.3b",
				seeAlso: ["http://www.cs.fsu.edu/~engelen/license.html"],
				isOsiApproved: false,
			},
			{
				reference: "./gnuplot.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/gnuplot.json",
				referenceNumber: "383",
				name: "gnuplot License",
				licenseId: "gnuplot",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Gnuplot"],
				isOsiApproved: false,
			},
			{
				reference: "./iMatix.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/iMatix.json",
				referenceNumber: "177",
				name: "iMatix Standard Function Library Agreement",
				licenseId: "iMatix",
				seeAlso: ["http://legacy.imatix.com/html/sfl/sfl4.htm#license"],
				isOsiApproved: false,
			},
			{
				reference: "./libpng-2.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/libpng-2.0.json",
				referenceNumber: "103",
				name: "PNG Reference Library version 2",
				licenseId: "libpng-2.0",
				seeAlso: ["http://www.libpng.org/pub/png/src/libpng-LICENSE.txt"],
				isOsiApproved: false,
			},
			{
				reference: "./libselinux-1.0.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/libselinux-1.0.json",
				referenceNumber: "18",
				name: "libselinux public domain notice",
				licenseId: "libselinux-1.0",
				seeAlso: [
					"https://github.com/SELinuxProject/selinux/blob/master/libselinux/LICENSE",
				],
				isOsiApproved: false,
			},
			{
				reference: "./libtiff.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/libtiff.json",
				referenceNumber: "407",
				name: "libtiff License",
				licenseId: "libtiff",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/libtiff"],
				isOsiApproved: false,
			},
			{
				reference: "./mpich2.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/mpich2.json",
				referenceNumber: "60",
				name: "mpich2 License",
				licenseId: "mpich2",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/MIT"],
				isOsiApproved: false,
			},
			{
				reference: "./psfrag.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/psfrag.json",
				referenceNumber: "408",
				name: "psfrag License",
				licenseId: "psfrag",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/psfrag"],
				isOsiApproved: false,
			},
			{
				reference: "./psutils.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/psutils.json",
				referenceNumber: "277",
				name: "psutils License",
				licenseId: "psutils",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/psutils"],
				isOsiApproved: false,
			},
			{
				reference: "./wxWindows.html",
				isDeprecatedLicenseId: true,
				detailsUrl: "http://spdx.org/licenses/wxWindows.json",
				referenceNumber: "244",
				name: "wxWindows Library License",
				licenseId: "wxWindows",
				seeAlso: ["https://opensource.org/licenses/WXwindows"],
				isOsiApproved: false,
			},
			{
				reference: "./xinetd.html",
				isDeprecatedLicenseId: false,
				isFsfLibre: true,
				detailsUrl: "http://spdx.org/licenses/xinetd.json",
				referenceNumber: "399",
				name: "xinetd License",
				licenseId: "xinetd",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/Xinetd_License"],
				isOsiApproved: false,
			},
			{
				reference: "./xpp.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/xpp.json",
				referenceNumber: "96",
				name: "XPP License",
				licenseId: "xpp",
				seeAlso: ["https://fedoraproject.org/wiki/Licensing/xpp"],
				isOsiApproved: false,
			},
			{
				reference: "./zlib-acknowledgement.html",
				isDeprecatedLicenseId: false,
				detailsUrl: "http://spdx.org/licenses/zlib-acknowledgement.json",
				referenceNumber: "246",
				name: "zlib/libpng License with Acknowledgement",
				licenseId: "zlib-acknowledgement",
				seeAlso: [
					"https://fedoraproject.org/wiki/Licensing/ZlibWithAcknowledgement",
				],
				isOsiApproved: false,
			},
		],
		releaseDate: "2020-02-13",
	};


  // project-rome/@romejs/codec-spdx-license/parse.ts









	function ___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$isWordChar(
		char,
	) {
		return (
			___R$project$rome$$romejs$parser$core$index_ts$isAlpha(char) ||
			___R$project$rome$$romejs$parser$core$index_ts$isDigit(char) ||
			char === "-" ||
			char === "."
		);
	}



	const ___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$createSPDXLicenseParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser((
		ParserCore,
	) =>
		(() => {
			class SPDXLicenseParser extends ParserCore {
				constructor(opts) {
					super(opts, "parse/spdxLicense");
					this.loose = opts.loose === true;
				}

				// For some reason Flow will throw an error without the type casts...
				tokenize(index, input) {
					const char = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
						index,
					)];

					if (char === "+") {
						return this.finishToken("Plus");
					}

					if (char === "(") {
						return this.finishToken("ParenOpen");
					}

					if (char === ")") {
						return this.finishToken("ParenClose");
					}

					// Skip spaces
					if (char === " ") {
						return this.lookaheadToken(
							___R$project$rome$$romejs$ob1$index_ts$ob1Inc(index),
						);
					}

					if (
						___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$isWordChar(
							char,
						)
					) {
						const [value, end] = this.readInputFrom(
							index,
							___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$isWordChar,
						);

						if (value === "AND") {
							return this.finishToken("And", end);
						} else if (value === "OR") {
							return this.finishToken("Or", end);
						} else if (value === "WITH") {
							return this.finishToken("With", end);
						} else {
							return this.finishValueToken("Word", value, end);
						}
					}

					return undefined;
				}

				parseLicense(token) {
					const startPos = this.getPosition();
					this.nextToken();

					// Validate id
					const id = token.value;
					let licenseInfo = ___R$project$rome$$romejs$codec$spdx$license$index_ts$getSPDXLicense(
						id,
					);
					const nextToken = this.getToken();

					// Sometimes licenses will be specified as "Apache 2.0" but what they actually meant was "Apache-2.0"

					// In loose mode, just make it equivalent, otherwise, complain
					if (licenseInfo === undefined && nextToken.type === "Word") {
						const possibleCorrectLicense = id + "-" + nextToken.value;
						const possibleLicenseInfo = ___R$project$rome$$romejs$codec$spdx$license$index_ts$getSPDXLicense(
							possibleCorrectLicense,
						);

						if (possibleLicenseInfo !== undefined) {
							if (this.loose) {
								// Just allow it...
								licenseInfo = possibleLicenseInfo;
								this.nextToken();
							} else {
								throw this.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SPDX.VALID_LICENSE_WITH_MISSING_DASH(
										possibleCorrectLicense,
									),
									start: this.getPositionFromIndex(token.start),
									end: this.getPositionFromIndex(nextToken.end),
								});
							}
						}
					}

					if (licenseInfo === undefined) {
						throw this.unexpected({
							description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SPDX.UNKNOWN_LICENSE(
								id,
								___R$project$rome$$romejs$codec$spdx$license$index_ts$licenseNames,
							),
							start: this.getPositionFromIndex(token.start),
							end: this.getPositionFromIndex(token.end),
						});
					}

					// Is this a plus? (wtf is this)
					const plus = this.eatToken("Plus") !== undefined;

					// Get exception
					let exception;
					if (this.eatToken("With")) {
						const token = this.getToken();
						if (token.type === "Word") {
							exception = token.value;
							this.nextToken();
						} else {
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SPDX.WITH_RIGHT_LICENSE_ONLY,
							});
						}
					}

					return {
						type: "License",
						loc: this.finishLoc(startPos),
						id,
						exception,
						plus,
					};
				}

				parseExpression() {
					const startPos = this.getPosition();
					const startToken = this.getToken();

					let value;

					switch (startToken.type) {
						case "ParenOpen": {
							this.nextToken();
							value = this.parseExpression();
							this.expectToken("ParenClose");
							break;
						}

						case "Word": {
							value = this.parseLicense(startToken);
							break;
						}

						case "Or":
						case "And":
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SPDX.OPERATOR_NOT_BETWEEN_EXPRESSION,
							});

						case "Plus":
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SPDX.PLUS_NOT_AFTER_LICENSE,
							});

						case "ParenClose":
							throw this.unexpected({
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SPDX.UNOPENED_PAREN,
							});

						default:
							throw this.unexpected();
					}

					// Parse and/or
					const nextToken = this.getToken();
					switch (nextToken.type) {
						case "Or": {
							this.nextToken();
							return {
								type: "Or",
								loc: this.finishLoc(startPos),
								left: value,
								right: this.parseExpression(),
							};
						}

						case "And": {
							this.nextToken();
							return {
								type: "And",
								loc: this.finishLoc(startPos),
								left: value,
								right: this.parseExpression(),
							};
						}

						default:
							return value;
					}
				}

				parse() {
					const expr = this.parseExpression();
					this.finalize();
					return expr;
				}
			}
			return SPDXLicenseParser;
		})()
	);

	function ___R$project$rome$$romejs$codec$spdx$license$parse_ts$default(opts) {
		return ___R$$priv$project$rome$$romejs$codec$spdx$license$parse_ts$createSPDXLicenseParser(
			opts,
		).parse();
	}


  // project-rome/@romejs/codec-spdx-license/stringify.ts
function ___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(node) {
		// TODO parens
		switch (node.type) {
			case "Or":
				return (
					___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(
						node.left,
					) +
					" OR " +
					___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(
						node.right,
					)
				);

			case "And":
				return (
					___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(
						node.left,
					) +
					" AND " +
					___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(
						node.right,
					)
				);

			case "License": {
				let str = node.id;
				if (node.plus) {
					str += "+";
				}
				if (node.exception !== undefined) {
					str += " WITH " + node.exception;
				}
				return str;
			}
		}
	}


  // project-rome/@romejs/codec-spdx-license/index.ts


	const ___R$$priv$project$rome$$romejs$codec$spdx$license$index_ts$idToLicense = new Map();
	const ___R$project$rome$$romejs$codec$spdx$license$index_ts$licenseNames = [];
	for (const license of ___R$project$rome$$romejs$codec$spdx$license$data_ts$default.licenses) {
		___R$project$rome$$romejs$codec$spdx$license$index_ts$licenseNames.push(
			license.licenseId,
		);
		___R$$priv$project$rome$$romejs$codec$spdx$license$index_ts$idToLicense.set(
			license.licenseId,
			license,
		);
	}

	function ___R$project$rome$$romejs$codec$spdx$license$index_ts$getSPDXLicense(
		licenseId,
	) {
		return ___R$$priv$project$rome$$romejs$codec$spdx$license$index_ts$idToLicense.get(
			licenseId,
		);
	}


  // project-rome/@romejs/codec-js-manifest/name.ts






	function ___R$$priv$project$rome$$romejs$codec$js$manifest$name_ts$validateNamePart(
		{loose, unexpected},
		{name, isOrg, isOrgPart, offset},
	) {
		let normalizedName = "";

		for (let i = 0; i < name.length; i++) {
			const char = name[i];

			if (isOrg && char === "@" && i === 0) {
				unexpected({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.REDUNDANT_ORG_NAME_START,
					start: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(offset, i),
				});
			} else if (!isOrgPart && char === "/") {
				/*unexpected({
        at: 'prefix',
        message: `cannot contain any slashes`,
        start: add(offset, i),
        advice: [
          {
            type: 'log',
            category: 'info',
            message:
              'Did you forget a <emphasis>@</emphasis> prefix to make this a scope?',
          },
        ],
      });*/
				normalizedName = "@" + normalizedName + "/";
			} else if (!loose && char.match(/[A-Z]/)) {
				/*unexpected({
          at: 'prefix',
          message: `cannot contain uppercase letters`,
          start: add(offset, i),
        });*/
				normalizedName += char.toLowerCase();
			} else if (char.match(/[A-Za-z0-9\-_.]/)) {
				normalizedName += char;
			} else {
				unexpected({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.INVALID_NAME_CHAR(
						char,
					),
					start: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(offset, i),
				});
			}
		}

		return normalizedName;
	}

	function ___R$project$rome$$romejs$codec$js$manifest$name_ts$manifestNameToString(
		name,
	) {
		const {packageName, org} = name;

		if (org === undefined) {
			return packageName;
		}

		return "@" + org + "/" + packageName;
	}

	function ___R$project$rome$$romejs$codec$js$manifest$name_ts$normalizeName(
		opts,
	) {
		const {unexpected} = opts;
		let {name} = opts;

		let org;
		let packageName;

		if (name.length > 214) {
			unexpected({
				at: "prefix",
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.NAME_EXCEEDS,
			});
			name = name.slice(0, 214);
		}

		if (name[0] === "." || name[0] === "_") {
			unexpected({
				at: "prefix",
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.INVALID_NAME_START,
				start: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			});
			name = name.slice(1);
		}

		if (name[0] === "@") {
			// Validate org and package name separately
			const [rawOrg, rawPackageName, ...other] = name.slice(1).split("/");

			// Leading @
			let offset = ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(1);

			// Org
			const sanitizedOrg = ___R$$priv$project$rome$$romejs$codec$js$manifest$name_ts$validateNamePart(
				opts,
				{
					isOrg: true,
					isOrgPart: true,
					name: rawOrg,
					offset,
				},
			);
			offset = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
				offset,
				rawOrg.length,
			);
			org = sanitizedOrg;

			if (rawPackageName === undefined) {
				unexpected({
					at: "prefix",
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.ORG_WITH_NO_PACKAGE_NAME,
					start: offset,
				});
			} else {
				// Forward slashSeparator
				offset = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(offset);

				// Package name
				const sanitizedPackageName = ___R$$priv$project$rome$$romejs$codec$js$manifest$name_ts$validateNamePart(
					opts,
					{
						isOrg: false,
						isOrgPart: true,
						name: rawPackageName,
						offset,
					},
				);
				offset = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
					offset,
					rawPackageName.length,
				);

				// Complain on excess separators
				if (other.length > 0) {
					unexpected({
						at: "prefix",
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.ORG_TOO_MANY_PARTS,
						start: offset,
					});
				}

				packageName = sanitizedPackageName;
			}
		} else {
			packageName = ___R$$priv$project$rome$$romejs$codec$js$manifest$name_ts$validateNamePart(
				opts,
				{
					name,
					offset: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
					isOrg: false,
					isOrgPart: false,
				},
			);
		}

		return {org, packageName};
	}


  // project-rome/@romejs/codec-js-manifest/dependencies.ts






	function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$stringifyDependencyPattern(
		pattern,
	) {
		switch (pattern.type) {
			case "hosted-git": {
				let str = pattern.host + ":" + pattern.user + "/" + pattern.repo;
				if (pattern.commitish !== undefined) {
					str += "#" + pattern.commitish;
				}
				return str;
			}

			case "file":
				return "file:" + pattern.path;

			case "semver":
				return ___R$project$rome$$romejs$codec$semver$stringify_ts$default(
					pattern.range,
				);

			case "tag":
				return pattern.tag;

			case "git":
			case "http-tarball":
				if (pattern.hash === undefined) {
					return pattern.url;
				} else {
					return pattern.url + "#" + pattern.hash;
				}

			case "npm": {
				let str =
					"" +
					___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX +
					pattern.name;
				if (pattern.range !== undefined) {
					str +=
						"@" +
						___R$project$rome$$romejs$codec$semver$stringify_ts$default(
							pattern.range,
						);
				}
				return str;
			}

			case "link":
				return (
					"" +
					___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$LINK_PREFIX +
					pattern.path.join()
				);
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(
		pattern,
		consumer,
	) {
		const parts = pattern.split("#");

		if (parts.length > 2) {
			consumer.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.TOO_MANY_HASH_PARTS,
			);
		}

		return {
			hash: parts[1],
			url: parts[0],
		};
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$removePrefix(
		prefix,
		value,
	) {
		if (value.startsWith(prefix)) {
			return value.slice(prefix.length);
		} else {
			return value;
		}
	}

	//# HOSTED GIT






	const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$GITHUB_SHORTHAND = /^[^:@%\/\s.\-][^:@%\/\s]*[\/][^:@\s\/%]+(?:#.*)?$/;

	const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$HOSTED_GIT_PREFIXES = [
		"bitbucket",
		"github",
		"gist",
		"gitlab",
	];

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHostedGit(
		host,
		pattern,
		consumer,
	) {
		// Extract and trim hash
		let commitish;
		if (pattern.includes("#")) {
			const hashIndex = pattern.indexOf("#");
			commitish = pattern.slice(hashIndex + 1);
			pattern = pattern.slice(0, hashIndex - 1);
		}

		const parts = pattern.split("/");
		if (parts.length > 2) {
			consumer.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.TOO_MANY_HOSTED_GIT_PARTS,
			);
		}

		let user = parts[0];
		if (user === undefined) {
			consumer.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.MISSING_HOSTED_GIT_USER,
			);
			user = "unknown";
		}

		let repo = parts[1];
		if (repo === undefined) {
			consumer.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.MISSING_HOSTED_GIT_REPO,
			);
			repo = "unknown";
		}

		const incomplete = {
			type: "hosted-git",
			host,
			user,
			repo,
			commitish,
		};

		return Object.assign(
			{},
			incomplete,
			{
				url: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$getHostedGitURL(
					incomplete,
				),
			},
		);
	}

	function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$getHostedGitURL(
		pattern,
	) {
		switch (pattern.host) {
			case "bitbucket":
				return "";

			case "gitlab":
			case "gist":
				return "";

			case "github":
				return "";
		}
	}



	const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$GIT_PATTERN_MATCHERS = [
		/^git:/,
		/^git\+.+:/,
		/^ssh:/,
		/^https?:.+\.git$/,
		/^https?:.+\.git#.+/,
	];

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGit(
		pattern,
		consumer,
	) {
		return Object.assign(
			{type: "git"},
			___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(
				pattern,
				consumer,
			),
		);
	}

	//# TARBALL


	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHttpTarball(
		pattern,
		consumer,
	) {
		return Object.assign(
			{type: "http-tarball"},
			___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$explodeHashUrl(
				pattern,
				consumer,
			),
		);
	}

	//# SEMVER


	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseSemver(
		pattern,
		consumer,
		loose,
	) {
		const ast = ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
			{
				loose,
				path: consumer.path,
				input: pattern,
			},
			{
				getOffsetPosition: () => consumer.getLocation("inner-value").start,
				parse: (opts) =>
					___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(opts)
				,
			},
		);

		return {
			type: "semver",
			range: ast,
		};
	}

	//# FILE
	const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$FILE_PREFIX_REGEX = /^\.{1,2}\//;



	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseFile(
		pattern,
	) {
		return {
			type: "file",
			path: ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$removePrefix(
				"file:",
				pattern,
			),
		};
	}

	//# TAG

	// This regex will likely need to be refined, not sure what the allowable characters of a tag are
	const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$TAG_REGEX = /^[a-z]+$/g;



	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseTag(
		pattern,
	) {
		return {
			type: "tag",
			tag: pattern,
		};
	}

	//# LINK
	const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$LINK_PREFIX = "link:";



	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseLink(
		pattern,
	) {
		return {
			type: "link",
			path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
				pattern.slice(
					___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$LINK_PREFIX.length,
				),
			),
		};
	}

	//# NPM
	const ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX = "npm:";



	function ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseNpm(
		pattern,
		consumer,
		loose,
	) {
		// Prune prefix
		let offset = ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX.length;
		pattern = pattern.slice(
			___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX.length,
		);

		if (pattern === "") {
			consumer.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.EMPTY_NPM_PATTERN,
			);
			return {
				type: "npm",
				name: {
					org: undefined,
					packageName: undefined,
				},
				range: undefined,
			};
		}

		// Split and verify count
		const parts = pattern.split("@");
		let nameRaw = "";
		let rangeRaw;

		// Org signifier
		if (parts[0] === "") {
			nameRaw += "@";
			parts.shift();
		}

		// Name - We know there'll be at least two due to the empty string conditional
		nameRaw = String(parts.shift());

		// Range
		rangeRaw = parts.shift();

		if (parts.length > 0) {
			consumer.unexpected(
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.TOO_MANY_NPM_PARTS,
			);
		}

		const name = ___R$project$rome$$romejs$codec$js$manifest$name_ts$normalizeName({
			name: nameRaw,
			loose,
			unexpected({description, at, start, end}) {
				consumer.unexpected(
					description,
					{
						at,
						loc: start === undefined
							? undefined
							: consumer.getLocationRange(
									___R$project$rome$$romejs$ob1$index_ts$ob1Add(start, offset),
									end === undefined
										? undefined
										: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(end, offset),
									"inner-value",
								),
					},
				);
			},
		});

		// Increase offset passed name
		offset += nameRaw.length;
		offset++;

		let range;
		if (rangeRaw !== undefined) {
			range = ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
				{
					loose,
					path: consumer.path,
					input: rangeRaw,
				},
				{
					getOffsetPosition: () => {
						const pos = consumer.getLocation("inner-value").start;
						return Object.assign(
							{},
							pos,
							{
								column: ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
									pos.column,
									offset,
								),
							},
						);
					},
					parse: (opts) =>
						___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverRange(
							opts,
						)
					,
				},
			);
		}

		return {
			type: "npm",
			name,
			range,
		};
	}

	//#
	function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(
		consumer,
	) {
		const pattern = consumer.asString();

		for (const host of ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$HOSTED_GIT_PREFIXES) {
			const prefix = host + ":";
			if (pattern.startsWith(prefix)) {
				return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHostedGit(
					host,
					___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$removePrefix(
						prefix,
						pattern,
					),
					consumer,
				);
			}
		}

		for (const matcher of ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$GIT_PATTERN_MATCHERS) {
			if (matcher.test(pattern)) {
				return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGit(
					pattern,
					consumer,
				);
			}
		}

		if (
			___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$GITHUB_SHORTHAND.test(
				pattern,
			)
		) {
			return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHostedGit(
				"github",
				pattern,
				consumer,
			);
		}

		return undefined;
	}

	function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseDependencyPattern(
		consumer,
		loose,
	) {
		const pattern = consumer.asString();

		const gitPattern = ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(
			consumer,
		);
		if (gitPattern !== undefined) {
			return gitPattern;
		}

		if (pattern.startsWith("http://") || pattern.startsWith("https://")) {
			return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseHttpTarball(
				pattern,
				consumer,
			);
		}

		if (
			pattern.startsWith(
				___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$NPM_PREFIX,
			)
		) {
			return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseNpm(
				pattern,
				consumer,
				loose,
			);
		}

		if (
			pattern.startsWith(
				___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$LINK_PREFIX,
			)
		) {
			return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseLink(
				pattern,
			);
		}

		if (
			___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$FILE_PREFIX_REGEX.test(
				pattern,
			) ||
			___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(pattern).isAbsolute() ||
			pattern.startsWith("file:")
		) {
			return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseFile(
				pattern,
			);
		}

		if (
			pattern.match(
				___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$TAG_REGEX,
			)
		) {
			return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseTag(
				pattern,
			);
		}

		return ___R$$priv$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseSemver(
			pattern,
			consumer,
			loose,
		);
	}

	function ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
		root,
		key,
		loose,
	) {
		const map = new Map();

		if (!root.has(key)) {
			return map;
		}

		const consumer = root.get(key);

		// Some ridiculous code has the dependencies property as an empty array
		if (Array.isArray(consumer.asUnknown()) && loose) {
			return map;
		}

		for (const [rawName, value] of consumer.asMap()) {
			const name = ___R$project$rome$$romejs$codec$js$manifest$name_ts$normalizeName({
				name: rawName,
				loose,
				unexpected: ({description, at}) => {
					value.unexpected(
						description,
						{
							at,
							target: "key",
						},
					);
				},
			});

			map.set(
				name,
				___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseDependencyPattern(
					value,
					loose,
				),
			);
		}

		return map;
	}


  // project-rome/@romejs/codec-js-manifest/types.ts
const ___R$project$rome$$romejs$codec$js$manifest$types_ts = {};

































  // project-rome/@romejs/codec-js-manifest/convert.ts
const ___R$project$rome$$romejs$codec$js$manifest$convert_ts = {
		convertManifestToJSON: ___R$project$rome$$romejs$codec$js$manifest$convert_ts$convertManifestToJSON,
	};
	function ___R$project$rome$$romejs$codec$js$manifest$convert_ts$convertManifestToJSON(
		manifest,
	) {
		return Object.assign(
			{},
			manifest.raw,
			{
				name: ___R$project$rome$$romejs$codec$js$manifest$name_ts$manifestNameToString(
					manifest.name,
				),
				description: manifest.description,
				private: manifest.private,
				type: manifest.type,
				homepage: manifest.homepage,
				repository: manifest.repository,
				bugs: manifest.bugs,
				main: manifest.main,
				// TODO we now support fallbacks which means manifest.exports is lossy
				//exports: exportsToObject(manifest.exports),
				// rome-ignore lint/js/noExplicitAny
				exports: (manifest.raw.exports),
				author: manifest.author,
				contributors: manifest.contributors,
				maintainers: manifest.maintainers,
				version: manifest.version === undefined
					? undefined
					: ___R$project$rome$$romejs$codec$semver$stringify_ts$default(
							manifest.version,
						),
				license: manifest.license === undefined
					? undefined
					: ___R$project$rome$$romejs$codec$spdx$license$stringify_ts$default(
							manifest.license,
						),
				files: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(
					manifest.files.map((pattern) =>
						___R$project$rome$$romejs$path$match$stringify_ts$stringifyPathPattern(
							pattern,
						)
					),
				),
				keywords: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(
					manifest.keywords,
				),
				cpu: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(
					manifest.cpu,
				),
				os: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(
					manifest.os,
				),
				bin: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$mapToObject(
					manifest.bin,
				),
				scripts: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$mapToObject(
					manifest.scripts,
				),
				engines: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$mapToObject(
					manifest.engines,
				),
				dependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(
					manifest.dependencies,
				),
				devDependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(
					manifest.devDependencies,
				),
				optionalDependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(
					manifest.optionalDependencies,
				),
				peerDependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(
					manifest.peerDependencies,
				),
				// Common misspelling. If this existed then it was turned into bundledDependencies
				bundleDependencies: undefined,
				bundledDependencies: ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(
					manifest.bundledDependencies,
				),
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$exportsToObject(
		exports,
	) {
		if (exports === false) {
			return false;
		}

		if (exports === true) {
			return;
		}

		if (exports.size === 0) {
			return {};
		}

		const obj = {};

		for (const [key, entries] of exports) {
			if (entries.size === 1) {
				const def = entries.get("default");
				if (def !== undefined) {
					obj[key.join()] = def.relative.join();
					continue;
				}
			}

			const entriesObj = {};
			for (const [type, alias] of entries) {
				entriesObj[type] = alias.relative.join();
			}
			obj[key.join()] = entriesObj;
		}

		return obj;
	}
	___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$exportsToObject;

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$maybeArray(
		items,
	) {
		if (items.length === 0) {
			return undefined;
		} else {
			return items;
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$mapToObject(
		map,
	) {
		if (map.size === 0) {
			return;
		}

		const obj = {};
		for (const [key, value] of map) {
			obj[key] = value;
		}
		return obj;
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$convert_ts$dependencyMapToObject(
		map,
	) {
		if (map.size === 0) {
			return;
		}

		const obj = {};
		for (const [name, pattern] of map) {
			const key = ___R$project$rome$$romejs$codec$js$manifest$name_ts$manifestNameToString(
				name,
			);
			if (key !== undefined) {
				obj[key] = ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$stringifyDependencyPattern(
					pattern,
				);
			}
		}
		return obj;
	}


  // project-rome/@romejs/codec-js-manifest/index.ts
const ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$TYPO_KEYS = new Map([
		["autohr", "author"],
		["autor", "author"],
		["contributers", "contributors"],
		["depends", "dependencies"],
		["hampage", "homepage"],
		["hompage", "homepage"],
		["prefereGlobal", "preferGlobal"],
		["publicationConfig", "publishConfig"],
		["repo", "repository"],
		["repostitory", "repository"],
		["script", "scripts"],
	]);

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBoolean(
		consumer,
		key,
	) {
		if (consumer.has(key)) {
			return consumer.get(key).asBoolean();
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeString(
		consumer,
		key,
	) {
		if (consumer.has(key)) {
			return consumer.get(key).asString();
		} else {
			return undefined;
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePathPatterns(
		consumer,
		loose,
	) {
		return ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(
			consumer,
			loose,
		).map((str) =>
			___R$project$rome$$romejs$path$match$parse_ts$parsePattern({
				input: str,
			})
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(
		consumer,
		loose,
	) {
		if (consumer.exists()) {
			// When we are loose and expect an array but got a string, consider it to be a single element
			if (loose) {
				const val = consumer.asUnknown();

				if (typeof val === "string") {
					return [consumer.asString()];
				}

				// npm for some reason sometimes populates bundleDependencies as false? Despite it being a misspelling?
				if (val === false) {
					return [];
				}
			}

			return consumer.asArray().map((item) => item.asString());
		} else {
			return [];
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringMap(
		root,
		key,
		loose,
	) {
		const map = new Map();

		if (!root.has(key)) {
			return map;
		}

		const consumer = root.get(key);

		// Some code uses arrays for this case... Maybe we can normalize them. A `engines` array becomes an object with '*' properties etc
		if (Array.isArray(consumer.asUnknown()) && loose) {
			return map;
		}

		for (const [name, value] of consumer.asMap()) {
			// In loose mode let's be really generous
			if (loose && typeof value.asUnknown() !== "string") {
				continue;
			}

			map.set(name, value.asString());
		}

		return map;
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBin(
		consumer,
		name,
		loose,
	) {
		const map = new Map();
		if (!consumer.has("bin")) {
			return map;
		}

		// Allow a `bin` string
		const obj = consumer.get("bin");
		if (typeof obj.asUnknown() === "string") {
			if (name === undefined) {
				obj.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.STRING_BIN_WITHOUT_NAME,
				);
			} else {
				map.set(name, obj.asString());
				return map;
			}
		}

		// Otherwise expect it to be an object
		return ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringMap(
			consumer,
			"bin",
			loose,
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(
		consumer,
	) {
		const prop = consumer.get("type");
		const value = prop.asString();
		return [value, prop];
	}

	// These are all licenses I found that are wrong, we should eventually remove this as we update those deps
	const ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$INVALID_IGNORE_LICENSES = [
		"UNLICENSED",
		"none",
		"Facebook Platform License",
		"BSD",
		"MIT/X11",
		"Public Domain",
		"MIT License",
		"BSD-like",
	];

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeLicense(
		consumer,
		loose,
	) {
		if (!consumer.has("license")) {
			return undefined;
		}

		let licenseProp = consumer.get("license");

		let licenseId;

		// Support some legacy ways of specifying licenses: https://docs.npmjs.com/files/package.json#license
		const raw = licenseProp.asUnknown();
		if (loose && Array.isArray(raw)) {
			const licenseIds = licenseProp.asArray().map((consumer) =>
				___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(
					consumer,
				)[0]
			);
			licenseId = "(" + licenseIds.join(" OR ") + ")";
		} else if (loose && typeof raw === "object") {
			[licenseId, licenseProp] = ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$extractLicenseFromObjectConsumer(
				licenseProp,
			);
		} else {
			licenseId = licenseProp.asString();
		}

		// Allow referring to a custom license
		if (licenseId.startsWith("SEE LICENSE IN ")) {
			return undefined;
		}

		// Not valid licenses...
		if (
			___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$INVALID_IGNORE_LICENSES.includes(
				licenseId,
			)
		) {
			return undefined;
		}

		// Parse as a SPDX expression
		return ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
			{
				loose,
				path: consumer.path,
				input: licenseId,
			},
			{
				getOffsetPosition: () => licenseProp.getLocation("inner-value").start,
				parse: (opts) =>
					___R$project$rome$$romejs$codec$spdx$license$parse_ts$default(opts)
				,
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeVersion(
		consumer,
		loose,
	) {
		if (!consumer.has("version")) {
			return undefined;
		}

		const prop = consumer.get("version");
		const rawVersion = prop.asString();

		// Used in some package.json templates
		if (rawVersion === "VERSION_STRING") {
			return undefined;
		}

		const ast = ___R$project$rome$$romejs$parser$core$index_ts$tryParseWithOptionalOffsetPosition(
			{
				path: consumer.path,
				input: rawVersion,
				// Some node_modules have bogus versions, like being prefixed with a v like:
				// https://github.com/itinance/react-native-fs/commit/6232d4e392d5b52cca0792fdfe5903b7fb6b1c5c#diff-b9cfc7f2cdf78a7f4b91a753d10865a2R3
				loose,
			},
			{
				getOffsetPosition: () => prop.getLocation("inner-value").start,
				parse: (opts) =>
					___R$project$rome$$romejs$codec$semver$parse_ts$parseSemverVersion(
						opts,
					)
				,
			},
		);
		return ast;
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePerson(
		consumer,
		loose,
	) {
		if (typeof consumer.asUnknown() === "string") {
			// Parse the string. Format: name (url) <email>
			const str = consumer.asString();

			const nameMatch = str.match(/^([^(<]+)/);
			let name;
			if (nameMatch) {
				name = nameMatch[0].trim();
			}

			const person = {
				name,
				url: undefined,
				email: undefined,
				twitter: undefined,
				github: undefined,
			};

			const emailMatch = str.match(/<([^>]+)>/);
			if (emailMatch) {
				person.email = emailMatch[1];
			}

			const urlMatch = str.match(/\(([^)]+)\)/);
			if (urlMatch) {
				person.url = urlMatch[1];
			}

			return person;
		} else {
			// Validate as an object
			let url = consumer.get("url").asStringOrVoid();

			// Some packages use "web" or "website" instead of "url"
			if (loose) {
				if (url === undefined) {
					url = consumer.get("web").asStringOrVoid();
				}

				if (url === undefined) {
					url = consumer.get("website").asStringOrVoid();
				}
			}

			let github = consumer.get("github").asStringOrVoid();

			if (loose && github === undefined) {
				// Some rando packages use this
				github =
					consumer.get("githubUsername").asStringOrVoid() ||
					consumer.get("github-username").asStringOrVoid();
			}

			const person = {
				name: consumer.get("name").asString(loose ? "" : undefined),
				email: consumer.get("email").asStringOrVoid(),
				twitter: consumer.get("twitter").asStringOrVoid(),
				github,
				url,
			};
			if (!loose) {
				consumer.enforceUsedProperties();
			}
			return person;
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePeople(
		consumer,
		loose,
	) {
		if (!consumer.exists()) {
			return;
		}

		// Some packages have a single maintainer object instead of an array
		if (loose && consumer.isObject()) {
			return [
				___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePerson(
					consumer,
					loose,
				),
			];
		}

		// If it's not an array then just leave it. Some people put a URL here.
		if (loose && !Array.isArray(consumer.asUnknown())) {
			return;
		}

		const people = [];

		for (const item of consumer.asArray()) {
			people.push(
				___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePerson(
					item,
					loose,
				),
			);
		}

		return people;
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeRepo(
		consumer,
		loose,
	) {
		if (!consumer.exists()) {
			return;
		}

		if (typeof consumer.asUnknown() === "string") {
			let url = consumer.asString();

			// If this is a hosted git shorthand then explode it
			const parsed = ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$parseGitDependencyPattern(
				consumer,
			);
			if ((parsed == null ? undefined : parsed.type) === "hosted-git") {
				url = parsed.url;
			}

			return {
				type: "git",
				url,
				directory: undefined,
			};
		} else {
			let url;
			let type;

			if (loose) {
				// A lot of packages omit the "type"
				type = consumer.get("type").asString("git");

				// thanks i hate it
				consumer.markUsedProperty("web");
				consumer.markUsedProperty("git");
				consumer.markUsedProperty("dist");

				// Some gross packages use "repository" instead of "url"
				let looseUrl = consumer.get("url").asStringOrVoid();

				if (looseUrl === undefined) {
					looseUrl = consumer.get("repository").asStringOrVoid();
				}

				if (looseUrl === undefined) {
					consumer.unexpected(
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.MISSING_REPO_URL,
					);
					url = "";
				} else {
					url = looseUrl;
				}
			} else {
				url = consumer.get("url").asString();
				type = consumer.get("type").asString();
			}

			const repo = {
				type,
				url,
				directory: consumer.get("directory").asStringOrVoid(),
			};
			if (!loose) {
				consumer.enforceUsedProperties();
			}
			return repo;
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeExports(
		consumer,
	) {
		const unknown = consumer.asUnknown();

		// "exports": false
		if (typeof unknown === "boolean") {
			return consumer.asBoolean();
		}

		if (!consumer.exists()) {
			return true;
		}

		const exports = new ___R$project$rome$$romejs$path$collections_ts$RelativeFilePathMap();

		// "exports": "./index.js"
		if (typeof unknown === "string") {
			exports.set(
				___R$project$rome$$romejs$path$index_ts$createRelativeFilePath("."),
				new Map([
					[
						"default",
						{
							consumer,
							relative: consumer.asExplicitRelativeFilePath(),
						},
					],
				]),
			);
			return exports;
		}

		const dotConditions = new Map();

		for (const [relative, value] of consumer.asMap()) {
			// If it's not a relative path then it's a platform for the root
			if (relative[0] !== ".") {
				if (exports.size > 0) {
					value.unexpected(
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.MIXED_EXPORTS_PATHS,
					);
				}

				dotConditions.set(
					relative,
					{
						consumer: value,
						relative: value.asExplicitRelativeFilePath(),
					},
				);
				continue;
			}

			if (dotConditions.size > 0) {
				value.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.MIXED_EXPORTS_PATHS,
				);
			}

			const conditions = ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeExportsConditions(
				value,
			);
			exports.set(value.getKey().asExplicitRelativeFilePath(), conditions);
		}

		if (dotConditions.size > 0) {
			exports.set(
				___R$project$rome$$romejs$path$index_ts$createRelativeFilePath("."),
				dotConditions,
			);
		}

		return exports;
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeExportsConditions(
		value,
	) {
		const conditions = new Map();
		const unknown = value.asUnknown();

		if (typeof unknown === "string") {
			conditions.set(
				"default",
				{
					consumer: value,
					relative: value.asExplicitRelativeFilePath(),
				},
			);
		} else if (Array.isArray(unknown)) {
			// Find the first item that passes validation
			for (const elem of value.asArray()) {
				const {consumer, diagnostics} = elem.capture();
				const result = ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeExportsConditions(
					consumer,
				);
				if (diagnostics.length === 0) {
					return result;
				}
			}
		} else {
			for (const [type, relativeAlias] of value.asMap()) {
				conditions.set(
					type,
					{
						consumer: relativeAlias,
						relative: relativeAlias.asExplicitRelativeFilePath(),
					},
				);
			}
		}

		return conditions;
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBugs(
		consumer,
		loose,
	) {
		if (!consumer.exists()) {
			return;
		}

		if (typeof consumer.asUnknown() === "string") {
			return {
				email: undefined,
				url: consumer.asString(),
			};
		} else {
			let email = consumer.get("email").asStringOrVoid();

			// Some use a `mail` property
			if (loose && email === undefined) {
				email = consumer.get("mail").asStringOrVoid();
			}

			// TODO remove this
			consumer.markUsedProperty("type");

			const bugs = {
				email,
				url: consumer.get("url").asStringOrVoid(),
			};
			if (!loose) {
				consumer.enforceUsedProperties();
			}
			return bugs;
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeRootName(
		consumer,
		loose,
	) {
		if (!consumer.has("name")) {
			return {
				packageName: undefined,
				org: undefined,
			};
		}

		const prop = consumer.get("name");

		return ___R$project$rome$$romejs$codec$js$manifest$name_ts$normalizeName({
			name: prop.asString(),
			loose,
			unexpected: ({description, at, start, end}) => {
				prop.unexpected(
					description,
					{
						at,
						loc: start === undefined
							? undefined
							: prop.getLocationRange(start, end, "inner-value"),
					},
				);
			},
		});
	}

	const ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$DEPENDENCIES_KEYS = [
		"",
		"dev",
		"peer",
		"optional",
	];

	const ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$INCORRECT_DEPENDENCIES_SUFFIXES = [
		"depdenencies",
		"dependancies",
		"dependecies",
	];

	function ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$checkDependencyKeyTypo(
		key,
		prop,
	) {
		for (const depPrefixKey of ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$DEPENDENCIES_KEYS) {
			// Ignore if the key is a valid dependency key
			const depKey =
				depPrefixKey === "" ? "dependencies" : depPrefixKey + "Dependencies";
			if (key === depKey) {
				return;
			}

			// Check for casing issues
			const lowerKey = key.toLowerCase();
			if (lowerKey === depKey) {
				prop.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.INCORRECT_CAMEL_CASING(
						key,
						depKey,
					),
				);
			}

			// Check for common suffix misspellings
			for (const suffix of ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$INCORRECT_DEPENDENCIES_SUFFIXES) {
				if (lowerKey === "" + depPrefixKey + suffix) {
					prop.unexpected(
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.TYPO(
							key,
							depKey,
						),
					);
				}
			}

			// Check for kebab casing
			if (
				___R$project$rome$$romejs$string$utils$toCamelCase_ts$toCamelCase(
					depKey,
				) ===
				lowerKey
			) {
				prop.unexpected(
					___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.INCORRECT_CAMEL_CASING(
						key,
						depKey,
					),
				);
			}
		}
	}

	async function ___R$project$rome$$romejs$codec$js$manifest$index_ts$normalizeManifest(
		path,
		rawConsumer,
	) {
		const loose = path.getSegments().includes("node_modules");

		const {consumer, diagnostics} = rawConsumer.capture();

		// FIXME: There's this ridiculous node module that includes it's tests... which deliberately includes an invalid package.json
		if (path.join().includes("resolve/test/resolver/invalid_main")) {
			consumer.setValue({});
		}

		//
		if (!loose) {
			for (const [key, prop] of consumer.asMap()) {
				// Check for typos for dependencies
				___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$checkDependencyKeyTypo(
					key,
					prop,
				);

				// Check for other typos
				const correctKey = ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$TYPO_KEYS.get(
					key,
				);
				if (correctKey !== undefined) {
					prop.unexpected(
						___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.MANIFEST.TYPO(
							key,
							correctKey,
						),
					);
				}
			}
		}

		const name = ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeRootName(
			consumer,
			loose,
		);

		const manifest = {
			name,
			version: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeVersion(
				consumer,
				loose,
			),
			private: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBoolean(
				consumer,
				"private",
			) === true,
			description: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeString(
				consumer,
				"description",
			),
			license: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeLicense(
				consumer,
				loose,
			),
			type: consumer.get("type").asStringSetOrVoid(["module", "commonjs"]),
			bin: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBin(
				consumer,
				name.packageName,
				loose,
			),
			scripts: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringMap(
				consumer,
				"scripts",
				loose,
			),
			homepage: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeString(
				consumer,
				"homepage",
			),
			repository: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeRepo(
				consumer.get("repository"),
				loose,
			),
			bugs: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeBugs(
				consumer.get("bugs"),
				loose,
			),
			engines: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringMap(
				consumer,
				"engines",
				loose,
			),
			files: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePathPatterns(
				consumer.get("files"),
				loose,
			),
			keywords: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(
				consumer.get("keywords"),
				loose,
			),
			cpu: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(
				consumer.get("cpu"),
				loose,
			),
			os: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(
				consumer.get("os"),
				loose,
			),
			main: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeString(
				consumer,
				"main",
			),
			exports: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeExports(
				consumer.get("exports"),
			),
			// Dependency fields
			dependencies: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
				consumer,
				"dependencies",
				loose,
			),
			devDependencies: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
				consumer,
				"devDependencies",
				loose,
			),
			optionalDependencies: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
				consumer,
				"optionalDependencies",
				loose,
			),
			peerDependencies: ___R$project$rome$$romejs$codec$js$manifest$dependencies_ts$normalizeDependencies(
				consumer,
				"peerDependencies",
				loose,
			),
			bundledDependencies: [
				...___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(
					consumer.get("bundledDependencies"),
					loose,
				),
				// Common misspelling. We error on the existence of this for strict manifests already.
				...___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizeStringArray(
					consumer.get("bundleDependencies"),
					loose,
				),
			],
			// People fields
			author: consumer.has("author")
				? ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePerson(
						consumer.get("author"),
						loose,
					)
				: undefined,
			contributors: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePeople(
				consumer.get("contributors"),
				loose,
			),
			maintainers: ___R$$priv$project$rome$$romejs$codec$js$manifest$index_ts$normalizePeople(
				consumer.get("maintainers"),
				loose,
			),
			raw: consumer.asJSONObject(),
		};

		return {
			manifest,
			diagnostics,
		};
	}


  // project-rome/@romejs/core/master/bundler/Bundler.ts


	class ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default {
		constructor(req, config) {
			this.config = config;
			this.master = req.master;
			this.reporter = req.reporter;
			this.request = req;

			this.entries = [];

			this.compileLocker = new ___R$project$rome$$romejs$core$common$utils$Locker_ts$default();
			this.graph = new ___R$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$default(
				req,
				config.resolver,
			);
		}

		static createFromMasterRequest(req) {
			return new ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default(
				req,
				req.getBundlerConfigFromFlags(),
			);
		}

		async getResolvedEntry(unresolvedEntry) {
			const {cwd} = this.config;

			const res = await this.master.resolver.resolveEntryAssert(
				Object.assign(
					{},
					this.config.resolver,
					{
						origin: cwd,
						source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
							unresolvedEntry,
						),
					},
				),
			);

			const {master} = this;
			const resolvedEntry = res.path;

			// Now do the same resolver request but with a package
			const manifestRootResolved = master.resolver.resolveLocal(
				Object.assign(
					{},
					this.config.resolver,
					{
						origin: cwd,
						requestedType: "package",
						source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
							unresolvedEntry,
						),
					},
				),
			);
			const manifestRoot =
				manifestRootResolved.type === "FOUND"
					? manifestRootResolved.path
					: undefined;
			let manifestDef;
			if (manifestRoot !== undefined) {
				const def = master.memoryFs.getManifestDefinition(manifestRoot);
				if (def !== undefined) {
					manifestDef = def;
				}
			}

			return {manifestDef, resolvedEntry};
		}

		createBundleRequest(resolvedEntry, options, reporter) {
			const project = this.master.projectManager.assertProjectExisting(
				resolvedEntry,
			);
			const mode = project.config.bundler.mode;

			this.entries.push(resolvedEntry);
			return new ___R$project$rome$$romejs$core$master$bundler$BundleRequest_ts$default({
				bundler: this,
				mode,
				resolvedEntry,
				options,
				reporter,
			});
		}

		async compile(path) {
			const bundleRequest = this.createBundleRequest(path, {}, this.reporter);
			await bundleRequest.stepAnalyze();
			bundleRequest.diagnostics.maybeThrowDiagnosticsError();
			return await bundleRequest.compileJS(path);
		}

		// This will take multiple entry points and do some magic to make them more efficient to build in parallel
		async bundleMultiple(entries, options = {}) {
			// Clone so we can mess with it
			entries = [...entries];

			// Seed the dependency graph with all the entries at the same time
			const processor = this.request.createDiagnosticsProcessor({
				origins: [
					{
						category: "Bundler",
						message: "Analyzing dependencies for bundleMultiple",
					},
				],
			});
			const entryUids = entries.map((entry) =>
				this.master.projectManager.getUid(entry)
			);
			const analyzeProgress = this.reporter.progress({
				name: "bundler:analyze:" + entryUids.join(","),
				title: "Analyzing",
			});
			processor.setThrowAfter(100);
			await this.graph.seed({
				paths: entries,
				diagnosticsProcessor: processor,
				analyzeProgress,
				validate: false,
			});
			analyzeProgress.end();
			processor.maybeThrowDiagnosticsError();

			// Now actually bundle them
			const map = new Map();

			const progress = this.reporter.progress({title: "Bundling"});
			progress.setTotal(entries.length);

			const silentReporter = this.reporter.fork({
				streams: [],
			});

			const promises = new Set();

			// Could maybe do some of this in parallel?
			while (entries.length > 0) {
				const entry = entries.shift();

				const promise = (async () => {
					const text = ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${entry.join()}" />`;
					progress.pushText(text);
					map.set(entry, await this.bundle(entry, options, silentReporter));
					progress.popText(text);
					progress.tick();
				})();
				promise.then(() => {
					promises.delete(promise);
				});
				promises.add(promise);

				if (promises.size > 5) {
					await Promise.race(Array.from(promises));
				}
			}

			await Promise.all(Array.from(promises));

			progress.end();

			return map;
		}

		async bundleManifest({resolvedEntry, manifestDef}) {
			let bundles = [];
			const files = new Map();

			const createBundle = async (resolvedSegment, options) => {
				const bundle = await this.bundle(resolvedSegment, options);
				for (const [path, content] of bundle.files) {
					files.set(path, content);
				}
				bundles = bundles.concat(bundle.bundles);
				return bundle.entry;
			};

			const entryBundle = await createBundle(resolvedEntry, {});

			//
			const bundleBuddyStats = this.graph.getBundleBuddyStats(this.entries);
			files.set(
				"bundlebuddy.json",
				{
					kind: "stats",
					content: () =>
						___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
							bundleBuddyStats,
						)
					,
				},
			);

			// TODO ensure that __dirname is relative to the project root
			if (manifestDef !== undefined) {
				const newManifest = await this.deriveManifest(
					manifestDef,
					entryBundle,
					createBundle,
					(relative, buffer) => {
						if (!files.has(relative)) {
							files.set(
								relative,
								{
									kind: "file",
									content: () => buffer,
								},
							);
						}
					},
				);

				// If we have a `files` array then set it to all the newly added files
				// This will have included files already there that we copied
				if (newManifest.files !== undefined) {
					newManifest.files = Array.from(files.keys());
				}

				// Add a package.json with updated values
				files.set(
					"package.json",
					{
						kind: "manifest",
						content: () =>
							___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
								newManifest,
							)
						,
					},
				);
			}

			return {
				files,
				bundles,
				entry: entryBundle,
			};
		}

		async deriveManifest(manifestDef, entryBundle, createBundle, addFile) {
			// TODO figure out some way to use bundleMultiple here
			const manifest = manifestDef.manifest;

			const newManifest = Object.assign(
				{},
				___R$project$rome$$romejs$codec$js$manifest$convert_ts$convertManifestToJSON(
					manifest,
				),
				{main: entryBundle.js.path},
			);

			// TODO inherit some manifest properties from project configs
			const project = this.master.projectManager.findProjectExisting(
				manifestDef.folder,
			);
			if (project !== undefined) {
				if (newManifest.name === undefined) {
					newManifest.name = project.config.name;
				}
			}

			// TODO remove dependencies fields, probably?

			// TODO Compile a index.d.ts

			// Copy manifest.files
			if (manifest.files !== undefined) {
				const paths = await this.master.memoryFs.glob(
					manifestDef.folder,
					{
						overrideIgnore: ___R$project$rome$$romejs$path$match$index_ts$flipPathPatterns(
							manifest.files,
						),
					},
				);

				for (const path of paths) {
					const relative = manifestDef.folder.relative(path).join();
					const buffer = await ___R$project$rome$$romejs$fs$index_ts$readFile(
						path,
					);
					addFile(relative, buffer);
				}
			}

			// Compile manifest.bin files
			const bin = manifest.bin;
			if (bin !== undefined) {
				const newBin = {};
				newManifest.bin = newBin;

				const binConsumer = manifestDef.consumer.get("bin");
				const isBinShorthand = typeof binConsumer.asUnknown() === "string";

				for (const [binName, relative] of manifest.bin) {
					const location = (isBinShorthand
						? binConsumer
						: binConsumer.get(binName)).getDiagnosticLocation("inner-value");

					const absolute = await this.master.resolver.resolveAssert(
						Object.assign(
							{},
							this.config.resolver,
							{
								origin: manifestDef.folder,
								source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
									relative,
								).toExplicitRelative(),
							},
						),
						{
							location,
						},
					);

					const res = await createBundle(
						absolute.path,
						{
							prefix: "bin/" + binName,
							interpreter: "/usr/bin/env node",
						},
					);
					newBin[binName] = res.js.path;
				}
			}

			// TODO `{type: "module"}` will always fail since we've produced CJS bundles
			// rome-ignore lint/js/noDelete
			delete newManifest.type;

			return newManifest;
		}

		async bundle(resolvedEntry, options = {}, reporter = this.reporter) {
			reporter.info(
				___R$project$rome$$romejs$string$markup$escape_ts$markup`Bundling <filelink emphasis target="${resolvedEntry.join()}" />`,
			);

			const req = this.createBundleRequest(resolvedEntry, options, reporter);
			const res = await req.bundle();

			const processor = this.request.createDiagnosticsProcessor();
			processor.addDiagnostics(res.diagnostics);
			processor.maybeThrowDiagnosticsError();

			if (res.cached) {
				reporter.warn("Bundle was built completely from cache");
			}

			const prefix = options.prefix === undefined ? "" : options.prefix + "/";
			const jsPath = prefix + "index.js";
			const mapPath = jsPath + ".map";

			const files = new Map();
			files.set(
				jsPath,
				{
					kind: "entry",
					content: () => res.content,
				},
			);

			files.set(
				mapPath,
				{
					kind: "sourcemap",
					content: () => res.sourceMap.toJSON(),
				},
			);

			for (const [relative, buffer] of res.assets) {
				files.set(
					relative,
					{
						kind: "asset",
						content: () => buffer,
					},
				);
			}

			const bundle = {
				js: {
					path: jsPath,
					content: res.content,
				},
				sourceMap: {
					path: mapPath,
					map: res.sourceMap,
				},
			};
			return {
				entry: bundle,
				bundles: [bundle],
				files,
			};
		}
	}


  // project-rome/@romejs/core/master/commands/run.ts

	const ___R$project$rome$$romejs$core$master$commands$run_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: "TODO",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {args} = req.query;
			const {flags} = req.client;
			const {master} = req;
			req.expectArgumentLength(1);

			async function executeCode(path) {
				const bundler = ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(
					req,
				);
				const {entry} = await bundler.bundle(path);
				return {
					type: "executeCode",
					filename: path.join(),
					code: entry.js.content,
					map: entry.sourceMap.map.serialize(),
				};
			}

			// Get the current project
			const project = await master.projectManager.findProject(flags.cwd);

			// check for absolute paths
			const target = args[0];
			const resolved = await master.resolver.resolveEntry(
				Object.assign(
					{},
					req.getResolverOptionsFromFlags(),
					{
						source: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
							target,
						),
					},
				),
			);
			if (resolved.type === "FOUND") {
				return executeCode(resolved.path);
			}

			// check for bin files in any manifests that belong to any projects
			if (project !== undefined) {
				for (const {manifest, folder} of project.packages.values()) {
					const relative = manifest.bin.get(target);
					if (relative === undefined) {
						continue;
					}

					const resolved = await master.resolver.resolveEntryAssertPath(
						Object.assign(
							{},
							req.getResolverOptionsFromFlags(),
							{
								origin: folder,
								platform: "node",
								source: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
									relative,
								),
							},
						),
					);

					return executeCode(resolved);
				}
			}

			// TODO check node_modules/.bin

			// TODO check package.json scripts
			throw new Error('Failed to find "' + target + '"');
		},
	});


  // project-rome/@romejs/core/master/commands/publish.ts
const ___R$project$rome$$romejs$core$master$commands$publish_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: "TODO",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			req.expectArgumentLength(1);

			// TODO
		},
	});


  // project-rome/@romejs/core/master/commands/status.ts



	const ___R$project$rome$$romejs$core$master$commands$status_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: "dump memory and process info of master and workers",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback({master}) {
			const workers = await Promise.all(
				master.workerManager.getWorkers().map(async (worker) => {
					const workerStatus = await worker.bridge.status.call();

					return {
						astCacheSize: workerStatus.astCacheSize,
						heapTotal: workerStatus.memoryUsage.heapTotal,
						pid: workerStatus.pid,
						uptime: workerStatus.uptime,
						ownedBytes: worker.byteCount,
						ownedFileCount: worker.fileCount,
					};
				}),
			);

			const {heapTotal} = process.memoryUsage();
			return {
				master: {
					heapTotal,
					pid: process.pid,
					uptime: process.uptime(),
				},
				workers,
				projects: master.projectManager.getProjects().map((project) => {
					return {
						id: project.id,
					};
				}),
			};
		},
	});


  // project-rome/@romejs/core/master/commands/stop.ts
const ___R$project$rome$$romejs$core$master$commands$stop_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROCESS_MANAGEMENT,
		description: "stop daemon",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback({master}) {
			master.end();
		},
	});


  // project-rome/@romejs/codec-websocket/types.ts




	const ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES = {
		CONTINUATION: 0,
		TEXT: 1,
		BINARY: 2,
		TERMINATE: 8,
		PING: 9,
		PONG: 10,
	};

	const ___R$project$rome$$romejs$codec$websocket$types_ts$GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";


  // project-rome/@romejs/codec-websocket/frame.ts
const ___R$$priv$project$rome$$romejs$codec$websocket$frame_ts$crypto = require(
		"crypto",
	);
	function ___R$project$rome$$romejs$codec$websocket$frame_ts$isCompleteFrame(
		frame,
	) {
		return Buffer.byteLength(frame.payload) >= frame.payloadLength;
	}

	function ___R$project$rome$$romejs$codec$websocket$frame_ts$unmaskPayload(
		payload,
		mask,
		offset,
	) {
		if (mask === undefined) {
			return payload;
		}

		for (let i = 0; i < payload.length; i++) {
			payload[i] ^= mask[offset + i & 3];
		}

		return payload;
	}

	function ___R$project$rome$$romejs$codec$websocket$frame_ts$buildFrame(
		opts,
		shouldMask,
	) {
		const {opcode, fin, data} = opts;

		let offset = shouldMask ? 6 : 2;
		let dataLength = data.length;

		if (dataLength >= 65_536) {
			offset += 8;
			dataLength = 127;
		} else if (dataLength > 125) {
			offset += 2;
			dataLength = 126;
		}

		const head = Buffer.allocUnsafe(offset);

		head[0] = fin ? opcode | 128 : opcode;
		head[1] = dataLength;

		if (dataLength === 126) {
			head.writeUInt16BE(data.length, 2);
		} else if (dataLength === 127) {
			head.writeUInt32BE(0, 2);
			head.writeUInt32BE(data.length, 6);
		}

		if (shouldMask) {
			const mask = ___R$$priv$project$rome$$romejs$codec$websocket$frame_ts$crypto.randomBytes(
				4,
			);
			head[1] |= 128;
			head[offset - 4] = mask[0];
			head[offset - 3] = mask[1];
			head[offset - 2] = mask[2];
			head[offset - 1] = mask[3];

			const masked = Buffer.alloc(dataLength);
			for (let i = 0; i < dataLength; ++i) {
				masked[i] = data[i] ^ mask[i & 3];
			}

			return Buffer.concat([head, masked]);
		} else {
			return Buffer.concat([head, data]);
		}
	}

	function ___R$project$rome$$romejs$codec$websocket$frame_ts$parseFrame(buffer) {
		const firstByte = buffer.readUInt8(0);
		const isFinalFrame = Boolean(firstByte >>> 7 & 1);
		const opcode = firstByte & 15;

		const [reserved1, reserved2, reserved3] = [
			(firstByte >>> 6 & 1) === 1,
			(firstByte >>> 5 & 1) === 1,
			(firstByte >>> 4 & 1) === 1,
		];
		reserved1;
		reserved2;
		reserved3;

		const secondByte = buffer.readUInt8(1);
		const isMasked = Boolean(secondByte >>> 7 & 1);

		// Keep track of our current position as we advance through the buffer
		let currentOffset = 2;
		let payloadLength = secondByte & 127;
		if (payloadLength > 125) {
			if (payloadLength === 126) {
				payloadLength = buffer.readUInt16BE(currentOffset);
				currentOffset += 2;
			} else if (payloadLength === 127) {
				const leftPart = buffer.readUInt32BE(currentOffset);
				currentOffset += 4;

				// The maximum safe integer in JavaScript is 2^53 - 1. An error is returned

				// if payload length is greater than this number.
				if (leftPart >= Number.MAX_SAFE_INTEGER) {
					throw new Error(
						"Unsupported WebSocket frame: payload length > 2^53 - 1",
					);
				}

				const rightPart = buffer.readUInt32BE(currentOffset);
				currentOffset += 4;

				payloadLength = leftPart * Math.pow(2, 32) + rightPart;
			} else {
				throw new Error("Unknown payload length");
			}
		}

		// Get the masking key if one exists
		let mask;
		if (isMasked) {
			mask = buffer.slice(currentOffset, currentOffset + 4);
			currentOffset += 4;
		}

		let payload = ___R$project$rome$$romejs$codec$websocket$frame_ts$unmaskPayload(
			buffer.slice(currentOffset),
			mask,
			0,
		);

		return {
			fin: isFinalFrame,
			opcode,
			mask,
			payload,
			payloadLength,
		};
	}


  // project-rome/@romejs/codec-websocket/index.ts
const ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$crypto = require(
		"crypto",
	);
	const ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$url = require(
		"url",
	);
	const ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$http = require(
		"http",
	);
	const ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$net = require(
		"net",
	);
	function ___R$project$rome$$romejs$codec$websocket$index_ts$createKey(key) {
		return ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$crypto.createHash(
			"sha1",
		).update("" + key + ___R$project$rome$$romejs$codec$websocket$types_ts$GUID).digest(
			"base64",
		);
	}



	class ___R$project$rome$$romejs$codec$websocket$index_ts$WebSocketInterface {
		constructor(type, socket, reporter) {
			// When a frame is set here then any additional continuation frames payloads will be appended
			this.unfinishedFrame = undefined;

			// When a frame is set here, all additional chunks will be appended until we reach the correct payloadLength
			this.incompleteFrame = undefined;

			this.reporter = reporter;
			this.socket = socket;
			this.alive = true;
			this.type = type;

			this.completeFrameEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "WebSocketInterface.message",
			});
			this.errorEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "WebSocketInterface.error",
			});
			this.endEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "WebSocketInterface.end",
				serial: true,
			});

			socket.on(
				"data",
				(buff) => {
					this.addBuffer(buff);
				},
			);

			socket.on(
				"error",
				(err) => {
					if (err.code === "ECONNRESET") {
						this.endEvent.send();
					} else {
						this.errorEvent.send(err);
					}
				},
			);

			socket.on(
				"close",
				() => {
					this.end();
				},
			);
		}

		end() {
			if (!this.alive) {
				return;
			}

			this.alive = false;
			this.endEvent.send();
			this.socket.end();
		}

		send(buff) {
			if (typeof buff === "string") {
				this.sendFrame({
					opcode: ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.TEXT,
					fin: true,
					data: Buffer.from(buff),
				});
			} else if (buff instanceof Buffer) {
				this.sendFrame({
					opcode: ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.BINARY,
					fin: true,
					data: buff,
				});
			} else {
				throw new Error("Don't know how to send this");
			}
		}

		sendJSON(val) {
			this.send(String(JSON.stringify(val)));
		}

		sendFrame(frameOpts) {
			if (this.reporter !== undefined) {
				this.reporter.info(
					"Sending frame",
					{
						fin: frameOpts.fin,
						opcode: frameOpts.opcode,
						msg: frameOpts.data,
					},
				);
			}
			this.socket.write(
				___R$project$rome$$romejs$codec$websocket$frame_ts$buildFrame(
					frameOpts,
					this.type === "client",
				),
			);
		}

		completeFrame(frame) {
			// If we have an unfinished frame then only allow continuations
			const {unfinishedFrame} = this;
			if (unfinishedFrame !== undefined) {
				if (
					frame.opcode ===
					___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.CONTINUATION
				) {
					unfinishedFrame.payload = Buffer.concat([
						unfinishedFrame.payload,
						___R$project$rome$$romejs$codec$websocket$frame_ts$unmaskPayload(
							frame.payload,
							unfinishedFrame.mask,
							unfinishedFrame.payload.length,
						),
					]);

					if (frame.fin) {
						this.unfinishedFrame = undefined;
						this.completeFrame(unfinishedFrame);
					}
					return;
				} else {
					// Silently ignore the previous frame...
					this.unfinishedFrame = undefined;
					/*throw new Error(
          `We're waiting for a frame to finish so only allow continuation frames. Received frame: ${JSON.stringify(
            frame,
          )} Unfinished frame: ${JSON.stringify(unfinishedFrame)}`,
        );*/
				}
			}

			if (frame.fin) {
				if (
					frame.opcode ===
					___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.PING
				) {
					this.sendFrame({
						opcode: ___R$project$rome$$romejs$codec$websocket$types_ts$OPCODES.PONG,
						fin: true,
						data: frame.payload,
					});
				} else {
					// Trim off any excess payload
					let excess;
					if (frame.payload.length > frame.payloadLength) {
						excess = frame.payload.slice(frame.payloadLength);
						frame.payload = frame.payload.slice(0, frame.payloadLength);
					}

					if (this.reporter !== undefined) {
						this.reporter.info(
							"Received complete frame",
							{
								opcode: frame.opcode,
								length: frame.payloadLength,
								msg: frame.payload,
							},
						);
					}

					this.completeFrameEvent.send(frame);

					if (excess !== undefined) {
						this.addBuffer(excess);
					}
				}
			} else {
				this.unfinishedFrame = frame;
			}
		}

		addBufferToIncompleteFrame(incompleteFrame, buff) {
			incompleteFrame.payload = Buffer.concat([
				incompleteFrame.payload,
				___R$project$rome$$romejs$codec$websocket$frame_ts$unmaskPayload(
					buff,
					incompleteFrame.mask,
					incompleteFrame.payload.length,
				),
			]);

			if (
				___R$project$rome$$romejs$codec$websocket$frame_ts$isCompleteFrame(
					incompleteFrame,
				)
			) {
				this.incompleteFrame = undefined;
				this.completeFrame(incompleteFrame);
			}
		}

		addBuffer(buff) {
			// Check if we're still waiting for the rest of a payload
			const {incompleteFrame} = this;
			if (incompleteFrame !== undefined) {
				this.addBufferToIncompleteFrame(incompleteFrame, buff);
				return;
			}

			const frame = ___R$project$rome$$romejs$codec$websocket$frame_ts$parseFrame(
				buff,
			);

			if (
				___R$project$rome$$romejs$codec$websocket$frame_ts$isCompleteFrame(
					frame,
				)
			) {
				// Frame has been completed!
				this.completeFrame(frame);
			} else {
				this.incompleteFrame = frame;
			}
		}
	}

	async function ___R$project$rome$$romejs$codec$websocket$index_ts$createClient(
		rawUrl,
	) {
		const parts = ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$url.parse(
			rawUrl,
		);

		return new Promise((resolve, reject) => {
			const key = ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$crypto.randomBytes(
				16,
			).toString("base64");
			const digest = ___R$project$rome$$romejs$codec$websocket$index_ts$createKey(
				key,
			);

			const req = ___R$$priv$project$rome$$romejs$codec$websocket$index_ts$http.request({
				hostname: parts.hostname,
				port: parts.port,
				path: parts.path,
				method: "GET",
				headers: {
					Connection: "Upgrade",
					Upgrade: "websocket",
					"Sec-WebSocket-Key": key,
					"Sec-WebSocket-Version": "13",
				},
			});

			req.on(
				"response",
				(res) => {
					if (res.statusCode && res.statusCode >= 400) {
						process.stderr.write(
							"Unexpected HTTP code: " + res.statusCode + "\n",
						);
						res.pipe(process.stderr);
					} else {
						res.pipe(process.stderr);
					}
				},
			);

			req.on(
				"upgrade",
				(res, socket, head) => {
					if (res.headers["sec-websocket-accept"] !== digest) {
						socket.end();
						reject(
							new Error(
								"Digest mismatch " +
								digest +
								" !== " +
								res.headers["sec-websocket-accept"],
							),
						);
						return;
					}

					const client = new ___R$project$rome$$romejs$codec$websocket$index_ts$WebSocketInterface(
						"client",
						socket,
					);
					//client.addBuffer(head);
					head;
					resolve(client);
				},
			);

			req.on(
				"error",
				(err) => {
					reject(err);
				},
			);

			req.end();
		});
	}


  // project-rome/@romejs/codec-url/index.ts
const ___R$$priv$project$rome$$romejs$codec$url$index_ts$url = require("url");


	function ___R$project$rome$$romejs$codec$url$index_ts$consumeUrl(rawUrl) {
		const parts = ___R$$priv$project$rome$$romejs$codec$url$index_ts$url.parse(
			rawUrl,
			true,
		);

		const query = ___R$project$rome$$romejs$consume$index_ts$consumeUnknown(
			Object.assign({}, parts.query),
			"parse/url/query",
		);

		const path = ___R$project$rome$$romejs$consume$index_ts$consume({
			value: parts.pathname,
			context: {
				category: "parse/url",
				getDiagnosticPointer() {
					return {
						language: "url",
						mtime: undefined,
						sourceText: rawUrl,
						filename: "url",
						start: {
							index: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
							line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
							column: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
						},
						end: {
							index: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
								rawUrl.length - 1,
							),
							line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number1,
							column: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0(
								rawUrl.length - 1,
							),
						},
					};
				},
			},
		});

		return {query, path};
	}


  // project-rome/@romejs/core/master/web/WebRequest.ts
const ___R$$priv$project$rome$$romejs$core$master$web$WebRequest_ts$http = require(
		"http",
	);
	const ___R$$priv$project$rome$$romejs$core$master$web$WebRequest_ts$waitForever = new Promise(() => {});

	function ___R$project$rome$$romejs$core$master$web$WebRequest_ts$stripBundleSuffix(
		pathname,
	) {
		return ___R$project$rome$$romejs$string$utils$removePrefix_ts$removePrefix(
			___R$project$rome$$romejs$string$utils$removeSuffix_ts$removeSuffix(
				pathname,
				".bundle",
			),
			"/",
		);
	}

	class ___R$project$rome$$romejs$core$master$web$WebRequest_ts$default {
		constructor(server, req, res) {
			this.req = req;
			this.res = res;
			this.server = server;
			this.reporter = server.reporter;
			this.masterRequest = server.masterRequest;
			this.master = server.master;

			const reqUrl = req.url;
			if (reqUrl === undefined) {
				throw new Error("req.url should not be undefined");
			}
			this.url = ___R$project$rome$$romejs$codec$url$index_ts$consumeUrl(reqUrl);
		}

		loadRawBody() {
			const {req} = this;

			req.setEncoding("utf8");
			let rawBody = "";

			return new Promise((resolve) => {
				req.on(
					"data",
					(chunk) => {
						rawBody += chunk;
					},
				);

				req.on(
					"end",
					() => {
						resolve(rawBody);
					},
				);
			});
		}

		async dispatch() {
			const {res} = this;

			try {
				const rawBody = await this.loadRawBody();
				await this.dispatchWithBody(rawBody);
				res.end();
			} catch (err) {
				res.writeHead(500, {"Content-Type": "text/plain"});

				let diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(
					err,
				);
				if (diagnostics === undefined) {
					diagnostics = [
						___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
							err,
							{
								description: {
									category: "internalError/httpServer",
								},
							},
						),
					];
				}

				//this.request.reporter.clear();
				try {
					const printer = this.masterRequest.createDiagnosticsPrinter(
						this.master.createDiagnosticsProcessor({
							origins: [
								{
									category: "WebRequest",
								},
							],
						}),
					);
					printer.processor.addDiagnostics(diagnostics);
					await printer.print();
				} catch (err) {
					this.reporter.warn("Failed trying to print diagnostics");
					this.reporter.error(err.stack);
				}

				res.end("Diagnostics available, see console");
			}
		}

		async dispatchWithBody(body) {
			const {res} = this;
			const pathname = this.url.path.asString();
			body;

			switch (pathname) {
				case "/favicon.ico": {
					res.end("");
					break;
				}

				case "/__rome__/websocket":
					return this.handleFrontendWebsocket();

				case "/__rome__/script.js":
					return this.handleFrontendScript();

				case "/__rome__": {
					res.writeHead(200, {"Content-Type": "text/html"});
					res.end(
						___R$project$rome$$romejs$string$utils$dedent_ts$dedent`
            <!doctype html>
            <html>
              <head>
                <meta charset="utf-8">
                <title>Rome</title>
                <link rel="stylesheet" href="https://meyerweb.com/eric/tools/css/reset/reset.css">
              </head>
              <body>
                <div id="app"></div>
                <script src="/__rome__/script.js"></script>
              </body>
            </html>
          `,
					);
					break;
				}

				case "/hot":
					return this.handleDeviceWebsocket();

				default:
					return this.handleWildcard(pathname);
			}
		}

		async handleWildcard(pathname) {
			const {req, res} = this;

			// Check for *.bundle
			if (pathname.endsWith(".bundle")) {
				const handled = await this.handleBundleRequest();
				if (handled) {
					return;
				}
			}

			// Look up static file
			const project = await this.masterRequest.assertClientCwdProject();
			if (project.config.develop.serveStatic) {
				const handled = await this.handlePossibleStatic(pathname, project);
				if (handled) {
					return;
				}
			}

			this.reporter.error("Unknown request for", req.url);
			res.writeHead(404);
			res.end("Not found");
		}

		async handlePossibleStatic(pathname, project) {
			project;

			const possibleStaticPath = await this.server.pathnameToAbsolutePath(
				pathname,
			);

			// TODO check if it is a file
			if (
				possibleStaticPath !== undefined &&
				(await this.master.memoryFs.existsHard(possibleStaticPath))
			) {
				return true;
			}

			return false;
		}

		async handleFrontendScript() {
			const {res} = this;
			res.writeHead(200, {"Content-Type": "application/javascript"});

			const bundler = new ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default(
				this.masterRequest,
				{
					inlineSourceMap: false,
					cwd: this.masterRequest.client.flags.cwd,
					resolver: {
						platform: "web",
					},
				},
			);
			const resolved = await this.master.resolver.resolveEntryAssertPath({
				origin: this.masterRequest.client.flags.cwd,
				source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
					"@romejs-web/frontend",
				),
			});
			const bundle = await bundler.bundle(resolved);
			res.end(bundle.entry.js);
		}

		negotiateWebsocket() {
			const {req} = this;

			const digest = ___R$project$rome$$romejs$codec$websocket$index_ts$createKey(
				String(req.headers["sec-websocket-key"]),
			);

			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				"Sec-WebSocket-Protocol: rome",
				"Sec-WebSocket-Accept: " + digest,
				"",
				"",
			];

			req.socket.write(headers.join("\r\n"));
		}

		async handleDeviceWebsocketMessage(socket, data) {
			switch (data.type) {
				case "log":
					return this.server.printConsoleLog(data);

				case "log-opt-in":
					// ???
					return;

				case "register-entrypoints":
					/// ???
					return;

				default:
					console.log("UNKNOWN MESSAGE", data);
			}
		}

		async handleDeviceWebsocket() {
			const {req} = this;
			this.negotiateWebsocket();

			const socket = new ___R$project$rome$$romejs$codec$websocket$index_ts$WebSocketInterface(
				"server",
				req.socket,
			);
			this.server.deviceWebsockets.add(socket);

			req.socket.on(
				"error",
				(err) => {
					console.log(err.stack);
				},
			);

			this.reporter.success("Device websocket client connected");

			socket.completeFrameEvent.subscribe((frame) => {
				const text = frame.payload.toString();
				try {
					const json = JSON.parse(text);
					this.handleDeviceWebsocketMessage(socket, json);
				} catch (err) {
					if (err instanceof SyntaxError) {
						console.log("UNKNOWN FRAME", text);
						return;
					} else {
						throw err;
					}
				}
			});

			socket.errorEvent.subscribe((err) => {
				console.log(err);
			});

			socket.endEvent.subscribe(() => {
				console.log("END");
				this.server.deviceWebsockets.delete(socket);
			});

			await ___R$$priv$project$rome$$romejs$core$master$web$WebRequest_ts$waitForever;
		}

		async handleFrontendWebsocket() {
			const {req} = this;
			this.negotiateWebsocket();

			const socket = new ___R$project$rome$$romejs$codec$websocket$index_ts$WebSocketInterface(
				"server",
				req.socket,
			);
			const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromWebSocketInterface(
				___R$project$rome$$romejs$core$common$bridges$WebBridge_ts$default,
				socket,
				{
					type: "client",
				},
			);
			this.server.frontendWebsocketBridges.add(bridge);

			req.socket.on(
				"close",
				() => {
					this.server.frontendWebsocketBridges.delete(bridge);
				},
			);

			await bridge.handshake();

			this.reporter.success("Frontend websocket client connected");

			this.server.sendRequests(bridge);

			await ___R$$priv$project$rome$$romejs$core$master$web$WebRequest_ts$waitForever;
		}

		async handleBundleRequest() {
			const {res} = this;

			const {bundler, path} = await this.server.getBundler(this.url);
			const bundle = await bundler.bundle(path);
			const content = bundle.entry.js.content;

			res.writeHead(200, {"Content-Type": "application/javascript"});
			res.end(content);
			return true;
		}
	}


  // project-rome/@romejs/core/common/types/platform.ts
const ___R$project$rome$$romejs$core$common$types$platform_ts = {
		get PLATFORMS() {
			return ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS;
		},
		get PLATFORM_ALIASES() {
			return ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORM_ALIASES;
		},
	};


	const ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS = [
		"ios",
		"android",
		"mobile",
		"electron",
		"web",
		"node",
	];

	const ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORM_ALIASES = {
		ios: ["mobile"],
		android: ["mobile"],
		electron: ["web"],
		mobile: [],
		node: [],
		web: [],
	};


  // project-rome/@romejs/core/master/web/index.ts
const ___R$$priv$project$rome$$romejs$core$master$web$index_ts$http = require(
		"http",
	);






	class ___R$project$rome$$romejs$core$master$web$index_ts$WebServer {
		constructor(req) {
			const {master} = req;

			this.masterRequest = req;
			this.reporter = req.reporter;
			this.master = master;

			this.bundlerCache = new Map();

			this.savingRequests = false;
			this.clientRequestHistory = new Map();
			this.clientHistory = new Map();

			this.deviceWebsockets = new Set();
			this.frontendWebsocketBridges = new Set();

			this.server = ___R$$priv$project$rome$$romejs$core$master$web$index_ts$http.createServer((
				req,
				res,
			) => {
				const webRequest = new ___R$project$rome$$romejs$core$master$web$WebRequest_ts$default(
					this,
					req,
					res,
				);
				webRequest.dispatch();
			});

			master.clientStartEvent.subscribe((client) => {
				if (!this.savingRequests) {
					return;
				}

				const data = {
					id: client.id,
					flags: Object.assign({}, client.flags, {cwd: client.flags.cwd.join()}),
					startTime: Date.now(),
					endTime: undefined,
					stdoutAnsi: "",
					stdoutHTML: "",
				};
				this.clientHistory.set(client.id, data);
				this.refreshRequests();

				const ansiReporterStream = {
					type: "all",
					format: "ansi",
					columns: 100,
					unicode: true,
					write(chunk) {
						data.stdoutAnsi += chunk;
					},
				};

				const htmlReporterStream = {
					type: "all",
					format: "html",
					columns: 100,
					unicode: true,
					write(chunk) {
						data.stdoutHTML += chunk;
					},
				};

				client.reporter.addStream(ansiReporterStream);
				master.connectedReporters.addStream(ansiReporterStream);

				client.reporter.addStream(htmlReporterStream);
				master.connectedReporters.addStream(htmlReporterStream);

				client.bridge.endEvent.subscribe(() => {
					master.connectedReporters.removeStream(ansiReporterStream);
					master.connectedReporters.removeStream(htmlReporterStream);

					data.endTime = Date.now();
					this.refreshRequests();
				});
			});

			master.requestStartEvent.subscribe((request) => {
				if (!this.savingRequests) {
					return;
				}

				const data = {
					id: request.id,
					client: request.client.id,
					query: request.query,
					markers: [],
					response: undefined,
					startTime: Date.now(),
					endTime: undefined,
				};
				this.clientRequestHistory.set(request.id, data);
				this.refreshRequests();

				request.markerEvent.subscribe((marker) => {
					data.markers.push(marker);
					this.refreshRequests();
				});

				request.endEvent.subscribe((response) => {
					// Update completion fields
					data.response = response;
					data.endTime = Date.now();
					this.refreshRequests();
				});
			});
		}

		sendRequests(bridge) {
			bridge.requests.send({
				requests: Array.from(this.clientRequestHistory.values()),
				clients: Array.from(this.clientHistory.values()),
			});
		}

		refreshRequests() {
			for (const bridge of this.frontendWebsocketBridges) {
				this.sendRequests(bridge);
			}
		}

		close() {
			this.server.close();
		}

		listen(port) {
			this.server.listen(port);

			//this.reporter.clear();
			const url = "http://localhost:" + String(port);
			this.reporter.success(
				"Listening on <hyperlink emphasis>" + url + "</hyperlink>",
			);
			this.reporter.info(
				"Web console available at <hyperlink emphasis>" +
				url +
				"/__rome__</hyperlink>",
			);
		}

		printConsoleLog(msg) {
			const {reporter} = this.masterRequest;

			let buf = msg.data.map((arg) => {
				if (typeof arg === "string") {
					return ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
						arg,
					);
				} else {
					return ___R$project$rome$$romejs$pretty$format$index_ts$default(
						arg,
						{markup: true},
					);
				}
			}).join(" ");

			switch (msg.level) {
				case "info": {
					reporter.info(buf);
					break;
				}

				case "warn": {
					reporter.warn(buf);
					break;
				}

				case "log":
				case "trace": {
					reporter.verboseForce(buf);
					break;
				}

				case "group":
				case "groupCollapsed":
				case "groupEnd":
					reporter.logAll("TODO");
			}
		}

		async pathnameToAbsolutePath(pathname) {
			const project = await this.masterRequest.assertClientCwdProject();
			const possibleStaticPath = project.folder.append(pathname);

			// This check makes sure that files outside of the project directory cannot be served
			if (possibleStaticPath.isRelativeTo(project.folder)) {
				return possibleStaticPath;
			} else {
				return undefined;
			}
		}

		sendToAllDeviceWebsockets(msg) {
			const text = JSON.stringify(msg);
			for (const socket of this.deviceWebsockets) {
				socket.send(text);
			}
		}

		async getBundler(url) {
			const pathname = ___R$project$rome$$romejs$core$master$web$WebRequest_ts$stripBundleSuffix(
				String(url.path.asString()),
			);

			const absolute = await this.pathnameToAbsolutePath(pathname);
			if (absolute === undefined) {
				throw new Error("Pathname is attempting to escalate out of cwd");
			}

			const pathPointer = url.path.getDiagnosticLocation();
			const path = await this.master.resolver.resolveEntryAssertPath(
				{
					origin: this.masterRequest.client.flags.cwd,
					source: absolute,
				},
				pathPointer === undefined ? undefined : {location: pathPointer},
			);

			const platform = url.query.get("platform").asStringSetOrVoid(
				___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS,
			);
			const cacheKey = JSON.stringify({
				platform,
			});

			const cached = this.bundlerCache.get(cacheKey);
			if (cached !== undefined) {
				return {bundler: cached, path};
			}

			const bundlerConfig = this.masterRequest.getBundlerConfigFromFlags({
				platform,
			});

			const bundler = new ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default(
				this.masterRequest,
				bundlerConfig,
			);
			this.bundlerCache.set(cacheKey, bundler);
			return {bundler, path};
		}
	}


  // project-rome/@romejs/core/master/commands/develop.ts


	const ___R$$priv$project$rome$$romejs$core$master$commands$develop_ts$DEFAULT_PORT = 8_081;
	const ___R$project$rome$$romejs$core$master$commands$develop_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: "start a web server",
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				port: c.get("port").asNumber(
					___R$$priv$project$rome$$romejs$core$master$commands$develop_ts$DEFAULT_PORT,
				),
			};
		},
		async callback(req, flags) {
			// Initialize cwd early since we'll need it for any requests
			await req.master.projectManager.findProject(req.client.flags.cwd);

			const web = new ___R$project$rome$$romejs$core$master$web$index_ts$WebServer(
				req,
			);
			web.listen(flags.port);

			req.endEvent.subscribe(() => {
				web.close();
			});

			await new Promise(() => {});
		},
	});


  // project-rome/@romejs/core/master/commands/config.ts
const ___R$project$rome$$romejs$core$master$commands$config_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: "Modify a project config",
		usage: "(enable|disable|set) key [value]",
		examples: [
			{
				command: "set name my_awesome_project",
				description: "Set the project name",
			},
		],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {reporter} = req;
			req.expectArgumentLength(2, 3);

			const project = await req.assertClientCwdProject();

			let keyParts;
			let value;

			const [action, ...restArgs] = req.query.args;
			switch (action) {
				case "enable": {
					req.expectArgumentLength(2);
					keyParts = req.query.args[1];
					value = true;
					break;
				}

				case "disable": {
					req.expectArgumentLength(2);
					keyParts = req.query.args[1];
					value = false;
					break;
				}

				case "set-directory": {
					req.expectArgumentLength(3);
					[keyParts, value] = restArgs;

					// If the value is an absolute path, then make it relative to the project folder
					const path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
						value,
					);
					if (path.isAbsolute()) {
						value = ___R$project$rome$$romejs$project$utils_ts$assertHardMeta(
							project.meta,
						).projectFolder.relative(path).join();
					}

					break;
				}

				case "set": {
					req.expectArgumentLength(3);
					[keyParts, value] = restArgs;
					break;
				}

				default:
					throw req.throwDiagnosticFlagError({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.FLAGS.UNKNOWN_ACTION(
							action,
						),
						target: {
							type: "arg",
							key: 0,
						},
					});
			}

			try {
				await ___R$project$rome$$romejs$project$save_ts$modifyProjectConfig(
					project.meta,
					{
						pre: (meta) => {
							reporter.success(
								___R$project$rome$$romejs$string$markup$escape_ts$markup`Setting <emphasis>${keyParts}</emphasis> to <emphasis>${JSON.stringify(
									value,
								)}</emphasis> in the project config <filelink emphasis target="${meta.configPath.join()}" />`,
							);

							if (value === "true" || value === "false") {
								const suggestedCommand = value === "true" ? "enable" : "disable";
								reporter.warn(
									___R$project$rome$$romejs$string$markup$escape_ts$markup`Value is the string <emphasis>${value}</emphasis> but it looks like a boolean. You probably meant to use the command:`,
								);
								reporter.command(
									___R$project$rome$$romejs$string$markup$escape_ts$markup`config ${suggestedCommand} ${keyParts}`,
								);
							}
						},
						modify: (consumer) => {
							// Set the specified value
							let keyConsumer = consumer;
							for (const key of keyParts.split(".")) {
								if (!keyConsumer.exists()) {
									keyConsumer.setValue({});
								}
								keyConsumer = keyConsumer.get(key);
							}
							keyConsumer.setValue(value);
						},
					},
				);
			} catch (err) {
				reporter.error(
					"Error occured while testing new project config. Your changes have not been saved.",
				);
				throw err;
			}
		},
	});


  // project-rome/@romejs/core/master/commands/compile.ts

	const ___R$project$rome$$romejs$core$master$commands$compile_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: "compile a single file",
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				bundle: c.get("bundle").asBoolean(false),
			};
		},
		async callback(req, commandFlags) {
			const {master, reporter} = req;
			const {args} = req.query;
			req.expectArgumentLength(1);

			const resolved = await master.resolver.resolveEntryAssert(
				Object.assign(
					{},
					req.getResolverOptionsFromFlags(),
					{
						source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
							args[0],
						),
					},
				),
				{location: req.getDiagnosticPointerFromFlags({type: "arg", key: 0})},
			);

			let res;
			if (commandFlags.bundle) {
				const bundler = ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(
					req,
				);
				res = await bundler.compile(resolved.path);
			} else {
				res = await req.requestWorkerCompile(resolved.path, "compile", {}, {});
			}

			const {compiledCode, diagnostics, suppressions} = res;

			if (diagnostics.length > 0) {
				throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
					"Compile diagnostics",
					diagnostics,
					suppressions,
				);
			}

			reporter.writeAll(compiledCode);
		},
	});


  // project-rome/@romejs/core/master/commands/resolve.ts
const ___R$project$rome$$romejs$core$master$commands$resolve_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: "resolve a file",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {master, reporter} = req;
			const {args} = req.query;
			const {flags} = req.client;
			req.expectArgumentLength(1, 2);

			let origin;
			let relative = "";
			let key;

			if (args.length === 2) {
				origin = flags.cwd.resolveMaybeUrl(args[0]);
				relative = args[1];
				key = 1;
			} else {
				origin = flags.cwd;
				relative = args[0];
				key = 0;
			}

			const query = Object.assign(
				{},
				req.getResolverOptionsFromFlags(),
				{
					origin,
					source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
						relative,
					),
				},
			);

			const resolved = await master.resolver.resolveEntryAssert(
				query,
				{
					location: req.getDiagnosticPointerFromFlags({type: "arg", key}),
				},
			);
			const filename = resolved.ref.real.join();
			reporter.logAll(filename);
			return filename;
		},
	});


  // project-rome/@romejs/core/master/commands/analyzeDependencies.ts


	function ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(
		obj,
	) {
		const ___R$ = obj;
		const locless = Object.assign({}, ___R$);
		delete locless.loc;
		const {loc} = ___R$;
		loc;
		return locless;
	}
	const ___R$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: "analyze and dump the dependencies of a file",
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				compact: c.get("compact").asBoolean(false),
				focusSource: c.get("focusSource").asStringOrVoid(),
			};
		},
		async callback(req, commandFlags) {
			const {master, reporter} = req;
			const {args} = req.query;
			req.expectArgumentLength(1);

			const filename = await master.resolver.resolveEntryAssertPath(
				Object.assign(
					{},
					req.getResolverOptionsFromFlags(),
					{
						source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
							args[0],
						),
					},
				),
				{location: req.getDiagnosticPointerFromFlags({type: "arg", key: 0})},
			);

			let res = await req.requestWorkerAnalyzeDependencies(filename, {});

			const {focusSource} = commandFlags;
			if (focusSource !== undefined) {
				res = Object.assign(
					{},
					res,
					{
						importFirstUsage: res.importFirstUsage.filter((dep) => {
							return dep.source === focusSource;
						}),
						dependencies: res.dependencies.filter((dep) => {
							return dep.source === focusSource;
						}),
					},
				);
			}

			if (commandFlags.compact) {
				res = Object.assign(
					{},
					res,
					{
						importFirstUsage: res.importFirstUsage.map((imp) => {
							return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(
								imp,
							);
						}),
						exports: res.exports.map((exp) => {
							// This weird switch is because TS only returns an object with the properties common amongst all
							switch (exp.type) {
								case "local":
									return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(
										exp,
									);

								case "external":
									return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(
										exp,
									);

								case "externalAll":
									return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(
										exp,
									);

								case "externalNamespace":
									return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(
										exp,
									);
							}
						}),
						dependencies: res.dependencies.map((dep) => {
							return Object.assign(
								{},
								___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(
									dep,
								),
								{
									names: dep.names.map((name) => {
										return ___R$$priv$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$removeLoc(
											name,
										);
									}),
								},
							);
						}),
					},
				);
			}

			reporter.inspect(res);
		},
	});


  // project-rome/@romejs/core/master/commands/parse.ts

	const ___R$project$rome$$romejs$core$master$commands$parse_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: "parse a single file and dump its ast",
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				allowDiagnostics: c.get("allowDiagnostics").asBoolean(false),
				compact: c.get("compact").asBoolean(true),
				sourceType: c.get("sourceType").asStringSetOrVoid(["module", "script"]),
			};
		},
		async callback(req, flags) {
			const {master, reporter} = req;
			const {args} = req.query;
			req.expectArgumentLength(1);

			const filename = await master.resolver.resolveEntryAssertPath(
				Object.assign(
					{},
					req.getResolverOptionsFromFlags(),
					{
						source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
							args[0],
						),
					},
				),
				{location: req.getDiagnosticPointerFromFlags({type: "arg", key: 0})},
			);

			let ast = await req.requestWorkerParse(
				filename,
				{
					sourceType: flags.sourceType,
					allowParserDiagnostics: flags.allowDiagnostics,
				},
			);

			if (flags.compact) {
				ast = ___R$project$rome$$romejs$js$ast$core$Program_ts$program.assert(
					___R$project$rome$$romejs$js$ast$utils$removeLoc_ts$default(ast),
				);
			}

			reporter.inspect(ast);
		},
	});


  // project-rome/@romejs/core/master/commands/bundle.ts

	const ___R$project$rome$$romejs$core$master$commands$bundle_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.SOURCE_CODE,
		description: "build a standalone js bundle for a package",
		usage: "",
		examples: [],
		defineFlags(consumer) {
			return {
				quiet: consumer.get("quiet").asBoolean(false),
			};
		},
		async callback(req, commandFlags) {
			const {flags} = req.client;
			const {args} = req.query;
			const {reporter} = req;
			req.expectArgumentLength(2);

			const [entryFilename, outputFolder] = args;
			const bundler = ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default.createFromMasterRequest(
				req,
			);

			const resolution = await bundler.getResolvedEntry(entryFilename);
			const {files: outFiles} = await bundler.bundleManifest(resolution);

			const savedList = [];
			const dir = flags.cwd.resolve(outputFolder);
			for (const [filename, {kind, content}] of outFiles) {
				const buff = content();
				const file = dir.append(filename);
				const loc = file.join();
				savedList.push(
					___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${loc}">${filename}</filelink> <filesize dim>${Buffer.byteLength(
						buff,
					)}</filesize> <inverse>${kind}</inverse>`,
				);
				await ___R$project$rome$$romejs$fs$index_ts$createDirectory(
					file.getParent(),
					{recursive: true},
				);
				await ___R$project$rome$$romejs$fs$index_ts$writeFile(file, buff);
			}

			if (commandFlags.quiet) {
				reporter.success(
					___R$project$rome$$romejs$string$markup$escape_ts$markup`Saved to <filelink target="${dir.join()}" />`,
				);
			} else {
				reporter.success(
					___R$project$rome$$romejs$string$markup$escape_ts$markup`Saved the following files to <filelink target="${dir.join()}" />`,
				);
				reporter.list(savedList);
			}
		},
	});


  // project-rome/@romejs/core/master/commands/format.ts

	const ___R$project$rome$$romejs$core$master$commands$format_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.INTERNAL,
		description: "TODO",
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				allowDiagnostics: c.get("allowDiagnostics").asBoolean(false),
			};
		},
		async callback(req, flags) {
			const {reporter, master} = req;
			const {args} = req.query;
			req.expectArgumentLength(1);

			const filename = await master.resolver.resolveEntryAssertPath(
				Object.assign(
					{},
					req.getResolverOptionsFromFlags(),
					{
						source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
							args[0],
						),
					},
				),
				{location: req.getDiagnosticPointerFromFlags({type: "arg", key: 0})},
			);

			const res = await req.requestWorkerFormat(
				filename,
				{
					allowParserDiagnostics: flags.allowDiagnostics,
				},
			);

			if (res === undefined) {
				reporter.error("No formatter for this file");
				return undefined;
			} else {
				reporter.writeAll(res.formatted);
				return res.formatted;
			}
		},
	});


  // project-rome/@romejs/core/master/linter/Linter.ts














	function ___R$$priv$project$rome$$romejs$core$master$linter$Linter_ts$createDiagnosticsPrinter(
		request,
		processor,
		totalCount,
		savedCount,
	) {
		const printer = request.createDiagnosticsPrinter(processor);

		printer.onFooterPrint((reporter, isError) => {
			if (isError) {
				let hasPendingFixes = false;

				for (const {fixable} of processor.getDiagnostics()) {
					if (fixable) {
						hasPendingFixes = true;
					}
				}

				if (hasPendingFixes) {
					reporter.info(
						"Fixes available. To apply recommended fixes and formatting run",
					);
					reporter.command("rome lint --save");
					reporter.info("To choose fix suggestions run");
					reporter.command("rome lint --review");
				}
			}

			if (savedCount > 0) {
				reporter.success(
					"<number emphasis>" +
					savedCount +
					'</number> <grammarNumber plural="files" singular="file">' +
					savedCount +
					"</grammarNumber> updated",
				);
			}

			if (!isError) {
				if (totalCount === 0) {
					reporter.warn("No files linted");
				} else {
					reporter.info(
						"<number emphasis>" +
						totalCount +
						'</number> <grammarNumber plural="files" singular="file">' +
						totalCount +
						"</grammarNumber> linted",
					);
				}
			}
		});

		return printer;
	}

	class ___R$$priv$project$rome$$romejs$core$master$linter$Linter_ts$LintRunner {
		constructor(
			linter,
			{
				graph,
				events,
			},
		) {
			this.linter = linter;
			this.master = linter.request.master;
			this.graph = graph;
			this.request = linter.request;
			this.options = linter.options;
			this.events = events;
			this.compilerDiagnosticsCache = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.hadDependencyValidationErrors = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
		}

		async runLint(
			{
				evictedPaths,
				processor,
			},
		) {
			let savedCount = 0;
			const {master} = this.request;

			const {
				lintCompilerOptionsPerFile = {},
				globalDecisions = [],
				hasDecisions,
			} = this.options;
			const shouldSave = this.linter.shouldSave();
			const shouldApplyFixes = !this.linter.shouldOnlyFormat();

			const queue = new ___R$project$rome$$romejs$core$master$WorkerQueue_ts$default(
				master,
			);

			const progress = this.events.createProgress({title: "Linting"});
			progress.setTotal(evictedPaths.size);

			queue.addCallback(async (path) => {
				const filename = path.join();
				const text = ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${filename}" />`;
				progress.pushText(text);

				let compilerOptions = lintCompilerOptionsPerFile[filename];

				// If we have decisions then make sure it's declared on all files
				if (hasDecisions) {
					if (compilerOptions === undefined) {
						compilerOptions = {
							hasDecisions: true,
							globalDecisions,
							decisionsByPosition: {},
						};
					} else {
						compilerOptions = Object.assign(
							{},
							compilerOptions,
							{
								hasDecisions: true,
								globalDecisions: [
									...(compilerOptions.globalDecisions || []),
									...globalDecisions,
								],
							},
						);
					}
				}

				const {
					diagnostics,
					suppressions,
					saved,
				} = await this.request.requestWorkerLint(
					path,
					{
						save: shouldSave,
						applyFixes: shouldApplyFixes,
						compilerOptions,
					},
				);
				processor.addSuppressions(suppressions);
				processor.addDiagnostics(diagnostics);
				this.compilerDiagnosticsCache.set(path, {suppressions, diagnostics});
				if (saved) {
					savedCount++;
				}

				progress.popText(text);
				progress.tick();
			});

			for (const path of evictedPaths) {
				await queue.pushQueue(path);
			}

			await queue.spin();
			progress.end();

			return {savedCount};
		}

		async runGraph(
			{
				evictedPaths,
				processor,
				firstRun,
			},
		) {
			const {graph} = this;

			// Get all the current dependency nodes for the evicted files, and invalidate their nodes
			const oldEvictedNodes = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			for (const path of evictedPaths) {
				const node = graph.maybeGetNode(path);
				if (node !== undefined) {
					oldEvictedNodes.set(path, node);
					graph.deleteNode(path);
				}
			}

			// Refresh only the evicted paths
			const progress = this.events.createProgress({
				title: firstRun ? "Analyzing files" : "Analyzing changed files",
			});
			await graph.seed({
				paths: Array.from(evictedPaths),
				diagnosticsProcessor: processor,
				validate: false,
				analyzeProgress: progress,
			});
			progress.end();

			// Maintain a list of all the dependencies we revalidated
			const validatedDependencyPaths = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

			// Maintain a list of all the dependents that need to be revalidated
			const validatedDependencyPathDependents = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

			// Build a list of dependents to recheck
			for (const path of evictedPaths) {
				validatedDependencyPaths.add(path);

				const newNode = graph.getNode(path);

				// Get the previous node and see if the exports have actually changed
				const oldNode = oldEvictedNodes.get(path);
				const sameShape =
					oldNode !== undefined &&
					___R$project$rome$$romejs$js$compiler$api$analyzeDependencies$utils_ts$areAnalyzeDependencyResultsEqual(
						oldNode.analyze,
						newNode.analyze,
					);

				for (const depNode of newNode.getDependents()) {
					// If the old node has the same shape as the new one, only revalidate the dependent if it had dependency errors
					if (
						sameShape &&
						this.hadDependencyValidationErrors.get(depNode.path) === false
					) {
						continue;
					}

					validatedDependencyPaths.add(depNode.path);
					validatedDependencyPathDependents.add(depNode.path);
				}
			}

			// Revalidate dependents
			if (validatedDependencyPathDependents.size > 0) {
				const progress = this.events.createProgress({
					title: "Analyzing dependents",
				});

				await graph.seed({
					paths: Array.from(validatedDependencyPaths),
					diagnosticsProcessor: processor,
					validate: false,
					analyzeProgress: progress,
				});

				progress.end();
			}

			// Validate connections
			for (const path of validatedDependencyPaths) {
				const hasValidationErrors = graph.validate(
					graph.getNode(path),
					processor,
				);
				this.hadDependencyValidationErrors.set(path, hasValidationErrors);
			}

			return validatedDependencyPaths;
		}

		computeChanges({evictedPaths, processor}, validatedDependencyPaths) {
			const {master} = this;
			const changes = [];

			const updatedPaths = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet([
				...validatedDependencyPaths,
			]);

			const diagnosticsByFilename = processor.getDiagnosticsByFilename();

			// In case we pushed on any diagnostics that aren't from the input paths, try to resolve them
			const includedFilenamesInDiagnostics = master.projectManager.normalizeFilenamesToFilePaths(
				diagnosticsByFilename.keys(),
			);
			for (const path of includedFilenamesInDiagnostics.absolutes) {
				updatedPaths.add(path);
			}

			// If we validated the diagnostics of the dependents, then we need to also push their previous compiler diagnostics
			for (const path of validatedDependencyPaths) {
				if (!evictedPaths.has(path)) {
					const compilerDiagnostics = this.compilerDiagnosticsCache.get(path);
					if (compilerDiagnostics !== undefined) {
						processor.addSuppressions(compilerDiagnostics.suppressions);
						processor.addDiagnostics(compilerDiagnostics.diagnostics);
					}
				}
			}

			// We can't just use getDiagnosticFilenames as we need to produce empty arrays for removed diagnostics
			for (const path of updatedPaths) {
				const ref = this.request.master.projectManager.getFileReference(path);
				const diagnostics = [
					...(diagnosticsByFilename.get(ref.uid) || []),
					...(diagnosticsByFilename.get(ref.real.join()) || []),
				];

				changes.push({
					filename: ref.uid,
					ref,
					diagnostics,
				});
			}

			// We can produce diagnostics that don't actually point at a file. For LSP we will just throw these away,

			// otherwise inside of Rome we can display them.

			// These filenames may be relative or undefined
			for (const filename of includedFilenamesInDiagnostics.others) {
				changes.push({
					filename,
					ref: undefined,
					diagnostics: diagnosticsByFilename.get(filename) || [],
				});
			}

			return changes;
		}

		async run(opts) {
			this.events.onRunStart();
			const {savedCount} = await this.runLint(opts);
			const validatedDependencyPaths = await this.runGraph(opts);
			const changes = await this.computeChanges(opts, validatedDependencyPaths);
			return {
				evictedPaths: opts.evictedPaths,
				changes,
				savedCount,
				totalCount: opts.evictedPaths.size,
				runner: this,
			};
		}
	}

	class ___R$project$rome$$romejs$core$master$linter$Linter_ts$default {
		constructor(req, opts) {
			this.request = req;
			this.options = opts;
		}

		shouldOnlyFormat() {
			const {formatOnly} = this.options;
			const {review} = this.request.query.requestFlags;
			return formatOnly || review;
		}

		shouldSave() {
			const {save, hasDecisions} = this.options;
			return save || hasDecisions || this.shouldOnlyFormat();
		}

		getFileArgOptions() {
			return {
				args: this.options.args,
				noun: "lint",
				verb: "linting",
				configCategory: "lint",
				extensions: ___R$project$rome$$romejs$core$common$file$handlers$index_ts$LINTABLE_EXTENSIONS,
				disabledDiagnosticCategory: "lint/disabled",
			};
		}

		createDiagnosticsProcessor(evictedPaths, runner) {
			const processor = this.request.createDiagnosticsProcessor({
				origins: [
					{
						category: "lint",
						message: "Dispatched",
					},
				],
			});

			processor.addAllowedUnusedSuppressionPrefix("bundler");

			// Only display files that aren't absolute, are in the changed paths, or have had previous compiler diagnostics

			// This hides errors that have been lint ignored but may have been produced by dependency analysis
			processor.addFilter({
				test: (diag) => {
					const absolute = this.request.master.projectManager.getFilePathFromUidOrAbsolute(
						diag.location.filename,
					);
					return (
						absolute === undefined ||
						evictedPaths.has(absolute) ||
						runner.compilerDiagnosticsCache.has(absolute)
					);
				},
			});

			return processor;
		}

		async watch(events) {
			const graph = new ___R$project$rome$$romejs$core$master$dependencies$DependencyGraph_ts$default(
				this.request,
				this.request.getResolverOptionsFromFlags(),
			);

			const runner = new ___R$$priv$project$rome$$romejs$core$master$linter$Linter_ts$LintRunner(
				this,
				{
					events,
					graph,
				},
			);

			let firstRun = true;

			return this.request.watchFilesFromArgs(
				this.getFileArgOptions(),
				async ({paths: evictedPaths}, initial) => {
					const processor = this.createDiagnosticsProcessor(
						evictedPaths,
						runner,
					);

					const result = await runner.run({firstRun, evictedPaths, processor});
					events.onChanges(result, initial, runner);
					firstRun = false;
				},
			);
		}

		async run(watch) {
			const {request} = this;
			const {reporter} = request;

			let printer;

			const diagnosticsByFilename = new Map();

			const watchEvent = await this.watch({
				onRunStart: () => {
					if (watch) {
						reporter.clearScreen();
					}
				},
				createProgress: (opts) => {
					return reporter.progress(opts);
				},
				onChanges: ({evictedPaths, changes, totalCount, savedCount, runner}) => {
					printer = ___R$$priv$project$rome$$romejs$core$master$linter$Linter_ts$createDiagnosticsPrinter(
						request,
						this.createDiagnosticsProcessor(evictedPaths, runner),
						totalCount,
						savedCount,
					);

					// Update our diagnostics with the changes
					for (const {filename, diagnostics} of changes) {
						if (diagnostics.length === 0) {
							diagnosticsByFilename.delete(filename);
						} else {
							diagnosticsByFilename.set(filename, diagnostics);
						}
					}

					// Print all diagnostics
					for (const diagnostics of diagnosticsByFilename.values()) {
						printer.processor.addDiagnostics(diagnostics);
					}

					if (watch) {
						reporter.clearScreen();
						printer.print();
						printer.footer();
					}
				},
			});

			if (watch) {
				await request.endEvent.wait();
			} else {
				watchEvent.unsubscribe();

				if (printer === undefined) {
					throw new Error("Expected a printer");
				}

				throw printer;
			}
		}
	}


  // project-rome/@romejs/core/master/lsp/LSPServer.ts




	const ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$HEADERS_END = "\r\n\r\n";

	function ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$parseHeaders(
		buffer,
	) {
		const headers = new Map();

		for (const line of buffer.split("\n")) {
			const clean = line.trim();
			const match = clean.match(/^(.*?): (.*?)$/);
			if (match == null) {
				throw new Error("Invalid header: " + clean);
			}

			const [, key, value] = match;
			headers.set(key.toLowerCase(), value);
		}

		const length = headers.get("content-length");
		if (length === undefined) {
			throw new Error("Expected Content-Length");
		}
		headers.delete("content-length");

		return {
			length: Number(length),
			extra: headers,
		};
	}

	function ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$convertPositionToLSP(
		pos,
	) {
		if (pos === undefined) {
			return {
				line: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
				character: ___R$project$rome$$romejs$ob1$index_ts$ob1Number0,
			};
		} else {
			return {
				line: ___R$project$rome$$romejs$ob1$index_ts$ob1Coerce1To0(pos.line),
				character: pos.column,
			};
		}
	}

	function ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$convertDiagnosticLocationToLSPRange(
		location,
	) {
		return {
			start: ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$convertPositionToLSP(
				location.start,
			),
			end: ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$convertPositionToLSP(
				location.end,
			),
		};
	}

	function ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$convertDiagnosticsToLSP(
		diagnostics,
		master,
	) {
		const lspDiagnostics = [];

		for (const {description, location} of diagnostics) {
			// Infer relatedInformation from log messages followed by frames
			let relatedInformation = [];
			const {advice} = description;
			for (let i = 0; i < advice.length; i++) {
				const item = advice[i];
				const nextItem = advice[i + 1];
				if (
					item.type === "log" &&
					nextItem !== undefined &&
					nextItem.type === "frame"
				) {
					const abs = master.projectManager.getFilePathFromUidOrAbsolute(
						nextItem.location.filename,
					);
					if (abs !== undefined) {
						relatedInformation.push({
							message: ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainTextString(
								item.text,
							),
							location: {
								uri: "file://" + abs.join(),
								range: ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$convertDiagnosticLocationToLSPRange(
									nextItem.location,
								),
							},
						});
					}
				}
			}

			lspDiagnostics.push({
				severity: 1,
				range: ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$convertDiagnosticLocationToLSPRange(
					location,
				),
				message: ___R$project$rome$$romejs$string$markup$format_ts$markupToPlainTextString(
					description.message.value,
				),
				code: description.category,
				source: "rome",
				relatedInformation,
			});
		}

		return lspDiagnostics;
	}

	function ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$getPathFromTextDocument(
		consumer,
	) {
		return ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
			consumer.get("uri").asString(),
		);
	}

	function ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$diffTextEdits(
		original,
		desired,
	) {
		const edits = [];

		const diffs = ___R$project$rome$$romejs$string$diff$index_ts$default(
			original,
			desired,
		);

		let currLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
		let currChar = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;

		function advance(str) {
			for (const char of str) {
				if (char === "\n") {
					currLine = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(currLine);
					currChar = ___R$project$rome$$romejs$ob1$index_ts$ob1Number0;
				} else {
					currChar = ___R$project$rome$$romejs$ob1$index_ts$ob1Inc(currChar);
				}
			}
		}

		function getPosition() {
			return {
				line: currLine,
				character: currChar,
			};
		}

		for (const [type, text] of diffs) {
			switch (type) {
				case ___R$project$rome$$romejs$string$diff$index_ts$diffConstants.ADD: {
					const pos = getPosition();
					edits.push({
						range: {
							start: pos,
							end: pos,
						},
						newText: text,
					});
					break;
				}

				case ___R$project$rome$$romejs$string$diff$index_ts$diffConstants.DELETE: {
					const start = getPosition();
					advance(text);
					const end = getPosition();
					edits.push({
						range: {
							start,
							end,
						},
						newText: "",
					});
					break;
				}

				case ___R$project$rome$$romejs$string$diff$index_ts$diffConstants.EQUAL: {
					advance(text);
					break;
				}
			}
		}

		return edits;
	}

	let ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$progressTokenCounter = 0;

	class ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$LSPProgress
		extends ___R$project$rome$$romejs$cli$reporter$ProgressBase_ts$default {
		constructor(server, reporter, opts) {
			super(reporter, opts);
			this.server = server;
			this.token = ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$progressTokenCounter++;
			this.lastRenderKey = "";

			server.write({
				type: "$/progress",
				params: {
					token: this.token,
					value: {
						kind: "begin",
						cancellable: false,
						title: this.title,
						percentage: 0,
					},
				},
			});
		}

		render() {
			const total = this.total === undefined ? 0 : this.total;
			const percentage = Math.floor(100 / total * this.current);

			// Make sure we don't send pointless duplicate messages
			const renderKey = "percent:" + percentage + ",text:" + this.text;
			if (this.lastRenderKey === renderKey) {
				return;
			}

			this.lastRenderKey = renderKey;
			this.server.write({
				type: "$/progress",
				params: {
					token: this.token,
					value: {
						kind: "report",
						cancellable: false,
						message: this.text,
						percentage,
					},
				},
			});
		}

		end() {
			this.server.write({
				type: "$/progress",
				params: {
					token: this.token,
					value: {
						kind: "end",
					},
				},
			});
		}
	}

	class ___R$project$rome$$romejs$core$master$lsp$LSPServer_ts$default {
		constructor(request) {
			this.status = "IDLE";
			this.buffer = "";
			this.nextHeaders = undefined;

			this.request = request;
			this.master = request.master;
			this.client = request.client;

			this.lintSessionsPending = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();
			this.lintSessions = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();

			request.endEvent.subscribe(() => {
				this.shutdown();
			});
		}

		write(res) {
			const json = JSON.stringify(res);
			const out =
				"Content-Length: " +
				String(json.length) +
				___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$HEADERS_END +
				json;
			this.client.bridge.lspFromServerBuffer.send(out);
		}

		createFakeMasterRequest(commandName, args = []) {
			return new ___R$project$rome$$romejs$core$master$MasterRequest_ts$default({
				client: this.client,
				master: this.master,
				query: {
					requestFlags: ___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS,
					commandFlags: {},
					args,
					commandName,
					silent: true,
					noData: false,
					terminateWhenIdle: false,
				},
			});
		}

		unwatchProject(path) {
			// TODO maybe unset all buffers?
			const req = this.lintSessions.get(path);
			if (req !== undefined) {
				req.teardown(
					___R$project$rome$$romejs$core$master$MasterRequest_ts$EMPTY_SUCCESS_RESPONSE,
				);
				this.lintSessions.delete(path);
			}
		}

		createProgress(opts) {
			return new ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$LSPProgress(
				this,
				this.request.reporter,
				opts,
			);
		}

		async watchProject(path) {
			if (this.lintSessions.has(path) || this.lintSessionsPending.has(path)) {
				return;
			}

			this.lintSessionsPending.add(path);

			const project = await this.master.projectManager.findProject(path);

			if (project === undefined) {
				// Not a Rome project
				this.lintSessionsPending.delete(path);
				return;
			}

			const req = this.createFakeMasterRequest("lsp_project", [path.join()]);
			await req.init();

			const linter = new ___R$project$rome$$romejs$core$master$linter$Linter_ts$default(
				req,
				{
					save: false,
					hasDecisions: false,
					formatOnly: false,
				},
			);

			const subscription = await linter.watch({
				onRunStart: () => {},
				createProgress: () => {
					return this.createProgress();
				},
				onChanges: ({changes}) => {
					for (const {ref, diagnostics} of changes) {
						if (ref === undefined) {
							// Cannot display diagnostics without a reference
							continue;
						}

						// We want to filter pendingFixes because we'll autoformat the file on save if necessary and it's just noise
						const processor = this.request.createDiagnosticsProcessor();
						processor.addFilter({
							category: "lint/pendingFixes",
						});
						processor.addDiagnostics(diagnostics);

						this.write({
							method: "textDocument/publishDiagnostics",
							params: {
								uri: "file://" + ref.real.join(),
								diagnostics: ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$convertDiagnosticsToLSP(
									processor.getDiagnostics(),
									this.master,
								),
							},
						});
					}
				},
			});

			req.endEvent.subscribe(() => {
				subscription.unsubscribe();
			});

			this.lintSessions.set(path, req);
			this.lintSessionsPending.delete(path);
		}

		shutdown() {
			for (const path of this.lintSessions.keys()) {
				this.unwatchProject(path);
			}
			this.lintSessions.clear();
		}

		async sendClientRequest(req) {
			return this.master.handleRequest(
				this.client,
				Object.assign({silent: true}, req),
			);
		}

		async handleRequest(method, params) {
			switch (method) {
				case "initialize": {
					const rootUri = params.get("rootUri");
					if (rootUri.exists()) {
						this.watchProject(
							___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
								rootUri.asString(),
							),
						);
					}

					const workspaceFolders = params.get("workspaceFolders");
					if (workspaceFolders.exists()) {
						for (const elem of workspaceFolders.asArray()) {
							this.watchProject(
								___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$getPathFromTextDocument(
									elem,
								),
							);
						}
					}

					return {
						capabilities: {
							textDocumentSync: {
								openClose: true,
								// This sends over the full text on change. We should make this incremental later
								change: 1,
							},
							documentFormattingProvider: true,
							workspaceFolders: {
								supported: true,
								changeNotifications: true,
							},
						},
						serverInfo: {
							name: "rome",
						},
					};
				}

				case "textDocument/formatting": {
					const path = ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$getPathFromTextDocument(
						params.get("textDocument"),
					);

					const project = this.master.projectManager.findProjectExisting(path);
					if (project === undefined) {
						// Not in a Rome project
						return null;
					}

					const res = await this.request.requestWorkerFormat(path, {});
					if (res === undefined) {
						// Not a file we support formatting
						return null;
					}

					return ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$diffTextEdits(
						res.original,
						res.formatted,
					);
				}

				case "shutdown": {
					this.shutdown();
					break;
				}
			}

			return null;
		}

		async handleNotification(method, params) {
			switch (method) {
				case "workspace/didChangeWorkspaceFolders": {
					for (const elem of params.get("added").asArray()) {
						this.watchProject(
							___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$getPathFromTextDocument(
								elem,
							),
						);
					}
					for (const elem of params.get("removed").asArray()) {
						this.unwatchProject(
							___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$getPathFromTextDocument(
								elem,
							),
						);
					}
					break;
				}

				case "textDocument/didChange": {
					const path = ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$getPathFromTextDocument(
						params.get("textDocument"),
					);
					const content = params.get("contentChanges").asArray()[0].get("text").asString();
					await this.request.requestWorkerUpdateBuffer(path, content);
					break;
				}
			}
		}

		normalizeMessage(content) {
			try {
				const data = JSON.parse(content);
				const consumer = ___R$project$rome$$romejs$consume$index_ts$consumeUnknown(
					data,
					"lsp/parse",
				);
				return consumer;
			} catch (err) {
				if (err instanceof SyntaxError) {
					console.error("JSON parse error", content);
					return undefined;
				} else {
					throw err;
				}
			}
		}

		async onMessage(headers, content) {
			const consumer = this.normalizeMessage(content);
			if (consumer === undefined) {
				return;
			}

			if (!consumer.has("method")) {
				console.error("NO METHOD", content);
				return;
			}

			const method = consumer.get("method").asString();
			const params = consumer.get("params");

			if (consumer.has("id")) {
				const id = consumer.get("id").asNumber();

				try {
					const res = {
						id,
						result: await this.handleRequest(method, params),
					};
					this.write(res);
				} catch (err) {
					const res = {
						id,
						error: {
							code: -32_603,
							message: err.message,
						},
					};
					this.write(res);
				}
			} else {
				await this.handleNotification(method, params);
			}
		}

		process() {
			switch (this.status) {
				case "IDLE": {
					if (this.buffer.length > 0) {
						this.status = "WAITING_FOR_HEADERS_END";
						this.process();
					}
					break;
				}

				case "WAITING_FOR_HEADERS_END": {
					const endIndex = this.buffer.indexOf(
						___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$HEADERS_END,
					);
					if (endIndex !== -1) {
						// Parse headers
						const rawHeaders = this.buffer.slice(0, endIndex);
						this.nextHeaders = ___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$parseHeaders(
							rawHeaders,
						);

						// Process rest of the buffer
						this.status = "WAITING_FOR_RESPONSE_END";
						this.buffer = this.buffer.slice(
							endIndex +
							___R$$priv$project$rome$$romejs$core$master$lsp$LSPServer_ts$HEADERS_END.length,
						);
						this.process();
					}
					break;
				}

				case "WAITING_FOR_RESPONSE_END": {
					const headers = this.nextHeaders;
					if (headers === undefined) {
						throw new Error("Expected headers due to our status");
					}
					if (this.buffer.length >= headers.length) {
						const content = this.buffer.slice(0, headers.length);
						this.onMessage(headers, content);

						// Reset headers and trim content
						this.nextHeaders = undefined;
						this.buffer = this.buffer.slice(headers.length);

						// Process rest of the buffer
						this.status = "IDLE";
						this.process();
					}
					break;
				}
			}
		}

		append(data) {
			this.buffer += data;
			this.process();
		}
	}


  // project-rome/@romejs/core/master/commands/lsp.ts
const ___R$project$rome$$romejs$core$master$commands$lsp_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.PROJECT_MANAGEMENT,
		description: "TODO",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {master, bridge} = req;

			const lspServer = new ___R$project$rome$$romejs$core$master$lsp$LSPServer_ts$default(
				req,
			);
			master.connectedLSPServers.add(lspServer);

			bridge.endEvent.subscribe(() => {
				master.connectedLSPServers.delete(lspServer);
			});

			bridge.lspFromClientBuffer.subscribe((chunk) => {
				lspServer.append(chunk);
			});

			await bridge.endEvent.wait();
		},
	});


  // project-rome/@romejs/core/master/commands/lint.ts

	const ___R$project$rome$$romejs$core$master$commands$lint_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.CODE_QUALITY,
		description: "run lint against a set of files",
		allowRequestFlags: ["watch", "review"],
		usage: "",
		examples: [],
		defineFlags(consumer) {
			return {
				decisions: consumer.get("decisions").asImplicitArray().map((item) =>
					item.asString()
				),
				save: consumer.get("save").asBoolean(false),
				formatOnly: consumer.get("formatOnly").asBoolean(false),
				changed: consumer.get("changed").asStringOrVoid(),
			};
		},
		async callback(req, flags) {
			const {reporter} = req;

			let lintCompilerOptionsPerFile = {};
			let globalDecisions = [];
			const {decisions} = flags;
			if (decisions !== undefined) {
				({lintCompilerOptionsPerFile, globalDecisions} = ___R$project$rome$$romejs$js$compiler$lint$decisions_ts$parseDecisionStrings(
					decisions,
					req.client.flags.cwd,
					(description) => {
						throw req.throwDiagnosticFlagError({
							description,
							target: {type: "flag", key: "decisions"},
						});
					},
				));
			}

			// Look up arguments manually in vsc if we were passed a changes branch
			let args;
			if (flags.changed !== undefined) {
				// No arguments expected when using this flag
				req.expectArgumentLength(0);

				const client = await req.getVCSClient();
				const target = flags.changed === "" ? client.trunkBranch : flags.changed;
				args = await client.getModifiedFiles(target);

				// Only include lintable files
				args = args.filter((arg) => {
					const path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
						arg,
					);

					for (const ext of ___R$project$rome$$romejs$core$common$file$handlers$index_ts$LINTABLE_EXTENSIONS) {
						if (path.hasEndExtension(ext)) {
							return true;
						}
					}

					return false;
				});

				if (args.length === 0) {
					reporter.warn(
						"No files changed from <emphasis>" + target + "</emphasis>",
					);
				} else {
					reporter.info(
						"Files changed from <emphasis>" + target + "</emphasis>",
					);
					reporter.list(
						args.map((arg) =>
							___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${arg}" />`
						),
					);
					reporter.hr();
				}
			}

			const opts = {
				hasDecisions: flags.decisions.length > 0,
				lintCompilerOptionsPerFile,
				globalDecisions,
				save: flags.save,
				formatOnly: flags.formatOnly,
				args,
			};

			const linter = new ___R$project$rome$$romejs$core$master$linter$Linter_ts$default(
				req,
				opts,
			);
			await linter.run(req.query.requestFlags.watch);
		},
	});


  // project-rome/@romejs/core/common/utils/fork.ts
const ___R$$priv$project$rome$$romejs$core$common$utils$fork_ts$child = require(
		"child_process",
	);
	function ___R$project$rome$$romejs$core$common$utils$fork_ts$default(
		processType,
		opts = {},
		args = [],
	) {
		return ___R$$priv$project$rome$$romejs$core$common$utils$fork_ts$child.fork(
			___R$project$rome$$romejs$core$common$constants_ts$BIN.join(),
			args,
			Object.assign(
				{
					stdio: "inherit",
					execArgv: ___R$project$rome$$romejs$core$common$constants_ts$CHILD_ARGS,
				},
				opts,
				{
					env: Object.assign(
						{},
						process.env,
						{
							ROME_PROCESS_VERSION: ___R$project$rome$$romejs$core$common$constants_ts$VERSION,
							ROME_PROCESS_TYPE: processType,
						},
					),
				},
			),
		);
	}


  // project-rome/@romejs/core/master/testing/utils.ts
function ___R$project$rome$$romejs$core$master$testing$utils_ts$sortMapKeys(map) {
		const sortedKeys = Array.from(map.keys()).sort(
			___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare,
		);
		const newMap = new Map();
		for (const key of sortedKeys) {
			const val = map.get(key);
			if (val === undefined) {
				throw new Error("Expected value");
			}
			newMap.set(key, val);
		}
		return newMap;
	}

	function ___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(
		num,
	) {
		const str = String(Math.floor(num));
		if (num > 80) {
			return "<success>" + str + "</success>";
		} else if (num > 40) {
			return "<warn>" + str + "</warn>";
		} else {
			return "<error>" + str + "</error>";
		}
	}

	function ___R$project$rome$$romejs$core$master$testing$utils_ts$percentInsideCoverageFolder(
		folder,
	) {
		let totalFiles = 0;
		let functions = 0;
		let branches = 0;
		let lines = 0;

		const folders = [folder];
		while (folders.length > 0) {
			const folder = folders.shift();

			for (const file of folder.files.values()) {
				totalFiles++;
				functions += file.functions.percent;
				branches += file.branches.percent;
				lines += file.lines.percent;
			}

			for (const subFolder of folder.folders.values()) {
				folders.push(subFolder);
			}
		}

		return {
			functions: totalFiles === 0 ? 100 : functions / totalFiles,
			branches: totalFiles === 0 ? 100 : branches / totalFiles,
			lines: totalFiles === 0 ? 100 : lines / totalFiles,
		};
	}


  // project-rome/@romejs/core/master/testing/TestMasterRunner.ts
const ___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$net = require(
		"net",
	);
	class ___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$BridgeDiagnosticsError
		extends ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError {
		constructor(diag, bridge) {
			super(diag.description.message.value, [diag]);
			this.bridge = bridge;
		}
	}

	function ___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$grammarNumberTests(
		num,
	) {
		return (
			'<grammarNumber plural="tests" singular="test">' +
			num +
			"</grammarNumber>"
		);
	}

	function ___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$getProgressTestRefText(
		ref,
	) {
		return ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${ref.filename}" />: ${___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
			ref.testName,
		)}`;
	}

	function ___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$findAvailablePort() {
		return new Promise((resolve, reject) => {
			// When you create a server without specifying a port then the OS will choose a port number for you!
			const server = ___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$net.createServer();
			server.unref();
			server.on("error", reject);
			server.listen(
				undefined,
				() => {
					const address = server.address();
					if (address == null || typeof address === "string") {
						throw new Error("Invalid address value");
					}

					server.close(() => {
						resolve(address.port);
					});
				},
			);
		});
	}



	class ___R$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$default {
		constructor(opts) {
			this.sources = opts.sources;
			this.reporter = opts.request.reporter;
			this.master = opts.request.master;
			this.cwd = opts.request.client.flags.cwd;
			this.request = opts.request;
			this.options = opts.options;

			this.ignoreBridgeEndError = new Set();

			this.sourcesQueue = Array.from(opts.sources.values());

			this.coverageCollector = new ___R$project$rome$$romejs$v8$CoverageCollector_ts$default();

			this.progress = {
				totalTests: 0,
				startedTests: 0,
				finishedTests: 0,
				updatedSnapshots: 0,
				deletedSnapshots: 0,
				createdSnapshots: 0,
				updatedInlineSnapshots: 0,
			};

			this.focusedTests = [];

			this.runningTests = new Map();
			this.testFileCounter = 0;

			this.printer = opts.request.createDiagnosticsPrinter(
				this.request.createDiagnosticsProcessor({
					origins: [
						{
							category: "test",
							message: "Run initiated",
						},
					],
				}),
			);
			this.printer.processor.addDiagnostics(opts.addDiagnostics);
			this.sourceMaps = this.printer.processor.sourceMaps;

			// Add source maps
			for (const [filename, {code, sourceMap}] of opts.sources) {
				const consumer = sourceMap.toConsumer();
				this.coverageCollector.addSourceMap(filename, code, consumer);
				this.printer.processor.sourceMaps.add(filename, consumer);
			}
		}

		async processTestResult(ref, {inlineSnapshotUpdates, snapshotCounts}) {
			this.progress.createdSnapshots += snapshotCounts.created;
			this.progress.updatedSnapshots += snapshotCounts.updated;
			this.progress.deletedSnapshots += snapshotCounts.deleted;
			this.progress.updatedInlineSnapshots += inlineSnapshotUpdates.length;

			if (inlineSnapshotUpdates.length > 0) {
				const path = ref.real;
				const filename = path.join();

				// Resolve source maps. These will originally be pointed to the compiled source.
				inlineSnapshotUpdates = inlineSnapshotUpdates.map((update) => {
					const resolved = this.sourceMaps.assertApproxOriginalPositionFor(
						filename,
						update.line,
						update.column,
					);

					if (resolved.source !== filename && resolved.source !== ref.uid) {
						throw new Error(
							"Inline snapshot update resolved to " +
							resolved.source +
							" when it should be " +
							filename,
						);
					}

					return Object.assign(
						{},
						update,
						{line: resolved.line, column: resolved.column},
					);
				});

				const diagnostics = await this.request.requestWorkerUpdateInlineSnapshots(
					path,
					inlineSnapshotUpdates,
					{},
				);
				this.printer.processor.addDiagnostics(diagnostics);
			}
		}

		async prepareWorker({bridge, process, inspector}, progress) {
			const {options: opts, sourcesQueue} = this;
			const req = this.request;
			const {flags} = req.client;

			if (inspector !== undefined && opts.coverage === true) {
				await inspector.call("Profiler.enable");
				await inspector.call(
					"Profiler.startPreciseCoverage",
					{
						// Turning this on disables V8 optimizations https://v8.dev/blog/javascript-code-coverage#precise-coverage-(function-granularity)
						callCount: false,
						// Otherwise coverage will only have function granularity
						detailed: true,
					},
				);
			}

			const tests = [];

			const prepareTest = async () => {
				if (sourcesQueue.length === 0) {
					return;
				}

				const item = sourcesQueue.pop();
				const {ref, code} = item;

				const id = this.testFileCounter;
				this.testFileCounter++;

				const progressText = '<filelink target="' + ref.uid + '" />';
				progress.pushText(progressText);

				try {
					const {focusedTests} = await bridge.prepareTest.call({
						id,
						options: opts,
						projectFolder: req.master.projectManager.assertProjectExisting(
							ref.real,
						).folder.join(),
						file: req.master.projectManager.getTransportFileReference(ref.real),
						cwd: flags.cwd.join(),
						code,
					});

					this.focusedTests = this.focusedTests.concat(focusedTests);

					tests.push({id, ref});
				} catch (err) {
					this.handlePossibleBridgeError(err);
				}

				progress.popText(progressText);
				progress.tick();

				await prepareTest();
			};

			await prepareTest();

			return async () => {
				try {
					for (const {ref, id} of tests) {
						const result = await bridge.runTest.call({
							id,
							onlyFocusedTests: this.focusedTests.length > 0,
						});
						await this.processTestResult(ref, result);
					}
				} catch (err) {
					this.handlePossibleBridgeError(err);
				} finally {
					if (inspector !== undefined) {
						if (opts.coverage) {
							if (inspector.alive) {
								const profile = await inspector.call(
									"Profiler.takePreciseCoverage",
								);
								this.coverageCollector.addCoverage(
									profile.get("result").asAny(),
								);

								// Not really necessary but let's clean up anyway for completeness
								await inspector.call("Profiler.stopPreciseCoverage");
								await inspector.call("Profiler.disable");
							} else {
								// TODO log that we failed to fetch some coverage
							}
						}

						inspector.end();
					}

					process.kill();
				}
			};
		}

		handlePossibleBridgeError(err) {
			let diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(
				err,
			);
			let bridge;

			if (
				err instanceof
				___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$BridgeDiagnosticsError
			) {
				bridge = err.bridge;
			}

			if (err instanceof ___R$project$rome$$romejs$events$BridgeError_ts$default) {
				bridge = err.bridge;
				diagnostics = [
					___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
						err,
						{
							description: {
								category: "tests/failure",
							},
						},
					),
				];
			}

			if (diagnostics === undefined || bridge === undefined) {
				throw err;
			} else {
				if (!this.ignoreBridgeEndError.has(bridge)) {
					this.printer.processor.addDiagnostics(diagnostics);
				}
			}
		}

		async spawnWorker(flags) {
			const proc = ___R$project$rome$$romejs$core$common$utils$fork_ts$default(
				"test-worker",
				{
					stdio: "pipe",
				},
				["--inspector-port", String(flags.inspectorPort)],
			);

			const {stdout, stderr} = proc;
			if (stdout == null || stderr == null) {
				throw new Error("stdout or stderr was undefined for a spawned Worker");
			}

			stdout.on(
				"data",
				(chunk) => {
					process.stdout.write(chunk);
				},
			);

			// Suppress any debugger logs
			stderr.on(
				"data",
				(chunk) => {
					const str = chunk.toString();

					if (str.startsWith("Debugger listening on ws://")) {
						return;
					}

					if (
						str.startsWith(
							"For help, see: https://nodejs.org/en/docs/inspector",
						)
					) {
						return;
					}

					if (str.startsWith("Debugger attached")) {
						return;
					}

					process.stderr.write(chunk);
				},
			);

			const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(
				___R$project$rome$$romejs$core$common$bridges$TestWorkerBridge_ts$default,
				proc,
				{
					type: "client",
				},
			);
			await bridge.handshake();

			const {inspectorUrl} = await bridge.inspectorDetails.call();

			let inspector;
			if (inspectorUrl !== undefined) {
				const client = new ___R$project$rome$$romejs$v8$InspectorClient_ts$default(
					await ___R$project$rome$$romejs$codec$websocket$index_ts$createClient(
						inspectorUrl,
					),
				);
				inspector = client;
				await client.call("Debugger.enable");

				bridge.endEvent.subscribe(() => {
					client.end();
				});
			}

			bridge.testsFound.subscribe((tests) => {
				for (const ref of tests) {
					this.onTestFound(ref);
				}
			});

			bridge.testDiagnostic.subscribe(({diagnostic, origin}) => {
				this.printer.processor.addDiagnostic(diagnostic, origin);
			});

			return {
				bridge,
				process: proc,
				inspector,
			};
		}

		async setupWorkers() {
			// TODO some smarter logic. we may not need all these workers
			const containerPromises = [];
			for (
				let i = 0;
				i < ___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_COUNT;
				i++
			) {
				const inspectorPort = await ___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$findAvailablePort();
				containerPromises.push(this.spawnWorker({inspectorPort}));
			}

			const containers = await Promise.all(containerPromises);

			// Every 5 seconds, ping the worker and wait a max of 5 seconds, if we receive no response then consider the worker dead
			for (const container of containers) {
				container.bridge.monitorHeartbeat(
					5_000,
					async () => {
						this.handleWorkerTimeout("10 seconds", container);
					},
				);
			}

			return containers;
		}

		async init() {
			this.workers = await this.setupWorkers();

			const workerContainers = this.getWorkers();

			// Prepare all tests
			const progress = this.reporter.progress({
				title: "Preparing",
			});
			progress.setTotal(this.sourcesQueue.length);
			const callbacks = await Promise.all(
				workerContainers.map((container) =>
					this.prepareWorker(container, progress)
				),
			);
			progress.end();

			// Run tests
			const runProgress = this.setupRunProgress();
			await Promise.all(callbacks.map((callback) => callback()));
			runProgress.teardown();

			this.throwPrinter();
		}

		async handleWorkerTimeout(duration, container) {
			return new Promise((resolve, reject) => {
				const timeout = setTimeout(
					() => {
						resolve(
							container.bridge.end(
								"Test worker was unresponsive for " +
								duration +
								". We tried to collect some additional metadata but we timed out again trying to fetch it...",
							),
						);
					},
					3_000,
				);

				this._handleWorkerTimeout(duration, container).then(() => {
					clearTimeout(timeout);
					resolve();
				}).catch((err) => {
					clearTimeout(timeout);
					if (
						err instanceof
						___R$project$rome$$romejs$v8$InspectorClient_ts$InspectorClientCloseError
					) {
						return container.bridge.end(
							"Test worker was unresponsive for " +
							duration +
							". We tried to collect some additional metadata but the inspector connection closed abruptly",
						);
					} else {
						reject(err);
					}
				});
			});
		}

		async _handleWorkerTimeout(duration, {bridge, inspector}) {
			if (inspector === undefined) {
				bridge.end(
					"Test worker was unresponsive for " +
					duration +
					". There was no inspector connected so we were unable to capture stack frames before it was terminated.",
				);
				return undefined;
			}

			inspector.call("Debugger.pause");

			const params = await inspector.wait("Debugger.paused");

			const frames = [];

			const callFrames = params.get("callFrames").asArray().slice(0, 20);
			for (const callFrame of callFrames) {
				const loc = callFrame.get("location");

				const resolved = this.sourceMaps.assertApproxOriginalPositionFor(
					___R$project$rome$$romejs$v8$utils_ts$urlToFilename(
						callFrame.get("url").asString(),
					),
					___R$project$rome$$romejs$ob1$index_ts$ob1Coerce0To1(
						loc.get("lineNumber").asZeroIndexedNumber(),
					),
					loc.get("columnNumber").asZeroIndexedNumber(),
				);

				const name = callFrame.get("scopeChain").asArray()[0].get("name").asString(
					"",
				).split("$").pop();

				frames.push({
					resolvedLocation: resolved.found,
					typeName: undefined,
					functionName: name,
					methodName: undefined,
					filename: resolved.source,
					lineNumber: resolved.line,
					columnNumber: resolved.column,
					isTopLevel: false,
					isEval: false,
					isNative: false,
					isConstructor: false,
					isAsync: false,
				});
			}

			bridge.endWithError(
				new ___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$BridgeDiagnosticsError(
					___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
						{
							name: "Error",
							frames,
						},
						{
							description: {
								category: "tests/timeout",
								message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
									"Test worker was unresponsive for <emphasis>" +
									duration +
									"</emphasis>. Possible infinite loop. Below is a stack trace before the test was terminated.",
								),
								advice: [
									{
										type: "log",
										category: "info",
										text: "You can find the specific test that caused this by running <command>rome test --sync-tests</command>",
									},
								],
							},
						},
					),
					bridge,
				),
			);
		}

		getWorkers() {
			if (this.workers === undefined) {
				throw new Error("TestMasterRunner.init has not been called yet");
			} else {
				return this.workers;
			}
		}

		refToKey(ref) {
			return ref.filename + ": " + ref.testName;
		}

		getTotalTests() {
			if (this.focusedTests.length > 0) {
				return this.focusedTests.length;
			} else {
				return this.progress.totalTests;
			}
		}

		onTestStart(container, ref, timeoutMs) {
			this.progress.startedTests++;

			let timeout = undefined;
			if (timeoutMs !== undefined) {
				timeout = setTimeout(
					() => {
						// TODO This will kill the whole worker, maybe it's possible to just terminate the current test? Throw an error, see if the next test was ran, or else terminate completely
						this.handleWorkerTimeout(String(timeoutMs) + "ms", container);
					},
					timeoutMs,
				);
			}

			this.runningTests.set(
				this.refToKey(ref),
				{
					ref,
					timeout,
				},
			);
		}

		onTestFound(data) {
			data;
			this.progress.totalTests++;
		}

		onTestFinished(ref) {
			const key = this.refToKey(ref);
			const running = this.runningTests.get(key);
			if (running === undefined) {
				throw new Error("Expected there to be a running test");
			}

			if (running.timeout !== undefined) {
				clearTimeout(running.timeout);
			}
			this.runningTests.delete(key);

			this.progress.finishedTests++;
		}

		setupRunProgress() {
			const workers = this.getWorkers();

			const progress = this.request.reporter.progress({
				persistent: true,
				title: "Running",
			});
			progress.setTotal(this.getTotalTests());

			for (let i = 0; i < workers.length; i++) {
				const container = workers[i];
				const {bridge} = container;

				const ourRunningTests = new Set();

				bridge.endEvent.subscribe((error) => {
					// Cancel all currently running tests
					const cancelTests = [];

					for (const key of ourRunningTests) {
						const test = this.runningTests.get(key);
						if (test !== undefined) {
							cancelTests.push(test.ref);
						}
					}

					for (const ref of cancelTests) {
						this.onTestFinished(ref);

						if (cancelTests.length === 1) {
							// If we only have one test to cancel then let's only point the bridge error to this test
							this.ignoreBridgeEndError.add(bridge);

							const errDiag = ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
								error,
								{
									label: ref.testName,
									filename: ref.filename,
									description: {
										category: "tests/failure",
									},
								},
							);

							this.printer.processor.addDiagnostic(
								Object.assign(
									{},
									errDiag,
									{
										description: Object.assign(
											{},
											errDiag.description,
											{
												// We don't care about the advice
												advice: [],
											},
										),
									},
								),
							);
						} else {
							this.printer.processor.addDiagnostic({
								label: ref.testName,
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TESTS.CANCELLED,
								location: {
									filename: ref.filename,
								},
							});
						}
					}
				});

				bridge.testStart.subscribe((data) => {
					ourRunningTests.add(this.refToKey(data.ref));
					this.onTestStart(container, data.ref, data.timeout);
					progress.pushText(
						___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$getProgressTestRefText(
							data.ref,
						),
					);
				});

				bridge.testFinish.subscribe((data) => {
					this.onTestFinished(data.ref);
					progress.popText(
						___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$getProgressTestRefText(
							data.ref,
						),
					);
					progress.tick();
				});
			}

			return {
				teardown() {
					progress.end();
				},
			};
		}

		printCoverageReport(isError) {
			const {reporter, master, coverageCollector} = this;

			if (isError && this.options.showAllCoverage) {
				// Only show coverage for errors when --show-all-coverage has been specified
				return;
			}

			if (!this.options.coverage) {
				return;
			}

			reporter.info("Generating coverage");

			// Fetch coverage entries
			const files = coverageCollector.generate();
			if (files.length === 0) {
				return;
			}

			reporter.heading("Code coverage");

			// Get the packages associated with all the ran tests, we will filter code coverage to those packages only
			const testedPackages = new Set();
			for (const {ref} of this.sources.values()) {
				testedPackages.add(master.memoryFs.getOwnedManifest(ref.real));
			}

			let root = {
				name: undefined,
				folders: new Map(),
				files: new Map(),
			};

			let totalFiles = 0;

			// Turn the flat list of filenames into a directory tree
			for (const file of files) {
				const {filename} = file;

				// Get the absolute filename
				const absolute = master.projectManager.getFilePathFromUid(filename);
				if (absolute === undefined) {
					continue;
				}

				// Filter out untested packages
				const pkg = master.memoryFs.getOwnedManifest(absolute);
				if (testedPackages.has(pkg) === false) {
					continue;
				}

				// TODO maybe filter out test files too?

				// Track unfiltered files
				totalFiles++;

				const filenameParts = filename.split("/");
				const basename = filenameParts.pop();
				if (basename === undefined) {
					throw new Error(
						"Should always be at least one element from a split()",
					);
				}

				let target = root;

				for (const part of filenameParts) {
					const existingFolder = target.folders.get(part);
					if (existingFolder === undefined) {
						const newFolder = {
							name: part,
							folders: new Map(),
							files: new Map(),
						};
						target.folders.set(part, newFolder);
						target = newFolder;
					} else {
						target = existingFolder;
					}
				}

				target.files.set(basename, file);
			}

			// Continuously merge all entries with only a single folder from the root
			while (root.folders.size === 1 && root.files.size === 0) {
				// Awkward way to get the first value out of the folders map...
				const newRoot = root.folders.values().next().value;
				root = Object.assign(
					{},
					newRoot,
					{
						name: root.name !== undefined && newRoot.name !== undefined
							? root.name + "/" + newRoot.name
							: newRoot.name,
					},
				);
			}

			const rows = [];

			// If there's more than 15 files to show, and we don't have the explicit showAllCoverage flag

			// then truncate the output
			const showAllCoverage = this.options.showAllCoverage || totalFiles < 15;

			function buildRows(folder, depth) {
				const name = folder.name === undefined ? "All files" : folder.name + "/";
				const folderPercent = ___R$project$rome$$romejs$core$master$testing$utils_ts$percentInsideCoverageFolder(
					folder,
				);

				rows.push([
					" ".repeat(depth) + ("<emphasis>" + name + "</emphasis>"),
					___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(
						folderPercent.functions,
					),
					___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(
						folderPercent.branches,
					),
					___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(
						folderPercent.lines,
					),
				]);

				// Don't ever show anything deeper than a single level when showAllCoverage is off
				if (!showAllCoverage && depth > 0) {
					return;
				}

				const fileIndent = " ".repeat(depth + 1);
				for (const [name, file] of ___R$project$rome$$romejs$core$master$testing$utils_ts$sortMapKeys(
					folder.files,
				)) {
					let absolute = file.filename;

					// Exchange any UIDs
					const absolutePath = master.projectManager.getFilePathFromUid(
						file.filename,
					);
					if (absolutePath !== undefined) {
						absolute = absolutePath.join();
					}

					rows.push([
						fileIndent +
						___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${absolute}">${name}</filelink>`,
						___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(
							file.functions.percent,
						),
						___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(
							file.branches.percent,
						),
						___R$project$rome$$romejs$core$master$testing$utils_ts$formatPercent(
							file.lines.percent,
						),
					]);
				}

				for (const subFolder of ___R$project$rome$$romejs$core$master$testing$utils_ts$sortMapKeys(
					folder.folders,
				).values()) {
					buildRows(subFolder, depth + 1);
				}
			}

			buildRows(root, 0);

			reporter.table(["File", "% Functions", "% Branches", "% Lines"], rows);

			if (!showAllCoverage) {
				reporter.br();
				reporter.info(
					"Additional coverage information available. Refine the executed tests or add the <emphasis>--show-all-coverage</emphasis> flag",
				);
			}

			reporter.hr();
		}

		getSourceCode(filename) {
			const testSource = this.sources.get(filename);
			if (testSource === undefined) {
				return undefined;
			} else {
				return testSource.code;
			}
		}

		printFocusedTestWarning(reporter) {
			const {focusedTests} = this;
			if (focusedTests.length === 0) {
				return;
			}

			const formattedFocusedTests = focusedTests.map(({testName, location}) => {
				const loc = this.printer.processor.normalizer.normalizeLocation(
					location,
				);

				return ___R$project$rome$$romejs$string$markup$escape_ts$markup`<emphasis>${testName}</emphasis> at <emphasis>${___R$project$rome$$romejs$string$markup$escape_ts$safeMarkup(
					___R$project$rome$$romejs$diagnostics$helpers_ts$diagnosticLocationToMarkupFilelink(
						loc,
					),
				)}</emphasis>`;
			});

			if (focusedTests.length === 1) {
				reporter.warn("Only ran the focused test " + formattedFocusedTests[0]);
			} else {
				reporter.warn(
					"Only ran the following <number emphasis>" +
					focusedTests.length +
					"</number> focused " +
					___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$grammarNumberTests(
						focusedTests.length,
					),
				);
				reporter.list(formattedFocusedTests);
			}

			const otherTotal = this.progress.totalTests - this.focusedTests.length;
			reporter.info(
				"<number emphasis>" +
				otherTotal +
				"</number> other " +
				___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$grammarNumberTests(
					otherTotal,
				) +
				" ignored",
			);
		}

		printSnapshotCounts(reporter) {
			const {
				createdSnapshots,
				deletedSnapshots,
				updatedSnapshots,
				updatedInlineSnapshots,
			} = this.progress;

			const snapshotCounts = [
				{inline: false, count: createdSnapshots, noun: "created"},
				{inline: false, count: updatedSnapshots, noun: "updated"},
				{inline: false, count: deletedSnapshots, noun: "deleted"},
				{inline: true, count: updatedInlineSnapshots, noun: "updated"},
			].filter(({count}) => count > 0);

			if (snapshotCounts.length === 0) {
				return;
			}

			const first = snapshotCounts.shift();
			const parts = [
				"<number emphasis>" +
				first.count +
				"</number> " +
				(first.inline ? "inline snapshots" : "snapshots") +
				" " +
				first.noun,
			];

			for (let {inline, count, noun} of snapshotCounts) {
				if (inline) {
					noun = "inline " + noun;
				}
				parts.push("<number emphasis>" + count + "</number> " + noun);
			}

			reporter.success(parts.join(", "));
		}

		throwPrinter() {
			const {printer} = this;

			printer.onFooterPrint((reporter, isError) => {
				this.printCoverageReport(isError);
				this.printSnapshotCounts(reporter);
				this.printFocusedTestWarning(reporter);

				if (!isError) {
					// Don't say "all" when we have focused tests
					let prefix = this.focusedTests.length === 0 ? "All " : "";
					const totalCount = this.getTotalTests();
					reporter.success(
						prefix +
						"<emphasis>" +
						___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
							totalCount,
						) +
						"</emphasis> " +
						___R$$priv$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$grammarNumberTests(
							totalCount,
						) +
						" passed!",
					);
					return true;
				}

				// Show default footer
				return false;
			});

			throw printer;
		}
	}


  // project-rome/@romejs/core/master/commands/test.ts

	const ___R$project$rome$$romejs$core$master$commands$test_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.CODE_QUALITY,
		description: "run tests",
		usage: "",
		examples: [],
		defineFlags(c) {
			return {
				coverage: c.get("coverage").asBoolean(false),
				showAllCoverage: c.get("showAllCoverage").asBoolean(false),
				updateSnapshots: c.get("updateSnapshots").asBoolean(false),
				freezeSnapshots: c.get("freezeSnapshots").asBoolean(false),
				focusAllowed: c.get("focusAllowed").asBoolean(true),
				syncTests: c.get("syncTests").asBoolean(false),
			};
		},
		async callback(req, commandFlags) {
			const {paths} = await req.getFilesFromArgs({
				tryAlternateArg: (path) => {
					if (path.hasExtension("test")) {
						return undefined;
					} else {
						return path.getParent().append(
							path.getExtensionlessBasename() + ".test" + path.getExtensions(),
						);
					}
				},
				test: (path) => path.hasExtension("test"),
				noun: "test",
				verb: "testing",
				configCategory: "tests",
				advice: [
					{
						type: "log",
						category: "info",
						text: "Searched for files with <emphasis>.test.*</emphasis> file extension",
					},
				],
				extensions: ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$JS_EXTENSIONS,
				disabledDiagnosticCategory: "tests/disabled",
			});

			let addDiagnostics = [];

			const tests = new Map();

			const bundler = new ___R$project$rome$$romejs$core$master$bundler$Bundler_ts$default(
				req,
				req.getBundlerConfigFromFlags({
					mocks: true,
				}),
			);

			for (const [path, res] of await bundler.bundleMultiple(
				Array.from(paths),
				{
					deferredSourceMaps: true,
				},
			)) {
				tests.set(
					path.join(),
					{
						code: res.entry.js.content,
						sourceMap: res.entry.sourceMap.map,
						ref: req.master.projectManager.getFileReference(path),
					},
				);
			}

			const runner = new ___R$project$rome$$romejs$core$master$testing$TestMasterRunner_ts$default({
				addDiagnostics,
				options: Object.assign(
					{},
					commandFlags,
					{verboseDiagnostics: req.query.requestFlags.verboseDiagnostics},
				),
				sources: tests,
				request: req,
			});
			await runner.init();
		},
	});


  // project-rome/@romejs/core/master/commands/ci.ts
async function ___R$$priv$project$rome$$romejs$core$master$commands$ci_ts$runChildCommand(
		req,
		fn,
	) {
		try {
			await fn();
		} catch (err) {
			if (
				err instanceof
				___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default
			) {
				// If the command raises diagnostics, it is safe to throw the printer.
				// By doing so, the `ci` command bails and is marked as failed.
				if (err.hasDiagnostics()) {
					throw err;
				} else {
					req.master.handleRequestError(req, err);
				}
			} else {
				throw err;
			}
		}
	}


	const ___R$project$rome$$romejs$core$master$commands$ci_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.CODE_QUALITY,
		description: "run lint and tests",
		usage: "",
		examples: [],
		defineFlags(consumer) {
			return {
				fix: consumer.get("fix").asBoolean(false),
			};
		},
		async callback(req, flags) {
			const {reporter} = req;

			reporter.heading("Running lint");
			await ___R$$priv$project$rome$$romejs$core$master$commands$ci_ts$runChildCommand(
				req,
				async () => {
					await ___R$project$rome$$romejs$core$master$commands$lint_ts$default.callback(
						req,
						{
							formatOnly: false,
							decisions: [],
							save: flags.fix,
							changed: undefined,
						},
					);
				},
			);

			reporter.heading("Running tests");
			await ___R$$priv$project$rome$$romejs$core$master$commands$ci_ts$runChildCommand(
				req,
				async () => {
					await ___R$project$rome$$romejs$core$master$commands$test_ts$default.callback(
						req,
						{
							focusAllowed: false,
							coverage: false,
							freezeSnapshots: !flags.fix,
							updateSnapshots: flags.fix,
							showAllCoverage: false,
							syncTests: false,
						},
					);
				},
			);
		},
	});


  // project-rome/@romejs/core/master/commands/_evict.ts
const ___R$project$rome$$romejs$core$master$commands$_evict_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		description: "evict a file from the memory cache",
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.INTERNAL,
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {
				master,
				reporter,
				client,
				query: {args},
			} = req;

			const files =
				args.length === 0 ? master.fileAllocator.getAllOwnedFilenames() : args;

			for (const file of files) {
				await master.fileAllocator.evict(client.flags.cwd.resolve(file));
				reporter.success("Evicted " + file);
			}

			reporter.info("Evicted " + String(files.length) + " files");
		},
	});


  // project-rome/@romejs/core/master/commands/_moduleSignature.ts
const ___R$project$rome$$romejs$core$master$commands$_moduleSignature_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.INTERNAL,
		description: "get the module type signature of a file",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			const {master, reporter} = req;
			const {args} = req.query;
			req.expectArgumentLength(1);

			const filename = await master.resolver.resolveEntryAssertPath(
				Object.assign(
					{},
					req.getResolverOptionsFromFlags(),
					{
						source: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
							args[0],
						),
					},
				),
				{location: req.getDiagnosticPointerFromFlags({type: "arg", key: 0})},
			);
			reporter.inspect(await req.requestWorkerModuleSignature(filename, {}));
		},
	});


  // project-rome/@romejs/core/master/commands/_noop.ts
const ___R$project$rome$$romejs$core$master$commands$_noop_ts$default = ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand({
		category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.INTERNAL,
		description: "TODO",
		usage: "",
		examples: [],
		defineFlags() {
			return {};
		},
		async callback(req) {
			req;
		},
	});


  // project-rome/@romejs/core/master/commands.ts


	function ___R$project$rome$$romejs$core$master$commands_ts$createMasterCommand(
		cmd,
	) {
		return cmd;
	}

	const ___R$project$rome$$romejs$core$master$commands_ts$masterCommands = new Map();
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"test",
		___R$project$rome$$romejs$core$master$commands$test_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"lint",
		___R$project$rome$$romejs$core$master$commands$lint_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"config",
		___R$project$rome$$romejs$core$master$commands$config_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"bundle",
		___R$project$rome$$romejs$core$master$commands$bundle_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"parse",
		___R$project$rome$$romejs$core$master$commands$parse_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"analyzeDependencies",
		___R$project$rome$$romejs$core$master$commands$analyzeDependencies_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"resolve",
		___R$project$rome$$romejs$core$master$commands$resolve_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"compile",
		___R$project$rome$$romejs$core$master$commands$compile_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"stop",
		___R$project$rome$$romejs$core$master$commands$stop_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"status",
		___R$project$rome$$romejs$core$master$commands$status_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"run",
		___R$project$rome$$romejs$core$master$commands$run_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"publish",
		___R$project$rome$$romejs$core$master$commands$publish_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"ci",
		___R$project$rome$$romejs$core$master$commands$ci_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"develop",
		___R$project$rome$$romejs$core$master$commands$develop_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"format",
		___R$project$rome$$romejs$core$master$commands$format_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"lsp",
		___R$project$rome$$romejs$core$master$commands$lsp_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"_evict",
		___R$project$rome$$romejs$core$master$commands$_evict_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"_moduleSignature",
		___R$project$rome$$romejs$core$master$commands$_moduleSignature_ts$default,
	);
	___R$project$rome$$romejs$core$master$commands_ts$masterCommands.set(
		"_noop",
		___R$project$rome$$romejs$core$master$commands$_noop_ts$default,
	);


  // project-rome/@romejs/vcs/index.ts
const ___R$$priv$project$rome$$romejs$vcs$index_ts$childProcess = require(
		"child_process",
	);
	const ___R$$priv$project$rome$$romejs$vcs$index_ts$TIMEOUT = 10_000;

	async function ___R$$priv$project$rome$$romejs$vcs$index_ts$exec(
		command,
		args,
	) {
		return new Promise((resolve, reject) => {
			const proc = ___R$$priv$project$rome$$romejs$vcs$index_ts$childProcess.spawn(
				command,
				args,
				{timeout: ___R$$priv$project$rome$$romejs$vcs$index_ts$TIMEOUT},
			);
			let stderr = "";
			let stdout = "";

			proc.stdout.on(
				"data",
				(data) => {
					stdout += data;
				},
			);

			proc.stderr.on(
				"data",
				(data) => {
					stderr += data;
				},
			);

			function error(message) {
				reject(
					new Error(
						"Error while running " +
						command +
						" " +
						args.join(" ") +
						": " +
						message +
						". stderr: " +
						stderr,
					),
				);
			}

			proc.on(
				"error",
				(err) => {
					if (err.code === "ETIMEDOUT") {
						error(
							"Timed out after " +
							___R$$priv$project$rome$$romejs$vcs$index_ts$TIMEOUT +
							"ms",
						);
					} else {
						error(err.message);
					}
				},
			);

			proc.on(
				"close",
				(code) => {
					if (code === 0) {
						resolve(stdout);
					} else {
						error("Exited with code " + code);
					}
				},
			);
		});
	}

	function ___R$$priv$project$rome$$romejs$vcs$index_ts$extractFileList(out) {
		const lines = out.trim().split("\n");

		const files = [];

		for (const line of lines) {
			const match = line.trim().match(/^(?:[AM]|\?\?)\s+(.*?)$/);
			if (match != null) {
				files.push(match[1]);
			}
		}

		return files;
	}

	class ___R$project$rome$$romejs$vcs$index_ts$VCSClient {
		constructor(root) {
			this.root = root;
			this.trunkBranch = "unknown";
		}

		getModifiedFiles(branch) {
			throw new Error("unimplemented");
		}

		getUncommittedFiles() {
			throw new Error("unimplemented");
		}
	}

	class ___R$$priv$project$rome$$romejs$vcs$index_ts$GitVCSClient
		extends ___R$project$rome$$romejs$vcs$index_ts$VCSClient {
		constructor(root) {
			super(root);
			this.trunkBranch = "master";
		}

		async getUncommittedFiles() {
			const out = await ___R$$priv$project$rome$$romejs$vcs$index_ts$exec(
				"git",
				["status", "--short"],
			);
			return ___R$$priv$project$rome$$romejs$vcs$index_ts$extractFileList(out);
		}

		async getModifiedFiles(branch) {
			const out = await ___R$$priv$project$rome$$romejs$vcs$index_ts$exec(
				"git",
				["diff", "--name-status", branch],
			);
			return ___R$$priv$project$rome$$romejs$vcs$index_ts$extractFileList(out);
		}
	}

	async function ___R$project$rome$$romejs$vcs$index_ts$getVCSClient(root) {
		if (await ___R$project$rome$$romejs$fs$index_ts$exists(root.append(".git"))) {
			return new ___R$$priv$project$rome$$romejs$vcs$index_ts$GitVCSClient(root);
		}

		return undefined;
	}


  // project-rome/@romejs/core/master/project/ProjectManager.ts
function ___R$$priv$project$rome$$romejs$core$master$project$ProjectManager_ts$cleanUidParts(
		parts,
	) {
		let uid = "";

		let lastPart = "";
		for (const part of parts) {
			if (uid !== "") {
				uid += "/";
			}

			// Prune off any prefix shared with the last part
			let sharedPrefix = "";
			for (let i = 0; i < part.length && lastPart[i] === part[i]; i++) {
				sharedPrefix += part[i];
			}

			const partWithoutExtension = part.split(".")[0];
			if (sharedPrefix === partWithoutExtension) {
				uid += part;
			} else {
				uid += part.slice(sharedPrefix.length);
			}

			lastPart = part;
		}

		return uid;
	}

	// If a UID has a relative path that's just index.js, index.ts etc then omit it
	function ___R$$priv$project$rome$$romejs$core$master$project$ProjectManager_ts$cleanRelativeUidPath(
		relative,
	) {
		return relative.join();

		const segments = relative.getSegments();

		// Quick deopt if there last segment is not index.
		if (!segments[segments.length - 1].startsWith("index.")) {
			return relative.join();
		}

		// Verify and pop off the last segment if it matches index.VALID_JS_EXTENSION
		const basename = relative.getBasename();
		for (const ext of ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$IMPLICIT_JS_EXTENSIONS) {
			// Got a matching basename that we should omit
			if (basename === "index." + ext) {
				if (segments.length === 1) {
					// If there's a single segment then we don't want anything
					return undefined;
				} else {
					return relative.getParent().join();
				}
			}
		}

		// No matches, we hit the index. check above but not any of the valid extensions
		return relative.join();
	}



	class ___R$project$rome$$romejs$core$master$project$ProjectManager_ts$default {
		constructor(master) {
			this.master = master;

			this.isAddingProject = false;
			this.pendingAddProjects = [];

			this.projectIdCounter = 0;
			this.projectFolderToId = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.projectConfigDependenciesToIds = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.fileToProject = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.projects = new Map();

			// We maintain these maps so we can reverse any uids, and protect against collisions
			this.uidToFilename = new Map();
			this.filenameToUid = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.remoteToLocalPath = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();
			this.localPathToRemote = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
		}

		async init() {
			this.master.memoryFs.deletedFileEvent.subscribe((path) => {
				this.handleDeleted(path);
			});

			const vendorProjectConfig = Object.assign(
				{},
				___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
				{name: "rome-internal-remote"},
			);
			const defaultVendorPath = vendorProjectConfig.files.vendorPath;
			await ___R$project$rome$$romejs$fs$index_ts$createDirectory(
				defaultVendorPath,
				{recursive: true},
			);
			await this.addProjectWithConfig({
				projectFolder: defaultVendorPath,
				meta: ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META,
				config: vendorProjectConfig,
			});
			await this.master.memoryFs.watch(defaultVendorPath, vendorProjectConfig);
		}

		handleDeleted(path) {
			const filename = path.join();

			this.projectConfigDependenciesToIds.delete(path);
			this.fileToProject.delete(path);

			// Remove uids
			const uid = this.filenameToUid.get(path);
			this.filenameToUid.delete(path);
			if (uid !== undefined) {
				this.uidToFilename.delete(filename);
			}
		}

		getRemoteFromLocalPath(path) {
			return this.localPathToRemote.get(path);
		}

		getFilePathFromUid(uid) {
			return this.uidToFilename.get(uid);
		}

		getFilePathFromUidOrAbsolute(uid) {
			if (uid === undefined) {
				return undefined;
			}

			const uidToPath = this.getFilePathFromUid(uid);
			if (uidToPath !== undefined) {
				return uidToPath;
			}

			const path = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
				uid,
			);
			if (path.isAbsolute()) {
				return path.assertAbsolute();
			}

			return undefined;
		}

		normalizeFilenamesToFilePaths(filenames) {
			const others = new Set();
			const absolutes = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

			for (const filename of filenames) {
				if (filename === undefined) {
					others.add(undefined);
					continue;
				}

				const absolute = this.getFilePathFromUidOrAbsolute(filename);
				if (absolute === undefined) {
					// Relative path
					others.add(filename);
				} else {
					absolutes.add(absolute);
				}
			}

			return {absolutes, others};
		}

		setUid(path, uid) {
			const filename = path.join();

			// Verify we didn't already generate this uid for another file
			const collided = this.uidToFilename.get(uid);
			if (collided !== undefined && !collided.equal(path)) {
				throw new Error(
					"UID collision between " + filename + " and " + collided + ": " + uid,
				);
			}

			this.uidToFilename.set(uid, path);
			this.filenameToUid.set(path, uid);
		}

		getUid(path) {
			// Allow passing in a UID
			const filename = path.join();
			if (this.uidToFilename.has(filename)) {
				return filename;
			}

			// Check if we've already calculated and saved a UID
			const existing = this.filenameToUid.get(path);
			if (existing !== undefined) {
				return existing;
			}

			const project = this.assertProjectExisting(path);

			// Format of uids will be <PROJECT_NAME>/<PACKAGE_NAME>/<RELATIVE>
			const parts = [];

			let root = project.folder;

			// Push on parent package names
			let targetPackagePath = path;
			while (true) {
				const pkg = this.master.memoryFs.getOwnedManifest(targetPackagePath);
				if (pkg === undefined || pkg.folder.equal(project.folder)) {
					break;
				} else {
					const name = ___R$project$rome$$romejs$codec$js$manifest$name_ts$manifestNameToString(
						pkg.manifest.name,
					);
					if (name !== undefined) {
						parts.unshift(name);

						if (targetPackagePath === path) {
							root = pkg.folder;
						}
					}
					targetPackagePath = pkg.folder.getParent();
				}
			}

			parts.unshift(project.config.name);

			const relative = ___R$$priv$project$rome$$romejs$core$master$project$ProjectManager_ts$cleanRelativeUidPath(
				root.relative(path),
			);
			if (relative !== undefined) {
				parts.push(relative);
			}

			const uid = ___R$$priv$project$rome$$romejs$core$master$project$ProjectManager_ts$cleanUidParts(
				parts,
			);
			this.setUid(path, uid);
			return uid;
		}

		getFileReference(path) {
			const project = this.assertProjectExisting(path);
			const uid = this.getUid(path);
			const pkg = this.master.memoryFs.getOwnedManifest(path);
			return {
				uid,
				project: project.id,
				real: path,
				manifest: pkg === undefined ? undefined : pkg.id,
				relative: project.folder.relative(path).assertRelative(),
				remote: this.localPathToRemote.has(path),
			};
		}

		getURLFileReference(local, url) {
			if (!this.remoteToLocalPath.has(url)) {
				this.remoteToLocalPath.set(url, local);
				this.localPathToRemote.set(local, url);
			}

			return this.getFileReference(local);
		}

		getTransportFileReference(path) {
			const ref = this.getFileReference(path);
			return Object.assign(
				{},
				ref,
				{relative: ref.relative.join(), real: ref.real.join()},
			);
		}

		async maybeEvictPossibleConfig(path) {
			// TODO not sure if this case handles new manifests?
			// check if this filename is a rome config dependency
			const projectIds = this.projectConfigDependenciesToIds.get(path);
			if (projectIds === undefined) {
				return false;
			}

			const projectsToEvict = new Set();

			function getAllProjects(project) {
				let children = [];
				for (const child of project.children) {
					children = children.concat(getAllProjects(child));
				}
				return [project, ...children];
			}

			for (const evictProjectId of projectIds) {
				// Fetch the project
				const project = this.projects.get(evictProjectId);
				if (project === undefined) {
					throw new Error(
						"Expected project of id " +
						evictProjectId +
						" since it was declared in projectConfigLocsToId",
					);
				}

				// Add all parent projects
				let topProject = project;
				while (topProject.parent !== undefined) {
					topProject = topProject.parent;
				}
				for (const project of getAllProjects(topProject)) {
					projectsToEvict.add(project);
				}
			}

			for (const project of projectsToEvict) {
				await this.evictProject(project);
			}

			return true;
		}

		async evictProject(project) {
			const evictProjectId = project.id;

			// Remove the config locs from 'our internal map that belong to this project
			for (const [configLoc, projectIds] of this.projectConfigDependenciesToIds) {
				if (projectIds.has(evictProjectId)) {
					projectIds.delete(evictProjectId);
				}

				if (projectIds.size === 0) {
					this.projectConfigDependenciesToIds.delete(configLoc);
				}
			}

			// Notify all workers that it should delete the project
			for (const {bridge} of this.master.workerManager.getWorkers()) {
				// Evict project
				bridge.updateProjects.send({
					projects: [
						{
							id: evictProjectId,
							folder: project.folder.join(),
							config: undefined,
						},
					],
				});

				// Evict packages
				bridge.updateManifests.send({
					manifests: Array.from(
						project.manifests.values(),
						(def) => ({
							id: def.id,
							manifest: undefined,
						}),
					),
				});
			}

			// Delete the project from 'our internal map
			this.projects.delete(evictProjectId);
			this.projectFolderToId.delete(project.folder);

			// Evict all files that belong to this project and delete their project mapping
			const ownedFiles = [];
			for (const {projectId, path} of this.fileToProject.values()) {
				if (evictProjectId === projectId) {
					this.handleDeleted(path);
					ownedFiles.push(path);
				}
			}
			await Promise.all(
				ownedFiles.map((path) => this.master.fileAllocator.evict(path)),
			);

			// Tell the MemoryFileSystem to stop watching and clear it's maps
			this.master.memoryFs.unwatch(project.folder);
		}

		getProjects() {
			return Array.from(this.projects.values());
		}

		async queueAddProject(projectFolder, configPath) {
			// Check if we've already loaded this project
			const maybeProject = this.findProjectExisting(projectFolder);
			if (maybeProject !== undefined) {
				return maybeProject;
			}

			// If we're currently adding a project then add it to the queue
			if (this.isAddingProject) {
				return new Promise((resolve) => {
					this.pendingAddProjects.push({projectFolder, configPath, resolve});
				});
			}

			// First time loading this project
			this.isAddingProject = true;

			// fetch this project
			const mainProject = await this.addProject(projectFolder, configPath);
			const resolvedProjectsByDir = new Map();
			resolvedProjectsByDir.set(projectFolder.join(), mainProject);

			// Resolve all pending projects that were added while we were adding the current project
			const resolvedProjects = [];
			for (const {projectFolder, configPath, resolve} of this.pendingAddProjects) {
				// Check if the project has already been resolved
				const existing = resolvedProjectsByDir.get(projectFolder.join());
				if (existing !== undefined) {
					resolvedProjects.push({project: existing, resolve});
				} else {
					// It hasn't been resolved yet so let's add it
					const project = await this.addProject(projectFolder, configPath);
					resolvedProjects.push({project, resolve});
				}
			}

			// Resolve all promises
			for (const {project, resolve} of resolvedProjects) {
				resolve(project);
			}

			// Cleanup
			this.pendingAddProjects = [];
			this.isAddingProject = false;

			return mainProject;
		}

		addDependencyToProjectId(path, projectId) {
			const ids = this.projectConfigDependenciesToIds.get(path);

			if (ids === undefined) {
				this.projectConfigDependenciesToIds.set(path, new Set([projectId]));
			} else {
				ids.add(projectId);
			}
		}

		findProjectConfigConsumer(def, test) {
			const meta = ___R$project$rome$$romejs$project$utils_ts$assertHardMeta(
				def.meta,
			);

			for (const consumer of meta.consumersChain) {
				const value = test(consumer);
				if (value !== undefined && value !== false && value.exists()) {
					return {value, consumer: meta.consumer};
				}
			}

			return {value: undefined, consumer: meta.consumer};
		}

		async getVCSClient(project) {
			const client = await this.maybeGetVCSClient(project);

			if (client === undefined) {
				const {
					value: rootConfigConsumer,
					consumer,
				} = this.findProjectConfigConsumer(
					project,
					(consumer) => consumer.has("vsc") && consumer.get("vsc").get("root"),
				);

				const rootConfigLocation =
					rootConfigConsumer === undefined
						? undefined
						: rootConfigConsumer.getDiagnosticLocation();

				const location =
					rootConfigLocation === undefined
						? consumer.getDiagnosticLocation()
						: rootConfigLocation;

				throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PROJECT_MANAGER.NO_VCS(
						rootConfigLocation,
					),
					location,
				});
			} else {
				return client;
			}
		}

		async maybeGetVCSClient(project) {
			return await ___R$project$rome$$romejs$vcs$index_ts$getVCSClient(
				project.config.vcs.root,
			);
		}

		async addProject(projectFolder, configPath) {
			const {config, meta} = ___R$project$rome$$romejs$project$load_ts$loadCompleteProjectConfig(
				projectFolder,
				configPath,
			);

			return this.addProjectWithConfig({
				projectFolder,
				meta,
				config,
			});
		}

		async addProjectWithConfig(
			{
				projectFolder,
				meta,
				config,
			},
		) {
			// Make sure there's no project with the same `name` as us
			for (const project of this.projects.values()) {
				if (project.config.name === config.name) {
					throw new Error(
						"Conflicting project names. " +
						projectFolder +
						" and " +
						project.folder,
					);
				}
			}

			// Declare the project
			const parentProject = this.findProjectExisting(projectFolder.getParent());
			const project = {
				config,
				meta,
				folder: projectFolder,
				id: this.projectIdCounter++,
				packages: new Map(),
				manifests: new Map(),
				parent: parentProject,
				children: new Set(),
			};

			this.projects.set(project.id, project);
			this.fileToProject.set(
				projectFolder,
				{
					path: projectFolder,
					projectId: project.id,
				},
			);
			this.projectFolderToId.set(projectFolder, project.id);

			if (parentProject !== undefined) {
				parentProject.children.add(project);
			}

			// Add all project config dependencies so changes invalidate the whole project
			if (meta.configPath !== undefined) {
				this.addDependencyToProjectId(meta.configPath, project.id);
			}
			for (const loc of meta.configDependencies) {
				this.addDependencyToProjectId(loc, project.id);
			}

			// Notify other pieces of our creation
			this.master.workerManager.onNewProject(project);

			// Start watching and crawl this project folder
			await this.master.memoryFs.watch(projectFolder, config);

			return project;
		}

		declareManifest(project, isProjectPackage, def, diagnostics) {
			const name = ___R$project$rome$$romejs$codec$js$manifest$name_ts$manifestNameToString(
				def.manifest.name,
			);

			// Declare this package in all projects
			const projects = this.getHierarchyFromProject(project);

			// Check for collisions
			if (isProjectPackage && name !== undefined) {
				for (const project of projects) {
					// If there is no package then there's nothing to collide
					const existingPackage = project.packages.get(name);
					if (existingPackage === undefined) {
						continue;
					}

					diagnostics.addDiagnostic({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PROJECT_MANAGER.DUPLICATE_PACKAGE(
							name,
							existingPackage.path.join(),
						),
						location: def.consumer.get("name").getDiagnosticLocation(
							"inner-value",
						),
					});
					return;
				}
			}

			// Set as a package
			for (const project of projects) {
				this.addDependencyToProjectId(def.path, project.id);
				project.manifests.set(def.id, def);

				if (isProjectPackage && name !== undefined) {
					project.packages.set(name, def);
				}
			}
		}

		async notifyWorkersOfProjects(workers, projects) {
			if (projects === undefined) {
				projects = Array.from(this.projects.values());
			}

			const manifestsSerial = [];
			const projectsSerial = [];
			for (const project of projects) {
				projectsSerial.push({
					config: ___R$project$rome$$romejs$project$transport_ts$serializeJSONProjectConfig(
						project.config,
					),
					id: project.id,
					folder: project.folder.join(),
				});

				for (const def of project.manifests.values()) {
					manifestsSerial.push({
						id: def.id,
						manifest: this.master.memoryFs.getPartialManifest(def),
					});
				}
			}

			const promises = [];

			for (const worker of workers) {
				promises.push(
					worker.bridge.updateProjects.call({projects: projectsSerial}),
				);
				promises.push(
					worker.bridge.updateManifests.call({
						manifests: manifestsSerial,
					}),
				);
			}

			await Promise.all(promises);
		}

		async assertProject(path, location) {
			// We won't recurse up and check a parent project if we've already visited it
			const syncProject = this.findProjectExisting(path);
			const project = syncProject || (await this.findProject(path));

			if (project) {
				// Continue searching for projects up the directory
				// We don't do this for root projects since it would be a waste, but there's no implications other than some unnecessary work if we did
				if (project.config.root === false && syncProject === undefined) {
					await this.findProject(project.folder.getParent());
				}

				return project;
			}

			if (location === undefined) {
				throw new Error(
					"Couldn't find a project. Checked " +
					___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.join(
						" or ",
					) +
					" for " +
					path.join(),
				);
			}

			throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError({
				location,
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PROJECT_MANAGER.NOT_FOUND,
			});
		}

		// Convenience method to get the project config and pass it to the file handler class
		getHandlerWithProject(path) {
			const project = this.findProjectExisting(path);
			if (project === undefined) {
				return {ext: "", handler: undefined};
			} else {
				return ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandler(
					path,
					project.config,
				);
			}
		}

		getHierarchyFromFilename(path) {
			const project = this.findProjectExisting(path);
			if (project === undefined) {
				return [];
			} else {
				return this.getHierarchyFromProject(project);
			}
		}

		getHierarchyFromProject(project) {
			const projects = [];

			let currProject = project;
			while (currProject !== undefined) {
				projects.push(currProject);

				// root projects shouldn't be considered to have any parents
				if (currProject.config.root) {
					break;
				}

				currProject = project.parent;
			}

			return projects;
		}

		assertProjectExisting(path) {
			const project = this.findProjectExisting(path);
			if (project === undefined) {
				throw new Error("Expected existing project for " + path.join());
			}
			return project;
		}

		findProjectExisting(cwd) {
			const tried = [];

			for (const dir of cwd.getChain()) {
				const cached = this.fileToProject.get(dir);
				if (cached === undefined) {
					tried.push(dir);
				} else {
					for (const dir of tried) {
						this.fileToProject.set(dir, cached);
					}

					const project = this.projects.get(cached.projectId);
					if (project === undefined) {
						throw new Error(
							"Expected project from project id found in fileToProject",
						);
					}
					return project;
				}
			}

			return undefined;
		}

		async findProject(cwd) {
			// Check if we have an existing project
			const syncProject = this.findProjectExisting(cwd);
			if (syncProject !== undefined) {
				return syncProject;
			}

			const parentDirectories = cwd.getChain();

			// If not then let's access the file system and try to find one
			for (const dir of parentDirectories) {
				// Check for dedicated project configs
				for (const configFilename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES) {
					// Check in root
					const configPath = dir.append(configFilename);

					const hasProject = await this.master.memoryFs.existsHard(configPath);
					if (hasProject) {
						return this.queueAddProject(dir, configPath);
					}
				}

				// Check for package.json
				const packagePath = dir.append("package.json");
				if (await this.master.memoryFs.existsHard(packagePath)) {
					const input = await ___R$project$rome$$romejs$fs$index_ts$readFileText(
						packagePath,
					);
					const json = await ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON({
						input,
						path: packagePath,
					});
					if (
						json.has(
							___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_PACKAGE_JSON_FIELD,
						)
					) {
						return this.queueAddProject(dir, packagePath);
					}
				}
			}

			// If we didn't find a project config then check for incorrect config filenames
			for (const dir of parentDirectories) {
				for (const basename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES) {
					const path = dir.append(basename);

					if (await this.master.memoryFs.existsHard(path)) {
						this.warnIncorrectConfigFile(
							path,
							___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default.createImmediateThrower([
								{
									category: "project-manager",
									message: "Find project",
								},
							]),
						);
					}
				}
			}

			return undefined;
		}

		checkConfigFile(path, diagnostics) {
			if (
				___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_WARN_FILENAMES.includes(
					path.getBasename(),
				)
			) {
				this.warnIncorrectConfigFile(path, diagnostics);
			}
		}

		warnIncorrectConfigFile(path, diagnostics) {
			diagnostics.addDiagnostic({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.PROJECT_MANAGER.INCORRECT_CONFIG_FILENAME(
					___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES,
				),
				location: {
					filename: path.join(),
				},
			});
		}
	}


  // project-rome/@romejs/core/master/WorkerManager.ts
const ___R$$priv$project$rome$$romejs$core$master$WorkerManager_ts$child = require(
		"child_process",
	);


	class ___R$project$rome$$romejs$core$master$WorkerManager_ts$default {
		constructor(master) {
			this.master = master;

			this.workerStartEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "WorkerManager.workerStart",
				onError: master.onFatalErrorBound,
			});
			this.selfWorker = true;
			this.locker = new ___R$project$rome$$romejs$core$common$utils$Locker_ts$default();
			this.workers = new Map();
			this.idCounter = 0;
		}

		getNextWorkerId() {
			return this.idCounter++;
		}

		getWorkerAssert(id) {
			const worker = this.workers.get(id);
			if (worker === undefined) {
				throw new Error("Expected worker");
			}
			return worker;
		}

		getWorkers() {
			return Array.from(this.workers.values());
		}

		// Get worker count, excluding ghost workers
		getWorkerCount() {
			let count = 0;
			for (const worker of this.workers.values()) {
				if (worker.ghost === false) {
					count++;
				}
			}
			return count;
		}

		// Get all the workers that live in external processes
		getExternalWorkers() {
			return this.getWorkers().filter((worker) => worker.process !== undefined);
		}

		end() {
			// Shutdown all workers, no need to clean up any internal data structures since they will never be used
			for (const {bridge} of this.workers.values()) {
				bridge.end();
			}
		}

		getLowestByteCountWorker() {
			// Find the worker with the lowest byteCount value
			let smallestWorker;
			let byteCount;
			for (const worker of this.workers.values()) {
				if (
					!worker.ghost &&
					(byteCount === undefined || byteCount > worker.byteCount)
				) {
					smallestWorker = worker;
					byteCount = worker.byteCount;
				}
			}

			if (smallestWorker === undefined) {
				// This shouldn't be possible
				throw new Error("No worker found");
			} else {
				return smallestWorker;
			}
		}

		async init() {
			// Create the worker
			const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromLocal(
				___R$project$rome$$romejs$core$common$bridges$WorkerBridge_ts$default,
				{},
			);
			const worker = new ___R$project$rome$$romejs$core$worker$Worker_ts$default({
				bridge,
				globalErrorHandlers: false,
			});

			// We make an assumption elsewhere in the code that this is always the first worker

			// Let's use an invariant here for completeness
			const id = this.getNextWorkerId();
			if (id !== 0) {
				throw new Error("Expected master worker id to be 0");
			}

			const container = {
				id: 0,
				fileCount: 0,
				byteCount: 0,
				process: undefined,
				bridge,
				ghost: false,
				ready: false,
			};
			this.workers.set(0, container);
			await worker.init();

			await Promise.all([this.workerHandshake(container), bridge.handshake()]);

			this.workerStartEvent.send(bridge);
		}

		async replaceOwnWorker() {
			const lock = this.locker.getNewLock(0);

			try {
				const masterWorker = this.getWorkerAssert(0);
				this.master.logger.info(
					"[WorkerManager] Spawning first worker outside of master after exceeding " +
					___R$project$rome$$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS +
					" bytes",
				);
				this.selfWorker = false;

				// Spawn a new worker
				const newWorker = await this.spawnWorker(this.getNextWorkerId(), true);

				// End the old worker, will automatically cleanup
				masterWorker.bridge.end();

				// Swap the workers

				// We perform this as a single atomic operation rather than doing it in spawnWorker so we have predictable worker retrieval
				this.workers.set(
					0,
					{
						id: 0,
						fileCount: masterWorker.fileCount,
						byteCount: masterWorker.byteCount,
						bridge: newWorker.bridge,
						process: newWorker.process,
						ghost: false,
						ready: true,
					},
				);
				this.workers.delete(newWorker.id);
			} finally {
				lock.release();
			}
		}

		onNewProject(newProject) {
			this.master.projectManager.notifyWorkersOfProjects(
				this.getWorkers(),
				[newProject],
			);
		}

		async workerHandshake(worker) {
			const {bridge} = worker;
			await bridge.handshake({timeout: 3_000});
			await this.master.projectManager.notifyWorkersOfProjects([worker]);
			worker.ready = true;
		}

		async spawnWorker(workerId, isGhost = false) {
			const lock = this.locker.getNewLock(workerId);
			try {
				return await this._spawnWorker(workerId, isGhost);
			} finally {
				lock.release();
			}
		}

		async _spawnWorker(workerId, isGhost) {
			const start = Date.now();

			const process = ___R$project$rome$$romejs$core$common$utils$fork_ts$default(
				"worker",
			);

			const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromChildProcess(
				___R$project$rome$$romejs$core$common$bridges$WorkerBridge_ts$default,
				process,
				{
					type: "client",
					onSendMessage: (data) => {
						this.master.logger.info(
							"[WorkerManager] Sending worker request to %s:",
							workerId,
							data,
						);
					},
				},
			);

			const worker = {
				id: workerId,
				fileCount: 0,
				byteCount: 0,
				process,
				bridge,
				ghost: isGhost,
				ready: false,
			};
			this.workers.set(workerId, worker);

			process.once(
				"error",
				(err) => {
					// The process could not be spawned, or
					// The process could not be killed, or
					// Sending a message to the child process failed.
					this.master.onFatalError(err);
					process.kill();
				},
			);

			process.once(
				"exit",
				() => {
					//bridge.end(`Worker ${String(workerId)} died`);
					this.master.onFatalError(
						new Error("Worker " + String(workerId) + " died"),
					);
				},
			);

			await this.workerHandshake(worker);

			// If a worker is spawned while we're profiling then make sure it's profiling too
			if (this.master.profiling !== undefined) {
				await bridge.profilingStart.call(this.master.profiling);
			}

			this.workerStartEvent.send(bridge);

			this.master.logger.info(
				"[WorkerManager] Worker %s started after %sms",
				workerId,
				Date.now() - start,
			);

			return worker;
		}

		own(workerId, stats) {
			const worker = this.getWorkerAssert(workerId);
			worker.byteCount += stats.size;
			worker.fileCount++;
		}

		disown(workerId, stats) {
			const worker = this.getWorkerAssert(workerId);
			worker.byteCount -= stats.size;
			worker.fileCount--;
		}

		async getNextWorker(path) {
			const {logger, memoryFs, fileAllocator} = this.master;

			// Get stats first
			let stats = memoryFs.getFileStats(path);
			if (stats === undefined) {
				// Give memoryFs a chance to finish initializing if it's in a pending project
				await this.master.memoryFs.waitIfInitializingWatch(path);

				stats = memoryFs.getFileStats(path);
				if (stats === undefined) {
					console.error(
						Array.from(memoryFs.files.keys(), (path) => path.join()),
					);
					throw new Error("The file " + path.join() + " doesn't exist");
				}
			}

			// Verify that this file doesn't exceed any size limit
			fileAllocator.verifySize(path, stats);

			// Lock in case we're in the process of swapping the master worker with a dedicated worker
			await this.locker.waitLock(0);

			// If the worker is running in the master process and we've exceed our byte limit

			// then start up a dedicated worker process
			if (this.selfWorker) {
				const worker = this.getWorkerAssert(0);
				if (
					worker.byteCount >
					___R$project$rome$$romejs$core$common$constants_ts$MAX_MASTER_BYTES_BEFORE_WORKERS
				) {
					await this.replaceOwnWorker();
				}
			}

			// Find the worker with the lowest owned byte size
			const smallestWorker = this.getLowestByteCountWorker();
			let workerId = smallestWorker.id;

			// When the smallest worker exceeds the max worker byte limit and we're still under

			// our max worker limit, then let's start a new one
			if (
				smallestWorker.byteCount >
				___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD &&
				this.getWorkerCount() <
				___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_COUNT
			) {
				logger.info(
					"[WorkerManager] Spawning a new worker as we've exceeded " +
					___R$project$rome$$romejs$core$common$constants_ts$MAX_WORKER_BYTES_BEFORE_ADD +
					" bytes across each worker",
				);
				workerId = this.getNextWorkerId();
				await this.spawnWorker(workerId);
			}

			// Register size of file
			this.own(workerId, stats);

			// Just in case we've chosen a worker that's still spawning
			await this.locker.waitLock(workerId);

			return this.getWorkerAssert(workerId);
		}
	}


  // project-rome/@romejs/core/master/fs/resolverSuggest.ts
function ___R$project$rome$$romejs$core$master$fs$resolverSuggest_ts$default(
		resolver,
		query,
		resolved,
		origQuerySource,
	) {
		let errMsg = "";
		if (resolved.type === "UNSUPPORTED") {
			errMsg = "Unsupported path format";
		} else if (resolved.type === "MISSING") {
			errMsg = "Cannot find";
		} else if (resolved.type === "FETCH_ERROR") {
			errMsg = "Failed to fetch";
		}

		errMsg +=
			' "' + query.source.join() + '" from "' + query.origin.join() + '"';

		// Use the querySource returned by the resolution which will be the one that actually triggered this error, otherwise use the query source provided to us
		const querySource =
			resolved.source === undefined ? origQuerySource : resolved.source;
		if (querySource === undefined || querySource.location === undefined) {
			// TODO do something about the `advice` on some `resolved` that may contain metadata?
			throw new Error(errMsg);
		}

		const {location} = querySource;

		let advice = [];

		if (query.origin.isAbsolute()) {
			const localQuery = Object.assign(
				{},
				query,
				{origin: query.origin.assertAbsolute()},
			);

			// Provide advice in strict-mode if a non-strict version existed
			if (query.strict) {
				const nonStrictResolved = resolver.resolveLocal(
					Object.assign({}, localQuery, {strict: false}),
				);

				if (nonStrictResolved.type === "FOUND") {
					if (nonStrictResolved.types.includes("implicitIndex")) {
						advice.push({
							type: "log",
							category: "info",
							text: "This successfully resolves as an implicit index file. Trying adding <emphasis>/index" +
							nonStrictResolved.path.getExtensions() +
							"</emphasis> to the end of the import source",
						});
					} else if (nonStrictResolved.types.includes("implicitExtension")) {
						advice.push({
							type: "log",
							category: "info",
							text: "This successfully resolves as an implicit extension. Try adding the extension <emphasis>" +
							nonStrictResolved.path.getExtensions() +
							"</emphasis>",
						});
					}
				}
			}

			// We may set this to `true` for stuff like forgetting a platform
			let skipSimilaritySuggestions = false;

			// Try other platforms
			const validPlatforms = [];
			for (const PLATFORM of ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS) {
				if (PLATFORM === query.platform) {
					continue;
				}

				const resolved = resolver.resolveLocal(
					Object.assign({}, localQuery, {platform: PLATFORM}),
				);

				if (resolved.type === "FOUND") {
					validPlatforms.push(
						___R$project$rome$$romejs$string$markup$escape_ts$markup`<emphasis>${PLATFORM}</emphasis> at <filelink emphasis target="${resolved.ref.uid}" />`,
					);
				}
			}
			if (validPlatforms.length > 0) {
				if (query.platform === undefined) {
					advice.push({
						type: "log",
						category: "info",
						text: "No platform was specified but we found modules for the following platforms",
					});
				} else {
					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`No module found for the platform <emphasis>${query.platform}</emphasis> but we found these others`,
					});
				}

				skipSimilaritySuggestions = true;

				advice.push({
					type: "list",
					list: validPlatforms,
				});
			}

			// Hint on any indirection
			if (
				origQuerySource !== undefined &&
				origQuerySource.location !== undefined &&
				resolved.source !== undefined
			) {
				advice.push({
					type: "log",
					category: "info",
					text: "Found while resolving <emphasis>" +
					query.source +
					'</emphasis> from <filelink emphasis target="' +
					query.origin +
					'" />',
				});

				const origPointer = origQuerySource.location;

				advice.push({
					type: "frame",
					location: origPointer,
				});
			}

			// Suggestions based on similarity to paths and packages on disk
			if (!skipSimilaritySuggestions) {
				const suggestions = ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getSuggestions(
					resolver,
					localQuery,
				);
				if (suggestions.size > 0) {
					const originFolder = resolver.getOriginFolder(localQuery);

					// Relative paths to absolute
					const relativeToAbsolute = new Map();

					const relativeSuggestions = Array.from(
						suggestions,
						([human, absolute]) => {
							if (human !== absolute) {
								relativeToAbsolute.set(human, absolute);
								return human;
							}

							let relativePath = originFolder.relative(absolute);

							// If the user didn't use extensions, then neither should we
							if (!query.source.hasExtensions()) {
								// TODO only do this if it's an implicit extension
								relativePath = relativePath.changeBasename(
									relativePath.getExtensionlessBasename(),
								);
							}

							const relativeStr = relativePath.toExplicitRelative().join();
							relativeToAbsolute.set(relativeStr, absolute);
							return relativeStr;
						},
					);

					advice = [
						...advice,
						...___R$project$rome$$romejs$diagnostics$helpers_ts$buildSuggestionAdvice(
							query.source.join(),
							relativeSuggestions,
							{
								formatItem: (relative) => {
									const absolute = relativeToAbsolute.get(relative);
									if (absolute === undefined) {
										throw new Error("Should be valid");
									}

									return ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${absolute}">${relative}</filelink>`;
								},
							},
						),
					];
				}
			}

			// Hint if this was an entry resolve and the cwd wasn't a project
			if (
				query.entry === true &&
				resolver.master.projectManager.findProjectExisting(localQuery.origin) ===
				undefined
			) {
				advice.push({
					type: "log",
					category: "warn",
					text: "You aren't in a Rome project",
				});
			}
		}

		// TODO check if this would have been successful if not for exports access control
		const source =
			querySource.source === undefined
				? query.source.join()
				: querySource.source;

		if (resolved.advice !== undefined) {
			advice = advice.concat(resolved.advice);
		}

		throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError({
			location,
			description: Object.assign(
				{},
				___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.RESOLVER.NOT_FOUND(
					resolved.type,
					source,
					location,
				),
				{advice},
			),
		});
	}



	function ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(
		resolver,
		query,
	) {
		const {source} = query;
		const originFolder = resolver.getOriginFolder(query);
		const suggestions = new Map();

		// Try normal resolved
		___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(
			resolver,
			suggestions,
			originFolder.resolve(source),
		);

		// Remove . and .. entries from beginning
		const sourceParts = [...source.getSegments()];
		while (sourceParts[0] === "." || sourceParts[0] === "..") {
			sourceParts.shift();
		}

		// Try parent directories of the origin

		for (const path of originFolder.getChain()) {
			___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(
				resolver,
				suggestions,
				path.append(sourceParts),
			);
		}

		return suggestions;
	}

	const ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY = 0.8;

	function ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(
		resolver,
		suggestions,
		path,
	) {
		const {memoryFs} = resolver.master;

		const segments = path.getSegments();
		const chain = path.getChain();

		// Get all segments that are unknown
		for (let i = chain.length - 1; i >= 0; i--) {
			const path = chain[i];

			if (memoryFs.exists(path)) {
				// If this is an absolute match then we should be a suggestion
				if (i === chain.length) {
					const filename = path.join();
					suggestions.set(filename, filename);
				}

				// Otherwise this segment exists and should have been dealt with previously in the loop
				break;
			}

			const parentPath = path.getParent();

			// Our basename isn't valid, but our parent exists
			if (!memoryFs.exists(path) && memoryFs.exists(parentPath)) {
				const entries = Array.from(
					memoryFs.readdir(parentPath),
					(path) => path.join(),
				);
				if (entries.length === 0) {
					continue;
				}

				const ratings = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
					path.getExtensionlessBasename(),
					entries,
					{
						minRating: ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY,
						formatItem: (target) => {
							return ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
								target,
							).getExtensionlessBasename();
						},
					},
				);

				for (const rating of ratings) {
					___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$tryPathSuggestions(
						resolver,
						suggestions,
						___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
							rating.target,
						).append(segments.slice(1)).assertAbsolute(),
					);
				}
			}
		}
	}

	function ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(
		resolver,
		query,
	) {
		const possibleGlobalPackages = new Map();

		const mainProject = resolver.master.projectManager.findProjectExisting(
			query.origin,
		);
		if (mainProject !== undefined) {
			const projects = resolver.master.projectManager.getHierarchyFromProject(
				mainProject,
			);

			for (const project of projects) {
				for (const [name, value] of project.packages) {
					possibleGlobalPackages.set(name, value.folder.join());
				}
			}
		}

		// TODO Add node_modules
		const matches = ___R$project$rome$$romejs$string$utils$orderBySimilarity_ts$orderBySimilarity(
			query.source.join(),
			Array.from(possibleGlobalPackages.keys()),
			{
				minRating: ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$MIN_SIMILARITY,
			},
		).map((item) => {
			const name = item.target;

			const absolute = possibleGlobalPackages.get(name);
			if (absolute === undefined) {
				throw new Error("Should exist");
			}

			return [name, absolute];
		});
		return new Map(matches);
	}

	function ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getSuggestions(
		resolver,
		query,
	) {
		if (query.entry === true) {
			return new Map([
				...___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(
					resolver,
					query,
				),
				...___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(
					resolver,
					query,
				),
			]);
		} else if (
			___R$project$rome$$romejs$core$master$fs$Resolver_ts$isPathLike(
				query.source,
			)
		) {
			return ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPathSuggestions(
				resolver,
				query,
			);
		} else {
			return ___R$$priv$project$rome$$romejs$core$master$fs$resolverSuggest_ts$getPackageSuggestions(
				resolver,
				query,
			);
		}
	}


  // project-rome/@romejs/core/master/fs/Resolver.ts
const ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$https = require(
		"https",
	);
	function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$request(
		url,
	) {
		return new Promise((resolve) => {
			const req = ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$https.get(
				url,
				(res) => {
					if (res.statusCode !== 200) {
						console.log("non-200 return");
						resolve({
							type: "FETCH_ERROR",
							source: undefined,
							advice: [
								{
									type: "log",
									category: "info",
									text: '<hyperlink target="' +
									url +
									'" /> returned a ' +
									res.statusCode +
									" status code",
								},
							],
						});
						return;
					}

					let data = "";

					res.on(
						"data",
						(chunk) => {
							data += chunk;
						},
					);

					res.on(
						"end",
						() => {
							resolve({type: "DOWNLOADED", content: data});
						},
					);
				},
			);

			req.on(
				"error",
				(err) => {
					resolve({
						type: "FETCH_ERROR",
						source: undefined,
						advice: [
							{
								type: "log",
								category: "info",
								text: '<hyperlink target="' +
								url +
								'" /> resulted in the error "' +
								err.message +
								'"',
							},
						],
					});
				},
			);
		});
	}

	const ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$NODE_MODULES = "node_modules";



















	const ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING = {
		type: "MISSING",
		source: undefined,
	};





	function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(
		res,
	) {
		return res.type === "FOUND" || res.source !== undefined;
	}

	function ___R$project$rome$$romejs$core$master$fs$Resolver_ts$isPathLike(
		source,
	) {
		return source.isAbsolute() || source.isExplicitRelative();
	}

	function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(
		res,
		types,
	) {
		if (res.type === "FOUND") {
			return Object.assign({}, res, {types: [...res.types, ...types]});
		} else {
			return res;
		}
	}





	function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$attachExportAliasIfUnresolved(
		res,
		alias,
	) {
		if (res.type === "FOUND") {
			return res;
		}

		const location = alias.key.getDiagnosticLocation("value");

		return Object.assign(
			{},
			res,
			{
				source: location === undefined
					? undefined
					: {
							location,
							source: alias.value.join(),
						},
			},
		);
	}

	function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getExportsAlias(
		{
			manifest,
			relative,
			platform,
		},
	) {
		if (typeof manifest.exports === "boolean") {
			return undefined;
		}

		if (platform === undefined) {
			return undefined;
		}

		if (!relative.isRelative()) {
			return undefined;
		}

		const aliases = manifest.exports.get(relative.assertRelative());
		if (aliases === undefined) {
			return undefined;
		}

		const alias = aliases.get(platform);
		if (alias !== undefined) {
			return {
				key: alias.consumer,
				value: alias.relative,
			};
		}

		const def = aliases.get("default");
		if (def !== undefined) {
			return {
				key: def.consumer,
				value: def.relative,
			};
		}

		// TODO check for folder aliases
		return undefined;
	}

	function ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getPreferredMainKey(
		consumer,
		manifest,
		platform,
	) {
		const alias = ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getExportsAlias({
			manifest,
			relative: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
				".",
			),
			platform,
		});
		if (alias !== undefined) {
			return alias;
		}

		if (manifest.main !== undefined) {
			return {
				key: consumer.get("main"),
				value: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
					manifest.main,
				),
			};
		}

		return undefined;
	}

	class ___R$project$rome$$romejs$core$master$fs$Resolver_ts$default {
		constructor(master) {
			this.master = master;
		}

		init() {}

		async findProjectFromQuery(query) {
			// If we were passed an absolute path then we should find and add the project it belongs to
			if (query.source.isAbsolute()) {
				await this.master.projectManager.findProject(
					query.source.assertAbsolute(),
				);
			} else if (query.origin.isAbsolute()) {
				const origin = query.origin.assertAbsolute();
				await this.master.projectManager.findProject(origin);
				await this.master.projectManager.findProject(
					origin.append(query.source.assertRelative()),
				);
			}
		}

		async resolveEntryAssert(query, querySource) {
			await this.findProjectFromQuery(query);
			return this.resolveAssert(
				Object.assign({}, query, {entry: true}),
				querySource,
			);
		}

		// I found myself wanting only `ref.path` a lot so this is just a helper method
		async resolveEntryAssertPath(query, querySource) {
			const res = await this.resolveEntryAssert(query, querySource);
			return res.path;
		}

		async resolveEntry(query) {
			await this.findProjectFromQuery(query);
			return this.resolveRemote(Object.assign({}, query, {entry: true}));
		}

		async resolveAssert(query, origQuerySource) {
			const resolved = await this.resolveRemote(query);
			if (resolved.type === "FOUND") {
				return resolved;
			} else {
				throw ___R$project$rome$$romejs$core$master$fs$resolverSuggest_ts$default(
					this,
					query,
					resolved,
					origQuerySource,
				);
			}
		}

		async resolveRemote(query) {
			const {origin, source} = query;

			if (source.isURL()) {
				const sourceURL = source.assertURL();
				const protocol = sourceURL.getProtocol();

				switch (protocol) {
					case "http":
					case "https": {
						let projectConfig = ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG;

						if (origin.isAbsolute()) {
							const project = this.master.projectManager.findProjectExisting(
								query.origin.assertAbsolute(),
							);
							if (project !== undefined) {
								projectConfig = project.config;
							}
						}

						const remotePath = projectConfig.files.vendorPath.append(
							source.join().replace(/[\/:]/g, "$").replace(/\$+/g, "$"),
						);

						if (!this.master.memoryFs.exists(remotePath)) {
							const result = await ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$request(
								source.join(),
							);
							if (result.type === "DOWNLOADED") {
								await ___R$project$rome$$romejs$fs$index_ts$writeFile(
									remotePath,
									result.content,
								);
							} else {
								return result;
							}
						}

						return {
							type: "FOUND",
							types: [],
							ref: this.master.projectManager.getURLFileReference(
								remotePath,
								sourceURL,
							),
							path: remotePath,
						};
					}

					default:
						return {
							type: "UNSUPPORTED",
							source: undefined,
							advice: [
								{
									type: "log",
									category: "info",
									text: "<emphasis>" +
									protocol +
									"</emphasis> is not a supported remote protocol",
								},
							],
						};
				}
			}

			if (origin.isURL()) {
				if (source.isAbsolute() || source.isExplicitRelative()) {
					// Relative to the origin
					return this.resolveRemote(
						Object.assign({}, query, {source: origin.resolve(source)}),
					);
				} else {
					// TODO add support for import maps
					return {
						type: "MISSING",
						source: undefined,
					};
				}
			}

			return this.resolveLocal(
				Object.assign({}, query, {origin: query.origin.assertAbsolute()}),
			);
		}

		resolveLocal(query) {
			// Do some basic checks to determine if this is an absolute or relative path
			if (
				___R$project$rome$$romejs$core$master$fs$Resolver_ts$isPathLike(
					query.source,
				)
			) {
				return this.resolvePath(query);
			}

			// Now resolve it as a module
			const resolved = this.resolveModule(query);

			// If we didn't resolve to a module, and we were asked to resolve relative, then do that
			if (resolved.type === "MISSING" && query.entry === true) {
				return this.resolvePath(query);
			}

			return resolved;
		}

		*getFilenameVariants(query, path) {
			const seen = new Set();
			for (const variant of this._getFilenameVariants(query, path, [])) {
				const filename = variant.path.join();
				if (seen.has(filename)) {
					continue;
				}

				seen.add(filename);
				yield variant;
			}
		}

		*_getFilenameVariants(query, path, callees) {
			const {platform} = query;

			yield {path, types: callees};

			//
			const {handler} = this.master.projectManager.getHandlerWithProject(
				path.isAbsolute() ? path.assertAbsolute() : query.origin,
			);
			const usesUnknownExtension = !query.strict && handler === undefined;

			// Check with appended `platform`
			if (platform !== undefined && !callees.includes("implicitPlatform")) {
				yield* this._getFilenameVariants(
					query,
					path.addExtension("." + platform),
					[...callees, "implicitPlatform"],
				);

				// Check if this platform has any subplatforms
				const platformAliases = ___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORM_ALIASES[platform];
				if (platformAliases !== undefined) {
					for (const platform of platformAliases) {
						yield* this._getFilenameVariants(
							query,
							path.addExtension("." + platform, true),
							[...callees, "implicitPlatform"],
						);
					}
				}
			}

			// Check with appended extensions
			if (usesUnknownExtension && !callees.includes("implicitExtension")) {
				for (const ext of ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$IMPLICIT_JS_EXTENSIONS) {
					yield* this._getFilenameVariants(
						query,
						path.addExtension("." + ext),
						[...callees, "implicitExtension"],
					);
				}
			}

			// Check with appended `scale`, other.filename
			if (
				handler !== undefined &&
				handler.canHaveScale === true &&
				!callees.includes("implicitScale")
			) {
				const scale = query.scale === undefined ? 3 : query.scale;
				for (let i = scale; i >= 1; i--) {
					yield* this._getFilenameVariants(
						query,
						path.changeBasename(
							path.getExtensionlessBasename() +
							"@" +
							String(i) +
							"x" +
							path.memoizedExtension,
						),
						[...callees, "implicitScale"],
					);
				}
			}
		}

		finishResolverQueryResponse(path, types) {
			return {
				type: "FOUND",
				types: types === undefined ? [] : types,
				ref: this.master.projectManager.getFileReference(path),
				path,
			};
		}

		getOriginFolder(query) {
			const {memoryFs} = this.master;
			const {origin} = query;

			if (memoryFs.isFile(origin)) {
				return origin.getParent();
			} else {
				return origin;
			}
		}

		resolvePath(query, checkVariants = true, types) {
			const {memoryFs} = this.master;

			// Resolve the path heiarchy
			const originFolder = this.getOriginFolder(query);
			const resolvedOrigin = originFolder.resolve(query.source);

			// Check if this is an absolute filename
			if (memoryFs.isFile(resolvedOrigin)) {
				// If we're querying a package then we should never return a file
				if (query.requestedType === "package") {
					return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
				}

				return this.finishResolverQueryResponse(resolvedOrigin, types);
			}

			// Check variants
			if (checkVariants) {
				for (const variant of this.getFilenameVariants(query, resolvedOrigin)) {
					if (variant.path.equal(resolvedOrigin)) {
						continue;
					}

					const resolved = this.resolvePath(
						Object.assign({}, query, {source: variant.path}),
						false,
						variant.types,
					);

					if (
						___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(
							resolved,
						)
					) {
						return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(
							resolved,
							variant.types,
						);
					}
				}
			}

			// check if this is a folder
			if (memoryFs.isDirectory(resolvedOrigin)) {
				if (query.requestedType === "folder") {
					return this.finishResolverQueryResponse(resolvedOrigin, types);
				}

				// If this has a package.json then follow the `main` field
				const manifestDef = memoryFs.getManifestDefinition(resolvedOrigin);
				if (manifestDef !== undefined) {
					// If we're resolving a package then don't follow this
					if (query.requestedType === "package") {
						return this.finishResolverQueryResponse(resolvedOrigin, types);
					}

					const main = ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getPreferredMainKey(
						manifestDef.consumer,
						manifestDef.manifest,
						query.platform,
					);
					if (main !== undefined) {
						const resolved = this.resolvePath(
							Object.assign(
								{},
								query,
								{origin: resolvedOrigin, source: main.value},
							),
							true,
							["package"],
						);

						return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$attachExportAliasIfUnresolved(
							resolved,
							main,
						);
					}
				}

				if (!query.strict) {
					// Check if it has an index.* file
					for (const ext of ___R$project$rome$$romejs$core$common$file$handlers$javascript_ts$IMPLICIT_JS_EXTENSIONS) {
						const indexResolved = this.resolvePath(
							Object.assign(
								{},
								query,
								{source: resolvedOrigin.append("index." + ext)},
							),
							true,
							["implicitIndex"],
						);

						if (
							___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(
								indexResolved,
							)
						) {
							return indexResolved;
						}
					}
				}
			}

			return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
		}

		resolvePackageFolder(query, moduleName) {
			// Find the project
			const project = this.master.projectManager.findProjectExisting(
				query.origin,
			);
			if (project === undefined) {
				return undefined;
			}

			// Find the package
			const projects = this.master.projectManager.getHierarchyFromProject(
				project,
			);

			for (const project of projects) {
				const pkg = project.packages.get(moduleName);
				if (pkg !== undefined) {
					return pkg;
				}
			}

			return undefined;
		}

		resolvePackage(query, moduleName, moduleNameParts) {
			const manifestDef = this.resolvePackageFolder(query, moduleName);
			return this.resolveManifest(query, manifestDef, moduleNameParts);
		}

		resolveManifest(query, manifestDef, moduleNameParts) {
			if (manifestDef === undefined) {
				return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
			}

			if (moduleNameParts.length > 0) {
				// Submodules of this package are private
				if (manifestDef.manifest.exports === false) {
					return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
				}

				// Check if we're allowed to touch this submodule
				if (manifestDef.manifest.exports !== true) {
					const alias = ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$getExportsAlias({
						manifest: manifestDef.manifest,
						relative: ___R$project$rome$$romejs$path$index_ts$createFilePathFromSegments(
							moduleNameParts,
						),
						platform: query.platform,
					});

					if (alias === undefined) {
						// No submodule found
						return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
					}

					// Alias found!
					const resolved = this.resolvePath(
						Object.assign(
							{},
							query,
							{source: manifestDef.folder.append(alias.value)},
						),
						true,
						["package"],
					);
					return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$attachExportAliasIfUnresolved(
						resolved,
						alias,
					);
				}
			}

			// All exports are enabled or we are importing the root
			return this.resolvePath(
				Object.assign(
					{},
					query,
					{source: manifestDef.folder.append(moduleNameParts)},
				),
				true,
				["package"],
			);
		}

		resolveMock(query, project, parentDirectories) {
			if (project === undefined) {
				return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
			}

			const moduleName = query.source.assertRelative();

			for (const dir of parentDirectories) {
				const mocksDir = dir.append(
					___R$project$rome$$romejs$core$common$constants_ts$MOCKS_FOLDER_NAME,
				);

				// No use resolving against a directory that doesn't exist
				if (!this.master.memoryFs.exists(mocksDir)) {
					continue;
				}

				const resolved = this.resolveLocal(
					Object.assign({}, query, {source: mocksDir.append(moduleName)}),
				);

				if (
					___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(
						resolved,
					)
				) {
					return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$appendTypeQueryResponse(
						resolved,
						["mock"],
					);
				}
			}

			return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
		}

		// Given a reference to a module, extract the module name and any trailing relative paths
		splitModuleName(path) {
			// fetch the first part of the path as that's the module name
			// possible values of `moduleNameFull` could be `react` or `react/lib/whatever`
			const [moduleName, ...moduleNameParts] = path.getSegments();

			// For scoped modules in the form of `@romejs/bar`, make sure we keep the `/bar` on the module name
			if (moduleName[0] === "@" && moduleNameParts.length > 0) {
				return [moduleName + "/" + moduleNameParts.shift(), moduleNameParts];
			}

			return [moduleName, moduleNameParts];
		}

		resolveModule(query) {
			const {origin, source} = query;

			// Get project for the origin
			const project = this.master.projectManager.findProjectExisting(origin);

			// Get all the parent directories for when we crawl up
			const parentDirectories = this.getOriginFolder(query).getChain();

			// If mocks are enabled for this query then check all parent mocks folder
			if (query.mocks === true) {
				const mockResolved = this.resolveMock(query, project, parentDirectories);
				if (
					___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(
						mockResolved,
					)
				) {
					return mockResolved;
				}
			}

			// Extract the module name and it's relative file parts
			const [moduleName, moduleNameParts] = this.splitModuleName(source);

			// Resolve a virtual module
			const virtualResolved = this.master.virtualModules.resolve(moduleName);
			if (virtualResolved !== undefined) {
				return this.resolvePath(
					Object.assign(
						{},
						query,
						{source: virtualResolved.append(moduleNameParts)},
					),
					true,
					["virtual"],
				);
			}

			// Check if it matches any of our project packages
			const packageResolved = this.resolvePackage(
				query,
				moduleName,
				moduleNameParts,
			);
			if (
				___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$shouldReturnQueryResponse(
					packageResolved,
				)
			) {
				return packageResolved;
			}

			// Check all parent directories for node_modules
			for (const dir of parentDirectories) {
				const modulePath = dir.append(
					___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$NODE_MODULES,
				).append(moduleName);
				const manifestDef = this.master.memoryFs.getManifestDefinition(
					modulePath,
				);
				if (manifestDef !== undefined) {
					return this.resolveManifest(query, manifestDef, moduleNameParts);
				}
			}

			return ___R$$priv$project$rome$$romejs$core$master$fs$Resolver_ts$QUERY_RESPONSE_MISSING;
		}
	}


  // project-rome/@romejs/core/master/fs/FileAllocator.ts
class ___R$project$rome$$romejs$core$master$fs$FileAllocator_ts$default {
		constructor(master) {
			this.master = master;
			this.fileToWorker = new Map();
			this.locker = new ___R$project$rome$$romejs$core$common$utils$Locker_ts$default();
			this.evictEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "evict",
			});
		}

		init() {
			this.master.memoryFs.deletedFileEvent.subscribe((path) => {
				return this.handleDeleted(path);
			});

			this.master.memoryFs.changedFileEvent.subscribe((
				{path, oldStats, newStats},
			) => {
				return this.handleChange(path, oldStats, newStats);
			});
		}

		getAllOwnedFilenames() {
			return Array.from(this.fileToWorker.keys());
		}

		hasOwner(path) {
			return this.getOwnerId(path) !== undefined;
		}

		getOwnerId(path) {
			return this.fileToWorker.get(path.join());
		}

		verifySize(path, stats) {
			const project = this.master.projectManager.assertProjectExisting(path);
			const maxSize = project.config.files.maxSize;

			if (stats.size > maxSize) {
				throw new Error(
					"The file " +
					path.join() +
					" exceeds the project config max size of " +
					maxSize +
					" bytes",
				);
			}
		}

		getOwnerAssert(path) {
			const {workerManager} = this.master;
			const workerId = this.getOwnerId(path);
			if (workerId === undefined) {
				throw new Error("No worker found for " + path);
			}

			const worker = workerManager.getWorkerAssert(workerId);
			if (!worker.ready) {
				throw new Error("Worker " + workerId + " isn't ready");
			}
			return worker;
		}

		async getOrAssignOwner(path) {
			const {workerManager} = this.master;

			const workerId = this.getOwnerId(path);
			if (workerId === undefined) {
				return this.assignOwner(path);
			} else {
				await workerManager.locker.waitLock(workerId);
				return workerManager.getWorkerAssert(workerId);
			}
		}

		async evict(path) {
			// Find owner
			const workerId = this.getOwnerId(path);
			if (workerId === undefined) {
				return;
			}

			// Notify the worker to remove it from 'it's cache
			const filename = path.join();
			const worker = this.master.workerManager.getWorkerAssert(workerId);
			await worker.bridge.evict.call({
				filename,
			});
			this.evictEvent.send(path);

			this.master.logger.info("[FileAllocator] Evicted %s", filename);
		}

		async handleDeleted(path) {
			// Find owner
			const workerId = this.getOwnerId(path);
			if (workerId === undefined) {
				return;
			}

			// Evict file from 'worker cache
			await this.evict(path);

			// Disown it from 'our internal map
			this.fileToWorker.delete(path.join());

			// Remove the total size from 'this worker so it'll be assigned next
			const stats = this.master.memoryFs.getFileStatsAssert(path);
			this.master.workerManager.disown(workerId, stats);
		}

		async handleChange(path, oldStats, newStats) {
			const filename = path.join();
			const {logger, workerManager} = this.master;

			// Send update to worker owner
			if (this.hasOwner(path)) {
				// Get the worker
				const workerId = this.getOwnerId(path);
				if (workerId === undefined) {
					throw new Error("Expected worker id for " + filename);
				}

				// Evict the file from 'cache
				await this.evict(path);

				// Verify that this file doesn't exceed any size limit
				this.verifySize(path, newStats);

				// Add on the new size, and remove the old
				if (oldStats === undefined) {
					throw new Error(
						"File already has an owner so expected to have old stats but had none",
					);
				}
				workerManager.disown(workerId, oldStats);
				workerManager.own(workerId, newStats);
			} else if (await this.master.projectManager.maybeEvictPossibleConfig(path)) {
				logger.info(
					"[FileAllocator] Evicted the project belonging to config %s",
					filename,
				);
			} else {
				logger.info("[FileAllocator] No owner for eviction %s", filename);
			}
		}

		async assignOwner(path) {
			const {workerManager, logger} = this.master;

			const filename = path.join();
			const lock = await this.locker.getLock(filename);

			// We may have waited on the lock and could already have an owner
			if (this.hasOwner(path)) {
				lock.release();
				return this.getOwnerAssert(path);
			}

			const worker = await workerManager.getNextWorker(path);

			// Add ourselves to the file map
			logger.info(
				"[FileAllocator] File %s assigned to worker %s",
				filename,
				worker.id,
			);
			this.fileToWorker.set(filename, worker.id);

			// Release and continue
			lock.release();

			return worker;
		}
	}


  // project-rome/@romejs/core/common/utils/Logger.ts
class ___R$project$rome$$romejs$core$common$utils$Logger_ts$default
		extends ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default {
		constructor(name, isEnabled, opts) {
			super(Object.assign({verbose: true}, opts));
			this._loggerName = name;
			this.isEnabled = isEnabled;
		}

		getMessagePrefix() {
			return "<dim>[" + this._loggerName + " " + process.pid + "]</dim> ";
		}
	}


  // project-rome/@romejs/core/master/fs/MemoryFileSystem.ts
const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$crypto = require(
		"crypto",
	);
	const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$fs = require(
		"fs",
	);
	const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$DEFAULT_DENYLIST = [
		".hg",
		".git",
	];

	const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$GLOB_IGNORE = [
		___R$project$rome$$romejs$path$match$parse_ts$parsePattern({
			input: "node_modules",
		}),
		___R$project$rome$$romejs$path$match$parse_ts$parsePattern({input: ".git"}),
		___R$project$rome$$romejs$path$match$parse_ts$parsePattern({input: ".hg"}),
	];

	function ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$concatGlobIgnore(
		patterns,
	) {
		// If there are any negate patterns then it'll never include GLOB_IGNORE
		for (const {negate} of patterns) {
			if (negate) {
				return patterns;
			}
		}

		return [
			...___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$GLOB_IGNORE,
			...patterns,
		];
	}

	function ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$isValidManifest(
		path,
	) {
		if (path.getBasename() !== "package.json") {
			return false;
		}

		// If a manifest is in node_modules, then make sure we're directly inside
		// a folder in node_modules.
		//
		// For unscoped package, the segments should be:
		//   -1: package.json
		//   -2: module folder
		//   -3: node_modules
		//
		// For scoped package (@scope/some-module), the segments should be:
		//   -1: package.json
		//   -2: module folder
		//   -3: scope folder
		//   -4: node_modules
		const segments = path.getSegments();
		if (segments.includes("node_modules")) {
			// Unscoped package
			if (segments[segments.length - 3] === "node_modules") {
				return true;
			}

			// Scoped module
			if (
				segments[segments.length - 4] === "node_modules" &&
				segments[segments.length - 3].startsWith("@")
			) {
				return true;
			}

			return false;
		}

		return true;
	}

	// Whenever we're performing an operation on a set of files, always do these first as they may influence how the rest are processed
	const ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$PRIORITY_FILES = new Set(
		___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES,
	);













	async function ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$createWatcher(
		memoryFs,
		diagnostics,
		projectFolderPath,
	) {
		const projectFolder = projectFolderPath.join();
		const {logger} = memoryFs.master;

		// Create activity spinners for all connected reporters
		const activity = memoryFs.master.connectedReporters.progress({
			initDelay: 1_000,
			title: "Adding project " + projectFolder,
		});

		const watchers = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();

		try {
			function onFoundDirectory(folderPath) {
				if (watchers.has(folderPath)) {
					return;
				}

				let recursive = true;

				if (process.platform === "linux") {
					// Node on Linux doesn't support recursive directory watching so we need an fs.watch for every directory...
					recursive = false;
				} else if (!folderPath.equal(projectFolderPath)) {
					// If we're on any other platform then only watch the root project folder
					return;
				}

				const watcher = ___R$project$rome$$romejs$fs$index_ts$watch(
					folderPath,
					{recursive, persistent: false},
					(eventType, filename) => {
						if (filename === null) {
							// TODO not sure how we want to handle this?
							return;
						}

						const path = folderPath.resolve(filename);

						memoryFs.stat(path).then((newStats) => {
							const diagnostics = memoryFs.master.createDisconnectedDiagnosticsProcessor([
								{
									category: "memory-fs",
									message: "Processing fs.watch changes",
								},
							]);

							if (newStats.type === "file") {
								memoryFs.handleFileChange(
									path,
									newStats,
									{
										diagnostics,
										crawl: true,
									},
								);
							} else if (newStats.type === "directory") {
								memoryFs.addDirectory(
									path,
									newStats,
									{
										crawl: true,
										diagnostics,
										onFoundDirectory,
									},
								);
							}
						}).catch((err) => {
							if (err.code === "ENOENT") {
								memoryFs.handleDeletion(path);
							} else {
								throw err;
							}
						});
					},
				);
				watchers.set(folderPath, watcher);
			}

			// No need to call watch() on the projectFolder since it will call us

			// Perform an initial crawl
			const stats = await memoryFs.stat(projectFolderPath);
			await memoryFs.addDirectory(
				projectFolderPath,
				stats,
				{
					crawl: true,
					diagnostics,
					onFoundDirectory,
				},
			);
			logger.info(
				"[MemoryFileSystem] Finished initial crawl for " +
				projectFolder +
				" - added " +
				___R$project$rome$$romejs$string$utils$humanizeNumber_ts$humanizeNumber(
					memoryFs.countFiles(projectFolderPath),
				) +
				" files",
			);
		} finally {
			activity.end();
		}

		return () => {
			for (const watcher of watchers.values()) {
				watcher.close();
			}
		};
	}

	class ___R$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$default {
		constructor(master) {
			this.master = master;

			this.watchPromises = new Map();
			this.directoryListings = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.directories = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.files = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.manifests = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.watchers = new Map();
			this.manifestCounter = 0;

			this.changedFileEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "MemoryFileSystem.changedFile",
				onError: master.onFatalErrorBound,
			});
			this.deletedFileEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "MemoryFileSystem.deletedFile",
				onError: master.onFatalErrorBound,
			});
		}

		init() {}

		unwatch(dirPath) {
			const dir = dirPath.join();
			const watcher = this.watchers.get(dir);
			if (watcher === undefined) {
				return;
			}

			this.watchers.delete(dir);
			watcher.close();

			// Go through and clear all files and directories from our internal maps

			// NOTE: We deliberately do not call 'deletedFileEvent' as the code that

			// calls us will already be cleaning up
			let queue = [dirPath];
			while (queue.length > 0) {
				const path = queue.pop();
				if (path === undefined) {
					throw new Error("Unknown path");
				}

				this.directories.delete(path);
				this.manifests.delete(path);
				this.files.delete(path);

				const listing = this.directoryListings.get(path);
				if (listing !== undefined) {
					this.directoryListings.delete(path);
					queue = queue.concat(Array.from(listing.values()));
				}
			}
		}

		unwatchAll() {
			for (const {close} of this.watchers.values()) {
				close();
			}
		}

		readdir(path) {
			const listing = this.directoryListings.get(path);
			if (listing === undefined) {
				return [];
			} else {
				return listing.values();
			}
		}

		isDirectory(path) {
			return this.directories.has(path);
		}

		isFile(path) {
			return this.files.has(path);
		}

		getFiles() {
			return Array.from(this.files.values());
		}

		getManifestDefinition(dirname) {
			return this.manifests.get(dirname);
		}

		getManifest(dirname) {
			const def = this.getManifestDefinition(dirname);
			if (def === undefined) {
				return undefined;
			} else {
				return def.manifest;
			}
		}

		getOwnedManifest(path) {
			for (const dir of path.getChain()) {
				const def = this.master.memoryFs.getManifestDefinition(dir);
				if (def !== undefined) {
					return def;
				}
			}
			return undefined;
		}

		getPartialManifest(def) {
			return {
				path: def.path.join(),
				type: def.manifest.type,
			};
		}

		addFileToDirectoryListing(path) {
			const dirname = path.getParent();
			let listing = this.directoryListings.get(dirname);
			if (listing === undefined) {
				listing = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
				this.directoryListings.set(dirname, listing);
			}
			listing.set(path, path);
		}

		handleDeletion(path) {
			// If a folder then evict all children
			const folderInfo = this.directories.get(path);
			if (folderInfo !== undefined) {
				this.directories.delete(path);

				const listing = this.directoryListings.get(path);
				if (listing !== undefined) {
					this.directoryListings.delete(path);
					for (const path of listing.values()) {
						this.handleDeletion(path);
					}
				}
			}

			// Remove from 'all possible caches
			this.files.delete(path);

			// If this is a manifest filename then clear it from 'any possible package and our internal module map
			const basename = path.getBasename();
			if (basename === "package.json") {
				this.handleDeletedManifest(path);
			}

			// Remove from 'parent directory listing
			const dirname = path.getParent();
			const parentListing = this.directoryListings.get(dirname);
			if (parentListing !== undefined) {
				parentListing.delete(path);
			}

			this.deletedFileEvent.send(path);
		}

		handleDeletedManifest(path) {
			const folder = path.getParent();
			const def = this.manifests.get(folder);
			if (def !== undefined) {
				this.manifests.delete(folder);
			}
		}

		async handleFileChange(path, stats, opts) {
			const oldStats = this.getFileStats(path);
			const changed = await this.addFile(path, stats, opts);
			if (changed) {
				const newStats = this.getFileStatsAssert(path);
				this.changedFileEvent.send({path, oldStats, newStats});
			}
			return changed;
		}

		async waitIfInitializingWatch(projectFolderPath) {
			// Defer if we're initializing a parent folder
			for (const {promise, path} of this.watchPromises.values()) {
				if (projectFolderPath.isRelativeTo(path)) {
					await promise;
					return;
				}
			}

			// Wait if we're initializing descendents
			for (const {path, promise} of this.watchPromises.values()) {
				if (path.isRelativeTo(projectFolderPath)) {
					await promise;
				}
			}
		}

		async watch(projectFolderPath, projectConfig) {
			const {logger} = this.master;
			const projectFolder = projectFolderPath.join();
			const folderLink = ___R$project$rome$$romejs$string$markup$escape_ts$markup`<filelink target="${projectFolder}" />`;

			// Defer if we're already currently initializing this project
			const cached = this.watchPromises.get(projectFolder);
			if (cached !== undefined) {
				await cached;
				return undefined;
			}

			// Check if we're already watching this folder
			if (this.watchers.has(projectFolder)) {
				return undefined;
			}

			// Check if we're already watching a parent directory
			for (const {path} of this.watchers.values()) {
				if (projectFolderPath.isRelativeTo(path)) {
					logger.info(
						"[MemoryFileSystem] Skipped crawl for " +
						folderLink +
						" because we're already watching the parent directory " +
						path.join(),
					);
					return undefined;
				}
			}

			// Wait for other initializations
			await this.waitIfInitializingWatch(projectFolderPath);

			// New watch target
			logger.info("[MemoryFileSystem] Adding new project folder " + folderLink);

			// Remove watchers that are descedents of this folder as this watcher will handle them
			for (const [loc, {close, path}] of this.watchers) {
				if (path.isRelativeTo(projectFolderPath)) {
					this.watchers.delete(loc);
					close();
				}
			}

			const diagnostics = this.master.createDiagnosticsProcessor({
				origins: [
					{
						category: "memory-fs",
						message: "Crawling project folder",
					},
				],
			});

			logger.info("[MemoryFileSystem] Watching " + folderLink);
			const promise = ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$createWatcher(
				this,
				diagnostics,
				projectFolderPath,
			);
			this.watchPromises.set(
				projectFolder,
				{
					path: projectFolderPath,
					promise,
				},
			);

			const watcherClose = await promise;
			this.watchers.set(
				projectFolder,
				{
					path: projectFolderPath,
					close: watcherClose,
				},
			);
			this.watchPromises.delete(projectFolder);

			diagnostics.maybeThrowDiagnosticsError();
		}

		async stat(path) {
			const stats = await ___R$project$rome$$romejs$fs$index_ts$lstat(path);

			let type = "unknown";
			if (stats.isDirectory()) {
				type = "directory";
			} else if (stats.isFile()) {
				type = "file";
			}

			return {
				type,
				size: stats.size,
				mtime: stats.mtimeMs,
			};
		}

		getMtime(path) {
			const stats = this.getFileStats(path);
			if (stats === undefined) {
				throw new Error(
					"File " + path.join() + " not in database, cannot get mtime",
				);
			} else {
				return stats.mtime;
			}
		}

		getFileStats(path) {
			return this.files.get(path);
		}

		getFileStatsAssert(path) {
			const stats = this.getFileStats(path);
			if (stats === undefined) {
				throw new Error("Expected file stats for " + path);
			}
			return stats;
		}

		isIgnored(path, type) {
			const project = this.master.projectManager.findProjectExisting(path);
			if (project === undefined) {
				return false;
			}

			// If we're a file and don't have an extension handler so there's no reason for us to care about it
			if (
				type === "file" &&
				___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandler(
					path,
					project.config,
				) === undefined
			) {
				return true;
			}

			// Ensure we aren't in any of the default denylists
			const basename = path.getBasename();
			if (
				___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$DEFAULT_DENYLIST.includes(
					basename,
				)
			) {
				return true;
			}

			return false;
		}

		isInsideProject(path) {
			return path.getSegments().includes("node_modules") === false;
		}

		// This is a wrapper around _declareManifest as it can produce diagnostics
		async declareManifest(opts) {
			const {diagnostics} = await ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(() => {
				return this._declareManifest(opts);
			});

			if (diagnostics !== undefined) {
				opts.diagnostics.addDiagnostics(diagnostics);
			}
		}

		async _declareManifest(
			{
				path,
				diagnostics,
			},
		) {
			// Fetch the manifest
			const manifestRaw = await ___R$project$rome$$romejs$fs$index_ts$readFileText(
				path,
			);
			const hash = ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$crypto.createHash(
				"sha256",
			).update(manifestRaw).digest("hex");

			const consumer = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON({
				path,
				input: manifestRaw,
				consumeDiagnosticCategory: "parse/manifest",
			});

			const {
				manifest,
				diagnostics: normalizedDiagnostics,
			} = await ___R$project$rome$$romejs$codec$js$manifest$index_ts$normalizeManifest(
				path,
				consumer,
			);

			// If manifest is undefined then we failed to validate and have diagnostics
			if (normalizedDiagnostics.length > 0) {
				diagnostics.addDiagnostics(normalizedDiagnostics);
				return;
			}

			const folder = path.getParent();
			const manifestId = this.manifestCounter++;
			const def = {
				id: manifestId,
				path,
				folder,
				consumer,
				manifest,
				hash,
			};

			this.manifests.set(folder, def);

			// If we aren't in node_modules then this is a project package
			const isProjectPackage = this.isInsideProject(path);
			const {projectManager} = this.master;
			const project = projectManager.findProjectExisting(path);
			if (project !== undefined) {
				projectManager.declareManifest(
					project,
					isProjectPackage,
					def,
					diagnostics,
				);
			}

			// Tell all workers of our discovery
			for (const worker of this.master.workerManager.getWorkers()) {
				worker.bridge.updateManifests.call({
					manifests: [{id: def.id, manifest: this.getPartialManifest(def)}],
				});
			}
		}

		glob(cwd, opts = {}) {
			const {extensions, getProjectIgnore, test, overrideIgnore = []} = opts;

			const paths = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathSet();

			let crawl = [cwd];

			const ignoresByProject = new Map();

			while (crawl.length > 0) {
				const path = crawl.pop();

				const project = this.master.projectManager.assertProjectExisting(path);

				let ignore = overrideIgnore;

				// Get ignore patterns
				if (getProjectIgnore !== undefined) {
					const projectIgnore = ignoresByProject.get(project);
					if (projectIgnore === undefined) {
						ignore = ___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$concatGlobIgnore([
							...ignore,
							...getProjectIgnore(project),
						]);
						ignoresByProject.set(project, ignore);
					} else {
						ignore = projectIgnore;
					}
				}

				const ignoreMatched = ___R$project$rome$$romejs$path$match$index_ts$matchPathPatterns(
					path,
					ignore,
					cwd,
				);

				// Don't even recurse into explicit matches
				if (ignoreMatched === "EXPLICIT_MATCH") {
					continue;
				}

				// Add if a matching file
				if (this.files.has(path) && ignoreMatched === "NO_MATCH") {
					if (test !== undefined && !test(path)) {
						continue;
					}

					// Check extensions
					if (extensions !== undefined) {
						let matchedExt = false;
						for (const ext of extensions) {
							matchedExt = path.hasEndExtension(ext);
							if (matchedExt) {
								break;
							}
						}
						if (!matchedExt) {
							continue;
						}
					}

					paths.add(path);
					continue;
				}

				// Crawl if we're a folder

				// NOTE: We still continue crawling on implicit matches
				const listing = this.directoryListings.get(path);
				if (listing !== undefined) {
					crawl = crawl.concat(Array.from(listing.values()));
					continue;
				}

				// TODO maybe throw? not a file or folder, doesn't exist!
			}

			return paths;
		}

		getAllFilesInFolder(folder) {
			let files = [];

			const listing = this.directoryListings.get(folder);
			if (listing !== undefined) {
				for (const file of listing.keys()) {
					if (this.files.has(file)) {
						files.push(file);
					} else {
						files = files.concat(this.getAllFilesInFolder(file));
					}
				}
			}

			return files;
		}

		countFiles(folder) {
			let count = 0;

			const listing = this.directoryListings.get(folder);
			if (listing !== undefined) {
				for (const file of listing.keys()) {
					count++;
					count += this.countFiles(file);
				}
			}

			return count;
		}

		hasStatsChanged(path, newStats) {
			const oldStats = this.directories.get(path) || this.files.get(path);
			return oldStats === undefined || newStats.mtime !== oldStats.mtime;
		}

		async addDirectory(folderPath, stats, opts) {
			if (!this.hasStatsChanged(folderPath, stats)) {
				return false;
			}

			// Check if this folder has been ignored
			if (this.isIgnored(folderPath, "directory")) {
				return false;
			}

			if (opts.tick !== undefined) {
				opts.tick(folderPath);
			}

			this.addFileToDirectoryListing(folderPath);
			this.directories.set(folderPath, stats);

			if (opts.onFoundDirectory !== undefined) {
				opts.onFoundDirectory(folderPath);
			}

			if (opts.crawl) {
				// Crawl the folder
				const files = await ___R$project$rome$$romejs$fs$index_ts$readdir(
					folderPath,
				);

				// Declare the file
				const declareItem = async (path) => {
					const stats = await this.stat(path);
					if (stats.type === "file") {
						await this.addFile(path, stats, opts);
					} else if (stats.type === "directory") {
						await this.addDirectory(path, stats, opts);
					}
				};

				// Give priority to package.json in case we want to derive something from the project config
				for (const file of files) {
					if (
						___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$PRIORITY_FILES.has(
							file.getBasename(),
						)
					) {
						files.delete(file);
						await declareItem(file);
					}
				}

				// Add the rest of the items
				await Promise.all(Array.from(files, declareItem));
			}

			return true;
		}

		exists(path) {
			// if we have this in our cache then the file exists
			if (this.files.has(path) || this.directories.has(path)) {
				return true;
			}

			// If we're still performing an initial crawl of any path higher in the tree then we don't know if it exists yet
			for (const {path: projectFolder} of this.watchPromises.values()) {
				if (path.isRelativeTo(projectFolder)) {
					return undefined;
				}
			}

			// if we're watching the parent folder then we'd have it in our cache if it existed
			const parent = path.getParent();
			if (this.directories.has(parent)) {
				return false;
			}

			return undefined;
		}

		async existsHard(path) {
			const resolvedExistence = this.exists(path);
			if (resolvedExistence === undefined) {
				return ___R$project$rome$$romejs$fs$index_ts$exists(path);
			} else {
				return resolvedExistence;
			}
		}

		async addFile(path, stats, opts) {
			if (!this.hasStatsChanged(path, stats)) {
				return false;
			}

			// Check if this file has been ignored
			if (this.isIgnored(path, "file")) {
				return false;
			}

			if (opts.tick !== undefined) {
				opts.tick(path);
			}

			this.files.set(path, stats);
			this.addFileToDirectoryListing(path);

			const basename = path.getBasename();
			const dirname = path.getParent();

			// Warn about potentially incorrect Rome config filenames
			const {projectManager} = this.master;
			projectManager.checkConfigFile(path, opts.diagnostics);

			// Add project if this is a config
			if (
				___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES.includes(
					basename,
				)
			) {
				await projectManager.queueAddProject(dirname, path);
			}

			if (
				___R$$priv$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$isValidManifest(
					path,
				)
			) {
				await this.declareManifest({
					diagnostics: opts.diagnostics,
					dirname,
					path,
				});
			}

			return true;
		}
	}


  // project-rome/@romejs/core/master/Cache.ts

	// Basic checks to determine if we can consider a and b to be mergable
	function ___R$$priv$project$rome$$romejs$core$master$Cache_ts$areEntriesEqual(
		a,
		b,
	) {
		if (a.version !== b.version) {
			// Outdated cache file
			return false;
		}

		if (a.configHash !== b.configHash) {
			// Project config has been changed since this was last updated
			return false;
		}

		if (a.mtime !== b.mtime) {
			// File has been changed
			return false;
		}

		return true;
	}

	class ___R$project$rome$$romejs$core$master$Cache_ts$default {
		constructor(master) {
			this.master = master;
			this.loadedEntries = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.disabled = process.env.ROME_CACHE === "0";
			this.cachePath = master.userConfig.cachePath;
		}

		async init() {
			this.master.memoryFs.deletedFileEvent.subscribe((filename) => {
				return this.master.cache.handleDeleted(filename);
			});

			const {memoryFs} = this.master;
			await ___R$project$rome$$romejs$fs$index_ts$createDirectory(
				this.cachePath,
				{recursive: true},
			);
			await memoryFs.watch(
				this.cachePath,
				___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
			);
		}

		async createEmptyEntry(path) {
			const {projectManager, memoryFs} = this.master;

			const project = await projectManager.assertProject(path);

			const configHashes = [...project.meta.configHashes];
			const pkg = this.master.memoryFs.getOwnedManifest(path);
			if (pkg !== undefined) {
				configHashes.push(pkg.hash);
			}

			const entry = {
				version: ___R$project$rome$$romejs$core$common$constants_ts$VERSION,
				projectDir: project.folder.join(),
				configHash: configHashes.join(";"),
				mtime: memoryFs.getMtime(path),
				compile: {},
				analyzeDependencies: undefined,
				moduleSignature: undefined,
				lint: {},
			};

			return entry;
		}

		getCacheFilename(path) {
			const uid = this.master.projectManager.getUid(path);
			return this.cachePath.append(uid);
		}

		async handleDeleted(path) {
			// Handle the file not existing
			const cacheFilename = this.getCacheFilename(path);
			await ___R$project$rome$$romejs$fs$index_ts$unlink(cacheFilename);
			this.loadedEntries.delete(path);
		}

		async get(path) {
			const emptyEntry = await this.createEmptyEntry(path);

			// If we have a loaded memory entry, make sure it's valid compared to the default entry (file changes etc)
			let loaded = this.loadedEntries.get(path);
			if (
				loaded !== undefined &&
				___R$$priv$project$rome$$romejs$core$master$Cache_ts$areEntriesEqual(
					loaded,
					emptyEntry,
				)
			) {
				return loaded;
			}

			if (this.disabled) {
				return emptyEntry;
			}

			const cacheFilename = this.getCacheFilename(path);
			const entry = await this.checkPossibleDiskCacheEntry(
				cacheFilename,
				emptyEntry,
			);
			this.loadedEntries.set(path, entry);
			return entry;
		}

		async checkPossibleDiskCacheEntry(cacheFilename, emptyEntry) {
			const {memoryFs} = this.master;

			if (!memoryFs.exists(cacheFilename)) {
				return emptyEntry;
			}

			try {
				const json = await ___R$project$rome$$romejs$fs$index_ts$readFileText(
					cacheFilename,
				);
				const obj = JSON.parse(json);

				if (
					___R$$priv$project$rome$$romejs$core$master$Cache_ts$areEntriesEqual(
						emptyEntry,
						obj,
					)
				) {
					return Object.assign({}, emptyEntry, obj);
				} else {
					// If the entries aren't equal then there's something wrong with the cache entry
					await this.handleDeleted(cacheFilename);
					return emptyEntry;
				}
			} catch (err) {
				// TODO add some heuristic to only catch json and cache permission errors
				return emptyEntry;
			}
		}

		async update(path, partialEntryCallback) {
			const currEntry = await this.get(path);
			const partialEntry =
				typeof partialEntryCallback === "function"
					? partialEntryCallback(currEntry)
					: partialEntryCallback;

			const entry = Object.assign({}, currEntry, partialEntry);

			// TODO should batch these and write during idle time
			const cacheFilename = this.getCacheFilename(path);
			this.loadedEntries.set(path, entry);

			if (this.disabled) {
				return;
			}

			await ___R$project$rome$$romejs$fs$index_ts$createDirectory(
				cacheFilename.getParent(),
				{
					recursive: true,
				},
			);
			await ___R$project$rome$$romejs$fs$index_ts$writeFile(
				cacheFilename,
				___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(entry),
			);
		}
	}


  // project-rome/@romejs/core/common/utils/setupGlobalErrorHandlers.ts
function ___R$project$rome$$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default(
		callback,
	) {
		const onUncaughtException = (err) => {
			callback(err);
		};
		process.on("uncaughtException", onUncaughtException);

		const onUnhandledRejection = (reason, promise) => {
			promise.then(() => {
				throw new Error(
					"Promise is rejected so should never hit this condition",
				);
			}).catch((err) => {
				console.error(err);
				callback(err);
			});
		};
		process.on("unhandledRejection", onUnhandledRejection);

		return () => {
			process.removeListener("uncaughtException", onUncaughtException);
			process.removeListener("unhandledRejection", onUnhandledRejection);
		};
	}


  // project-rome/@romejs/core/common/userConfig.ts


	const ___R$$priv$project$rome$$romejs$core$common$userConfig_ts$VERSION_PATH = ___R$project$rome$$romejs$path$index_ts$TEMP_PATH.append(
		"rome-" + ___R$project$rome$$romejs$core$common$constants_ts$VERSION,
	);

	const ___R$project$rome$$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG = {
		runtimeModulesPath: ___R$$priv$project$rome$$romejs$core$common$userConfig_ts$VERSION_PATH.append(
			"runtime",
		),
		cachePath: ___R$$priv$project$rome$$romejs$core$common$userConfig_ts$VERSION_PATH.append(
			"cache",
		),
	};

	function ___R$project$rome$$romejs$core$common$userConfig_ts$loadUserConfig() {
		for (const configFilename of ___R$project$rome$$romejs$project$constants_ts$ROME_CONFIG_FILENAMES) {
			const configPath = ___R$project$rome$$romejs$path$index_ts$HOME_PATH.append([
				".config",
				configFilename,
			]);

			if (!___R$project$rome$$romejs$fs$index_ts$existsSync(configPath)) {
				continue;
			}

			const configFile = ___R$project$rome$$romejs$fs$index_ts$readFileTextSync(
				configPath,
			);
			const consumer = ___R$project$rome$$romejs$codec$json$index_ts$consumeJSON({
				path: configPath,
				input: configFile,
			});

			const userConfig = Object.assign(
				{},
				___R$project$rome$$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG,
			);

			if (consumer.has("cachePath")) {
				userConfig.cachePath = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
					consumer.get("cachePath").asString(),
				);
			}

			if (consumer.has("runtimeModulesPath")) {
				userConfig.runtimeModulesPath = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
					consumer.get("runtimeModulesPath").asString(),
				);
			}

			consumer.enforceUsedProperties("config property");

			return userConfig;
		}

		return ___R$project$rome$$romejs$core$common$userConfig_ts$DEFAULT_USER_CONFIG;
	}


  // project-rome/@romejs/core/master/MasterReporter.ts
class ___R$project$rome$$romejs$core$master$MasterReporter_ts$default
		extends ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default {
		constructor(master) {
			super({
				wrapperFactory: master.wrapFatal.bind(master),
			});
			this.master = master;
		}

		// This is so all progress bars are also shown on an LSP client, alongside connected CLIs
		progress(opts) {
			const progresses = [this.progressLocal(opts)];

			for (const server of this.master.connectedLSPServers) {
				progresses.push(server.createProgress(opts));
			}

			return ___R$project$rome$$romejs$cli$reporter$util_ts$mergeProgresses(
				progresses,
			);
		}
	}


  // project-rome/@romejs/core/master/fs/runtime-modules.ts
const ___R$project$rome$$romejs$core$master$fs$runtime$modules_ts$modules = new Map();

	// EVERYTHING BELOW IS AUTOGENERATED. SEE SCRIPTS FOLDER FOR UPDATE SCRIPTS
	___R$project$rome$$romejs$core$master$fs$runtime$modules_ts$modules.set(
		"rome",
		new Map([
			[
				"index.ts",
				'/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {TestHelper, test, testOptions} from "./test";\n',
			],
			[
				"package.json",
				'{\n  "name": "@romejs-runtime/rome",\n  "type": "module",\n  "private": true,\n  "main": "index.ts"\n}\n',
			],
			[
				"test.ts",
				'/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {JSONPropertyValue} from "./types";\n\nexport type AsyncFunc = () => void | undefined | Promise<void>;\n\nexport type SyncThrower = () => void;\n\nexport type ExpectedError = undefined | string | RegExp | Function;\n\nexport type TestSnapshotOptions = {\n\tfilename?: string;\n\tlanguage?: string;\n};\n\n// These diagnostics are subsets of the official diagnostics\n// We can potentially normalize these and ensure backwards compatibility with the official diagnostics\n\nexport type TestDiagnosticLogCategory = "none" | "info" | "warn" | "error";\n\nexport type TestDiagnosticAdviceInspect = {\n\ttype: "inspect";\n\tdata: JSONPropertyValue;\n};\n\nexport type TestDiagnosticAdviceList = {\n\ttype: "list";\n\tlist: Array<string>;\n};\n\nexport type TestDiagnosticAdviceCode = {\n\ttype: "code";\n\tcode: string;\n};\n\nexport type TestDiagnosticAdviceLog = {\n\ttype: "log";\n\tcategory: TestDiagnosticLogCategory;\n\ttext: string;\n};\n\nexport type TestDiagnosticAdviceItem =\n\t| TestDiagnosticAdviceInspect\n\t| TestDiagnosticAdviceCode\n\t| TestDiagnosticAdviceLog\n\t| TestDiagnosticAdviceList;\n\nexport interface TestHelper {\n\taddToAdvice(item: TestDiagnosticAdviceItem): void;\n\tclearAdvice(): void;\n\tonTeardown(callback: AsyncFunc): void;\n\tclearTimeout(): void;\n\textendTimeout(time: number): void;\n\tsetTimeout(time: number): void;\n\tcheckTimeout(): void;\n\ttruthy(value: unknown, message?: string): void;\n\tfalsy(value: unknown, message?: string): void;\n\ttrue(value: unknown, message?: string): void;\n\tfalse(value: unknown, message?: string): void;\n\tis(received: unknown, expected: unknown, message?: string): void;\n\tnot(received: unknown, expected: unknown, message?: string): void;\n\tlooksLike(received: unknown, expected: unknown, message?: string): void;\n\tnotLooksLike(received: unknown, expected: unknown, message?: string): void;\n\tthrows(\n\t\tthrower: SyncThrower,\n\t\texpected?: ExpectedError,\n\t\tmessage?: string,\n\t): void;\n\tthrowsAsync(\n\t\tthrower: AsyncFunc,\n\t\texpected?: ExpectedError,\n\t\tmessage?: string,\n\t): Promise<void>;\n\tnotThrows(nonThrower: SyncThrower, message?: string): void;\n\tnotThrowsAsync(nonThrower: AsyncFunc, message?: string): Promise<void>;\n\tregex(contents: string, regex: RegExp, message?: string): void;\n\tnotRegex(contents: string, regex: RegExp, message?: string): void;\n\tsnapshot(\n\t\texpected: unknown,\n\t\tmessage?: string,\n\t\topts?: TestSnapshotOptions,\n\t): string;\n\tinlineSnapshot(received: unknown, expected?: string | boolean | number): void;\n\tnamedSnapshot(\n\t\tname: string,\n\t\texpected: unknown,\n\t\tmessage?: string,\n\t\topts?: TestSnapshotOptions,\n\t): string;\n}\n\nexport type TestName = string | Array<string>;\n\ndeclare const __ROME__TEST_OPTIONS__: GlobalTestOptions;\n\nexport type GlobalTestOptions =\n\t| undefined\n\t| {\n\t\t\tdirname?: string;\n\t\t\tregister?: (err: Error, opts: TestOptions, callback: TestCallback) => void;\n\t\t};\n\ntype NamelessTestOptions = {\n\ttimeout?: number;\n\tonly?: boolean;\n};\n\nexport type TestCallback = (t: TestHelper) => void | undefined | Promise<void>;\n\nexport type TestOptions = NamelessTestOptions & {\n\tname: TestName;\n};\n\ntype TestArg = TestName | NamelessTestOptions | TestCallback | undefined;\n\nexport const testOptions: NonNullable<GlobalTestOptions> =\n\t__ROME__TEST_OPTIONS__ === undefined ? {} : __ROME__TEST_OPTIONS__;\n\nfunction registerTest(\n\tcallsiteError: Error,\n\topts: TestOptions,\n\tcallback: TestCallback,\n) {\n\tconst register = testOptions.register;\n\n\tif (typeof register !== "function") {\n\t\tthrow new Error("Test harness does not exist");\n\t}\n\n\tregister(callsiteError, opts, callback);\n}\n\nfunction isOptionsObject(arg: TestArg): arg is NamelessTestOptions {\n\treturn typeof arg === "object" && arg != null && !Array.isArray(arg);\n}\n\nfunction splitArgs(\n\targs: TestRegisterFunctionArgs,\n): {\n\toptions: TestOptions;\n\tcallback: TestCallback;\n} {\n\tconst name = args.shift();\n\tif (typeof name !== "string" && !Array.isArray(name)) {\n\t\tthrow new Error("Expected test name to be a string or an array of strings");\n\t}\n\n\tconst callback = args.pop();\n\tif (typeof callback !== "function") {\n\t\tthrow new Error("Expected options callback");\n\t}\n\n\tconst options = args.pop();\n\tif (options !== undefined && !isOptionsObject(options)) {\n\t\tthrow new Error("Expected options object");\n\t}\n\n\tif (args.length > 0) {\n\t\tthrow new Error("Expected to have exhausted test register arguments");\n\t}\n\n\treturn {\n\t\toptions: {\n\t\t\t...options,\n\t\t\tname,\n\t\t},\n\t\tcallback,\n\t};\n}\n\ntype TestRegisterFunctionArgs =\n\t| [TestName, TestCallback]\n\t| [TestName, NamelessTestOptions, TestCallback];\n\ntype TestRegisterFunction = (...args: TestRegisterFunctionArgs) => void;\n\nexport const test: TestRegisterFunction & {\n\tonly: TestRegisterFunction;\n} = function(...args: TestRegisterFunctionArgs) {\n\tconst {options, callback} = splitArgs(args);\n\tregisterTest(new Error(), options, callback);\n};\n\ntest.only = function(...args: TestRegisterFunctionArgs) {\n\tconst {options, callback} = splitArgs(args);\n\tregisterTest(\n\t\tnew Error(),\n\t\t{\n\t\t\t...options,\n\t\t\tonly: true,\n\t\t},\n\t\tcallback,\n\t);\n};\n',
			],
			[
				"types.ts",
				"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// These are copied from packages/@romejs/codec-json/types.ts\nexport type JSONValue =\n\t| null\n\t| string\n\t| number\n\t| boolean\n\t| JSONObject\n\t| JSONArray;\n\nexport type JSONPropertyValue = undefined | void | JSONValue;\n\nexport type JSONObject = {\n\t[x: string]: JSONPropertyValue;\n};\n\nexport type JSONArray = Array<JSONValue>;\n",
			],
		]),
	);


  // project-rome/@romejs/core/master/fs/VirtualModules.ts
class ___R$project$rome$$romejs$core$master$fs$VirtualModules_ts$default {
		constructor(master) {
			this.master = master;
			this.runtimeModulesPath = master.userConfig.runtimeModulesPath;
		}

		async init() {
			const {runtimeModulesPath} = this;

			// Materalize virtual files to disk
			// We could technically keep these in memory and never materialize them but
			// this way we can have something to point at on disk for errors etc
			await ___R$project$rome$$romejs$fs$index_ts$createDirectory(
				runtimeModulesPath,
				{recursive: true},
			);
			for (const [name, files] of ___R$project$rome$$romejs$core$master$fs$runtime$modules_ts$modules) {
				const modulePath = runtimeModulesPath.append(name);
				await ___R$project$rome$$romejs$fs$index_ts$createDirectory(
					modulePath,
					{recursive: true},
				);
				for (const [basename, content] of files) {
					await ___R$project$rome$$romejs$fs$index_ts$writeFile(
						modulePath.append(basename),
						content,
					);
				}
			}

			// Initialize as project
			const projectConfig = Object.assign(
				{},
				___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG,
				{name: "rome-runtime"},
			);
			await this.master.projectManager.addProjectWithConfig({
				projectFolder: runtimeModulesPath,
				meta: ___R$project$rome$$romejs$project$types_ts$DEFAULT_PROJECT_CONFIG_META,
				config: projectConfig,
			});
			await this.master.memoryFs.watch(runtimeModulesPath, projectConfig);
		}

		resolve(name) {
			if (
				___R$project$rome$$romejs$core$master$fs$runtime$modules_ts$modules.has(
					name,
				)
			) {
				return this.runtimeModulesPath.append(name);
			} else {
				return undefined;
			}
		}
	}


  // project-rome/@romejs/core/master/Master.ts
const ___R$$priv$project$rome$$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH = 100_000;









	const ___R$$priv$project$rome$$romejs$core$master$Master_ts$disallowedFlagsWhenReviewing = [
		"watch",
	];

	async function ___R$$priv$project$rome$$romejs$core$master$Master_ts$validateRequestFlags(
		req,
		masterCommand,
	) {
		const {requestFlags} = req.query;

		// Commands need to explicitly allow these flags
		___R$$priv$project$rome$$romejs$core$master$Master_ts$validateAllowedRequestFlag(
			req,
			"watch",
			masterCommand,
		);
		___R$$priv$project$rome$$romejs$core$master$Master_ts$validateAllowedRequestFlag(
			req,
			"review",
			masterCommand,
		);

		// Don't allow review in combination with other flags
		if (requestFlags.review) {
			for (const key of ___R$$priv$project$rome$$romejs$core$master$Master_ts$disallowedFlagsWhenReviewing) {
				if (requestFlags[key]) {
					throw req.throwDiagnosticFlagError({
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.FLAGS.DISALLOWED_REVIEW_FLAG(
							key,
						),
						target: {type: "flag", key},
					});
				}
			}
		}
	}

	function ___R$$priv$project$rome$$romejs$core$master$Master_ts$validateAllowedRequestFlag(
		req,
		flagKey,
		masterCommand,
	) {
		const allowRequestFlags = masterCommand.allowRequestFlags || [];
		if (req.query.requestFlags[flagKey] && !allowRequestFlags.includes(flagKey)) {
			throw req.throwDiagnosticFlagError({
				description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.FLAGS.DISALLOWED_REQUEST_FLAG(
					flagKey,
				),
				target: {type: "flag", key: flagKey},
			});
		}
	}

	class ___R$project$rome$$romejs$core$master$Master_ts$default {
		constructor(opts) {
			this.onFatalErrorBound = this.onFatalError.bind(this);

			this.profiling = undefined;
			this.options = opts;

			this.userConfig = ___R$project$rome$$romejs$core$common$userConfig_ts$loadUserConfig();

			this.fileChangeEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Master.fileChange",
				onError: this.onFatalErrorBound,
			});

			this.clientStartEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Master.clientStart",
				onError: this.onFatalErrorBound,
			});

			this.requestStartEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Master.requestStart",
				onError: this.onFatalErrorBound,
			});

			this.logEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Master.log",
				onError: this.onFatalErrorBound,
			});

			this.endEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Master.end",
				onError: this.onFatalErrorBound,
				serial: true,
			});

			this.logger = new ___R$project$rome$$romejs$core$common$utils$Logger_ts$default(
				"master",
				() => {
					return (
						this.logEvent.hasSubscribers() ||
						this.connectedClientsListeningForLogs.size > 0
					);
				},
				{
					streams: [
						{
							type: "all",
							format: "none",
							columns: 0,
							unicode: true,
							write: (chunk) => {
								this.emitMasterLog(chunk);
							},
						},
					],
					markupOptions: {
						humanizeFilename: (filename) => {
							const path = ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
								filename,
							);
							if (path.isAbsolute()) {
								const remote = this.projectManager.getRemoteFromLocalPath(
									path.assertAbsolute(),
								);
								if (remote !== undefined) {
									return remote.join();
								}
							}
							return undefined;
						},
						normalizeFilename: (filename) => {
							const path = this.projectManager.getFilePathFromUid(filename);
							if (path === undefined) {
								return filename;
							} else {
								return path.join();
							}
						},
					},
				},
			);

			this.connectedReporters = new ___R$project$rome$$romejs$core$master$MasterReporter_ts$default(
				this,
			);

			this.connectedClientsListeningForLogs = new Set();
			this.connectedLSPServers = new Set();
			this.connectedClients = new Set();

			this.virtualModules = new ___R$project$rome$$romejs$core$master$fs$VirtualModules_ts$default(
				this,
			);
			this.memoryFs = new ___R$project$rome$$romejs$core$master$fs$MemoryFileSystem_ts$default(
				this,
			);
			this.projectManager = new ___R$project$rome$$romejs$core$master$project$ProjectManager_ts$default(
				this,
			);
			this.workerManager = new ___R$project$rome$$romejs$core$master$WorkerManager_ts$default(
				this,
			);
			this.fileAllocator = new ___R$project$rome$$romejs$core$master$fs$FileAllocator_ts$default(
				this,
			);
			this.resolver = new ___R$project$rome$$romejs$core$master$fs$Resolver_ts$default(
				this,
			);
			this.cache = new ___R$project$rome$$romejs$core$master$Cache_ts$default(
				this,
			);

			this.memoryFs.deletedFileEvent.subscribe((path) => {
				return this.handleFileDelete(path);
			});

			this.memoryFs.changedFileEvent.subscribe(({path}) => {
				return this.handleFileChange(path);
			});

			this.warnedCacheClients = new WeakSet();

			this.clientIdCounter = 0;

			this.requestRunningCounter = 0;
			this.terminateWhenIdle = false;
		}

		emitMasterLog(chunk) {
			this.logEvent.send(chunk);

			for (const {bridge} of this.connectedClientsListeningForLogs) {
				bridge.log.send({chunk, origin: "master"});
			}
		}

		onFatalError(err) {
			const message =
				"<emphasis>Fatal error occurred</emphasis>: " +
				___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					err.stack || err.message,
				);
			this.logger.error(message);
			this.connectedReporters.error(message);
			process.exit();
		}

		// rome-ignore lint/js/noExplicitAny
		wrapFatal(callback) {
			return (((...args) => {
				try {
					const res = callback.apply(null, [...args]);
					if (res instanceof Promise) {
						res.catch(this.onFatalErrorBound);
					}
					return res;
				} catch (err) {
					throw this.onFatalError(err);
				}
			}));
		}

		async handleDisconnectedDiagnostics(diagnostics) {
			this.connectedReporters.error(
				"Generated diagnostics without a current request",
			);

			___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnostics({
				diagnostics,
				suppressions: [],
				printerOptions: {
					processor: this.createDiagnosticsProcessor(),
					reporter: this.connectedReporters,
					readFile: this.readDiagnosticsPrinterFile.bind(this),
				},
			});
		}

		readDiagnosticsPrinterFile(path) {
			const remoteToLocal = this.projectManager.remoteToLocalPath.get(path);

			if (remoteToLocal === undefined) {
				return ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(
					path,
				);
			} else {
				return ___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$readDiagnosticsFileLocal(
					remoteToLocal,
				);
			}
		}

		createDiagnosticsProcessor(opts = {}) {
			return new ___R$project$rome$$romejs$diagnostics$DiagnosticsProcessor_ts$default(
				Object.assign({markupOptions: this.logger.markupOptions}, opts),
			);
		}

		createDisconnectedDiagnosticsProcessor(origins) {
			return this.createDiagnosticsProcessor({
				onDiagnostics: (diagnostics) => {
					this.handleDisconnectedDiagnostics(diagnostics);
				},
				origins: [
					...origins,
					{
						category: "master",
						message: "Created disconnected diagnostics collector",
					},
				],
			});
		}

		maybeSetupGlobalErrorHandlers() {
			if (!this.options.globalErrorHandlers) {
				return;
			}

			const teardown = ___R$project$rome$$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default((
				err,
			) => {
				this.onFatalError(err);
			});

			this.endEvent.subscribe(() => {
				teardown();
			});
		}

		async init() {
			this.maybeSetupGlobalErrorHandlers();
			this.memoryFs.init();
			await this.projectManager.init();
			this.fileAllocator.init();
			this.resolver.init();
			await this.cache.init();
			await this.virtualModules.init();
			await this.workerManager.init();
		}

		async end() {
			// Cancel all queries in flight
			for (const client of this.connectedClients) {
				for (const req of client.requestsInFlight) {
					req.cancel();
				}
			}

			// We should remove everything that has an external dependency like a socket or process
			await this.endEvent.callOptional();
			this.workerManager.end();
			this.memoryFs.unwatchAll();
		}

		async attachToBridge(bridge) {
			let profiler;

			// If we aren't a dedicated process then we should only expect a single connection
			// and when that ends. End the Master.
			if (this.options.dedicated === false) {
				bridge.endEvent.subscribe(() => {
					this.end();
				});
			}

			bridge.profilingStart.subscribe(async (data) => {
				if (profiler !== undefined) {
					throw new Error("Expected no profiler to be running");
				}
				profiler = new ___R$project$rome$$romejs$v8$Profiler_ts$default();
				await profiler.startProfiling(data.samplingInterval);
				this.profiling = data;
				for (const {bridge} of this.workerManager.getExternalWorkers()) {
					await bridge.profilingStart.call(data);
				}
			});

			bridge.profilingStop.subscribe(async () => {
				if (profiler === undefined) {
					throw new Error("Expected profiler to be running");
				}
				const masterProfile = await profiler.stopProfiling();
				profiler = undefined;
				this.profiling = undefined;
				return masterProfile;
			});

			bridge.profilingGetWorkers.subscribe(async () => {
				const ids = [];
				for (const {id} of this.workerManager.getExternalWorkers()) {
					ids.push(id);
				}
				return ids;
			});

			bridge.profilingStopWorker.subscribe(async (id) => {
				const worker = this.workerManager.getWorkerAssert(id);
				return await worker.bridge.profilingStop.call();
			});

			// When enableWorkerLogs is called we setup subscriptions to the worker logs
			// Logs are never transported from workers to the master unless there is a subscription
			let subscribedWorkers = false;
			bridge.enableWorkerLogs.subscribe(() => {
				// enableWorkerLogs could be called twice in the case of `--logs --rage`. We'll only want to setup the subscriptions once
				if (subscribedWorkers) {
					return;
				} else {
					subscribedWorkers = true;
				}

				function onLog(chunk) {
					bridge.log.call({origin: "worker", chunk});
				}

				// Add on existing workers if there are any
				for (const worker of this.workerManager.getWorkers()) {
					bridge.attachEndSubscriptionRemoval(
						worker.bridge.log.subscribe(onLog),
					);
				}

				// Listen for logs for any workers that start later
				this.workerManager.workerStartEvent.subscribe((worker) => {
					bridge.attachEndSubscriptionRemoval(worker.log.subscribe(onLog));
				});
			});

			await bridge.handshake();

			const client = await this.createClient(bridge);

			if (
				client.version !==
				___R$project$rome$$romejs$core$common$constants_ts$VERSION
			) {
				// TODO this wont ever actually be printed?
				client.reporter.error(
					"Client version " +
					client.version +
					" does not match server version " +
					___R$project$rome$$romejs$core$common$constants_ts$VERSION +
					". Goodbye lol.",
				);
				client.bridge.end();
				return;
			}

			bridge.query.subscribe(async (request) => {
				return await this.handleRequest(client, request);
			});

			bridge.cancelQuery.subscribe(async (token) => {
				for (const req of client.requestsInFlight) {
					if (req.query.cancelToken === token) {
						req.cancel();
					}
				}
			});

			await this.clientStartEvent.callOptional(client);
		}

		async createClient(bridge) {
			const {
				flags: rawFlags,
				useRemoteReporter,
				hasClearScreen,
				columns,
				unicode,
				format,
				version,
			} = await bridge.getClientInfo.call();

			// Turn the cwd back into a AbsoluteFilePath
			const flags = Object.assign(
				{},
				rawFlags,
				{
					cwd: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
						rawFlags.cwd,
					),
				},
			);

			const outStream = {
				type: "out",
				columns,
				format,
				unicode,
				write(chunk) {
					if (flags.silent === true) {
						return;
					}

					// Split up stdout chunks
					if (
						chunk.length <
						___R$$priv$project$rome$$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH
					) {
						bridge.stdout.send(chunk);
					} else {
						while (chunk.length > 0) {
							const subChunk = chunk.slice(
								0,
								___R$$priv$project$rome$$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH,
							);
							chunk = chunk.slice(
								___R$$priv$project$rome$$romejs$core$master$Master_ts$STDOUT_MAX_CHUNK_LENGTH,
							);
							bridge.stdout.send(subChunk);
						}
					}
				},
			};

			const errStream = Object.assign(
				{},
				outStream,
				{
					type: "error",
					write(chunk) {
						bridge.stderr.send(chunk);
					},
				},
			);

			bridge.setColumns.subscribe((columns) => {
				reporter.setStreamColumns([outStream, errStream], columns);
			});

			// Initialize the reporter
			const reporter = new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default({
				hasClearScreen,
				wrapperFactory: this.wrapFatal.bind(this),
				streams: [outStream, errStream],
				verbose: flags.verbose,
				markupOptions: Object.assign(
					{cwd: flags.cwd},
					this.logger.markupOptions,
				),
				useRemoteProgressBars: useRemoteReporter,
			});

			reporter.sendRemoteClientMessage.subscribe((msg) => {
				bridge.reporterRemoteServerMessage.send(msg);
			});

			bridge.reporterRemoteClientMessage.subscribe((msg) => {
				reporter.receivedRemoteServerMessage(msg);
			});

			// Add reporter to connected set, important logs may be output to these
			if (!flags.silent) {
				this.connectedReporters.addStream(outStream);
			}
			this.connectedReporters.addStream(errStream);

			const client = {
				id: this.clientIdCounter++,
				bridge,
				reporter,
				flags,
				version,
				requestsInFlight: new Set(),
			};

			this.connectedClients.add(client);

			bridge.updatedListenersEvent.subscribe((listeners) => {
				if (listeners.has("log")) {
					this.connectedClientsListeningForLogs.add(client);
				} else {
					this.connectedClientsListeningForLogs.delete(client);
				}
			});

			bridge.endEvent.subscribe(() => {
				// Cancel any requests still in flight
				for (const req of client.requestsInFlight) {
					req.cancel();
				}

				this.connectedClients.delete(client);
				this.connectedClientsListeningForLogs.delete(client);
				this.connectedReporters.removeStream(errStream);
				this.connectedReporters.removeStream(outStream);
			});

			return client;
		}

		async handleFileDelete(path) {
			this.logger.info("[Master] File delete:", path.join());
			this.fileChangeEvent.send(path);
		}

		async handleFileChange(path) {
			this.logger.info("[Master] File change:", path.join());
			this.fileChangeEvent.send(path);
		}

		async handleRequestStart(req) {
			this.logger.info("[Master] Handling CLI request:", req.query);

			// Hook used by the web server to track and collect master requests
			await this.requestStartEvent.callOptional(req);

			// Track the amount of running queries for terminateWhenIdle
			this.requestRunningCounter++;

			// Sometimes we'll want to terminate the process once all queries have finished
			if (req.query.terminateWhenIdle) {
				this.terminateWhenIdle = true;
			}
		}

		handleRequestEnd(req) {
			this.requestRunningCounter--;
			this.logger.info("[Master] Replying to CLI request:", req.query);

			// If we're waiting to terminate ourselves when idle, then do so when there's no running requests
			if (this.terminateWhenIdle && this.requestRunningCounter === 0) {
				this.end();
			}
		}

		async handleRequest(client, partialQuery) {
			const requestFlags = Object.assign(
				{},
				___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS,
				partialQuery.requestFlags,
			);

			const query = {
				commandName: partialQuery.commandName,
				args: partialQuery.args === undefined ? [] : partialQuery.args,
				noData: partialQuery.noData === true,
				requestFlags,
				silent: partialQuery.silent === true || requestFlags.benchmark,
				terminateWhenIdle: partialQuery.terminateWhenIdle === true,
				commandFlags: partialQuery.commandFlags === undefined
					? {}
					: partialQuery.commandFlags,
				cancelToken: partialQuery.cancelToken,
			};

			const {bridge} = client;

			// Create a promise for the client dying so we can race it later
			let bridgeEndEvent;
			const bridgeEndPromise = new Promise((resolve, reject) => {
				bridgeEndEvent = bridge.endEvent.subscribe((err) => {
					reject(err);
				});
			});
			if (bridgeEndEvent === undefined) {
				throw new Error("Expected bridgeEndEvent to have been initialized");
			}

			// Support a silent option on requests so they don't write output
			let reporter = client.reporter;
			if (query.silent) {
				reporter = reporter.fork({
					streams: [],
				});
			}

			const req = new ___R$project$rome$$romejs$core$master$MasterRequest_ts$default({
				client,
				query,
				master: this,
			});

			await req.init();

			try {
				let res = await this.dispatchRequest(req, bridgeEndPromise, []);

				res = req.teardown(res);

				if (res === undefined) {
					throw new Error(
						"teardown should have returned a normalized MasterQueryResponse",
					);
				}

				return res;
			} catch (err) {
				req.teardown(undefined);
				throw err;
			} finally {
				// We no longer care if the client dies
				bridgeEndEvent.unsubscribe();
			}
		}

		async dispatchBenchmarkRequest(req, bridgeEndPromise) {
			const {client} = req;
			const {reporter} = client;
			const {benchmarkIterations} = req.query.requestFlags;

			// Warmup
			const warmupStart = Date.now();
			const result = await this.dispatchRequest(
				req,
				bridgeEndPromise,
				["benchmark"],
			);
			const warmupTook = Date.now() - warmupStart;

			// Benchmark
			const progress = client.reporter.progress({title: "Running benchmark"});
			progress.setTotal(benchmarkIterations);
			const benchmarkStart = Date.now();
			for (let i = 0; i < benchmarkIterations; i++) {
				await this.dispatchRequest(req, bridgeEndPromise, ["benchmark"]);
				progress.tick();
			}
			progress.end();
			const benchmarkTook = Date.now() - benchmarkStart;

			reporter.section(
				"Benchmark results",
				() => {
					reporter.info(
						"Request artifacts may have been cached after the first run, artificially decreasing subsequent run time",
					);
					reporter.heading("Query");
					reporter.inspect(req.query);
					reporter.heading("Stats");
					reporter.list([
						"Warmup took <duration emphasis>" + warmupTook + "</duration>",
						"<number emphasis>" + benchmarkIterations + "</number> runs",
						"<duration emphasis>" + benchmarkTook + "</duration> total",
						"<duration emphasis approx>" +
						benchmarkTook / benchmarkIterations +
						"</duration> per run",
					]);
				},
			);

			return result;
		}

		async dispatchRequest(req, bridgeEndPromise, origins) {
			const {query, reporter, bridge} = req;
			const {requestFlags} = query;

			if (requestFlags.benchmark && !origins.includes("benchmark")) {
				return this.dispatchBenchmarkRequest(req, bridgeEndPromise);
			}

			try {
				const defaultCommandFlags = {};

				// A type-safe wrapper for retrieving command flags
				// TODO perhaps present this as JSON or something if this isn't a request from the CLI?
				const flagsConsumer = ___R$project$rome$$romejs$consume$index_ts$consume({
					filePath: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
						"argv",
					),
					parent: undefined,
					value: query.commandFlags,
					onDefinition(def) {
						// objectPath should only have a depth of 1
						defaultCommandFlags[def.objectPath[0]] = def.default;
					},
					objectPath: [],
					context: {
						category: "flags/invalid",
						getOriginalValue: () => {
							return undefined;
						},
						normalizeKey: (key) => {
							return ___R$project$rome$$romejs$string$utils$toKebabCase_ts$toKebabCase(
								key,
							);
						},
						getDiagnosticPointer: (keys) => {
							return req.getDiagnosticPointerFromFlags({
								type: "flag",
								key: String(keys[0]),
								target: "value",
							});
						},
					},
				});

				// An array of promises that we'll race, the only promise that will ever resolve will be the command one
				let promises = [bridgeEndPromise];

				// Get command
				const masterCommand = ___R$project$rome$$romejs$core$master$commands_ts$masterCommands.get(
					query.commandName,
				);
				if (masterCommand) {
					// Warn about disabled disk caching
					if (
						process.env.ROME_CACHE === "0" &&
						!this.warnedCacheClients.has(bridge)
					) {
						reporter.warn(
							"Disk caching has been disabled due to the <emphasis>ROME_CACHE=0</emphasis> environment variable",
						);
						this.warnedCacheClients.add(bridge);
					}

					await ___R$$priv$project$rome$$romejs$core$master$Master_ts$validateRequestFlags(
						req,
						masterCommand,
					);

					let commandFlags;
					if (masterCommand.defineFlags !== undefined) {
						commandFlags = masterCommand.defineFlags(flagsConsumer);
					}

					req.setNormalizedCommandFlags({
						flags: commandFlags,
						defaultFlags: defaultCommandFlags,
					});

					// @ts-ignore
					const commandPromise = masterCommand.callback(req, commandFlags);
					promises.push(commandPromise);

					await Promise.race(promises);

					// Only the command promise should have won the race with a resolve
					const data = await commandPromise;
					return Object.assign(
						{},
						___R$project$rome$$romejs$core$master$MasterRequest_ts$EMPTY_SUCCESS_RESPONSE,
						{hasData: data !== undefined, data},
					);
				} else {
					throw new Error("Unknown command " + String(query.commandName));
				}
			} catch (err) {
				let diagnostics = this.handleRequestError(req, err);

				if (diagnostics === undefined) {
					return {
						type: "ERROR",
						fatal: false,
						handled: true,
						name: err.name,
						message: err.message,
						stack: err.stack,
					};
				} else if (
					err instanceof
					___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestCancelled
				) {
					return {
						type: "CANCELLED",
					};
				} else if (
					err instanceof
					___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid
				) {
					return {
						type: "INVALID_REQUEST",
						diagnostics,
						showHelp: err.showHelp,
					};
				} else {
					return {
						type: "DIAGNOSTICS",
						hasDiagnostics: diagnostics.length > 0,
						diagnostics,
					};
				}
			}
		}

		handleRequestError(req, rawErr) {
			let err = rawErr;

			// If we can derive diagnostics from the error then create a diagnostics printer
			const diagnostics = ___R$project$rome$$romejs$diagnostics$errors_ts$getDiagnosticsFromError(
				err,
			);
			if (diagnostics !== undefined) {
				const printer = req.createDiagnosticsPrinter(
					req.createDiagnosticsProcessor({
						origins: [
							{
								category: "internal",
								message: "Derived diagnostics from thrown error",
							},
						],
					}),
				);
				printer.processor.addDiagnostics(diagnostics);
				err = printer;
			}

			// Print it!
			if (
				err instanceof
				___R$project$rome$$romejs$cli$diagnostics$DiagnosticsPrinter_ts$default
			) {
				const printer = err;

				// Only print when the bridge is alive and we aren't in review mode
				// When we're in review mode we don't expect to show any diagnostics because they'll be intercepted in the client command
				// We will always print invalid request errors
				let shouldPrint = true;
				if (req.query.requestFlags.review) {
					shouldPrint = false;
				}
				if (
					rawErr instanceof
					___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid
				) {
					shouldPrint = true;
				}
				if (!req.bridge.alive) {
					shouldPrint = false;
				}

				if (shouldPrint) {
					printer.print();

					// Don't output the footer if this is a notifier for an invalid request as it will be followed by a help screen
					if (
						!(rawErr instanceof
						___R$project$rome$$romejs$core$master$MasterRequest_ts$MasterRequestInvalid)
					) {
						printer.footer();
					}
				}

				return printer.getDiagnostics();
			}

			if (!req.bridge.alive) {
				return undefined;
			}

			const printer = req.createDiagnosticsPrinter(
				req.createDiagnosticsProcessor({
					origins: [
						{
							category: "internal",
							message: "Error captured and converted into a diagnostic",
						},
					],
				}),
			);
			const errorDiag = ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
				err,
				{
					description: {
						category: "internalError/request",
					},
				},
			);
			printer.processor.addDiagnostic(
				Object.assign(
					{},
					errorDiag,
					{
						description: Object.assign(
							{},
							errorDiag.description,
							{
								advice: [
									...errorDiag.description.advice,
									___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE,
								],
							},
						),
					},
				),
			);
			printer.print();

			// We could probably return printer.getDiagnostics() but we just want to print to the console

			// We will still want to send the `error` property
			return undefined;
		}
	}


  // project-rome/@romejs/codec-tar/index.ts
const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$stream = require(
		"stream",
	);






	const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$END_OF_TAR = Buffer.alloc(
		1_024,
	);
	const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$ZEROS = "0000000000000000000";
	const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$SEVENS = "7777777777777777777";
	const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$ZERO_OFFSET = "0".charCodeAt(
		0,
	);
	const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$USTAR = "ustar\x0000";
	const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$MASK = 4_095;
	const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$DMODE = 493;
	const ___R$$priv$project$rome$$romejs$codec$tar$index_ts$FMODE = 420;

	function ___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(num, n) {
		const oct = num.toString(8);
		if (oct.length > n) {
			return (
				___R$$priv$project$rome$$romejs$codec$tar$index_ts$SEVENS.slice(0, n) +
				" "
			);
		} else {
			return (
				"" +
				___R$$priv$project$rome$$romejs$codec$tar$index_ts$ZEROS.slice(
					0,
					n - oct.length,
				) +
				oct +
				" "
			);
		}
	}

	function ___R$$priv$project$rome$$romejs$codec$tar$index_ts$checksum(block) {
		let sum = 8 * 32;
		for (let i = 0; i < 148; i++) {
			sum += block[i];
		}
		for (let j = 156; j < 512; j++) {
			sum += block[j];
		}
		return sum;
	}

	function ___R$$priv$project$rome$$romejs$codec$tar$index_ts$toTypeflag(type) {
		switch (type) {
			case "file":
				return 0;
			case "link":
				return 1;
			case "symlink":
				return 2;
			case "character-device":
				return 3;
			case "block-device":
				return 4;
			case "directory":
				return 5;
			case "fifo":
				return 6;
			case "contiguous-file":
				return 7;
		}

		return 0;
	}

	function ___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeHeader(
		header,
	) {
		const buf = Buffer.alloc(512);

		let name = header.name;
		let prefix = "";

		if (Buffer.byteLength(name) !== name.length) {
			throw new Error(
				"utf-8 filename is only supported in PAX, we only support USTAR",
			);
		}

		// If a filename is over 100 characters then split it up if possible (requires a directory)
		while (Buffer.byteLength(name) > 100) {
			const i = name.indexOf("/");
			if (i === -1) {
				throw new Error(
					"filename is too long for USTAR and it was in no directory",
				);
			}

			prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
			name = name.slice(i + 1);
		}

		if (Buffer.byteLength(name) > 100) {
			throw new Error("filename is too long for USTAR");
		}

		if (Buffer.byteLength(prefix) > 155) {
			throw new Error("prefix is too long for USTAR");
		}

		if (
			header.linkname !== undefined &&
			Buffer.byteLength(header.linkname) > 100
		) {
			throw new Error("linkname is too long for USTAR");
		}

		buf.write(name);
		buf.write(
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(
				header.mode & ___R$$priv$project$rome$$romejs$codec$tar$index_ts$MASK,
				6,
			),
			100,
		);
		buf.write(
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(
				header.uid,
				6,
			),
			108,
		);
		buf.write(
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(
				header.gid,
				6,
			),
			116,
		);
		buf.write(
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(
				header.size,
				11,
			),
			124,
		);
		buf.write(
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(
				header.mtime.getTime() / 1_000 | 0,
				11,
			),
			136,
		);

		buf[156] =
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$ZERO_OFFSET +
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$toTypeflag(header.type);

		if (header.linkname !== undefined) {
			buf.write(header.linkname, 157);
		}

		buf.write(___R$$priv$project$rome$$romejs$codec$tar$index_ts$USTAR, 257);
		if (header.uname !== undefined) {
			buf.write(header.uname, 265);
		}
		if (header.gname !== undefined) {
			buf.write(header.gname, 297);
		}
		buf.write(
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(
				header.devmajor || 0,
				6,
			),
			329,
		);
		buf.write(
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(
				header.devminor || 0,
				6,
			),
			337,
		);

		if (prefix !== "") {
			buf.write(prefix, 345);
		}

		buf.write(
			___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeOct(
				___R$$priv$project$rome$$romejs$codec$tar$index_ts$checksum(buf),
				6,
			),
			148,
		);

		return buf;
	}

	class ___R$project$rome$$romejs$codec$tar$index_ts$TarWriter {
		constructor(stream) {
			this.finalized = false;
			this.stream = stream;
		}

		static normalizeHeader(partial, size) {
			let mode = partial.mode;
			if (mode === undefined) {
				if (partial.type === "directory") {
					mode = ___R$$priv$project$rome$$romejs$codec$tar$index_ts$DMODE;
				} else {
					mode = ___R$$priv$project$rome$$romejs$codec$tar$index_ts$FMODE;
				}
			}

			return {
				name: partial.name,
				size,
				mode,
				mtime: partial.mtime === undefined ? new Date() : partial.mtime,
				type: partial.type === undefined ? "file" : partial.type,
				linkname: partial.linkname,
				uid: partial.uid === undefined ? 0 : partial.uid,
				gid: partial.gid === undefined ? 0 : partial.gid,
				uname: partial.uname,
				gname: partial.gname,
				devmajor: partial.devmajor === undefined ? 0 : partial.devmajor,
				devminor: partial.devminor === undefined ? 0 : partial.devminor,
			};
		}

		overflow(size) {
			size &= 511;
			if (size > 0) {
				this.stream.write(
					___R$$priv$project$rome$$romejs$codec$tar$index_ts$END_OF_TAR.slice(
						0,
						512 - size,
					),
				);
			}
		}

		append(rawHeader, rawBuffer) {
			if (this.finalized) {
				throw new Error("Already finalized file");
			}

			const buffer =
				rawBuffer instanceof Buffer ? rawBuffer : Buffer.from(rawBuffer);
			const header = ___R$project$rome$$romejs$codec$tar$index_ts$TarWriter.normalizeHeader(
				rawHeader,
				buffer.length,
			);

			this.stream.write(
				___R$$priv$project$rome$$romejs$codec$tar$index_ts$encodeHeader(header),
			);
			this.stream.write(buffer);
			this.overflow(header.size);
		}

		finalize() {
			this.finalized = true;

			return new Promise((resolve, reject) => {
				const {stream} = this;

				stream.on(
					"close",
					() => {
						resolve();
					},
				);

				stream.on(
					"error",
					(err) => {
						reject(err);
					},
				);

				stream.write(
					___R$$priv$project$rome$$romejs$codec$tar$index_ts$END_OF_TAR,
				);
				stream.end();
			});
		}
	}


  // project-rome/@romejs/core/client/Client.ts
const ___R$$priv$project$rome$$romejs$core$client$Client_ts$stream = require(
		"stream",
	);
	const ___R$$priv$project$rome$$romejs$core$client$Client_ts$net = require(
		"net",
	);
	const ___R$$priv$project$rome$$romejs$core$client$Client_ts$zlib = require(
		"zlib",
	);
	const ___R$$priv$project$rome$$romejs$core$client$Client_ts$fs = require("fs");
	const ___R$$priv$project$rome$$romejs$core$client$Client_ts$child = require(
		"child_process",
	);
	function ___R$project$rome$$romejs$core$client$Client_ts$getFilenameTimestamp() {
		return new Date().toISOString().replace(/[^0-9a-zA-Z]/g, "");
	}

	const ___R$$priv$project$rome$$romejs$core$client$Client_ts$NEW_SERVER_INIT_TIMEOUT = 10_000;









	class ___R$project$rome$$romejs$core$client$Client_ts$default {
		constructor(opts) {
			this.options = opts;
			this.userConfig = ___R$project$rome$$romejs$core$common$userConfig_ts$loadUserConfig();
			this.queryCounter = 0;

			this.flags = Object.assign(
				{},
				___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS,
				opts.flags,
			);

			this.requestResponseEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Client.requestResponseEvent",
			});
			this.endEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Client.endEvent",
				serial: true,
			});
			this.bridgeStatus = undefined;

			this.bridgeAttachedEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "Client.bridgeAttached",
			});

			this.reporter = new ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default({
				stdin: opts.stdin,
				verbose: this.flags.verbose === true,
				markupOptions: {
					cwd: this.flags.cwd,
				},
			});

			// Suppress stdout when silent is set
			const isSilent =
				this.flags.silent === true ||
				opts.stdout === undefined ||
				opts.stderr === undefined;
			const stdout = isSilent ? undefined : opts.stdout;

			this.derivedReporterStreams = this.reporter.attachStdoutStreams(
				stdout,
				opts.stderr,
			);

			this.endEvent.subscribe(() => {
				this.reporter.teardown();
			});
		}

		setFlags(flags) {
			if (this.bridgeStatus !== undefined) {
				throw new Error(
					"Already connected to bridge. Cannot change client flags.",
				);
			}

			this.flags = Object.assign({}, this.flags, flags);
		}

		getClientJSONFlags() {
			return Object.assign({}, this.flags, {cwd: this.flags.cwd.join()});
		}

		async profile(opts, callback) {
			const {samplingInterval, timeoutInterval, includeWorkers} = opts;

			this.reporter.info("Starting CPU profile...");

			// Start server and start profiling
			const bridge = await this.findOrStartMaster();
			await bridge.profilingStart.call({
				samplingInterval,
			});

			// Start cli profiling
			let cliProfiler;
			const bridgeStatus = this.getBridge();
			if (bridgeStatus === undefined || bridgeStatus.dedicated) {
				cliProfiler = new ___R$project$rome$$romejs$v8$Profiler_ts$default();
				await cliProfiler.startProfiling(samplingInterval);
			}

			// Start a profile timer if one was specified
			let hasProfiled;
			let timeout;
			if (timeoutInterval !== undefined) {
				timeout = setTimeout(
					() => {
						hasProfiled = stopProfile(true);
					},
					timeoutInterval,
				);
			}

			const stopProfile = async (isTimeout) => {
				// This is to prevent stopping the profile multiple times via the timeout and then at the end
				// It's a promise so that the final stopProfile call will block until the first has finished
				if (hasProfiled) {
					return hasProfiled;
				}

				// Stop the timeout if it hasn't been triggered
				if (timeout !== undefined) {
					clearTimeout(timeout);
				}

				//
				const trace = new ___R$project$rome$$romejs$v8$Trace_ts$default();
				const fetchers = [];

				// CLI
				if (cliProfiler !== undefined) {
					const cliProfilerAssert = cliProfiler;
					fetchers.push([
						"CLI",
						async () => {
							return cliProfilerAssert.stopProfiling();
						},
					]);
				}

				// Master
				fetchers.push([
					cliProfiler === undefined ? "Master/CLI" : "Master",
					async () => {
						return await bridge.profilingStop.call(
							undefined,
							{
								priority: true,
							},
						);
					},
				]);

				// Workers
				if (includeWorkers) {
					const workerIds = await bridge.profilingGetWorkers.call();
					for (const id of workerIds) {
						fetchers.push([
							"Worker " + id,
							async () => {
								return await bridge.profilingStopWorker.call(
									id,
									{
										priority: true,
									},
								);
							},
						]);
					}
				}

				// Fetch profiles
				const progress = this.reporter.progress({title: "Fetching profiles"});
				progress.setTotal(fetchers.length);
				for (const [text, callback] of fetchers) {
					progress.setText(text);
					const profile = await callback();
					trace.addProfile(text, profile);
					progress.tick();
				}
				progress.end();

				const events = trace.build();
				await callback(events);

				// If we're a timeout than separate these logs from the
				if (isTimeout) {
					this.reporter.hr();
				}
			};

			this.endEvent.subscribe(() => {
				return stopProfile(false);
			});
		}

		async subscribeLogs(includeWorkerLogs, callback) {
			const bridge = await this.findOrStartMaster();

			if (includeWorkerLogs) {
				await bridge.enableWorkerLogs.call();
			}

			bridge.log.subscribe(({origin, chunk}) => {
				if (origin === "worker" && !includeWorkerLogs) {
					// We allow multiple calls to bridge.enableWorkerLogs
					// Filter the event if necessary if it wasn't requested by this log subscription
					return;
				}

				callback(chunk);
			});
		}

		async rage(ragePath, profileOpts) {
			if (this.bridgeStatus !== undefined) {
				throw new Error(
					"rage() can only be called before a query has been dispatched",
				);
			}

			let logs = "";
			await this.subscribeLogs(
				true,
				(chunk) => {
					logs += chunk;
				},
			);

			// Collect CPU profile
			// Callback will be called later once it has been collected
			// Initial async work is just connecting to the processes and setting up handlers
			let profileEvents = [];
			await this.profile(
				profileOpts,
				async (_profileEvents) => {
					profileEvents = _profileEvents;
				},
			);

			// Collect all responses
			const responses = [];
			this.requestResponseEvent.subscribe((result) => {
				responses.push(result);
			});

			this.endEvent.subscribe(async () => {
				const stream = ___R$$priv$project$rome$$romejs$core$client$Client_ts$zlib.createGzip();
				stream.pipe(
					___R$$priv$project$rome$$romejs$core$client$Client_ts$fs.createWriteStream(
						ragePath,
					),
				);

				const writer = new ___R$project$rome$$romejs$codec$tar$index_ts$TarWriter(
					stream,
				);

				writer.append(
					{name: "profile.json"},
					___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
						profileEvents,
					),
				);
				writer.append({name: "logs.txt"}, logs);

				// Add requests
				for (let i = 0; i < responses.length; i++) {
					const {request, response} = responses[i];
					const dirname = "requests/" + i + "-" + request.commandName;
					writer.append(
						{name: dirname + "/request.json"},
						___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(request),
					);
					writer.append(
						{name: dirname + "/response.json"},
						___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
							response,
						),
					);
				}

				// Add client flags
				writer.append(
					{name: "clientFlags.json"},
					___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
						this.getClientJSONFlags(),
					),
				);

				function indent(val) {
					const str =
						typeof val === "string"
							? val
							: ___R$project$rome$$romejs$pretty$format$index_ts$default(
									val,
									{
										compact: true,
									},
								);
					const lines = str.trim().split("\n");
					const indented = lines.join("\n  ");
					return "\n  " + indented;
				}

				const env = [];
				env.push("PATH: " + indent(process.env.PATH));
				env.push(
					"Rome version: " +
					indent(___R$project$rome$$romejs$core$common$constants_ts$VERSION),
				);
				env.push("Node version: " + indent(process.versions.node));
				env.push("Platform: " + indent(process.platform + " " + process.arch));
				writer.append({name: "environment.txt"}, env.join("\n\n") + "\n");

				// Don't do this if we never connected to the master
				const bridgeStatus = this.getBridge();
				if (bridgeStatus !== undefined) {
					const status = await this.query({
						silent: true,
						commandName: "status",
					});
					if (status.type === "SUCCESS") {
						writer.append(
							{name: "status.txt"},
							___R$project$rome$$romejs$pretty$format$index_ts$default(
								status.data,
								{
									compact: true,
								},
							) + "\n",
						);
					}
				}

				await writer.finalize();
				this.reporter.success("Rage archive written to", ragePath);
			});
		}

		async query(query, type) {
			const request = new ___R$project$rome$$romejs$core$client$ClientRequest_ts$default(
				this,
				type,
				query,
			);
			const res = await request.init();
			this.requestResponseEvent.send({request: query, response: res});
			return res;
		}

		cancellableQuery(query, type) {
			const cancelToken = String(this.queryCounter++);

			return {
				promise: this.query(Object.assign({}, query, {cancelToken}), type),
				cancel: async () => {
					const status = this.getBridge();
					if (status !== undefined) {
						await status.bridge.cancelQuery.call(cancelToken);
					}
				},
			};
		}

		getBridge() {
			return this.bridgeStatus;
		}

		async end() {
			await this.endEvent.callOptional();

			const status = this.bridgeStatus;
			if (status !== undefined) {
				status.bridge.end();
				this.bridgeStatus = undefined;
			}
		}

		async attachBridge(bridge, dedicated) {
			const {stdout, stderr, columnsUpdated} = this.derivedReporterStreams;

			if (this.bridgeStatus !== undefined) {
				throw new Error("Already attached bridge to API");
			}

			this.bridgeStatus = {bridge, dedicated};

			bridge.stderr.subscribe((chunk) => {
				stderr.write(chunk);
			});

			bridge.stdout.subscribe((chunk) => {
				stdout.write(chunk);
			});

			bridge.reporterRemoteServerMessage.subscribe((msg) => {
				this.reporter.processRemoteClientMessage(msg);
			});

			this.reporter.sendRemoteServerMessage.subscribe((msg) => {
				bridge.reporterRemoteClientMessage.send(msg);
			});

			// Listen for resize column events if stdout is a TTY
			columnsUpdated.subscribe((columns) => {
				bridge.setColumns.call(columns);
			});

			await Promise.all([
				bridge.getClientInfo.wait({
					version: ___R$project$rome$$romejs$core$common$constants_ts$VERSION,
					format: stdout.format,
					unicode: stdout.unicode,
					hasClearScreen: this.reporter.hasClearScreen,
					columns: stdout.columns,
					useRemoteReporter: true,
					flags: this.getClientJSONFlags(),
				}),
				bridge.handshake(),
			]);

			await this.bridgeAttachedEvent.call();
		}

		async findOrStartMaster() {
			// First check if we already have a bridge connection
			const connected = this.getBridge();
			if (connected !== undefined) {
				return connected.bridge;
			}

			// Then check if there's already a running daemon
			const runningDaemon = await this.tryConnectToExistingDaemon();
			if (runningDaemon) {
				return runningDaemon;
			}

			// Otherwise, start a master inside this process
			const master = new ___R$project$rome$$romejs$core$master$Master_ts$default({
				dedicated: false,
				globalErrorHandlers: this.options.globalErrorHandlers === true,
			});
			await master.init();

			const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromLocal(
				___R$project$rome$$romejs$core$common$bridges$MasterBridge_ts$default,
				{},
			);
			await Promise.all([
				master.attachToBridge(bridge),
				this.attachBridge(bridge, false),
			]);

			this.endEvent.subscribe(async () => {
				await master.end();
			});

			return bridge;
		}

		async forceStartDaemon() {
			const daemon = await this.startDaemon();
			if (daemon === undefined) {
				this.reporter.error("Failed to start daemon");
				throw new Error("Failed to start daemon");
			} else {
				return daemon;
			}
		}

		async startDaemon() {
			const {reporter} = this;

			if (this.bridgeStatus !== undefined) {
				throw new Error("Already started master");
			}

			reporter.info("No running daemon found. Starting one...");

			let exited = false;
			let proc;

			const newDaemon = await new Promise((resolve) => {
				const timeout = setTimeout(
					() => {
						reporter.error("Daemon connection timed out");
						cleanup();
						resolve();
					},
					___R$$priv$project$rome$$romejs$core$client$Client_ts$NEW_SERVER_INIT_TIMEOUT,
				);

				const socketServer = ___R$$priv$project$rome$$romejs$core$client$Client_ts$net.createServer(() => {
					cleanup();

					resolve(
						this.tryConnectToExistingDaemon().then((bridge) => {
							if (bridge !== undefined) {
								this.reporter.success("Started daemon!");
							}
							return bridge;
						}),
					);
				});

				function listen() {
					socketServer.listen(
						___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH.join(),
					);

					proc = ___R$project$rome$$romejs$core$common$utils$fork_ts$default(
						"master",
						{
							detached: true,
						},
					);
					proc.unref();

					proc.on(
						"close",
						() => {
							exited = true;
							cleanup();
							resolve();
						},
					);
				}

				___R$project$rome$$romejs$fs$index_ts$unlink(
					___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH,
				).finally(() => {
					listen();
				});

				function cleanup() {
					clearTimeout(timeout);
					socketServer.close();
				}
			});
			if (newDaemon) {
				return newDaemon;
			}

			// as a final precaution kill the server
			if (exited) {
				reporter.error("Daemon died while initialising.");
			} else {
				reporter.error("Failed to connect. Killing daemon.");
			}

			if (proc !== undefined) {
				proc.kill();
			}

			return undefined;
		}

		async tryConnectToExistingDaemon() {
			const promise = new Promise((resolve, reject) => {
				const socket = ___R$$priv$project$rome$$romejs$core$client$Client_ts$net.createConnection(
					{
						path: ___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH.join(),
					},
					() => {
						resolve(socket);
					},
				);

				socket.on(
					"error",
					(err) => {
						if (
							err.code === "ENOENT" ||
							err.code === "ECONNREFUSED" ||
							err.code === "EADDRINUSE"
						) {
							resolve();
						} else {
							reject(err);
						}
					},
				);
			});

			const socket = await promise;
			if (socket === undefined) {
				return undefined;
			}

			const server = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromSocket(
				___R$project$rome$$romejs$core$common$bridges$MasterBridge_ts$default,
				socket,
				{
					type: "server",
				},
			);
			await this.attachBridge(server, true);
			this.reporter.success("Connected to daemon");
			return server;
		}
	}


  // project-rome/@romejs/core/common/types/bundler.ts
const ___R$project$rome$$romejs$core$common$types$bundler_ts = {
		get BUNDLER_MODES() {
			return ___R$project$rome$$romejs$core$common$types$bundler_ts$BUNDLER_MODES;
		},
	};




	const ___R$project$rome$$romejs$core$common$types$bundler_ts$BUNDLER_MODES = [
		"modern",
		"legacy",
	];














  // project-rome/@romejs/core/common/types/files.ts
const ___R$project$rome$$romejs$core$common$types$files_ts = {
		convertTransportFileReference: ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference,
	};




	function ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
		ref,
	) {
		return Object.assign(
			{},
			ref,
			{
				relative: ___R$project$rome$$romejs$path$index_ts$createRelativeFilePath(
					ref.relative,
				),
				real: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
					ref.real,
				),
			},
		);
	}


  // project-rome/@romejs/core/worker/WorkerAPI.ts
// Some Windows git repos will automatically convert Unix line endings to Windows
	// This retains the line endings for the formatted code if they were present in the source
	function ___R$$priv$project$rome$$romejs$core$worker$WorkerAPI_ts$normalizeFormattedLineEndings(
		sourceText,
		formatted,
	) {
		if (sourceText.includes("\r")) {
			return formatted.replace(/\n/g, "\r\n");
		} else {
			return formatted;
		}
	}

	class ___R$project$rome$$romejs$core$worker$WorkerAPI_ts$default {
		constructor(worker) {
			this.worker = worker;
			this.logger = worker.logger;
		}

		interceptAndAddGeneratedToDiagnostics(val, generated) {
			if (generated) {
				const diagnostics = val.diagnostics.map((diag) => {
					return Object.assign(
						{},
						diag,
						{
							metadata: Object.assign(
								{},
								diag.description,
								{
									advice: [
										...diag.description.advice,
										{
											type: "log",
											category: "warn",
											text: "This diagnostic was generated on a file that has been converted to JavaScript. The source locations are most likely incorrect",
										},
									],
								},
							),
						},
					);
				});

				return Object.assign({}, val, {diagnostics});
			} else {
				return val;
			}
		}

		async moduleSignatureJS(ref, parseOptions) {
			const {ast, project} = await this.worker.parseJS(ref, parseOptions);

			this.logger.info("Generating export types:", ref.real);

			return await ___R$project$rome$$romejs$js$analysis$index_ts.getModuleSignature({
				ast,
				project,
				provider: await this.worker.getTypeCheckProvider(
					ref.project,
					{},
					parseOptions,
				),
			});
		}

		async updateInlineSnapshots(ref, updates, parseOptions) {
			let {ast, sourceText} = await this.worker.parseJS(ref, parseOptions);

			const appliedUpdatesToCallees = new Set();
			const pendingUpdates = new Set(updates);
			const context = new ___R$project$rome$$romejs$js$compiler$lib$CompilerContext_ts$default({
				ast,
				ref,
			});
			ast = context.reduceRoot(
				ast,
				{
					name: "updateInlineSnapshots",
					enter(path) {
						const {node} = path;
						if (node.type !== "CallExpression" || pendingUpdates.size === 0) {
							return node;
						}

						let matchedUpdate;

						const {callee} = node;
						for (const {node} of ___R$project$rome$$romejs$js$ast$utils$getNodeReferenceParts_ts$default(
							callee,
						).parts) {
							const {loc} = node;
							if (loc === undefined) {
								continue;
							}

							for (const update of pendingUpdates) {
								if (
									loc.start.column === update.column &&
									loc.start.line === update.line
								) {
									matchedUpdate = update;
									break;
								}
							}

							if (matchedUpdate !== undefined) {
								break;
							}
						}

						if (matchedUpdate !== undefined) {
							if (appliedUpdatesToCallees.has(callee)) {
								context.addNodeDiagnostic(
									node,
									___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.INLINE_COLLISION,
								);
								return node;
							}

							pendingUpdates.delete(matchedUpdate);
							appliedUpdatesToCallees.add(callee);

							const args = node.arguments;
							if (args.length < 1) {
								context.addNodeDiagnostic(
									node,
									___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.INLINE_MISSING_RECEIVED,
								);
								return node;
							}

							return Object.assign(
								{},
								node,
								{
									arguments: [
										args[0],
										___R$project$rome$$romejs$js$ast$utils$valueToNode_ts$default(
											matchedUpdate.snapshot,
										),
									],
								},
							);
						}

						return node;
					},
				},
			);

			const diags = context.diagnostics.getDiagnostics();

			if (pendingUpdates.size > 0 && diags.length === 0) {
				throw new Error("Left over inline snapshots that were not updated");
			}

			if (diags.length === 0) {
				const formatted = ___R$project$rome$$romejs$js$formatter$index_ts$formatJS(
					ast,
					{sourceText},
				).code;
				await this.worker.writeFile(ref.real, formatted);
			}

			return diags;
		}

		async analyzeDependencies(ref, parseOptions) {
			const project = this.worker.getProject(ref.project);
			const {handler} = ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandlerAssert(
				ref.real,
				project.config,
			);
			this.logger.info("Analyze dependencies:", ref.real);

			const {analyzeDependencies} = handler;
			if (analyzeDependencies === undefined) {
				return ___R$project$rome$$romejs$core$common$types$analyzeDependencies_ts$UNKNOWN_ANALYZE_DEPENDENCIES_RESULT;
			}

			return await analyzeDependencies({
				file: ref,
				project,
				worker: this.worker,
				parseOptions,
			});
		}

		async workerCompilerOptionsToCompilerOptions(
			ref,
			workerOptions,
			parseOptions,
		) {
			const ___R$ = workerOptions;
			const options = Object.assign({}, ___R$);
			delete options.bundle;
			const {bundle} = ___R$;
			if (bundle === undefined) {
				return options;
			} else {
				return Object.assign(
					{},
					options,
					{
						bundle: Object.assign(
							{},
							bundle,
							{analyze: await this.analyzeDependencies(ref, parseOptions)},
						),
					},
				);
			}
		}

		async compileJS(ref, stage, options, parseOptions) {
			const {ast, project, sourceText, generated} = await this.worker.parseJS(
				ref,
				parseOptions,
			);
			this.logger.info("Compiling:", ref.real);

			const compilerOptions = await this.workerCompilerOptionsToCompilerOptions(
				ref,
				options,
				parseOptions,
			);
			return this.interceptAndAddGeneratedToDiagnostics(
				await ___R$project$rome$$romejs$js$compiler$api$compile_ts$default({
					ref,
					ast,
					sourceText,
					options: compilerOptions,
					project,
					stage,
				}),
				generated,
			);
		}

		async parseJS(ref, opts) {
			let {ast, generated} = await this.worker.parseJS(
				ref,
				Object.assign({}, opts, {sourceType: opts.sourceType, cache: false}),
			);

			return this.interceptAndAddGeneratedToDiagnostics(ast, generated);
		}

		async format(ref, opts) {
			const res = await this._format(ref, opts);
			if (res === undefined) {
				return undefined;
			} else {
				return {
					formatted: ___R$$priv$project$rome$$romejs$core$worker$WorkerAPI_ts$normalizeFormattedLineEndings(
						res.sourceText,
						res.formatted,
					),
					original: res.sourceText,
					diagnostics: res.diagnostics,
				};
			}
		}

		async _format(ref, parseOptions) {
			const project = this.worker.getProject(ref.project);
			this.logger.info("Formatting:", ref.real);

			const {handler} = ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandlerAssert(
				ref.real,
				project.config,
			);
			const {format} = handler;
			if (format === undefined) {
				return;
			}

			const res = await format({
				file: ref,
				project,
				worker: this.worker,
				parseOptions,
			});

			return res;
		}

		async lint(ref, options, parseOptions) {
			const project = this.worker.getProject(ref.project);
			this.logger.info("Linting:", ref.real);

			// Get the extension handler
			const {handler} = ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandlerAssert(
				ref.real,
				project.config,
			);

			const {lint} = handler;
			if (lint === undefined && handler.format === undefined) {
				return {
					saved: false,
					diagnostics: [],
					suppressions: [],
				};
			}

			// Catch any diagnostics, in the case of syntax errors etc
			const res = await ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(
				() => {
					if (lint === undefined) {
						return this._format(ref, parseOptions);
					} else {
						return lint({
							file: ref,
							project,
							worker: this.worker,
							options,
							parseOptions,
						});
					}
				},
				{
					category: "lint",
					message: "Caught by WorkerAPI.lint",
				},
			);

			// These are fatal diagnostics
			if (res.diagnostics !== undefined) {
				return {
					saved: false,
					suppressions: [],
					diagnostics: res.diagnostics,
				};
			}

			// `format` could have return undefined
			if (res.value === undefined) {
				return {
					saved: false,
					diagnostics: [],
					suppressions: [],
				};
			}

			// These are normal diagnostics returned from the linter
			const {
				sourceText,
				diagnostics,
				suppressions,
			} = res.value;

			const formatted = ___R$$priv$project$rome$$romejs$core$worker$WorkerAPI_ts$normalizeFormattedLineEndings(
				sourceText,
				res.value.formatted,
			);

			// If the file has pending fixes
			const needsSave = formatted !== sourceText;

			// Autofix if necessary
			if (options.save && needsSave) {
				// Save the file and evict it from the cache
				await this.worker.writeFile(ref.real, formatted);

				// Relint this file without fixing it, we do this to prevent false positive error messages
				return Object.assign(
					{},
					await this.lint(
						ref,
						Object.assign({}, options, {save: false}),
						parseOptions,
					),
					{saved: true},
				);
			}

			// If there's no pending fix then no need for diagnostics
			if (!needsSave) {
				return {
					saved: false,
					diagnostics,
					suppressions,
				};
			}

			// Add pending autofix diagnostic
			return {
				saved: false,
				suppressions,
				diagnostics: [
					...diagnostics,
					{
						fixable: true,
						location: {
							filename: ref.uid,
						},
						description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.LINT.PENDING_FIXES(
							ref.relative.join(),
							sourceText,
							formatted,
						),
					},
				],
			};
		}
	}


  // project-rome/@romejs/core/worker/Worker.ts




	class ___R$project$rome$$romejs$core$worker$Worker_ts$default {
		constructor(opts) {
			this.bridge = opts.bridge;

			this.userConfig = ___R$project$rome$$romejs$core$common$userConfig_ts$loadUserConfig();
			this.partialManifests = new Map();
			this.projects = new Map();
			this.astCache = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.moduleSignatureCache = new ___R$project$rome$$romejs$path$collections_ts$UnknownFilePathMap();
			this.buffers = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();

			this.logger = new ___R$project$rome$$romejs$core$common$utils$Logger_ts$default(
				"worker",
				() => opts.bridge.log.hasSubscribers(),
				{
					streams: [
						{
							type: "all",
							format: "none",
							columns: ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.DEFAULT_COLUMNS,
							unicode: true,
							write(chunk) {
								opts.bridge.log.send(chunk.toString());
							},
						},
					],
				},
			);

			//
			this.api = new ___R$project$rome$$romejs$core$worker$WorkerAPI_ts$default(
				this,
			);

			if (opts.globalErrorHandlers) {
				___R$project$rome$$romejs$core$common$utils$setupGlobalErrorHandlers_ts$default((
					err,
				) => {
					// TODO
					err;
				});
			}
		}

		getPartialManifest(id) {
			const manifest = this.partialManifests.get(id);
			if (manifest === undefined) {
				throw new Error("Requested manifest " + id + " but we don't have it");
			}
			return manifest;
		}

		end() {
			// This will only actually be called when a Worker is created inside of the Master
			// Clear internal maps for memory, in case the Worker instance sticks around
			this.astCache.clear();
			this.projects.clear();
			this.moduleSignatureCache.clear();
		}

		async init() {
			const bridge = this.bridge;

			bridge.endEvent.subscribe(() => {
				this.end();
			});

			let profiler;
			bridge.profilingStart.subscribe(async (data) => {
				if (profiler !== undefined) {
					throw new Error("Expected no profiler to be running");
				}
				profiler = new ___R$project$rome$$romejs$v8$Profiler_ts$default();
				await profiler.startProfiling(data.samplingInterval);
			});

			bridge.profilingStop.subscribe(async () => {
				if (profiler === undefined) {
					throw new Error("Expected a profiler to be running");
				}
				const workerProfile = await profiler.stopProfiling();
				profiler = undefined;
				return workerProfile;
			});

			bridge.compileJS.subscribe((payload) => {
				return this.api.compileJS(
					___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
						payload.file,
					),
					payload.stage,
					payload.options,
					payload.parseOptions,
				);
			});

			bridge.parseJS.subscribe((payload) => {
				return this.api.parseJS(
					___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
						payload.file,
					),
					payload.options,
				);
			});

			bridge.lint.subscribe((payload) => {
				return this.api.lint(
					___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
						payload.file,
					),
					payload.options,
					payload.parseOptions,
				);
			});

			bridge.format.subscribe((payload) => {
				return this.api.format(
					___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
						payload.file,
					),
					payload.parseOptions,
				);
			});

			bridge.updateInlineSnapshots.subscribe((payload) => {
				return this.api.updateInlineSnapshots(
					___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
						payload.file,
					),
					payload.updates,
					payload.parseOptions,
				);
			});

			bridge.analyzeDependencies.subscribe((payload) => {
				return this.api.analyzeDependencies(
					___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
						payload.file,
					),
					payload.parseOptions,
				);
			});

			bridge.evict.subscribe((payload) => {
				this.evict(
					___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
						payload.filename,
					),
				);
				return undefined;
			});

			bridge.moduleSignatureJS.subscribe((payload) => {
				return this.api.moduleSignatureJS(
					___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
						payload.file,
					),
					payload.parseOptions,
				);
			});

			bridge.updateProjects.subscribe((payload) => {
				return this.updateProjects(payload.projects);
			});

			bridge.updateManifests.subscribe((payload) => {
				return this.updateManifests(payload.manifests);
			});

			bridge.status.subscribe(() => {
				return {
					astCacheSize: this.astCache.size,
					pid: process.pid,
					memoryUsage: process.memoryUsage(),
					uptime: process.uptime(),
				};
			});

			bridge.updateBuffer.subscribe((payload) => {
				return this.updateBuffer(
					___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
						payload.file,
					),
					payload.content,
				);
			});
		}

		async updateBuffer(ref, content) {
			const path = ref.real;
			this.buffers.set(path, content);

			// Now outdated
			this.astCache.delete(path);
			this.moduleSignatureCache.delete(path);
		}

		async getTypeCheckProvider(
			projectId,
			prefetchedModuleSignatures = {},
			parseOptions,
		) {
			const libs = [];

			// TODO Figure out how to get the uids for the libraries, probably adding some additional stuff to ProjectConfig?

			/*
    const projectConfig = this.getProjectConfig(projectId);
    for (const filename of projectConfig.typeChecking.libs) {
      const {ast, err} = await this.parse(filename, uid, projectId);
      if (err) {
        throw err;
      } else {
        invariant(ast, 'expected ast');
        libs.push(ast);
      }
    }
    */
			const resolveGraph = async (key) => {
				const value = prefetchedModuleSignatures[key];
				if (value === undefined) {
					return undefined;
				}

				switch (value.type) {
					case "RESOLVED": {
						this.moduleSignatureCache.set(
							___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
								value.graph.filename,
							),
							value.graph,
						);
						return value.graph;
					}

					case "OWNED":
						return this.api.moduleSignatureJS(
							___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
								value.file,
							),
							parseOptions,
						);

					case "POINTER":
						return resolveGraph(value.key);

					case "USE_CACHED": {
						const cached = this.moduleSignatureCache.get(
							___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(
								value.filename,
							),
						);
						if (cached === undefined) {
							throw new Error(
								"Master told us we have the export types for " +
								value.filename +
								" cached but we dont!",
							);
						}
						return cached;
					}
				}
			};

			return {
				getExportTypes: async (origin, relative) => {
					return resolveGraph(origin + ":" + relative);
				},
				libs,
			};
		}

		populateDiagnosticsMtime(diagnostics) {
			return diagnostics;
		}

		async readFile(path) {
			const buffer = this.buffers.get(path);
			if (buffer === undefined) {
				return await ___R$project$rome$$romejs$fs$index_ts$readFileText(path);
			} else {
				return buffer;
			}
		}

		async parseJS(ref, options) {
			const path = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
				ref.real,
			);

			const {project: projectId, uid} = ref;
			const project = this.getProject(projectId);

			// Fetch and validate extension handler
			const {handler} = ___R$project$rome$$romejs$core$common$file$handlers$index_ts$getFileHandlerAssert(
				ref.real,
				project.config,
			);
			if (handler.toJavaScript === undefined) {
				throw new Error(
					"We don't know how to convert the file " + path + " to js",
				);
			}

			// Get syntax
			let syntax = [];
			if (options.syntax !== undefined) {
				syntax = options.syntax;
			} else if (handler.syntax !== undefined) {
				syntax = handler.syntax;
			}

			// Get source type
			let sourceType;
			if (options.sourceType !== undefined) {
				sourceType = options.sourceType;
			} else if (handler.sourceType !== undefined) {
				sourceType = handler.sourceType;
			} else {
				sourceType = "script";

				if (ref.manifest !== undefined) {
					const manifest = this.getPartialManifest(ref.manifest);
					if (manifest.type === "module") {
						sourceType = "module";
					}
				}
			}

			if (project.config.bundler.mode === "legacy") {
				sourceType = "module";
			}

			const cacheEnabled = options.cache !== false;

			if (cacheEnabled) {
				// Update the lastAccessed of the ast cache and return it, it will be evicted on
				// any file change
				const cachedResult = this.astCache.get(path);
				if (cachedResult !== undefined) {
					let useCached = true;

					if (cachedResult.ast.sourceType !== sourceType) {
						useCached = false;
					}

					if (useCached) {
						this.astCache.set(
							path,
							Object.assign({}, cachedResult, {lastAccessed: Date.now()}),
						);
						return cachedResult;
					}
				}
			}

			this.logger.info("Parsing:", path);

			const stat = await ___R$project$rome$$romejs$fs$index_ts$lstat(path);

			const {sourceText, generated} = await handler.toJavaScript({
				file: ref,
				worker: this,
				project,
				parseOptions: options,
			});

			let manifestPath;
			if (ref.manifest !== undefined) {
				manifestPath = this.getPartialManifest(ref.manifest).path;
			}

			const ast = ___R$project$rome$$romejs$js$parser$index_ts$parseJS({
				input: sourceText,
				mtime: stat.mtimeMs,
				manifestPath,
				path: ___R$project$rome$$romejs$path$index_ts$createUnknownFilePath(uid),
				sourceType,
				syntax,
				allowReturnOutsideFunction: sourceType === "script",
			});

			// If the AST is corrupt then we don't under any circumstance allow it
			if (ast.corrupt) {
				throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
					"Corrupt AST",
					ast.diagnostics,
				);
			}

			// Sometimes we may want to allow the "fixed" AST
			const allowDiagnostics = options.allowParserDiagnostics === true;
			if (!allowDiagnostics && ast.diagnostics.length > 0) {
				throw new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
					"AST diagnostics aren't allowed",
					ast.diagnostics,
				);
			}

			const res = {
				ast,
				lastAccessed: Date.now(),
				sourceText,
				project,
				path,
				generated,
			};

			if (cacheEnabled) {
				this.astCache.set(path, res);
			}

			return res;
		}

		getProject(id) {
			const config = this.projects.get(id);
			if (config === undefined) {
				throw new Error(
					"Unknown project " +
					id +
					", known projects are " +
					this.projects.keys(),
				);
			}
			return config;
		}

		async writeFile(path, content) {
			// Write the file out
			await ___R$project$rome$$romejs$fs$index_ts$writeFile(path, content);

			// We just wrote the file but the server watcher hasn't had time to notify us
			this.evict(path);
		}

		evict(path) {
			this.astCache.delete(path);
			this.moduleSignatureCache.delete(path);
		}

		updateManifests(manifests) {
			for (const {id, manifest} of manifests) {
				if (manifest === undefined) {
					this.partialManifests.delete(id);
				} else {
					this.partialManifests.set(id, manifest);
				}
			}
		}

		updateProjects(projects) {
			for (const {config, folder, id} of projects) {
				if (config === undefined) {
					this.projects.delete(id);
				} else {
					this.projects.set(
						id,
						{
							folder: ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
								folder,
							),
							config: ___R$project$rome$$romejs$project$transport_ts$hydrateJSONProjectConfig(
								config,
							),
						},
					);
				}
			}
		}
	}


  // project-rome/@romejs/core/test-worker/TestAPI.ts
function ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$formatExpectedError(
		expected,
	) {
		if (typeof expected === "string") {
			return JSON.stringify(expected);
		}

		if (expected instanceof RegExp) {
			return String(expected);
		}

		if (typeof expected === "function") {
			return expected.name;
		}

		return "unknown";
	}

	function ___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$matchExpectedError(
		error,
		expected,
	) {
		if (expected === undefined) {
			return true;
		}

		if (typeof expected === "string") {
			return error.message.includes(expected);
		}

		if (expected instanceof RegExp) {
			return expected.test(error.message);
		}

		if (typeof expected === "function") {
			return error instanceof expected;
		}

		return false;
	}







	class ___R$project$rome$$romejs$core$test$worker$TestAPI_ts$default {
		constructor(
			{
				testName,
				onTimeout,
				file,
				snapshotManager,
				options,
				emitDiagnostic,
			},
		) {
			this.testName = testName;
			this.options = options;
			this.snapshotManager = snapshotManager;
			this.snapshotCounter = 0;
			this.file = file;
			this.teardownEvent = new ___R$project$rome$$romejs$events$Event_ts$default({
				name: "TestAPI.teardown",
			});
			this.startTime = Date.now();
			this.onTimeout = onTimeout;
			this.emitDiagnostic = emitDiagnostic;
			this.timeoutMax = 0;
			this.timeoutId = undefined;
			this.setTimeout(5_000);
			this.advice = [];
		}

		buildMatchAdvice(
			received,
			expected,
			{
				visualMethod,
				expectedAlias,
				receivedAlias,
			} = {},
		) {
			let expectedFormat;
			let receivedFormat;
			if (typeof received === "string" && typeof expected === "string") {
				expectedFormat = expected;
				receivedFormat = received;
			} else {
				expectedFormat = ___R$project$rome$$romejs$pretty$format$index_ts$default(
					expected,
				);
				receivedFormat = ___R$project$rome$$romejs$pretty$format$index_ts$default(
					received,
				);
			}

			const advice = [];

			if (expectedFormat === receivedFormat) {
				// Better error message when both values are visually identical
				advice.push({
					type: "log",
					category: "info",
					text: "Both the received and expected values are visually identical",
				});

				advice.push({
					type: "code",
					code: expectedFormat,
				});

				if (visualMethod !== undefined) {
					advice.push({
						type: "log",
						category: "info",
						text: "Try using t." +
						visualMethod +
						" if you wanted a visual match",
					});
				}
			} else {
				const bothSingleLine =
					!expectedFormat.match(/\n/g) && !receivedFormat.match(/\n/g);

				if (!bothSingleLine) {
					advice.push({
						type: "log",
						category: "info",
						text: "Expected to receive",
					});

					advice.push({
						type: "code",
						code: expectedFormat,
					});

					advice.push({
						type: "log",
						category: "info",
						text: "But got",
					});

					advice.push({
						type: "code",
						code: receivedFormat,
					});

					advice.push({
						type: "log",
						category: "info",
						text: "Diff",
					});
				}

				advice.push({
					type: "diff",
					diff: ___R$project$rome$$romejs$string$diff$index_ts$default(
						expectedFormat,
						receivedFormat,
					),
					legend: {
						add: receivedAlias ? receivedAlias : "Received",
						delete: expectedAlias ? expectedAlias : "Expected",
					},
				});
			}

			return advice;
		}

		addToAdvice(item) {
			this.advice.push(item);
		}

		clearAdvice() {
			this.advice = [];
		}

		onTeardown(callback) {
			this.teardownEvent.subscribe(callback);
		}

		clearTimeout() {
			if (this.timeoutId !== undefined) {
				clearTimeout(this.timeoutId);
			}

			this.timeoutMax = undefined;
			this.timeoutStart = undefined;
		}

		extendTimeout(time) {
			const {timeoutMax, timeoutStart} = this;
			if (timeoutMax === undefined || timeoutStart === undefined) {
				throw new Error("No timeout set");
			}

			const elapsed = Date.now() - timeoutStart;
			const newTime = timeoutMax - elapsed + time;
			this.setTimeout(newTime);
		}

		setTimeout(time) {
			this.clearTimeout();

			this.timeoutStart = Date.now();
			this.timeoutMax = time;

			this.timeoutId = setTimeout(
				() => {
					this.onTimeout(time);
				},
				time,
			);
		}

		checkTimeout() {
			const {startTime, timeoutMax} = this;
			if (timeoutMax === undefined) {
				return;
			}

			const delta = Date.now() - startTime;
			if (delta > timeoutMax) {
				throw new Error("Test timeout - exceeded " + String(timeoutMax) + "ms");
			}
		}

		fail(
			message = "Test failure triggered by t.fail()",
			advice = [],
			framesToShift = 0,
		) {
			const diag = ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
				___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(
					new Error(),
					framesToShift + 1,
				),
				{
					description: {
						category: "tests/failure",
						message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
							message,
						),
						advice,
					},
				},
			);
			throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
				diag,
			);
		}

		truthy(value, message = "Expected value to be truthy") {
			if (Boolean(value) === false) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: "Received",
						},
						{
							type: "code",
							code: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								value,
							),
						},
					],
					1,
				);
			}
		}

		falsy(value, message = "Expected value to be falsy") {
			if (Boolean(value) === true) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: "Received",
						},
						{
							type: "code",
							code: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								value,
							),
						},
					],
					1,
				);
			}
		}

		true(value, message = "Expected value to be true") {
			if (value !== true) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: "Received",
						},
						{
							type: "code",
							code: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								value,
							),
						},
					],
					1,
				);
			}
		}

		false(value, message = "Expected value to be false") {
			if (value !== false) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: "Received",
						},
						{
							type: "code",
							code: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								value,
							),
						},
					],
					1,
				);
			}
		}

		is(received, expected, message = "t.is() failed, using Object.is semantics") {
			if (Object.is(received, expected) !== true) {
				this.fail(
					message,
					this.buildMatchAdvice(
						received,
						expected,
						{
							visualMethod: "looksLike",
						},
					),
					1,
				);
			}
		}

		not(
			received,
			expected,
			message = "t.not() failed, using !Object.is() semantics",
		) {
			if (Object.is(received, expected) === true) {
				this.fail(
					message,
					this.buildMatchAdvice(
						received,
						expected,
						{
							visualMethod: "notLooksLike",
						},
					),
					1,
				);
			}
		}

		looksLike(
			received,
			expected,
			message = "t.looksLike() failed, using prettyFormat semantics",
		) {
			const actualInspect = ___R$project$rome$$romejs$pretty$format$index_ts$default(
				received,
			);
			const expectedInspect = ___R$project$rome$$romejs$pretty$format$index_ts$default(
				expected,
			);

			if (actualInspect !== expectedInspect) {
				this.fail(message, this.buildMatchAdvice(received, expected), 1);
			}
		}

		notLooksLike(
			received,
			expected,
			message = "t.notLooksLike() failed, using !prettyFormat semantics",
		) {
			const actualInspect = ___R$project$rome$$romejs$pretty$format$index_ts$default(
				received,
			);
			const expectedInspect = ___R$project$rome$$romejs$pretty$format$index_ts$default(
				expected,
			);

			if (actualInspect === expectedInspect) {
				this.fail(message, this.buildMatchAdvice(received, expected), 1);
			}
		}

		throws(
			thrower,
			expected,
			message = "t.throws() failed, callback did not throw an error",
		) {
			try {
				thrower();
			} catch (err) {
				if (
					___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$matchExpectedError(
						err,
						expected,
					)
				) {
					return undefined;
				} else {
					this.fail(
						"t.throws() expected an error to be thrown that matches " +
						___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$formatExpectedError(
							expected,
						) +
						" but got " +
						err.name +
						": " +
						JSON.stringify(err.message),
						___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(
							___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err),
							"Incorrect error stack trace",
						),
						1,
					);
				}
			}

			this.fail(message, undefined, 1);
		}

		async throwsAsync(
			thrower,
			expected,
			message = "t.throws() failed, callback did not throw an error",
		) {
			try {
				await thrower();
			} catch (err) {
				if (
					___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$matchExpectedError(
						err,
						expected,
					)
				) {
					return undefined;
				} else {
					this.fail(
						"t.throws() expected an error to be thrown that matches " +
						___R$$priv$project$rome$$romejs$core$test$worker$TestAPI_ts$formatExpectedError(
							expected,
						) +
						" but got " +
						err.name +
						": " +
						JSON.stringify(err.message),
						___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(
							___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err),
							"Incorrect error stack trace",
						),
						1,
					);
				}
			}
			this.fail(message, undefined, 1);
		}

		notThrows(
			nonThrower,
			message = "t.notThrows() failed, callback threw an error",
		) {
			try {
				nonThrower();
			} catch (err) {
				const advice = ___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(
					___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err),
					"t.notThrows did not expect an error to be thrown but got " +
					err.name +
					": " +
					JSON.stringify(err.message),
				);
				this.fail(message, advice, 1);
			}
		}

		async notThrowsAsync(
			nonThrower,
			message = "t.notThrowsAsync failed, callback threw an error",
		) {
			try {
				await nonThrower();
			} catch (err) {
				const advice = ___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(
					___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err),
					"t.notThrowsAsync did not expect an error to be thrown but got " +
					err.name +
					": " +
					JSON.stringify(err.message),
				);
				this.fail(message, advice, 1);
			}
		}

		regex(
			contents,
			regex,
			message = "t.regex failed, using RegExp.test semantics",
		) {
			if (!regex.test(contents)) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: "Expected",
						},
						{
							type: "code",
							code: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								contents,
							),
						},
						{
							type: "log",
							category: "info",
							text: "to match pattern",
						},
						{
							type: "code",
							code: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								regex.source,
							),
						},
					],
					1,
				);
			}
		}

		notRegex(
			contents,
			regex,
			message = "t.regex failed, using RegExp.test semantics",
		) {
			if (regex.test(contents)) {
				this.fail(
					message,
					[
						{
							type: "log",
							category: "info",
							text: "Expected",
						},
						{
							type: "code",
							code: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								contents,
							),
						},
						{
							type: "log",
							category: "info",
							text: "to not match pattern",
						},
						{
							type: "code",
							code: ___R$project$rome$$romejs$pretty$format$index_ts$default(
								regex.source,
							),
						},
					],
					1,
				);
			}
		}

		inlineSnapshot(received, snapshot) {
			const callFrame = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(
				new Error(),
			).frames[1];
			const callError = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(
				new Error(),
				1,
			);

			this.onTeardown(async () => {
				const {status} = this.snapshotManager.testInlineSnapshot(
					callFrame,
					received,
					snapshot,
				);

				if (status === "UPDATE" && this.options.freezeSnapshots) {
					await this.emitDiagnostic(
						___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
							callError,
							{
								description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.INLINE_FROZEN,
							},
						),
					);
				}

				if (status === "NO_MATCH") {
					await this.emitDiagnostic(
						___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
							callError,
							{
								description: Object.assign(
									{},
									___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.INLINE_BAD_MATCH,
									{
										advice: this.buildMatchAdvice(
											received,
											snapshot,
											{
												receivedAlias: "What the code gave us",
												expectedAlias: "Existing inline snapshot",
											},
										),
									},
								),
							},
						),
					);
				}
			});
		}

		snapshot(expected, message, opts) {
			const id = this.snapshotCounter++;
			return this.bufferSnapshot({
				entryName: String(id),
				expected,
				message,
				opts,
			});
		}

		namedSnapshot(entryName, expected, message, opts) {
			return this.bufferSnapshot({
				entryName,
				expected,
				message,
				opts,
			});
		}

		bufferSnapshot(
			{
				entryName,
				message,
				expected,
				opts = {},
			},
		) {
			let language = opts.language;

			let formatted = "";
			if (typeof expected === "string") {
				formatted = expected;
			} else {
				language = "javascript";
				formatted = ___R$project$rome$$romejs$pretty$format$index_ts$default(
					expected,
				);
			}

			const callError = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(
				new Error(),
				2,
			);

			this.onTeardown(async () => {
				// Get the current snapshot
				const existingSnapshot = await this.snapshotManager.get(
					this.testName,
					entryName,
					opts.filename,
				);
				if (existingSnapshot === undefined) {
					if (this.options.freezeSnapshots) {
						await this.emitDiagnostic(
							___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
								callError,
								{
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.FROZEN,
								},
							),
						);
					} else {
						// No snapshot exists, let's save this one!
						this.snapshotManager.set({
							testName: this.testName,
							entryName,
							value: formatted,
							language,
							optionalFilename: opts.filename,
						});
					}
					return;
				}

				// Compare the snapshots
				if (formatted !== existingSnapshot) {
					const advice = this.buildMatchAdvice(
						formatted,
						existingSnapshot,
						{
							receivedAlias: "What the code gave us",
							expectedAlias: "Existing snapshot",
						},
					);

					if (message === undefined) {
						message = ___R$project$rome$$romejs$string$markup$escape_ts$markup`Snapshot ${entryName} at <filelink emphasis target="${this.snapshotManager.defaultSnapshotPath.join()}" /> doesn't match`;
					} else {
						message = ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
							message,
						);

						advice.push({
							type: "log",
							category: "info",
							text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Snapshot can be found at <filelink emphasis target="${this.snapshotManager.defaultSnapshotPath.join()}" />`,
						});
					}

					advice.push({
						type: "log",
						category: "info",
						text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Run <command>rome test <filelink target="${this.file.uid}" /> --update-snapshots</command> to update this snapshot`,
					});

					await this.emitDiagnostic(
						___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
							callError,
							{
								description: {
									category: "tests/snapshots/incorrect",
									message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
										message,
									),
									advice,
								},
							},
						),
					);
				}
			});

			return entryName;
		}
	}


  // project-rome/@romejs/core/test-worker/SnapshotParser.ts










	function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isHash(
		char,
	) {
		return char === "#";
	}

	function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(
		index,
		input,
	) {
		return (
			input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index)] === "`" &&
			!___R$project$rome$$romejs$string$utils$isEscaped_ts$isEscaped(
				index,
				input,
			) &&
			input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 1),
			)] === "`" &&
			input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
				___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 2),
			)] === "`"
		);
	}

	function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isInCodeBlock(
		char,
		index,
		input,
	) {
		return !___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(
			index,
			input,
		);
	}

	function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isntNewline(
		char,
	) {
		return char !== "\n";
	}

	function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$unescapeTicks(
		code,
	) {
		return code;
	}

	const ___R$project$rome$$romejs$core$test$worker$SnapshotParser_ts$createSnapshotParser = ___R$project$rome$$romejs$parser$core$index_ts$createParser((
		ParserCore,
	) =>
		class SnapshotParser extends ParserCore {
			constructor(opts) {
				super(opts, "parse/snapshots");
				this.ignoreWhitespaceTokens = true;
			}

			tokenize(index, input) {
				const char = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(index)];

				switch (char) {
					case "#": {
						const [hashes] = this.readInputFrom(
							index,
							___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isHash,
						);
						const level = hashes.length;
						return this.finishValueToken(
							"Hashes",
							level,
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, level),
						);
					}

					case "`": {
						const nextChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 1),
						)];
						const nextNextChar = input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(
							___R$project$rome$$romejs$ob1$index_ts$ob1Add(index, 2),
						)];

						if (nextChar === "`" && nextNextChar === "`") {
							let codeOffset = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								index,
								3,
							);

							let language;
							if (
								input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(codeOffset)] !==
								"\n"
							) {
								[language, codeOffset] = this.readInputFrom(
									codeOffset,
									___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isntNewline,
								);
							}

							// Expect the first offset character to be a newline
							if (
								input[___R$project$rome$$romejs$ob1$index_ts$ob1Get0(codeOffset)] ===
								"\n"
							) {
								// Skip leading newline
								codeOffset = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
									codeOffset,
									1,
								);
							} else {
								throw this.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.MISSING_NEWLINE_AFTER_CODE_BLOCK,
									start: this.getPositionFromIndex(codeOffset),
								});
							}

							let [code] = this.readInputFrom(
								codeOffset,
								___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isInCodeBlock,
							);

							let end = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(
								codeOffset,
								code.length,
							);

							if (
								___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isCodeBlockEnd(
									end,
									input,
								)
							) {
								// Check for trailing newline
								if (code[code.length - 1] === "\n") {
									// Trim trailing newline
									code = code.slice(0, -1);

									// Skip closing ticks
									end = ___R$project$rome$$romejs$ob1$index_ts$ob1Add(end, 3);

									return this.finishValueToken(
										"CodeBlock",
										{
											language,
											text: ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$unescapeTicks(
												code,
											),
										},
										end,
									);
								} else {
									throw this.unexpected({
										description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.MISSING_NEWLINE_BEFORE_CODE_BLOCK,
										start: this.getPositionFromIndex(end),
									});
								}
							} else {
								throw this.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.UNCLOSED_CODE_BLOCK,
									start: this.getPositionFromIndex(end),
								});
							}
						}
					}
				}

				const [text, end] = this.readInputFrom(
					index,
					___R$$priv$project$rome$$romejs$core$test$worker$SnapshotParser_ts$isntNewline,
				);
				return this.finishValueToken("TextLine", text, end);
			}

			parse() {
				const nodes = [];

				while (!this.matchToken("EOF")) {
					const start = this.getPosition();
					const token = this.getToken();

					switch (token.type) {
						case "Hashes": {
							const level = token.value;
							this.nextToken();
							const text = this.expectToken("TextLine").value;
							nodes.push({
								type: "Heading",
								level,
								text,
								loc: this.finishLoc(start),
							});
							break;
						}

						case "CodeBlock": {
							nodes.push(
								Object.assign(
									{type: "CodeBlock"},
									token.value,
									{loc: this.finishLoc(start)},
								),
							);
							this.nextToken();
							break;
						}

						case "TextLine": {
							nodes.push({
								type: "TextLine",
								text: token.value,
								loc: this.finishLoc(start),
							});
							this.nextToken();
							break;
						}

						default:
							throw this.unexpected();
					}
				}

				return nodes;
			}
		}
	);


  // project-rome/@romejs/core/test-worker/SnapshotManager.ts
function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$cleanHeading(
		key,
	) {
		if (key[0] === "`") {
			key = key.slice(1);
		}

		if (key[key.length - 1] === "`") {
			key = key.slice(0, -1);
		}

		return key.trim();
	}





	const ___R$project$rome$$romejs$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT = ".test.md";

	function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$buildEntriesKey(
		testName,
		entryName,
	) {
		return testName + "#" + entryName;
	}







	function ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$stringOrPrettyFormat(
		value,
	) {
		if (typeof value === "string") {
			return value;
		} else {
			return ___R$project$rome$$romejs$pretty$format$index_ts$default(value);
		}
	}

	class ___R$project$rome$$romejs$core$test$worker$SnapshotManager_ts$default {
		constructor(runner, testPath) {
			this.defaultSnapshotPath = testPath.getParent().append(
				"" +
				testPath.getExtensionlessBasename() +
				___R$project$rome$$romejs$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT,
			);
			this.testPath = testPath;
			this.runner = runner;
			this.options = runner.options;
			this.snapshots = new ___R$project$rome$$romejs$path$collections_ts$AbsoluteFilePathMap();
			this.inlineSnapshotsUpdates = [];
			this.snapshotCounts = {
				deleted: 0,
				updated: 0,
				created: 0,
			};
		}

		normalizeSnapshotPath(filename) {
			if (filename === undefined) {
				return this.defaultSnapshotPath;
			}

			const path = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
				filename,
			);
			const ext = path.getExtensions();
			if (
				ext.endsWith(
					___R$project$rome$$romejs$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT,
				)
			) {
				return path;
			} else {
				return path.addExtension(
					___R$project$rome$$romejs$core$test$worker$SnapshotManager_ts$SNAPSHOT_EXT,
				);
			}
		}

		async init() {
			await this.loadSnapshot(this.defaultSnapshotPath);
		}

		async emitDiagnostic(metadata) {
			await this.runner.emitDiagnostic({
				description: metadata,
				location: {
					filename: this.defaultSnapshotPath.join(),
				},
			});
		}

		async loadSnapshot(path) {
			if (!(await ___R$project$rome$$romejs$fs$index_ts$exists(path))) {
				return;
			}

			const content = await ___R$project$rome$$romejs$fs$index_ts$readFileText(
				path,
			);
			const parser = ___R$project$rome$$romejs$core$test$worker$SnapshotParser_ts$createSnapshotParser({
				path,
				input: content,
			});

			const nodes = parser.parse();

			const snapshot = {
				existsOnDisk: true,
				used: false,
				raw: parser.input,
				entries: new Map(),
			};
			this.snapshots.set(path, snapshot);

			while (nodes.length > 0) {
				const node = nodes.shift();

				if (node.type === "Heading" && node.level === 1) {
					// Title
					continue;
				}

				if (node.type === "Heading" && node.level === 2) {
					const testName = ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$cleanHeading(
						node.text,
					);

					while (nodes.length > 0) {
						const node = nodes[0];

						if (node.type === "Heading" && node.level === 3) {
							nodes.shift();

							const entryName = ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$cleanHeading(
								node.text,
							);

							const codeBlock = nodes.shift();
							if (codeBlock === undefined || codeBlock.type !== "CodeBlock") {
								throw parser.unexpected({
									description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.EXPECTED_CODE_BLOCK_AFTER_HEADING,
									loc: node.loc,
								});
							}

							snapshot.entries.set(
								___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$buildEntriesKey(
									testName,
									entryName,
								),
								{
									testName,
									entryName,
									language: codeBlock.language,
									value: codeBlock.text,
								},
							);

							continue;
						}

						if (node.type === "CodeBlock") {
							nodes.shift();

							snapshot.entries.set(
								___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$buildEntriesKey(
									testName,
									"0",
								),
								{
									testName,
									entryName: "0",
									language: node.language,
									value: node.text,
								},
							);
						}

						break;
					}

					continue;
				}
			}

			return snapshot;
		}

		buildSnapshot(entries) {
			// Build the snapshot
			let lines = [];

			function pushNewline() {
				if (lines[lines.length - 1] !== "") {
					lines.push("");
				}
			}

			lines.push("# `" + this.testPath.getBasename() + "`");
			pushNewline();
			const relativeTestPath = this.runner.projectFolder.relative(this.testPath).join();
			lines.push(
				"**DO NOT MODIFY**. This file has been autogenerated. Run `rome test " +
				relativeTestPath +
				" --update-snapshots` to update.",
			);
			pushNewline();

			const testNameToEntries = new Map();
			for (const entry of entries) {
				let entriesByTestName = testNameToEntries.get(entry.testName);
				if (entriesByTestName === undefined) {
					entriesByTestName = new Map();
					testNameToEntries.set(entry.testName, entriesByTestName);
				}
				entriesByTestName.set(entry.entryName, entry);
			}

			// Get test names and sort them so they are in a predictable
			const testNames = Array.from(testNameToEntries.keys()).sort();

			for (const testName of testNames) {
				const entries = testNameToEntries.get(testName);

				lines.push("## `" + testName + "`");
				pushNewline();
				const entryNames = Array.from(entries.keys()).sort(
					___R$project$rome$$romejs$string$utils$naturalCompare_ts$naturalCompare,
				);

				for (const snapshotName of entryNames) {
					const entry = entries.get(snapshotName);

					const {value} = entry;
					const language = entry.language === undefined ? "" : entry.language;

					// If the test only has one snapshot then omit the heading
					const skipHeading = snapshotName === "0" && entryNames.length === 1;
					if (!skipHeading) {
						lines.push("### `" + snapshotName + "`");
					}

					pushNewline();
					lines.push("```" + language);
					// TODO escape triple backquotes
					lines.push(value);
					lines.push("```");
					pushNewline();
				}
			}
			return lines;
		}

		async save() {
			// If there'a s focused test then we don't write or validate a snapshot
			if (this.runner.hasFocusedTests) {
				return;
			}

			const {hasDiagnostics} = this.runner;

			for (const [path, {used, existsOnDisk, raw, entries}] of this.snapshots) {
				const lines = this.buildSnapshot(entries.values());
				const formatted = lines.join("\n");

				if (this.options.freezeSnapshots) {
					if (used) {
						if (formatted !== raw) {
							await this.emitDiagnostic(
								___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.INCORRECT(
									raw,
									formatted,
								),
							);
						}
					} else {
						await this.emitDiagnostic(
							___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.SNAPSHOTS.REDUNDANT,
						);
					}
				} else {
					if (existsOnDisk && !used) {
						// Don't delete a snapshot if there are test failures as those failures may be hiding a snapshot usage
						if (!hasDiagnostics) {
							// If a snapshot wasn't used or is empty then delete it!
							await ___R$project$rome$$romejs$fs$index_ts$unlink(path);
							this.snapshotCounts.deleted++;
						}
					} else if (used && formatted !== raw) {
						// Fresh snapshot!
						await ___R$project$rome$$romejs$fs$index_ts$writeFile(
							path,
							formatted,
						);
						if (existsOnDisk) {
							this.snapshotCounts.updated++;
						} else {
							this.snapshotCounts.created++;
						}
					}
				}
			}
		}

		testInlineSnapshot(callFrame, received, expected) {
			let receivedFormat = ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$stringOrPrettyFormat(
				received,
			);
			let expectedFormat = ___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$stringOrPrettyFormat(
				expected,
			);

			// Matches, no need to do anything
			if (receivedFormat === expectedFormat) {
				return {status: "MATCH"};
			}

			const shouldSave = this.options.updateSnapshots || expected === undefined;
			if (shouldSave) {
				const {lineNumber, columnNumber} = callFrame;
				if (lineNumber === undefined || columnNumber === undefined) {
					throw new Error("Call frame has no line or column");
				}

				if (!this.options.freezeSnapshots) {
					let snapshot = receivedFormat;
					if (
						typeof received === "string" ||
						typeof received === "number" ||
						typeof received === "boolean" ||
						received === null
					) {
						snapshot = received;
					}

					this.inlineSnapshotsUpdates.push({
						line: lineNumber,
						column: columnNumber,
						snapshot,
					});
				}

				return {status: "UPDATE"};
			}

			return {status: "NO_MATCH"};
		}

		async get(testName, entryName, optionalFilename) {
			const snapshotPath = this.normalizeSnapshotPath(optionalFilename);
			let snapshot = this.snapshots.get(snapshotPath);

			if (snapshot === undefined) {
				snapshot = await this.loadSnapshot(snapshotPath);
			}

			if (snapshot === undefined) {
				return undefined;
			}

			snapshot.used = true;

			// If we're force updating, pretend that there was no entry
			if (this.options.updateSnapshots) {
				return undefined;
			}

			const entry = snapshot.entries.get(
				___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$buildEntriesKey(
					testName,
					entryName,
				),
			);
			if (entry === undefined) {
				return undefined;
			} else {
				return entry.value;
			}
		}

		set(
			{
				testName,
				entryName,
				value,
				language,
				optionalFilename,
			},
		) {
			const snapshotPath = this.normalizeSnapshotPath(optionalFilename);
			let snapshot = this.snapshots.get(snapshotPath);
			if (snapshot === undefined) {
				snapshot = {
					raw: "",
					existsOnDisk: false,
					used: true,
					entries: new Map(),
				};
				this.snapshots.set(snapshotPath, snapshot);
			}

			snapshot.entries.set(
				___R$$priv$project$rome$$romejs$core$test$worker$SnapshotManager_ts$buildEntriesKey(
					testName,
					entryName,
				),
				{
					testName,
					entryName,
					language,
					value,
				},
			);
		}
	}


  // project-rome/@romejs/core/test-worker/TestWorkerRunner.ts
const ___R$$priv$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$MAX_RUNNING_TESTS = 20;

	function ___R$$priv$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$cleanFrames(
		frames,
	) {
		// TODO we should actually get the frames before module init and do it that way
		// Remove everything before the original module factory
		let latestTestWorkerFrame = frames.find((frame, i) => {
			if (
				frame.typeName === "global" &&
				frame.methodName === undefined &&
				frame.functionName === undefined
			) {
				// We are the global.<anonymous> frame
				// Now check for Script.runInContext
				const nextFrame = frames[i + 1];
				if (
					nextFrame !== undefined &&
					nextFrame.typeName === "Script" &&
					nextFrame.methodName === "runInContext"
				) {
					// Yes!
					// TODO also check for ___$romejs$core$common$utils$executeMain_ts$default (packages/romejs/core/common/utils/executeMain.ts:69:17)
					return true;
				}
			}

			return false;
		});

		// And if there was no module factory frame, then we must be inside of a test
		if (latestTestWorkerFrame === undefined) {
			latestTestWorkerFrame = frames.find((frame) => {
				return (
					frame.typeName !== undefined &&
					frame.typeName.includes("$TestWorkerRunner")
				);
			});
		}

		if (latestTestWorkerFrame === undefined) {
			return frames;
		}

		return frames.slice(0, frames.indexOf(latestTestWorkerFrame));
	}







	class ___R$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$default {
		constructor(opts, bridge) {
			this.opts = opts;
			this.locked = false;
			this.file = ___R$project$rome$$romejs$core$common$types$files_ts$convertTransportFileReference(
				opts.file,
			);
			this.options = opts.options;
			this.bridge = bridge;
			this.projectFolder = ___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
				opts.projectFolder,
			);

			this.snapshotManager = new ___R$project$rome$$romejs$core$test$worker$SnapshotManager_ts$default(
				this,
				___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
					opts.file.real,
				),
			);

			this.hasDiagnostics = false;
			this.consoleAdvice = [];
			this.hasFocusedTests = false;
			this.focusedTests = [];
			this.pendingDiagnostics = [];
			this.foundTests = new Map();
		}

		createConsole() {
			const addDiagnostic = (category, args) => {
				let textParts = [];
				if (args.length === 1 && typeof args[0] === "string") {
					textParts.push(
						___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
							args[0],
						),
					);
				} else {
					textParts = args.map((arg) =>
						___R$project$rome$$romejs$pretty$format$index_ts$default(
							arg,
							{markup: true},
						)
					);
				}
				const text = textParts.join(" ");

				const err = new Error();

				// Remove the first two frames to get to the actual source
				const frames = ___R$$priv$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$cleanFrames(
					___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err).frames.slice(
						2,
					),
				);

				this.consoleAdvice.push({
					type: "log",
					category,
					text,
				});
				this.consoleAdvice = this.consoleAdvice.concat(
					___R$project$rome$$romejs$diagnostics$derive_ts$getErrorStackAdvice(
						___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(
							Object.assign({}, err, {frames}),
						),
					),
				);
			};

			function log(...args) {
				addDiagnostic("none", args);
			}

			return {
				assert(expression, ...args) {
					if (!expression) {
						args[0] =
							"Assertion failed" + (args.length === 0 ? "" : ": " + args[0]);
						addDiagnostic("warn", args);
					}
				},
				dir(obj) {
					addDiagnostic("info", [obj]);
				},
				error: (...args) => {
					addDiagnostic("error", args);
				},
				warn: (...args) => {
					addDiagnostic("warn", args);
				},
				dirxml: log,
				debug: log,
				info: (...args) => {
					addDiagnostic("info", args);
				},
				log,
				trace: log,
				// Noop
				count() {},
				countReset() {},
				table() {},
				time() {},
				timeEnd() {},
				timeLog() {},
				clear() {},
				group() {},
				groupCollapsed() {},
				groupEnd() {},
				profile() {},
				profileEnd() {},
				timeStamp() {},
			};
		}

		//  Global variables to expose to tests
		getEnvironment() {
			const testOptions = {
				dirname: this.file.real.getParent().join(),
				register: (callsiteError, opts, callback) => {
					this.registerTest(callsiteError, opts, callback);
				},
			};

			return {
				__ROME__TEST_OPTIONS__: testOptions,
				console: this.createConsole(),
			};
		}

		// execute the test file and discover tests
		async discoverTests() {
			const {code} = this.opts;

			try {
				const res = await ___R$project$rome$$romejs$core$common$utils$executeMain_ts$default({
					path: this.file.real,
					code,
					globals: this.getEnvironment(),
				});

				if (res.syntaxError !== undefined) {
					const message =
						"A bundle was generated that contained a syntax error: " +
						res.syntaxError.description.message.value;

					throw ___R$project$rome$$romejs$diagnostics$errors_ts$createSingleDiagnosticError(
						Object.assign(
							{},
							res.syntaxError,
							{
								description: Object.assign(
									{},
									res.syntaxError.description,
									{
										message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
											message,
										),
										advice: [
											___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE,
										],
									},
								),
								location: Object.assign(
									{},
									res.syntaxError.location,
									{filename: this.file.uid},
								),
							},
						),
					);
				}
			} catch (err) {
				await this.onError(
					undefined,
					{
						error: err,
						firstAdvice: [],
						lastAdvice: [
							{
								type: "log",
								category: "info",
								text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Error occured while executing test file <filelink emphasis target="${this.file.uid}" />`,
							},
						],
					},
				);
			}
		}

		lockTests() {
			this.locked = true;
		}

		registerTest(callsiteError, options, callback) {
			if (this.locked) {
				throw new Error("Test can't be added outside of init");
			}

			let testName = options.name;
			if (Array.isArray(testName)) {
				testName = testName.join(" > ");
			}

			if (this.foundTests.has(testName)) {
				throw new Error("Test " + testName + " has already been defined");
			}

			this.foundTests.set(
				testName,
				{
					callback,
					options,
				},
			);

			if (options.only === true) {
				const callsiteStruct = ___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(
					callsiteError,
					1,
				);

				this.focusedTests.push({
					testName,
					location: ___R$project$rome$$romejs$v8$errors_ts$getSourceLocationFromErrorFrame(
						callsiteStruct.frames[0],
					),
				});

				this.hasFocusedTests = true;

				if (!this.options.focusAllowed) {
					const diag = this.deriveDiagnosticFromErrorStructure(callsiteStruct);

					this.pendingDiagnostics.push(
						Object.assign(
							{},
							diag,
							{
								description: Object.assign(
									{},
									diag.description,
									{
										message: ___R$project$rome$$romejs$diagnostics$descriptions_ts$createBlessedDiagnosticMessage(
											"Focused tests are not allowed due to a set flag",
										),
									},
								),
							},
						),
					);
				}
			}
		}

		async emitDiagnostic(diag, ref, advice) {
			let origin = {
				category: "test/error",
				message: "Generated from a test worker without being attached to a test",
			};

			if (ref !== undefined) {
				origin.message = ___R$project$rome$$romejs$string$markup$escape_ts$markup`Generated from the file <filelink target="${this.file.uid}" /> and test name "${ref.testName}"`;
			}

			let label = diag.label;
			if (label !== undefined && ref !== undefined) {
				label = ___R$project$rome$$romejs$string$markup$escape_ts$escapeMarkup(
					ref.testName,
				);
			}

			diag = Object.assign(
				{},
				diag,
				{
					label,
					description: Object.assign(
						{},
						diag.description,
						{advice: [...diag.description.advice, ...(advice || [])]},
					),
				},
			);

			this.hasDiagnostics = true;
			await this.bridge.testDiagnostic.call({diagnostic: diag, origin});
		}

		deriveDiagnosticFromErrorStructure(struct) {
			return ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromErrorStructure(
				struct,
				{
					description: {
						category: "tests/failure",
					},
					filename: this.file.real.join(),
					cleanFrames: ___R$$priv$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$cleanFrames,
				},
			);
		}

		async onError(testName, opts) {
			let diagnostic = this.deriveDiagnosticFromErrorStructure(
				___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(opts.error),
			);

			diagnostic = Object.assign(
				{},
				diagnostic,
				{
					unique: true,
					description: Object.assign(
						{},
						diagnostic.description,
						{
							advice: [
								...(opts.firstAdvice || []),
								...diagnostic.description.advice,
								...(opts.lastAdvice || []),
							],
						},
					),
				},
			);

			await this.emitDiagnostic(
				diagnostic,
				testName === undefined ? undefined : this.createTestRef(testName),
			);
		}

		async teardownTest(testName, api) {
			api.clearTimeout();

			try {
				await api.teardownEvent.callOptional();
				return true;
			} catch (err) {
				await this.onError(
					testName,
					{
						error: err,
						firstAdvice: [],
						lastAdvice: [
							{
								type: "log",
								category: "info",
								text: "Error occured while running <emphasis>teardown</emphasis> for test <emphasis>" +
								testName +
								"</emphasis>",
							},
							...api.advice,
						],
					},
				);
				return false;
			}
		}

		createTestRef(testName) {
			return {
				testName,
				filename: this.file.real.join(),
			};
		}

		async runTest(testName, callback) {
			let onTimeout = () => {
				throw new Error("Promise wasn't created. Should be impossible.");
			};

			const timeoutPromise = new Promise((resolve, reject) => {
				onTimeout = (time) => {
					reject(new Error("Test timeout - exceeded " + String(time) + "ms"));
				};
			});

			const ref = this.createTestRef(testName);

			const emitDiagnostic = (diag) => {
				return this.emitDiagnostic(diag, ref, api.advice);
			};

			const api = new ___R$project$rome$$romejs$core$test$worker$TestAPI_ts$default({
				file: this.file,
				testName,
				onTimeout,
				snapshotManager: this.snapshotManager,
				options: this.options,
				emitDiagnostic,
			});

			let testSuccess = false;

			try {
				const {diagnostics} = await ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(async () => {
					const res = callback(api);

					// Ducktyping this to detect a cross-realm Promise
					if (res !== undefined && typeof res.then === "function") {
						await Promise.race([timeoutPromise, res]);
					}
				});

				if (diagnostics !== undefined) {
					for (const diag of diagnostics) {
						await emitDiagnostic(diag);
					}
				}

				testSuccess = true;
			} catch (err) {
				await this.onError(
					testName,
					{
						error: err,
						firstAdvice: [],
						lastAdvice: api.advice,
					},
				);
			} finally {
				const teardownSuccess = await this.teardownTest(testName, api);
				await this.bridge.testFinish.call({
					success: testSuccess && teardownSuccess,
					ref,
				});
			}
		}

		async run(opts) {
			const promises = new Set();

			const {foundTests} = this;

			// Emit error about no found tests. If we already have diagnostics then there was an issue
			// during initialization.
			if (foundTests.size === 0 && !this.hasDiagnostics) {
				this.emitDiagnostic({
					location: {
						filename: this.file.uid,
					},
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TESTS.UNDECLARED,
				});
			}

			// We could be pretending we have focused tests here but at least one file was execueted with
			// focused tests
			if (opts.onlyFocusedTests) {
				this.hasFocusedTests = true;
			}

			// Execute all the tests
			for (const [testName, test] of foundTests) {
				const {options, callback} = test;
				if (this.hasFocusedTests && !test.options.only) {
					continue;
				}

				this.bridge.testStart.send({
					ref: {
						filename: this.file.real.join(),
						testName,
					},
					timeout: options.timeout,
				});

				const promise = this.runTest(testName, callback);

				if (this.options.syncTests) {
					await promise;
				} else {
					promise.then(() => {
						promises.delete(promise);
					});
					promises.add(promise);

					// if there's 5 promises, then wait for one of them to finish
					if (
						promises.size >
						___R$$priv$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$MAX_RUNNING_TESTS
					) {
						await Promise.race(Array.from(promises));
					}
				}
			}

			// Execute the remaining tests
			await Promise.all(Array.from(promises));

			// Save the snapshot
			await this.snapshotManager.save();

			if (this.hasDiagnostics && this.consoleAdvice.length > 0) {
				await this.emitDiagnostic({
					description: ___R$project$rome$$romejs$diagnostics$descriptions_ts$descriptions.TESTS.LOGS(
						this.consoleAdvice,
					),
					location: {
						filename: this.file.uid,
					},
				});
			}

			for (const diag of this.pendingDiagnostics) {
				await this.emitDiagnostic(diag);
			}

			return {
				inlineSnapshotUpdates: this.snapshotManager.inlineSnapshotsUpdates,
				snapshotCounts: this.snapshotManager.snapshotCounts,
			};
		}

		async emitFoundTests() {
			const tests = [];

			for (const testName of this.foundTests.keys()) {
				tests.push({
					filename: this.file.real.join(),
					testName,
				});
			}

			await this.bridge.testsFound.call(tests);
		}

		async wrap(callback) {
			try {
				const {diagnostics} = await ___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(
					callback,
				);

				if (diagnostics !== undefined) {
					for (const diagnostic of diagnostics) {
						await this.emitDiagnostic(diagnostic);
					}
				}
			} catch (err) {
				await this.onError(
					undefined,
					{
						error: err,
						firstAdvice: [],
						lastAdvice: [
							{
								type: "log",
								category: "info",
								text: ___R$project$rome$$romejs$string$markup$escape_ts$markup`Error occured while executing test file <filelink emphasis target="${this.file.uid}" />`,
							},
							___R$project$rome$$romejs$diagnostics$constants_ts$INTERNAL_ERROR_LOG_ADVICE,
						],
					},
				);
			}
		}

		async prepare() {
			await this.wrap(async () => {
				await this.snapshotManager.init();
				await this.discoverTests();
				await this.emitFoundTests();
				this.lockTests();
			});
			return {focusedTests: this.focusedTests};
		}
	}


  // project-rome/@romejs/core/test-worker/TestWorker.ts
const ___R$$priv$project$rome$$romejs$core$test$worker$TestWorker_ts$inspector = require(
		"inspector",
	);


	class ___R$project$rome$$romejs$core$test$worker$TestWorker_ts$default {
		constructor() {
			this.bridge = this.buildBridge();
			this.runners = new Map();
		}

		async init(flags) {
			___R$$priv$project$rome$$romejs$core$test$worker$TestWorker_ts$inspector.open(
				flags.inspectorPort,
			);

			await this.bridge.handshake();
		}

		buildBridge() {
			const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(
				___R$project$rome$$romejs$core$common$bridges$TestWorkerBridge_ts$default,
				{
					type: "server",
				},
			);

			process.on(
				"unhandledRejection",
				(err) => {
					bridge.testDiagnostic.send({
						origin: undefined,
						diagnostic: ___R$project$rome$$romejs$diagnostics$derive_ts$deriveDiagnosticFromError(
							err,
							{
								description: {
									category: "tests/unhandledRejection",
								},
							},
						),
					});
				},
			);

			bridge.inspectorDetails.subscribe(() => {
				return {
					inspectorUrl: ___R$$priv$project$rome$$romejs$core$test$worker$TestWorker_ts$inspector.url(),
				};
			});

			bridge.prepareTest.subscribe((data) => {
				return this.prepareTest(data);
			});

			bridge.runTest.subscribe((opts) => {
				return this.runTest(opts);
			});

			return bridge;
		}

		async runTest(opts) {
			const {id} = opts;
			const runner = this.runners.get(id);
			if (runner === undefined) {
				throw new Error("No runner " + id + " found");
			} else {
				return await runner.run(opts);
			}
		}

		async prepareTest(opts) {
			const runner = new ___R$project$rome$$romejs$core$test$worker$TestWorkerRunner_ts$default(
				opts,
				this.bridge,
			);
			this.runners.set(opts.id, runner);
			return await runner.prepare();
		}
	}


  // project-rome/@romejs/core/common/bridges/WorkerBridge.ts


























	class ___R$project$rome$$romejs$core$common$bridges$WorkerBridge_ts$default
		extends ___R$project$rome$$romejs$events$Bridge_ts$default {
		constructor(...args) {
			super(...args);
			this.log = this.createEvent({
				name: "log",
				direction: "server->client",
			});
			this.updateProjects = this.createEvent({
				name: "updateProjects",
				direction: "server->client",
			});
			this.updateManifests = this.createEvent({
				name: "updateManifests",
				direction: "server->client",
			});
			this.profilingStart = this.createEvent({
				name: "profiling.start",
				direction: "server->client",
			});
			this.profilingStop = this.createEvent({
				name: "profiling.stop",
				direction: "server->client",
			});
			this.status = this.createEvent({
				name: "status",
				direction: "server->client",
			});
			this.evict = this.createEvent({
				name: "evict",
				direction: "server->client",
			});
			this.format = this.createEvent({
				name: "format",
				direction: "server->client",
			});
			this.moduleSignatureJS = this.createEvent({
				name: "moduleSignatureJS",
				direction: "server->client",
			});
			this.analyzeDependencies = this.createEvent({
				name: "analyzeDependencies",
				direction: "server->client",
			});
			this.lint = this.createEvent({name: "lint", direction: "server->client"});
			this.updateInlineSnapshots = this.createEvent({
				name: "updateInlineSnapshots",
				direction: "server->client",
			});
			this.compileJS = this.createEvent({
				name: "compileJS",
				direction: "server->client",
			});
			this.parseJS = this.createEvent({
				name: "parseJS",
				direction: "server->client",
			});
			this.updateBuffer = this.createEvent({
				name: "updateBuffer",
				direction: "server->client",
			});
		}
		init() {
			this.addErrorTransport(
				"DiagnosticsError",
				{
					serialize(err) {
						if (
							!(err instanceof
							___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError)
						) {
							throw new Error("Expected DiagnosticsError");
						}

						return {
							diagnostics: err.diagnostics,
						};
					},
					hydrate(err, data) {
						return new ___R$project$rome$$romejs$diagnostics$errors_ts$DiagnosticsError(
							String(err.message),
							// rome-ignore lint/js/noExplicitAny
							(data.diagnostics),
						);
					},
				},
			);
		}
	}


  // project-rome/@romejs/core/common/bridges/MasterBridge.ts




















	class ___R$project$rome$$romejs$core$common$bridges$MasterBridge_ts$default
		extends ___R$project$rome$$romejs$events$Bridge_ts$default {
		constructor(...args) {
			super(...args);
			this.getClientInfo = this.createEvent({
				name: "getClientInfo",
				direction: "server->client",
			});
			this.stdout = this.createEvent({
				name: "stdout",
				direction: "server->client",
			});
			this.stderr = this.createEvent({
				name: "stderr",
				direction: "server->client",
			});
			this.enableWorkerLogs = this.createEvent({
				name: "enableWorkerLogs",
				direction: "server<-client",
			});
			this.log = this.createEvent({
				name: "log",
				direction: "server->client",
			});
			this.setColumns = this.createEvent({
				name: "columns.set",
				direction: "server<-client",
			});
			this.reporterRemoteServerMessage = this.createEvent({
				name: "reporterRemoteToLocalMessage",
				direction: "server->client",
			});
			this.reporterRemoteClientMessage = this.createEvent({
				name: "reporterLocalToRemoteMessage",
				direction: "server<-client",
			});
			this.query = this.createEvent({
				name: "query",
				direction: "server<-client",
			});
			this.cancelQuery = this.createEvent({
				name: "cancel",
				direction: "server<-client",
			});
			this.profilingGetWorkers = this.createEvent({
				name: "profiling.getWorkers",
				direction: "server<-client",
			});
			this.profilingStart = this.createEvent({
				name: "profiling.start",
				direction: "server<-client",
			});
			this.profilingStop = this.createEvent({
				name: "profiling.stop",
				direction: "server<-client",
			});
			this.profilingStopWorker = this.createEvent({
				name: "profile.stopWorker",
				direction: "server<-client",
			});
			this.lspFromClientBuffer = this.createEvent({
				name: "lspFromClientBuffer",
				direction: "server<-client",
			});
			this.lspFromServerBuffer = this.createEvent({
				name: "lspFromServerBuffer",
				direction: "server->client",
			});
		}
	}


  // project-rome/@romejs/core/common/bridges/WebBridge.ts
class ___R$project$rome$$romejs$core$common$bridges$WebBridge_ts$default
		extends ___R$project$rome$$romejs$events$Bridge_ts$default {
		constructor(...args) {
			super(...args);
			this.requests = this.createEvent({
				name: "WebBridge.requests",
				direction: "server->client",
			});
		}
	}


  // project-rome/@romejs/core/common/bridges/TestWorkerBridge.ts








	class ___R$project$rome$$romejs$core$common$bridges$TestWorkerBridge_ts$default
		extends ___R$project$rome$$romejs$events$Bridge_ts$default {
		constructor(...args) {
			super(...args);
			this.inspectorDetails = this.createEvent({
				name: "inspectorDetails",
				direction: "server->client",
			});
			this.prepareTest = this.createEvent({
				name: "prepareTest",
				direction: "server->client",
			});
			this.runTest = this.createEvent({
				name: "runTest",
				direction: "server->client",
			});
			this.testsFound = this.createEvent({
				name: "onTestFounds",
				direction: "server<-client",
			});
			this.testStart = this.createEvent({
				name: "onTestStart",
				direction: "server<-client",
			});
			this.testDiagnostic = this.createEvent({
				name: "testDiagnostic",
				direction: "server<-client",
			});
			this.testFinish = this.createEvent({
				name: "onTestSuccess",
				direction: "server<-client",
			});
		}
	}


  // project-rome/@romejs/core/index.ts



  // project-rome/@romejs/cli/utils/setProcessTitle.ts
function ___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default(title) {
		process.title = "rome-" + title;
	}


  // project-rome/@romejs/cli/cli.ts
const ___R$$priv$project$rome$$romejs$cli$cli_ts$fs = require("fs");


	async function ___R$project$rome$$romejs$cli$cli_ts$default() {
		___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default("cli");
		const p = ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlagsFromProcess({
			programName: process.env.ROME_DEV === "1" ? "dev-rome" : "rome",
			usage: "[command] [flags]",
			version: ___R$project$rome$$romejs$core$common$constants_ts$VERSION,
			defineFlags(c) {
				// We need this to resolve other flags relative to
				// We do the word `void ||` nonsense to avoid setting a default flag value
				const cwd =
					c.get(
						"cwd",
						{
							description: "Specify a different working directory",
						},
					).asAbsoluteFilePathOrVoid() ||
					___R$project$rome$$romejs$path$index_ts$createAbsoluteFilePath(
						process.cwd(),
					);

				return {
					clientFlags: Object.assign(
						{
							clientName: "cli",
							cwd,
							verbose: c.get(
								"verbose",
								{
									description: "Output verbose logs",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS.verbose,
							),
							silent: c.get(
								"silent",
								{
									description: "Don't write anything to the console",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_FLAGS.silent,
							),
						},
						overrideClientFlags,
					),
					cliFlags: Object.assign(
						{
							markersPath: c.get(
								"markersPath",
								{
									description: "Path where to write markers. When ommitted defaults to Marker-TIMESTAMP.json",
								},
							).asAbsoluteFilePathOrVoid(undefined, cwd),
							profile: c.get(
								"profile",
								{
									description: "Collect and write profile to disk. Includes profiles for all processes.",
								},
							).asBoolean(false),
							profilePath: c.get(
								"profilePath",
								{
									description: "Path where to write profile. When omitted defaults to Profile-TIMESTAMP.json",
								},
							).asAbsoluteFilePathOrVoid(undefined, cwd),
							profileTimeout: c.get(
								"profileTimeout",
								{
									inputName: "millisec",
									description: "Stop the profile after the milliseconds specified. When omitted the profile is of the whole command",
								},
							).asNumberOrVoid(),
							profileWorkers: c.get(
								"profileWorkers",
								{
									description: "Exclude workers from profile",
								},
							).asBoolean(true),
							profileSampling: c.get(
								"profileSampling",
								{
									description: "Profiler sampling interval in microseconds",
									inputName: "microsec",
								},
							).asNumber(100),
							temporaryDaemon: c.get(
								"temporaryDaemon",
								{
									description: "Start a daemon, if one isn't already running, for the lifetime of this command",
								},
							).asBoolean(false),
							rage: c.get(
								"rage",
								{
									description: "Create a rage tarball of debug information",
								},
							).asBoolean(false),
							ragePath: c.get(
								"ragePath",
								{
									description: "Path where to write rage tarball. When omitted defaults to Rage-TIMESTAMP.tgz",
								},
							).asAbsoluteFilePathOrVoid(undefined, cwd),
							logs: c.get(
								"logs",
								{
									description: "Output master logs",
								},
							).asBoolean(false),
							logWorkers: c.get(
								"logWorkers",
								{
									description: "Output worker logs",
								},
							).asBooleanOrVoid(),
							logPath: c.get(
								"logPath",
								{
									description: "Path where to output logs. When omitted logs are not written anywhere",
								},
							).asAbsoluteFilePathOrVoid(undefined, cwd),
						},
						overrideCLIFlags,
					),
					requestFlags: Object.assign(
						{
							benchmark: c.get(
								"benchmark",
								{
									description: "Run a command multiple times, calculating average",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.benchmark,
							),
							benchmarkIterations: c.get(
								"benchmarkIterations",
								{
									description: "The amount of benchmark iterations to perform",
								},
							).asNumber(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.benchmarkIterations,
							),
							collectMarkers: c.get(
								"collectMarkers",
								{
									description: "Collect and write performance markers to disk",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.collectMarkers,
							),
							timing: c.get(
								"timing",
								{
									description: "Dump timing information after running the command",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.timing,
							),
							review: c.get(
								"review",
								{
									description: "Display and perform actions on diagnostics. Only some commands support this.",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.review,
							),
							watch: c.get(
								"watch",
								{
									description: "Keep running command and update on file changes. Only some commands support this.",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.watch,
							),
							fieri: c.get(
								"fieri",
								{
									description: "Head to flavortown",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.fieri,
							),
							grep: c.get(
								"grep",
								{
									description: "Only display diagnostics with messages containing this string",
								},
							).asString(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.grep,
							),
							inverseGrep: c.get(
								"inverseGrep",
								{
									description: "Flip grep match. Only display diagnostics with messages that do NOT contain the grep string",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.inverseGrep,
							),
							maxDiagnostics: c.get(
								"maxDiagnostics",
								{
									description: "Cap the amount of diagnostics displayed",
								},
							).asNumber(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.maxDiagnostics,
							),
							verboseDiagnostics: c.get(
								"verboseDiagnostics",
								{
									description: "Display hidden and truncated diagnostic information",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.verboseDiagnostics,
							),
							showAllDiagnostics: c.get(
								"showAllDiagnostics",
								{
									description: "Display all diagnostics ignoring caps",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.showAllDiagnostics,
							),
							resolverPlatform: c.get(
								"resolverPlatform",
								{
									description: "Specify the platform for module resolution",
									inputName: "platform",
								},
							).asStringSetOrVoid(
								___R$project$rome$$romejs$core$common$types$platform_ts$PLATFORMS,
							),
							resolverScale: c.get(
								"resolverScale",
								{
									description: "Specify the image scale for module resolution",
								},
							).asNumberOrVoid(),
							resolverMocks: c.get(
								"resolverMocks",
								{
									description: "Enable mocks for module resolution",
								},
							).asBoolean(
								___R$project$rome$$romejs$core$common$types$client_ts$DEFAULT_CLIENT_REQUEST_FLAGS.resolverMocks,
							),
						},
						overrideRequestFlags,
					),
				};
			},
		});

		let command = "";
		let overrideClientFlags;
		let overrideRequestFlags;
		let overrideCLIFlags = {};
		let commandFlags = {};
		let args = [];

		// Create command handlers. We use a set here since we may have some conflicting master and local command names. We always want the local command to take precedence.
		const commandNames = new Set([
			...___R$project$rome$$romejs$core$client$commands_ts$localCommands.keys(),
			...___R$project$rome$$romejs$core$master$commands_ts$masterCommands.keys(),
		]);
		for (const cmd of commandNames) {
			const local = ___R$project$rome$$romejs$core$client$commands_ts$localCommands.get(
				cmd,
			);
			if (local !== undefined) {
				p.command({
					name: cmd,
					category: local.category,
					description: local.description,
					defineFlags: local.defineFlags,
					ignoreFlags: local.ignoreFlags,
					examples: local.examples,
					usage: local.usage,
					callback(_commandFlags) {
						commandFlags = _commandFlags;
						args = p.getArgs();
						command = cmd;
					},
				});
				continue;
			}

			const master = ___R$project$rome$$romejs$core$master$commands_ts$masterCommands.get(
				cmd,
			);
			if (master !== undefined) {
				p.command({
					name: cmd,
					category: master.category,
					description: master.description,
					defineFlags: master.defineFlags,
					ignoreFlags: master.ignoreFlags,
					usage: master.usage,
					examples: master.examples,
					callback(_commandFlags) {
						commandFlags = _commandFlags;
						overrideClientFlags = master.overrideClientFlags;
						overrideRequestFlags = master.overrideRequestFlags;

						args = p.getArgs();
						command = cmd;
					},
				});
			}
		}

		// Mock `rage` command that just uses the master noop command and adds the --rage flag
		p.command({
			name: "rage",
			category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.INTERNAL,
			description: "TODO",
			callback() {
				overrideCLIFlags = {
					rage: true,
				};

				command = "_noop";
			},
		});

		// Mock `logs` command that just uses the master noop command and adds the --logs flag
		p.command({
			name: "logs",
			category: ___R$project$rome$$romejs$core$common$commands_ts$commandCategories.INTERNAL,
			description: "TODO",
			callback() {
				overrideCLIFlags = {
					logs: true,
				};

				command = "_noop";
			},
		});

		// Initialize flags
		let {clientFlags, cliFlags, requestFlags} = await p.init();

		// Force collection of markers if markersPath or we are raging
		if (cliFlags.markersPath || cliFlags.rage) {
			requestFlags.collectMarkers = true;
		}

		// Force logs when logPath or logWorkers is set
		if (cliFlags.logPath !== undefined || cliFlags.logWorkers === true) {
			cliFlags.logs = true;
		}

		p.commandRequired();

		const client = new ___R$project$rome$$romejs$core$client$Client_ts$default({
			globalErrorHandlers: true,
			flags: clientFlags,
			stdin: process.stdin,
			stdout: process.stdout,
			stderr: process.stderr,
		});

		client.bridgeAttachedEvent.subscribe(async () => {
			const profileOptions = {
				samplingInterval: cliFlags.profileSampling,
				timeoutInterval: cliFlags.profileTimeout,
				includeWorkers: cliFlags.profileWorkers,
			};

			if (cliFlags.rage) {
				const {ragePath} = cliFlags;
				const filename = clientFlags.cwd.resolve(
					ragePath === undefined
						? "Rage-" +
							___R$project$rome$$romejs$core$client$Client_ts$getFilenameTimestamp() +
							".tgz"
						: ragePath,
				).join();
				await client.rage(filename, profileOptions);
				return;
			}

			if (cliFlags.profile) {
				await client.profile(
					profileOptions,
					async (events) => {
						const {cwd} = clientFlags;
						const {profilePath} = cliFlags;

						const resolvedProfilePath = cwd.resolve(
							profilePath === undefined
								? "Profile-" +
									___R$project$rome$$romejs$core$client$Client_ts$getFilenameTimestamp() +
									".json"
								: profilePath,
						);

						const str = ___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
							events,
						);
						await ___R$project$rome$$romejs$fs$index_ts$writeFile(
							resolvedProfilePath,
							str,
						);

						client.reporter.success(
							___R$project$rome$$romejs$string$markup$escape_ts$markup`Wrote CPU profile to <filelink emphasis target="${resolvedProfilePath.join()}" />`,
						);
					},
				);
			}

			if (cliFlags.logs) {
				let fileout;
				if (cliFlags.logPath !== undefined) {
					fileout = ___R$$priv$project$rome$$romejs$cli$cli_ts$fs.createWriteStream(
						clientFlags.cwd.resolve(cliFlags.logPath).join(),
					);

					client.endEvent.subscribe(() => {
						if (fileout !== undefined) {
							fileout.end();
						}
					});
				}

				await client.subscribeLogs(
					cliFlags.logWorkers === true,
					(chunk) => {
						if (fileout === undefined) {
							client.reporter.writeAll(chunk);
						} else {
							fileout.write(chunk);
						}
					},
				);
			}
		});

		if (cliFlags.temporaryDaemon) {
			await client.forceStartDaemon();
		}

		const res = await client.query({
			commandName: command,
			commandFlags,
			args,
			requestFlags,
			// Daemon would have been started before, so terminate when we complete
			terminateWhenIdle: cliFlags.temporaryDaemon,
			// We don't use the data result, so no point transporting it over the bridge
			noData: true,
		});
		await client.end();

		if (res.type === "SUCCESS") {
			// Write markers if we were collecting them
			if (requestFlags.collectMarkers) {
				const markersPath = clientFlags.cwd.resolve(
					cliFlags.markersPath === undefined
						? "Markers-" +
							___R$project$rome$$romejs$core$client$Client_ts$getFilenameTimestamp() +
							".json"
						: cliFlags.markersPath,
				);

				await ___R$project$rome$$romejs$fs$index_ts$writeFile(
					markersPath,
					___R$project$rome$$romejs$codec$json$index_ts$stringifyJSON(
						res.markers,
					),
				);

				client.reporter.success(
					___R$project$rome$$romejs$string$markup$escape_ts$markup`Wrote markers to <filelink emphasis target="${markersPath.join()}" />`,
				);
			}
		}

		switch (res.type) {
			case "ERROR": {
				if (!res.handled) {
					console.error("Unhandled CLI query error");
					console.error(res.stack);
				}
				process.exit(1);
				break;
			}

			case "INVALID_REQUEST": {
				if (res.showHelp) {
					await p.showHelp();
				}
				process.exit(1);
				break;
			}

			case "DIAGNOSTICS": {
				process.exit(res.hasDiagnostics ? 1 : 0);
				break;
			}

			case "CANCELLED": {
				process.exit(0);
				break;
			}

			case "SUCCESS": {
				process.exit(0);
				break;
			}
		}
	}


  // project-rome/@romejs/cli/master.ts
const ___R$$priv$project$rome$$romejs$cli$master_ts$net = require("net");
	async function ___R$project$rome$$romejs$cli$master_ts$default() {
		___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default("master");

		const master = new ___R$project$rome$$romejs$core$master$Master_ts$default({
			dedicated: true,
			globalErrorHandlers: true,
		});

		await master.init();

		const socketServer = ___R$$priv$project$rome$$romejs$cli$master_ts$net.createServer(function(
			socket,
		) {
			const client = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromSocket(
				___R$project$rome$$romejs$core$common$bridges$MasterBridge_ts$default,
				socket,
				{
					type: "client",
				},
			);
			master.attachToBridge(client);
		});

		if (
			await ___R$project$rome$$romejs$fs$index_ts$exists(
				___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH,
			)
		) {
			await ___R$project$rome$$romejs$fs$index_ts$unlink(
				___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH,
			);
		}

		socketServer.listen(
			___R$project$rome$$romejs$core$common$constants_ts$SOCKET_PATH.join(),
			() => {
				const socket = ___R$$priv$project$rome$$romejs$cli$master_ts$net.createConnection(
					___R$project$rome$$romejs$core$common$constants_ts$CLI_SOCKET_PATH.join(),
					() => {
						socket.end();
					},
				);

				socket.on(
					"error",
					(err) => {
						// Socket error occured, cli could have died before it caught us
						err;
						console.log(err);
						process.exit();
					},
				);
			},
		);
	}


  // project-rome/@romejs/cli/testWorker.ts
async function ___R$project$rome$$romejs$cli$testWorker_ts$default() {
		___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default(
			"test-worker",
		);

		const parser = ___R$project$rome$$romejs$cli$flags$index_ts$parseCLIFlagsFromProcess({
			programName: "rome test-worker",
			defineFlags(c) {
				return {
					inspectorPort: c.get("inspectorPort").asNumberFromString(),
				};
			},
		});
		const flags = await parser.init();

		const worker = new ___R$project$rome$$romejs$core$test$worker$TestWorker_ts$default();
		worker.init(flags);
	}


  // project-rome/@romejs/cli/worker.ts
async function ___R$project$rome$$romejs$cli$worker_ts$default() {
		___R$project$rome$$romejs$cli$utils$setProcessTitle_ts$default("worker");
		const bridge = ___R$project$rome$$romejs$events$bridgeCreators_ts$createBridgeFromParentProcess(
			___R$project$rome$$romejs$core$common$bridges$WorkerBridge_ts$default,
			{
				type: "server",
			},
		);
		const worker = new ___R$project$rome$$romejs$core$worker$Worker_ts$default({
			bridge,
			globalErrorHandlers: true,
		});
		await worker.init();
		bridge.handshake();
	}


  // project-rome/@romejs/cli/bin/rome.ts
async function ___R$$priv$project$rome$$romejs$cli$bin$rome_ts$main() {
		switch (
			process.env.ROME_PROCESS_VERSION ===
			___R$project$rome$$romejs$core$common$constants_ts$VERSION &&
			process.env.ROME_PROCESS_TYPE
		) {
			case "master":
				return ___R$project$rome$$romejs$cli$master_ts$default();

			case "worker":
				return ___R$project$rome$$romejs$cli$worker_ts$default();

			case "test-worker":
				return ___R$project$rome$$romejs$cli$testWorker_ts$default();

			default:
				return ___R$project$rome$$romejs$cli$cli_ts$default();
		}
	}

	___R$project$rome$$romejs$v8$sourceMapManager_ts$initErrorHooks();
	___R$project$rome$$romejs$v8$sourceMapManager_ts$default.add(
		___R$project$rome$$romejs$core$common$constants_ts$BIN.join(),
		___R$project$rome$$romejs$codec$source$map$SourceMapConsumer_ts$default.fromJSONLazy(
			___R$project$rome$$romejs$core$common$constants_ts$BIN.join(),
			() =>
				JSON.parse(
					___R$project$rome$$romejs$fs$index_ts$readFileTextSync(
						___R$project$rome$$romejs$core$common$constants_ts$MAP,
					),
				)
			,
		),
	);

	___R$project$rome$$romejs$diagnostics$wrap_ts$catchDiagnostics(
		___R$$priv$project$rome$$romejs$cli$bin$rome_ts$main,
	).then(({diagnostics}) => {
		if (diagnostics !== undefined) {
			const reporter = ___R$project$rome$$romejs$cli$reporter$Reporter_ts$default.fromProcess();
			___R$project$rome$$romejs$cli$diagnostics$index_ts$printDiagnostics({
				diagnostics,
				suppressions: [],
				printerOptions: {
					reporter,
				},
			});
			process.exit(1);
		}
	}).catch((err) => {
		console.error("Error thrown inside the CLI handler");
		console.error(
			___R$project$rome$$romejs$v8$errors_ts$getErrorStructure(err).stack,
		);
	});


  // project-rome/rome/bin/rome.ts
const ___R$project$rome$rome$bin$rome_ts = {};


  return ___R$project$rome$rome$bin$rome_ts;
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
//# sourceMappingURL=rome.ts.map
